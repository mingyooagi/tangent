"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/magicast@0.3.5";
exports.ids = ["vendor-chunks/magicast@0.3.5"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/magicast@0.3.5/node_modules/magicast/dist/index.mjs":
/*!*********************************************************************************!*\
  !*** ../node_modules/.pnpm/magicast@0.3.5/node_modules/magicast/dist/index.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MagicastError: () => (/* binding */ MagicastError),\n/* harmony export */   builders: () => (/* binding */ builders),\n/* harmony export */   detectCodeFormat: () => (/* binding */ detectCodeFormat),\n/* harmony export */   generateCode: () => (/* binding */ generateCode),\n/* harmony export */   loadFile: () => (/* binding */ loadFile),\n/* harmony export */   parseExpression: () => (/* binding */ parseExpression),\n/* harmony export */   parseModule: () => (/* binding */ parseModule),\n/* harmony export */   writeFile: () => (/* binding */ writeFile)\n/* harmony export */ });\n/* harmony import */ var node_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:fs */ \"node:fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var source_map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! source-map-js */ \"(rsc)/../node_modules/.pnpm/source-map-js@1.2.1/node_modules/source-map-js/source-map.js\");\n/* harmony import */ var _babel_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/parser */ \"(rsc)/../node_modules/.pnpm/@babel+parser@7.28.6/node_modules/@babel/parser/lib/index.js\");\n\n\n\n\n\nfunction sharedPlugin(fork) {\n  var types = fork.use(typesPlugin);\n  var Type = types.Type;\n  var builtin = types.builtInTypes;\n  var isNumber = builtin.number;\n  function geq(than) {\n    return Type.from(\n      (value) => isNumber.check(value) && value >= than,\n      isNumber + \" >= \" + than\n    );\n  }\n  const defaults = {\n    // Functions were used because (among other reasons) that's the most\n    // elegant way to allow for the emptyArray one always to give a new\n    // array instance.\n    \"null\": function() {\n      return null;\n    },\n    \"emptyArray\": function() {\n      return [];\n    },\n    \"false\": function() {\n      return false;\n    },\n    \"true\": function() {\n      return true;\n    },\n    \"undefined\": function() {\n    },\n    \"use strict\": function() {\n      return \"use strict\";\n    }\n  };\n  var naiveIsPrimitive = Type.or(\n    builtin.string,\n    builtin.number,\n    builtin.boolean,\n    builtin.null,\n    builtin.undefined\n  );\n  const isPrimitive = Type.from(\n    (value) => {\n      if (value === null)\n        return true;\n      var type = typeof value;\n      if (type === \"object\" || type === \"function\") {\n        return false;\n      }\n      return true;\n    },\n    naiveIsPrimitive.toString()\n  );\n  return {\n    geq,\n    defaults,\n    isPrimitive\n  };\n}\nfunction maybeSetModuleExports(moduleGetter) {\n  try {\n    var nodeModule = moduleGetter();\n    var originalExports = nodeModule.exports;\n    var defaultExport = originalExports[\"default\"];\n  } catch {\n    return;\n  }\n  if (defaultExport && defaultExport !== originalExports && typeof originalExports === \"object\") {\n    Object.assign(defaultExport, originalExports, { \"default\": defaultExport });\n    if (originalExports.__esModule) {\n      Object.defineProperty(defaultExport, \"__esModule\", { value: true });\n    }\n    nodeModule.exports = defaultExport;\n  }\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$2 = (obj, key, value) => {\n  __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst Op$1 = Object.prototype;\nconst objToStr = Op$1.toString;\nconst hasOwn$6 = Op$1.hasOwnProperty;\nclass BaseType {\n  assert(value, deep) {\n    if (!this.check(value, deep)) {\n      var str = shallowStringify(value);\n      throw new Error(str + \" does not match type \" + this);\n    }\n    return true;\n  }\n  arrayOf() {\n    const elemType = this;\n    return new ArrayType(elemType);\n  }\n}\nclass ArrayType extends BaseType {\n  constructor(elemType) {\n    super();\n    this.elemType = elemType;\n    __publicField$2(this, \"kind\", \"ArrayType\");\n  }\n  toString() {\n    return \"[\" + this.elemType + \"]\";\n  }\n  check(value, deep) {\n    return Array.isArray(value) && value.every((elem) => this.elemType.check(elem, deep));\n  }\n}\nclass IdentityType extends BaseType {\n  constructor(value) {\n    super();\n    this.value = value;\n    __publicField$2(this, \"kind\", \"IdentityType\");\n  }\n  toString() {\n    return String(this.value);\n  }\n  check(value, deep) {\n    const result = value === this.value;\n    if (!result && typeof deep === \"function\") {\n      deep(this, value);\n    }\n    return result;\n  }\n}\nclass ObjectType extends BaseType {\n  constructor(fields) {\n    super();\n    this.fields = fields;\n    __publicField$2(this, \"kind\", \"ObjectType\");\n  }\n  toString() {\n    return \"{ \" + this.fields.join(\", \") + \" }\";\n  }\n  check(value, deep) {\n    return objToStr.call(value) === objToStr.call({}) && this.fields.every((field) => {\n      return field.type.check(value[field.name], deep);\n    });\n  }\n}\nclass OrType extends BaseType {\n  constructor(types) {\n    super();\n    this.types = types;\n    __publicField$2(this, \"kind\", \"OrType\");\n  }\n  toString() {\n    return this.types.join(\" | \");\n  }\n  check(value, deep) {\n    if (this.types.some((type) => type.check(value, !!deep))) {\n      return true;\n    }\n    if (typeof deep === \"function\") {\n      deep(this, value);\n    }\n    return false;\n  }\n}\nclass PredicateType extends BaseType {\n  constructor(name, predicate) {\n    super();\n    this.name = name;\n    this.predicate = predicate;\n    __publicField$2(this, \"kind\", \"PredicateType\");\n  }\n  toString() {\n    return this.name;\n  }\n  check(value, deep) {\n    const result = this.predicate(value, deep);\n    if (!result && typeof deep === \"function\") {\n      deep(this, value);\n    }\n    return result;\n  }\n}\nclass Def {\n  constructor(type, typeName) {\n    this.type = type;\n    this.typeName = typeName;\n    __publicField$2(this, \"baseNames\", []);\n    __publicField$2(this, \"ownFields\", /* @__PURE__ */ Object.create(null));\n    // Includes own typeName. Populated during finalization.\n    __publicField$2(this, \"allSupertypes\", /* @__PURE__ */ Object.create(null));\n    // Linear inheritance hierarchy. Populated during finalization.\n    __publicField$2(this, \"supertypeList\", []);\n    // Includes inherited fields.\n    __publicField$2(this, \"allFields\", /* @__PURE__ */ Object.create(null));\n    // Non-hidden keys of allFields.\n    __publicField$2(this, \"fieldNames\", []);\n    // This property will be overridden as true by individual Def instances\n    // when they are finalized.\n    __publicField$2(this, \"finalized\", false);\n    // False by default until .build(...) is called on an instance.\n    __publicField$2(this, \"buildable\", false);\n    __publicField$2(this, \"buildParams\", []);\n  }\n  isSupertypeOf(that) {\n    if (that instanceof Def) {\n      if (this.finalized !== true || that.finalized !== true) {\n        throw new Error(\"\");\n      }\n      return hasOwn$6.call(that.allSupertypes, this.typeName);\n    } else {\n      throw new Error(that + \" is not a Def\");\n    }\n  }\n  checkAllFields(value, deep) {\n    var allFields = this.allFields;\n    if (this.finalized !== true) {\n      throw new Error(\"\" + this.typeName);\n    }\n    function checkFieldByName(name) {\n      var field = allFields[name];\n      var type = field.type;\n      var child = field.getValue(value);\n      return type.check(child, deep);\n    }\n    return value !== null && typeof value === \"object\" && Object.keys(allFields).every(checkFieldByName);\n  }\n  bases(...supertypeNames) {\n    var bases = this.baseNames;\n    if (this.finalized) {\n      if (supertypeNames.length !== bases.length) {\n        throw new Error(\"\");\n      }\n      for (var i = 0; i < supertypeNames.length; i++) {\n        if (supertypeNames[i] !== bases[i]) {\n          throw new Error(\"\");\n        }\n      }\n      return this;\n    }\n    supertypeNames.forEach((baseName) => {\n      if (bases.indexOf(baseName) < 0) {\n        bases.push(baseName);\n      }\n    });\n    return this;\n  }\n}\nclass Field {\n  constructor(name, type, defaultFn, hidden) {\n    this.name = name;\n    this.type = type;\n    this.defaultFn = defaultFn;\n    __publicField$2(this, \"hidden\");\n    this.hidden = !!hidden;\n  }\n  toString() {\n    return JSON.stringify(this.name) + \": \" + this.type;\n  }\n  getValue(obj) {\n    var value = obj[this.name];\n    if (typeof value !== \"undefined\") {\n      return value;\n    }\n    if (typeof this.defaultFn === \"function\") {\n      value = this.defaultFn.call(obj);\n    }\n    return value;\n  }\n}\nfunction shallowStringify(value) {\n  if (Array.isArray(value)) {\n    return \"[\" + value.map(shallowStringify).join(\", \") + \"]\";\n  }\n  if (value && typeof value === \"object\") {\n    return \"{ \" + Object.keys(value).map(function(key) {\n      return key + \": \" + value[key];\n    }).join(\", \") + \" }\";\n  }\n  return JSON.stringify(value);\n}\nfunction typesPlugin(_fork) {\n  const Type = {\n    or(...types) {\n      return new OrType(types.map((type) => Type.from(type)));\n    },\n    from(value, name) {\n      if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {\n        return value;\n      }\n      if (value instanceof Def) {\n        return value.type;\n      }\n      if (isArray.check(value)) {\n        if (value.length !== 1) {\n          throw new Error(\"only one element type is permitted for typed arrays\");\n        }\n        return new ArrayType(Type.from(value[0]));\n      }\n      if (isObject.check(value)) {\n        return new ObjectType(Object.keys(value).map((name2) => {\n          return new Field(name2, Type.from(value[name2], name2));\n        }));\n      }\n      if (typeof value === \"function\") {\n        var bicfIndex = builtInCtorFns.indexOf(value);\n        if (bicfIndex >= 0) {\n          return builtInCtorTypes[bicfIndex];\n        }\n        if (typeof name !== \"string\") {\n          throw new Error(\"missing name\");\n        }\n        return new PredicateType(name, value);\n      }\n      return new IdentityType(value);\n    },\n    // Define a type whose name is registered in a namespace (the defCache) so\n    // that future definitions will return the same type given the same name.\n    // In particular, this system allows for circular and forward definitions.\n    // The Def object d returned from Type.def may be used to configure the\n    // type d.type by calling methods such as d.bases, d.build, and d.field.\n    def(typeName) {\n      return hasOwn$6.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);\n    },\n    hasDef(typeName) {\n      return hasOwn$6.call(defCache, typeName);\n    }\n  };\n  var builtInCtorFns = [];\n  var builtInCtorTypes = [];\n  function defBuiltInType(name, example) {\n    const objStr = objToStr.call(example);\n    const type = new PredicateType(\n      name,\n      (value) => objToStr.call(value) === objStr\n    );\n    if (example && typeof example.constructor === \"function\") {\n      builtInCtorFns.push(example.constructor);\n      builtInCtorTypes.push(type);\n    }\n    return type;\n  }\n  const isString = defBuiltInType(\"string\", \"truthy\");\n  const isFunction = defBuiltInType(\"function\", function() {\n  });\n  const isArray = defBuiltInType(\"array\", []);\n  const isObject = defBuiltInType(\"object\", {});\n  const isRegExp = defBuiltInType(\"RegExp\", /./);\n  const isDate = defBuiltInType(\"Date\", /* @__PURE__ */ new Date());\n  const isNumber = defBuiltInType(\"number\", 3);\n  const isBoolean = defBuiltInType(\"boolean\", true);\n  const isNull = defBuiltInType(\"null\", null);\n  const isUndefined = defBuiltInType(\"undefined\", void 0);\n  const isBigInt = typeof BigInt === \"function\" ? defBuiltInType(\"BigInt\", BigInt(1234)) : new PredicateType(\"BigInt\", () => false);\n  const builtInTypes = {\n    string: isString,\n    function: isFunction,\n    array: isArray,\n    object: isObject,\n    RegExp: isRegExp,\n    Date: isDate,\n    number: isNumber,\n    boolean: isBoolean,\n    null: isNull,\n    undefined: isUndefined,\n    BigInt: isBigInt\n  };\n  var defCache = /* @__PURE__ */ Object.create(null);\n  function defFromValue(value) {\n    if (value && typeof value === \"object\") {\n      var type = value.type;\n      if (typeof type === \"string\" && hasOwn$6.call(defCache, type)) {\n        var d = defCache[type];\n        if (d.finalized) {\n          return d;\n        }\n      }\n    }\n    return null;\n  }\n  class DefImpl extends Def {\n    constructor(typeName) {\n      super(\n        new PredicateType(typeName, (value, deep) => this.check(value, deep)),\n        typeName\n      );\n    }\n    check(value, deep) {\n      if (this.finalized !== true) {\n        throw new Error(\n          \"prematurely checking unfinalized type \" + this.typeName\n        );\n      }\n      if (value === null || typeof value !== \"object\") {\n        return false;\n      }\n      var vDef = defFromValue(value);\n      if (!vDef) {\n        if (this.typeName === \"SourceLocation\" || this.typeName === \"Position\") {\n          return this.checkAllFields(value, deep);\n        }\n        return false;\n      }\n      if (deep && vDef === this) {\n        return this.checkAllFields(value, deep);\n      }\n      if (!this.isSupertypeOf(vDef)) {\n        return false;\n      }\n      if (!deep) {\n        return true;\n      }\n      return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);\n    }\n    build(...buildParams) {\n      this.buildParams = buildParams;\n      if (this.buildable) {\n        return this;\n      }\n      this.field(\"type\", String, () => this.typeName);\n      this.buildable = true;\n      const addParam = (built, param, arg, isArgAvailable) => {\n        if (hasOwn$6.call(built, param))\n          return;\n        var all = this.allFields;\n        if (!hasOwn$6.call(all, param)) {\n          throw new Error(\"\" + param);\n        }\n        var field = all[param];\n        var type = field.type;\n        var value;\n        if (isArgAvailable) {\n          value = arg;\n        } else if (field.defaultFn) {\n          value = field.defaultFn.call(built);\n        } else {\n          var message = \"no value or default function given for field \" + JSON.stringify(param) + \" of \" + this.typeName + \"(\" + this.buildParams.map(function(name) {\n            return all[name];\n          }).join(\", \") + \")\";\n          throw new Error(message);\n        }\n        if (!type.check(value)) {\n          throw new Error(\n            shallowStringify(value) + \" does not match field \" + field + \" of type \" + this.typeName\n          );\n        }\n        built[param] = value;\n      };\n      const builder = (...args) => {\n        var argc = args.length;\n        if (!this.finalized) {\n          throw new Error(\n            \"attempting to instantiate unfinalized type \" + this.typeName\n          );\n        }\n        var built = Object.create(nodePrototype);\n        this.buildParams.forEach(function(param, i) {\n          if (i < argc) {\n            addParam(built, param, args[i], true);\n          } else {\n            addParam(built, param, null, false);\n          }\n        });\n        Object.keys(this.allFields).forEach(function(param) {\n          addParam(built, param, null, false);\n        });\n        if (built.type !== this.typeName) {\n          throw new Error(\"\");\n        }\n        return built;\n      };\n      builder.from = (obj) => {\n        if (!this.finalized) {\n          throw new Error(\n            \"attempting to instantiate unfinalized type \" + this.typeName\n          );\n        }\n        var built = Object.create(nodePrototype);\n        Object.keys(this.allFields).forEach(function(param) {\n          if (hasOwn$6.call(obj, param)) {\n            addParam(built, param, obj[param], true);\n          } else {\n            addParam(built, param, null, false);\n          }\n        });\n        if (built.type !== this.typeName) {\n          throw new Error(\"\");\n        }\n        return built;\n      };\n      Object.defineProperty(builders, getBuilderName(this.typeName), {\n        enumerable: true,\n        value: builder\n      });\n      return this;\n    }\n    // The reason fields are specified using .field(...) instead of an object\n    // literal syntax is somewhat subtle: the object literal syntax would\n    // support only one key and one value, but with .field(...) we can pass\n    // any number of arguments to specify the field.\n    field(name, type, defaultFn, hidden) {\n      if (this.finalized) {\n        console.error(\"Ignoring attempt to redefine field \" + JSON.stringify(name) + \" of finalized type \" + JSON.stringify(this.typeName));\n        return this;\n      }\n      this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);\n      return this;\n    }\n    finalize() {\n      if (!this.finalized) {\n        var allFields = this.allFields;\n        var allSupertypes = this.allSupertypes;\n        this.baseNames.forEach((name) => {\n          var def = defCache[name];\n          if (def instanceof Def) {\n            def.finalize();\n            extend(allFields, def.allFields);\n            extend(allSupertypes, def.allSupertypes);\n          } else {\n            var message = \"unknown supertype name \" + JSON.stringify(name) + \" for subtype \" + JSON.stringify(this.typeName);\n            throw new Error(message);\n          }\n        });\n        extend(allFields, this.ownFields);\n        allSupertypes[this.typeName] = this;\n        this.fieldNames.length = 0;\n        for (var fieldName in allFields) {\n          if (hasOwn$6.call(allFields, fieldName) && !allFields[fieldName].hidden) {\n            this.fieldNames.push(fieldName);\n          }\n        }\n        Object.defineProperty(namedTypes, this.typeName, {\n          enumerable: true,\n          value: this.type\n        });\n        this.finalized = true;\n        populateSupertypeList(this.typeName, this.supertypeList);\n        if (this.buildable && this.supertypeList.lastIndexOf(\"Expression\") >= 0) {\n          wrapExpressionBuilderWithStatement(this.typeName);\n        }\n      }\n    }\n  }\n  function getSupertypeNames(typeName) {\n    if (!hasOwn$6.call(defCache, typeName)) {\n      throw new Error(\"\");\n    }\n    var d = defCache[typeName];\n    if (d.finalized !== true) {\n      throw new Error(\"\");\n    }\n    return d.supertypeList.slice(1);\n  }\n  function computeSupertypeLookupTable(candidates) {\n    var table = {};\n    var typeNames = Object.keys(defCache);\n    var typeNameCount = typeNames.length;\n    for (var i = 0; i < typeNameCount; ++i) {\n      var typeName = typeNames[i];\n      var d = defCache[typeName];\n      if (d.finalized !== true) {\n        throw new Error(\"\" + typeName);\n      }\n      for (var j = 0; j < d.supertypeList.length; ++j) {\n        var superTypeName = d.supertypeList[j];\n        if (hasOwn$6.call(candidates, superTypeName)) {\n          table[typeName] = superTypeName;\n          break;\n        }\n      }\n    }\n    return table;\n  }\n  var builders = /* @__PURE__ */ Object.create(null);\n  var nodePrototype = {};\n  function defineMethod(name, func) {\n    var old = nodePrototype[name];\n    if (isUndefined.check(func)) {\n      delete nodePrototype[name];\n    } else {\n      isFunction.assert(func);\n      Object.defineProperty(nodePrototype, name, {\n        enumerable: true,\n        // For discoverability.\n        configurable: true,\n        // For delete proto[name].\n        value: func\n      });\n    }\n    return old;\n  }\n  function getBuilderName(typeName) {\n    return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {\n      var len = upperCasePrefix.length;\n      switch (len) {\n        case 0:\n          return \"\";\n        case 1:\n          return upperCasePrefix.toLowerCase();\n        default:\n          return upperCasePrefix.slice(\n            0,\n            len - 1\n          ).toLowerCase() + upperCasePrefix.charAt(len - 1);\n      }\n    });\n  }\n  function getStatementBuilderName(typeName) {\n    typeName = getBuilderName(typeName);\n    return typeName.replace(/(Expression)?$/, \"Statement\");\n  }\n  var namedTypes = {};\n  function getFieldNames(object) {\n    var d = defFromValue(object);\n    if (d) {\n      return d.fieldNames.slice(0);\n    }\n    if (\"type\" in object) {\n      throw new Error(\n        \"did not recognize object of type \" + JSON.stringify(object.type)\n      );\n    }\n    return Object.keys(object);\n  }\n  function getFieldValue(object, fieldName) {\n    var d = defFromValue(object);\n    if (d) {\n      var field = d.allFields[fieldName];\n      if (field) {\n        return field.getValue(object);\n      }\n    }\n    return object && object[fieldName];\n  }\n  function eachField(object, callback, context) {\n    getFieldNames(object).forEach(function(name) {\n      callback.call(this, name, getFieldValue(object, name));\n    }, context);\n  }\n  function someField(object, callback, context) {\n    return getFieldNames(object).some(function(name) {\n      return callback.call(this, name, getFieldValue(object, name));\n    }, context);\n  }\n  function wrapExpressionBuilderWithStatement(typeName) {\n    var wrapperName = getStatementBuilderName(typeName);\n    if (builders[wrapperName])\n      return;\n    var wrapped = builders[getBuilderName(typeName)];\n    if (!wrapped)\n      return;\n    const builder = function(...args) {\n      return builders.expressionStatement(wrapped.apply(builders, args));\n    };\n    builder.from = function(...args) {\n      return builders.expressionStatement(wrapped.from.apply(builders, args));\n    };\n    builders[wrapperName] = builder;\n  }\n  function populateSupertypeList(typeName, list) {\n    list.length = 0;\n    list.push(typeName);\n    var lastSeen = /* @__PURE__ */ Object.create(null);\n    for (var pos = 0; pos < list.length; ++pos) {\n      typeName = list[pos];\n      var d = defCache[typeName];\n      if (d.finalized !== true) {\n        throw new Error(\"\");\n      }\n      if (hasOwn$6.call(lastSeen, typeName)) {\n        delete list[lastSeen[typeName]];\n      }\n      lastSeen[typeName] = pos;\n      list.push.apply(list, d.baseNames);\n    }\n    for (var to = 0, from = to, len = list.length; from < len; ++from) {\n      if (hasOwn$6.call(list, from)) {\n        list[to++] = list[from];\n      }\n    }\n    list.length = to;\n  }\n  function extend(into, from) {\n    Object.keys(from).forEach(function(name) {\n      into[name] = from[name];\n    });\n    return into;\n  }\n  function finalize() {\n    Object.keys(defCache).forEach(function(name) {\n      defCache[name].finalize();\n    });\n  }\n  return {\n    Type,\n    builtInTypes,\n    getSupertypeNames,\n    computeSupertypeLookupTable,\n    builders,\n    defineMethod,\n    getBuilderName,\n    getStatementBuilderName,\n    namedTypes,\n    getFieldNames,\n    getFieldValue,\n    eachField,\n    someField,\n    finalize\n  };\n}\nmaybeSetModuleExports(() => module);\n\nvar Op = Object.prototype;\nvar hasOwn$5 = Op.hasOwnProperty;\nfunction pathPlugin(fork) {\n  var types = fork.use(typesPlugin);\n  var isArray = types.builtInTypes.array;\n  var isNumber = types.builtInTypes.number;\n  const Path = function Path2(value, parentPath, name) {\n    if (!(this instanceof Path2)) {\n      throw new Error(\"Path constructor cannot be invoked without 'new'\");\n    }\n    if (parentPath) {\n      if (!(parentPath instanceof Path2)) {\n        throw new Error(\"\");\n      }\n    } else {\n      parentPath = null;\n      name = null;\n    }\n    this.value = value;\n    this.parentPath = parentPath;\n    this.name = name;\n    this.__childCache = null;\n  };\n  var Pp = Path.prototype;\n  function getChildCache(path) {\n    return path.__childCache || (path.__childCache = /* @__PURE__ */ Object.create(null));\n  }\n  function getChildPath(path, name) {\n    var cache = getChildCache(path);\n    var actualChildValue = path.getValueProperty(name);\n    var childPath = cache[name];\n    if (!hasOwn$5.call(cache, name) || // Ensure consistency between cache and reality.\n    childPath.value !== actualChildValue) {\n      childPath = cache[name] = new path.constructor(\n        actualChildValue,\n        path,\n        name\n      );\n    }\n    return childPath;\n  }\n  Pp.getValueProperty = function getValueProperty(name) {\n    return this.value[name];\n  };\n  Pp.get = function get(...names) {\n    var path = this;\n    var count = names.length;\n    for (var i = 0; i < count; ++i) {\n      path = getChildPath(path, names[i]);\n    }\n    return path;\n  };\n  Pp.each = function each(callback, context) {\n    var childPaths = [];\n    var len = this.value.length;\n    var i = 0;\n    for (var i = 0; i < len; ++i) {\n      if (hasOwn$5.call(this.value, i)) {\n        childPaths[i] = this.get(i);\n      }\n    }\n    context = context || this;\n    for (i = 0; i < len; ++i) {\n      if (hasOwn$5.call(childPaths, i)) {\n        callback.call(context, childPaths[i]);\n      }\n    }\n  };\n  Pp.map = function map(callback, context) {\n    var result = [];\n    this.each(function(childPath) {\n      result.push(callback.call(this, childPath));\n    }, context);\n    return result;\n  };\n  Pp.filter = function filter(callback, context) {\n    var result = [];\n    this.each(function(childPath) {\n      if (callback.call(this, childPath)) {\n        result.push(childPath);\n      }\n    }, context);\n    return result;\n  };\n  function emptyMoves() {\n  }\n  function getMoves(path, offset, start, end) {\n    isArray.assert(path.value);\n    if (offset === 0) {\n      return emptyMoves;\n    }\n    var length = path.value.length;\n    if (length < 1) {\n      return emptyMoves;\n    }\n    var argc = arguments.length;\n    if (argc === 2) {\n      start = 0;\n      end = length;\n    } else if (argc === 3) {\n      start = Math.max(start, 0);\n      end = length;\n    } else {\n      start = Math.max(start, 0);\n      end = Math.min(end, length);\n    }\n    isNumber.assert(start);\n    isNumber.assert(end);\n    var moves = /* @__PURE__ */ Object.create(null);\n    var cache = getChildCache(path);\n    for (var i = start; i < end; ++i) {\n      if (hasOwn$5.call(path.value, i)) {\n        var childPath = path.get(i);\n        if (childPath.name !== i) {\n          throw new Error(\"\");\n        }\n        var newIndex = i + offset;\n        childPath.name = newIndex;\n        moves[newIndex] = childPath;\n        delete cache[i];\n      }\n    }\n    delete cache.length;\n    return function() {\n      for (var newIndex2 in moves) {\n        var childPath2 = moves[newIndex2];\n        if (childPath2.name !== +newIndex2) {\n          throw new Error(\"\");\n        }\n        cache[newIndex2] = childPath2;\n        path.value[newIndex2] = childPath2.value;\n      }\n    };\n  }\n  Pp.shift = function shift() {\n    var move = getMoves(this, -1);\n    var result = this.value.shift();\n    move();\n    return result;\n  };\n  Pp.unshift = function unshift(...args) {\n    var move = getMoves(this, args.length);\n    var result = this.value.unshift.apply(this.value, args);\n    move();\n    return result;\n  };\n  Pp.push = function push(...args) {\n    isArray.assert(this.value);\n    delete getChildCache(this).length;\n    return this.value.push.apply(this.value, args);\n  };\n  Pp.pop = function pop() {\n    isArray.assert(this.value);\n    var cache = getChildCache(this);\n    delete cache[this.value.length - 1];\n    delete cache.length;\n    return this.value.pop();\n  };\n  Pp.insertAt = function insertAt(index) {\n    var argc = arguments.length;\n    var move = getMoves(this, argc - 1, index);\n    if (move === emptyMoves && argc <= 1) {\n      return this;\n    }\n    index = Math.max(index, 0);\n    for (var i = 1; i < argc; ++i) {\n      this.value[index + i - 1] = arguments[i];\n    }\n    move();\n    return this;\n  };\n  Pp.insertBefore = function insertBefore(...args) {\n    var pp = this.parentPath;\n    var argc = args.length;\n    var insertAtArgs = [this.name];\n    for (var i = 0; i < argc; ++i) {\n      insertAtArgs.push(args[i]);\n    }\n    return pp.insertAt.apply(pp, insertAtArgs);\n  };\n  Pp.insertAfter = function insertAfter(...args) {\n    var pp = this.parentPath;\n    var argc = args.length;\n    var insertAtArgs = [this.name + 1];\n    for (var i = 0; i < argc; ++i) {\n      insertAtArgs.push(args[i]);\n    }\n    return pp.insertAt.apply(pp, insertAtArgs);\n  };\n  function repairRelationshipWithParent(path) {\n    if (!(path instanceof Path)) {\n      throw new Error(\"\");\n    }\n    var pp = path.parentPath;\n    if (!pp) {\n      return path;\n    }\n    var parentValue = pp.value;\n    var parentCache = getChildCache(pp);\n    if (parentValue[path.name] === path.value) {\n      parentCache[path.name] = path;\n    } else if (isArray.check(parentValue)) {\n      var i = parentValue.indexOf(path.value);\n      if (i >= 0) {\n        parentCache[path.name = i] = path;\n      }\n    } else {\n      parentValue[path.name] = path.value;\n      parentCache[path.name] = path;\n    }\n    if (parentValue[path.name] !== path.value) {\n      throw new Error(\"\");\n    }\n    if (path.parentPath.get(path.name) !== path) {\n      throw new Error(\"\");\n    }\n    return path;\n  }\n  Pp.replace = function replace(replacement) {\n    var results = [];\n    var parentValue = this.parentPath.value;\n    var parentCache = getChildCache(this.parentPath);\n    var count = arguments.length;\n    repairRelationshipWithParent(this);\n    if (isArray.check(parentValue)) {\n      var originalLength = parentValue.length;\n      var move = getMoves(this.parentPath, count - 1, this.name + 1);\n      var spliceArgs = [this.name, 1];\n      for (var i = 0; i < count; ++i) {\n        spliceArgs.push(arguments[i]);\n      }\n      var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);\n      if (splicedOut[0] !== this.value) {\n        throw new Error(\"\");\n      }\n      if (parentValue.length !== originalLength - 1 + count) {\n        throw new Error(\"\");\n      }\n      move();\n      if (count === 0) {\n        delete this.value;\n        delete parentCache[this.name];\n        this.__childCache = null;\n      } else {\n        if (parentValue[this.name] !== replacement) {\n          throw new Error(\"\");\n        }\n        if (this.value !== replacement) {\n          this.value = replacement;\n          this.__childCache = null;\n        }\n        for (i = 0; i < count; ++i) {\n          results.push(this.parentPath.get(this.name + i));\n        }\n        if (results[0] !== this) {\n          throw new Error(\"\");\n        }\n      }\n    } else if (count === 1) {\n      if (this.value !== replacement) {\n        this.__childCache = null;\n      }\n      this.value = parentValue[this.name] = replacement;\n      results.push(this);\n    } else if (count === 0) {\n      delete parentValue[this.name];\n      delete this.value;\n      this.__childCache = null;\n    } else {\n      throw new Error(\"Could not replace path\");\n    }\n    return results;\n  };\n  return Path;\n}\nmaybeSetModuleExports(() => module);\n\nvar hasOwn$4 = Object.prototype.hasOwnProperty;\nfunction scopePlugin(fork) {\n  var types = fork.use(typesPlugin);\n  var Type = types.Type;\n  var namedTypes = types.namedTypes;\n  var Node = namedTypes.Node;\n  var Expression = namedTypes.Expression;\n  var isArray = types.builtInTypes.array;\n  var b = types.builders;\n  const Scope = function Scope2(path, parentScope) {\n    if (!(this instanceof Scope2)) {\n      throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n    }\n    if (!TypeParameterScopeType.check(path.value)) {\n      ScopeType.assert(path.value);\n    }\n    var depth;\n    if (parentScope) {\n      if (!(parentScope instanceof Scope2)) {\n        throw new Error(\"\");\n      }\n      depth = parentScope.depth + 1;\n    } else {\n      parentScope = null;\n      depth = 0;\n    }\n    Object.defineProperties(this, {\n      path: { value: path },\n      node: { value: path.value },\n      isGlobal: { value: !parentScope, enumerable: true },\n      depth: { value: depth },\n      parent: { value: parentScope },\n      bindings: { value: {} },\n      types: { value: {} }\n    });\n  };\n  var ScopeType = Type.or(\n    // Program nodes introduce global scopes.\n    namedTypes.Program,\n    // Function is the supertype of FunctionExpression,\n    // FunctionDeclaration, ArrowExpression, etc.\n    namedTypes.Function,\n    // In case you didn't know, the caught parameter shadows any variable\n    // of the same name in an outer scope.\n    namedTypes.CatchClause\n  );\n  var TypeParameterScopeType = Type.or(\n    namedTypes.Function,\n    namedTypes.ClassDeclaration,\n    namedTypes.ClassExpression,\n    namedTypes.InterfaceDeclaration,\n    namedTypes.TSInterfaceDeclaration,\n    namedTypes.TypeAlias,\n    namedTypes.TSTypeAliasDeclaration\n  );\n  var FlowOrTSTypeParameterType = Type.or(\n    namedTypes.TypeParameter,\n    namedTypes.TSTypeParameter\n  );\n  Scope.isEstablishedBy = function(node) {\n    return ScopeType.check(node) || TypeParameterScopeType.check(node);\n  };\n  var Sp = Scope.prototype;\n  Sp.didScan = false;\n  Sp.declares = function(name) {\n    this.scan();\n    return hasOwn$4.call(this.bindings, name);\n  };\n  Sp.declaresType = function(name) {\n    this.scan();\n    return hasOwn$4.call(this.types, name);\n  };\n  Sp.declareTemporary = function(prefix) {\n    if (prefix) {\n      if (!/^[a-z$_]/i.test(prefix)) {\n        throw new Error(\"\");\n      }\n    } else {\n      prefix = \"t$\";\n    }\n    prefix += this.depth.toString(36) + \"$\";\n    this.scan();\n    var index = 0;\n    while (this.declares(prefix + index)) {\n      ++index;\n    }\n    var name = prefix + index;\n    return this.bindings[name] = types.builders.identifier(name);\n  };\n  Sp.injectTemporary = function(identifier, init) {\n    identifier || (identifier = this.declareTemporary());\n    var bodyPath = this.path.get(\"body\");\n    if (namedTypes.BlockStatement.check(bodyPath.value)) {\n      bodyPath = bodyPath.get(\"body\");\n    }\n    bodyPath.unshift(\n      b.variableDeclaration(\n        \"var\",\n        [b.variableDeclarator(identifier, init || null)]\n      )\n    );\n    return identifier;\n  };\n  Sp.scan = function(force) {\n    if (force || !this.didScan) {\n      for (var name in this.bindings) {\n        delete this.bindings[name];\n      }\n      for (var name in this.types) {\n        delete this.types[name];\n      }\n      scanScope(this.path, this.bindings, this.types);\n      this.didScan = true;\n    }\n  };\n  Sp.getBindings = function() {\n    this.scan();\n    return this.bindings;\n  };\n  Sp.getTypes = function() {\n    this.scan();\n    return this.types;\n  };\n  function scanScope(path, bindings, scopeTypes) {\n    var node = path.value;\n    if (TypeParameterScopeType.check(node)) {\n      const params = path.get(\"typeParameters\", \"params\");\n      if (isArray.check(params.value)) {\n        params.each((childPath) => {\n          addTypeParameter(childPath, scopeTypes);\n        });\n      }\n    }\n    if (ScopeType.check(node)) {\n      if (namedTypes.CatchClause.check(node)) {\n        addPattern(path.get(\"param\"), bindings);\n      } else {\n        recursiveScanScope(path, bindings, scopeTypes);\n      }\n    }\n  }\n  function recursiveScanScope(path, bindings, scopeTypes) {\n    var node = path.value;\n    if (path.parent && namedTypes.FunctionExpression.check(path.parent.node) && path.parent.node.id) {\n      addPattern(path.parent.get(\"id\"), bindings);\n    }\n    if (!node) ; else if (isArray.check(node)) {\n      path.each((childPath) => {\n        recursiveScanChild(childPath, bindings, scopeTypes);\n      });\n    } else if (namedTypes.Function.check(node)) {\n      path.get(\"params\").each((paramPath) => {\n        addPattern(paramPath, bindings);\n      });\n      recursiveScanChild(path.get(\"body\"), bindings, scopeTypes);\n      recursiveScanScope(path.get(\"typeParameters\"), bindings, scopeTypes);\n    } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node) || namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {\n      addTypePattern(path.get(\"id\"), scopeTypes);\n    } else if (namedTypes.VariableDeclarator.check(node)) {\n      addPattern(path.get(\"id\"), bindings);\n      recursiveScanChild(path.get(\"init\"), bindings, scopeTypes);\n    } else if (node.type === \"ImportSpecifier\" || node.type === \"ImportNamespaceSpecifier\" || node.type === \"ImportDefaultSpecifier\") {\n      addPattern(\n        // Esprima used to use the .name field to refer to the local\n        // binding identifier for ImportSpecifier nodes, but .id for\n        // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.\n        // ESTree/Acorn/ESpree use .local for all three node types.\n        path.get(node.local ? \"local\" : node.name ? \"name\" : \"id\"),\n        bindings\n      );\n    } else if (Node.check(node) && !Expression.check(node)) {\n      types.eachField(node, function(name, child) {\n        var childPath = path.get(name);\n        if (!pathHasValue(childPath, child)) {\n          throw new Error(\"\");\n        }\n        recursiveScanChild(childPath, bindings, scopeTypes);\n      });\n    }\n  }\n  function pathHasValue(path, value) {\n    if (path.value === value) {\n      return true;\n    }\n    if (Array.isArray(path.value) && path.value.length === 0 && Array.isArray(value) && value.length === 0) {\n      return true;\n    }\n    return false;\n  }\n  function recursiveScanChild(path, bindings, scopeTypes) {\n    var node = path.value;\n    if (!node || Expression.check(node)) ; else if (namedTypes.FunctionDeclaration.check(node) && node.id !== null) {\n      addPattern(path.get(\"id\"), bindings);\n    } else if (namedTypes.ClassDeclaration && namedTypes.ClassDeclaration.check(node) && node.id !== null) {\n      addPattern(path.get(\"id\"), bindings);\n      recursiveScanScope(path.get(\"typeParameters\"), bindings, scopeTypes);\n    } else if (namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {\n      addTypePattern(path.get(\"id\"), scopeTypes);\n    } else if (ScopeType.check(node)) {\n      if (namedTypes.CatchClause.check(node) && // TODO Broaden this to accept any pattern.\n      namedTypes.Identifier.check(node.param)) {\n        var catchParamName = node.param.name;\n        var hadBinding = hasOwn$4.call(bindings, catchParamName);\n        recursiveScanScope(path.get(\"body\"), bindings, scopeTypes);\n        if (!hadBinding) {\n          delete bindings[catchParamName];\n        }\n      }\n    } else {\n      recursiveScanScope(path, bindings, scopeTypes);\n    }\n  }\n  function addPattern(patternPath, bindings) {\n    var pattern = patternPath.value;\n    namedTypes.Pattern.assert(pattern);\n    if (namedTypes.Identifier.check(pattern)) {\n      if (hasOwn$4.call(bindings, pattern.name)) {\n        bindings[pattern.name].push(patternPath);\n      } else {\n        bindings[pattern.name] = [patternPath];\n      }\n    } else if (namedTypes.AssignmentPattern && namedTypes.AssignmentPattern.check(pattern)) {\n      addPattern(patternPath.get(\"left\"), bindings);\n    } else if (namedTypes.ObjectPattern && namedTypes.ObjectPattern.check(pattern)) {\n      patternPath.get(\"properties\").each(function(propertyPath) {\n        var property = propertyPath.value;\n        if (namedTypes.Pattern.check(property)) {\n          addPattern(propertyPath, bindings);\n        } else if (namedTypes.Property.check(property) || namedTypes.ObjectProperty && namedTypes.ObjectProperty.check(property)) {\n          addPattern(propertyPath.get(\"value\"), bindings);\n        } else if (namedTypes.SpreadProperty && namedTypes.SpreadProperty.check(property)) {\n          addPattern(propertyPath.get(\"argument\"), bindings);\n        }\n      });\n    } else if (namedTypes.ArrayPattern && namedTypes.ArrayPattern.check(pattern)) {\n      patternPath.get(\"elements\").each(function(elementPath) {\n        var element = elementPath.value;\n        if (namedTypes.Pattern.check(element)) {\n          addPattern(elementPath, bindings);\n        } else if (namedTypes.SpreadElement && namedTypes.SpreadElement.check(element)) {\n          addPattern(elementPath.get(\"argument\"), bindings);\n        }\n      });\n    } else if (namedTypes.PropertyPattern && namedTypes.PropertyPattern.check(pattern)) {\n      addPattern(patternPath.get(\"pattern\"), bindings);\n    } else if (namedTypes.SpreadElementPattern && namedTypes.SpreadElementPattern.check(pattern) || namedTypes.RestElement && namedTypes.RestElement.check(pattern) || namedTypes.SpreadPropertyPattern && namedTypes.SpreadPropertyPattern.check(pattern)) {\n      addPattern(patternPath.get(\"argument\"), bindings);\n    }\n  }\n  function addTypePattern(patternPath, types2) {\n    var pattern = patternPath.value;\n    namedTypes.Pattern.assert(pattern);\n    if (namedTypes.Identifier.check(pattern)) {\n      if (hasOwn$4.call(types2, pattern.name)) {\n        types2[pattern.name].push(patternPath);\n      } else {\n        types2[pattern.name] = [patternPath];\n      }\n    }\n  }\n  function addTypeParameter(parameterPath, types2) {\n    var parameter = parameterPath.value;\n    FlowOrTSTypeParameterType.assert(parameter);\n    if (hasOwn$4.call(types2, parameter.name)) {\n      types2[parameter.name].push(parameterPath);\n    } else {\n      types2[parameter.name] = [parameterPath];\n    }\n  }\n  Sp.lookup = function(name) {\n    for (var scope = this; scope; scope = scope.parent)\n      if (scope.declares(name))\n        break;\n    return scope;\n  };\n  Sp.lookupType = function(name) {\n    for (var scope = this; scope; scope = scope.parent)\n      if (scope.declaresType(name))\n        break;\n    return scope;\n  };\n  Sp.getGlobalScope = function() {\n    var scope = this;\n    while (!scope.isGlobal)\n      scope = scope.parent;\n    return scope;\n  };\n  return Scope;\n}\nmaybeSetModuleExports(() => module);\n\nfunction nodePathPlugin(fork) {\n  var types = fork.use(typesPlugin);\n  var n = types.namedTypes;\n  var b = types.builders;\n  var isNumber = types.builtInTypes.number;\n  var isArray = types.builtInTypes.array;\n  var Path2 = fork.use(pathPlugin);\n  var Scope2 = fork.use(scopePlugin);\n  const NodePath = function NodePath2(value, parentPath, name) {\n    if (!(this instanceof NodePath2)) {\n      throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n    }\n    Path2.call(this, value, parentPath, name);\n  };\n  var NPp = NodePath.prototype = Object.create(Path2.prototype, {\n    constructor: {\n      value: NodePath,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperties(NPp, {\n    node: {\n      get: function() {\n        Object.defineProperty(this, \"node\", {\n          configurable: true,\n          // Enable deletion.\n          value: this._computeNode()\n        });\n        return this.node;\n      }\n    },\n    parent: {\n      get: function() {\n        Object.defineProperty(this, \"parent\", {\n          configurable: true,\n          // Enable deletion.\n          value: this._computeParent()\n        });\n        return this.parent;\n      }\n    },\n    scope: {\n      get: function() {\n        Object.defineProperty(this, \"scope\", {\n          configurable: true,\n          // Enable deletion.\n          value: this._computeScope()\n        });\n        return this.scope;\n      }\n    }\n  });\n  NPp.replace = function() {\n    delete this.node;\n    delete this.parent;\n    delete this.scope;\n    return Path2.prototype.replace.apply(this, arguments);\n  };\n  NPp.prune = function() {\n    var remainingNodePath = this.parent;\n    this.replace();\n    return cleanUpNodesAfterPrune(remainingNodePath);\n  };\n  NPp._computeNode = function() {\n    var value = this.value;\n    if (n.Node.check(value)) {\n      return value;\n    }\n    var pp = this.parentPath;\n    return pp && pp.node || null;\n  };\n  NPp._computeParent = function() {\n    var value = this.value;\n    var pp = this.parentPath;\n    if (!n.Node.check(value)) {\n      while (pp && !n.Node.check(pp.value)) {\n        pp = pp.parentPath;\n      }\n      if (pp) {\n        pp = pp.parentPath;\n      }\n    }\n    while (pp && !n.Node.check(pp.value)) {\n      pp = pp.parentPath;\n    }\n    return pp || null;\n  };\n  NPp._computeScope = function() {\n    var value = this.value;\n    var pp = this.parentPath;\n    var scope = pp && pp.scope;\n    if (n.Node.check(value) && Scope2.isEstablishedBy(value)) {\n      scope = new Scope2(this, scope);\n    }\n    return scope || null;\n  };\n  NPp.getValueProperty = function(name) {\n    return types.getFieldValue(this.value, name);\n  };\n  NPp.needsParens = function(assumeExpressionContext) {\n    var pp = this.parentPath;\n    if (!pp) {\n      return false;\n    }\n    var node = this.value;\n    if (!n.Expression.check(node)) {\n      return false;\n    }\n    if (node.type === \"Identifier\") {\n      return false;\n    }\n    while (!n.Node.check(pp.value)) {\n      pp = pp.parentPath;\n      if (!pp) {\n        return false;\n      }\n    }\n    var parent = pp.value;\n    switch (node.type) {\n      case \"UnaryExpression\":\n      case \"SpreadElement\":\n      case \"SpreadProperty\":\n        return parent.type === \"MemberExpression\" && this.name === \"object\" && parent.object === node;\n      case \"BinaryExpression\":\n      case \"LogicalExpression\":\n        switch (parent.type) {\n          case \"CallExpression\":\n            return this.name === \"callee\" && parent.callee === node;\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n            return true;\n          case \"MemberExpression\":\n            return this.name === \"object\" && parent.object === node;\n          case \"BinaryExpression\":\n          case \"LogicalExpression\": {\n            const n2 = node;\n            const po = parent.operator;\n            const pp2 = PRECEDENCE[po];\n            const no = n2.operator;\n            const np = PRECEDENCE[no];\n            if (pp2 > np) {\n              return true;\n            }\n            if (pp2 === np && this.name === \"right\") {\n              if (parent.right !== n2) {\n                throw new Error(\"Nodes must be equal\");\n              }\n              return true;\n            }\n          }\n          default:\n            return false;\n        }\n      case \"SequenceExpression\":\n        switch (parent.type) {\n          case \"ForStatement\":\n            return false;\n          case \"ExpressionStatement\":\n            return this.name !== \"expression\";\n          default:\n            return true;\n        }\n      case \"YieldExpression\":\n        switch (parent.type) {\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"CallExpression\":\n          case \"MemberExpression\":\n          case \"NewExpression\":\n          case \"ConditionalExpression\":\n          case \"YieldExpression\":\n            return true;\n          default:\n            return false;\n        }\n      case \"Literal\":\n        return parent.type === \"MemberExpression\" && isNumber.check(node.value) && this.name === \"object\" && parent.object === node;\n      case \"AssignmentExpression\":\n      case \"ConditionalExpression\":\n        switch (parent.type) {\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n            return true;\n          case \"CallExpression\":\n            return this.name === \"callee\" && parent.callee === node;\n          case \"ConditionalExpression\":\n            return this.name === \"test\" && parent.test === node;\n          case \"MemberExpression\":\n            return this.name === \"object\" && parent.object === node;\n          default:\n            return false;\n        }\n      default:\n        if (parent.type === \"NewExpression\" && this.name === \"callee\" && parent.callee === node) {\n          return containsCallExpression(node);\n        }\n    }\n    if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement())\n      return true;\n    return false;\n  };\n  function isBinary(node) {\n    return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n  }\n  var PRECEDENCE = {};\n  [\n    [\"||\"],\n    [\"&&\"],\n    [\"|\"],\n    [\"^\"],\n    [\"&\"],\n    [\"==\", \"===\", \"!=\", \"!==\"],\n    [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n    [\">>\", \"<<\", \">>>\"],\n    [\"+\", \"-\"],\n    [\"*\", \"/\", \"%\"]\n  ].forEach(function(tier, i) {\n    tier.forEach(function(op) {\n      PRECEDENCE[op] = i;\n    });\n  });\n  function containsCallExpression(node) {\n    if (n.CallExpression.check(node)) {\n      return true;\n    }\n    if (isArray.check(node)) {\n      return node.some(containsCallExpression);\n    }\n    if (n.Node.check(node)) {\n      return types.someField(node, function(_name, child) {\n        return containsCallExpression(child);\n      });\n    }\n    return false;\n  }\n  NPp.canBeFirstInStatement = function() {\n    var node = this.node;\n    return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);\n  };\n  NPp.firstInStatement = function() {\n    return firstInStatement(this);\n  };\n  function firstInStatement(path) {\n    for (var node, parent; path.parent; path = path.parent) {\n      node = path.node;\n      parent = path.parent.node;\n      if (n.BlockStatement.check(parent) && path.parent.name === \"body\" && path.name === 0) {\n        if (parent.body[0] !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        return true;\n      }\n      if (n.ExpressionStatement.check(parent) && path.name === \"expression\") {\n        if (parent.expression !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        return true;\n      }\n      if (n.SequenceExpression.check(parent) && path.parent.name === \"expressions\" && path.name === 0) {\n        if (parent.expressions[0] !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        continue;\n      }\n      if (n.CallExpression.check(parent) && path.name === \"callee\") {\n        if (parent.callee !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        continue;\n      }\n      if (n.MemberExpression.check(parent) && path.name === \"object\") {\n        if (parent.object !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        continue;\n      }\n      if (n.ConditionalExpression.check(parent) && path.name === \"test\") {\n        if (parent.test !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        continue;\n      }\n      if (isBinary(parent) && path.name === \"left\") {\n        if (parent.left !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        continue;\n      }\n      if (n.UnaryExpression.check(parent) && !parent.prefix && path.name === \"argument\") {\n        if (parent.argument !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        continue;\n      }\n      return false;\n    }\n    return true;\n  }\n  function cleanUpNodesAfterPrune(remainingNodePath) {\n    if (n.VariableDeclaration.check(remainingNodePath.node)) {\n      var declarations = remainingNodePath.get(\"declarations\").value;\n      if (!declarations || declarations.length === 0) {\n        return remainingNodePath.prune();\n      }\n    } else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n      if (!remainingNodePath.get(\"expression\").value) {\n        return remainingNodePath.prune();\n      }\n    } else if (n.IfStatement.check(remainingNodePath.node)) {\n      cleanUpIfStatementAfterPrune(remainingNodePath);\n    }\n    return remainingNodePath;\n  }\n  function cleanUpIfStatementAfterPrune(ifStatement) {\n    var testExpression = ifStatement.get(\"test\").value;\n    var alternate = ifStatement.get(\"alternate\").value;\n    var consequent = ifStatement.get(\"consequent\").value;\n    if (!consequent && !alternate) {\n      var testExpressionStatement = b.expressionStatement(testExpression);\n      ifStatement.replace(testExpressionStatement);\n    } else if (!consequent && alternate) {\n      var negatedTestExpression = b.unaryExpression(\"!\", testExpression, true);\n      if (n.UnaryExpression.check(testExpression) && testExpression.operator === \"!\") {\n        negatedTestExpression = testExpression.argument;\n      }\n      ifStatement.get(\"test\").replace(negatedTestExpression);\n      ifStatement.get(\"consequent\").replace(alternate);\n      ifStatement.get(\"alternate\").replace();\n    }\n  }\n  return NodePath;\n}\nmaybeSetModuleExports(() => module);\n\nvar hasOwn$3 = Object.prototype.hasOwnProperty;\nfunction pathVisitorPlugin(fork) {\n  var types = fork.use(typesPlugin);\n  var NodePath2 = fork.use(nodePathPlugin);\n  var isArray = types.builtInTypes.array;\n  var isObject = types.builtInTypes.object;\n  var isFunction = types.builtInTypes.function;\n  var undefined$1;\n  const PathVisitor = function PathVisitor2() {\n    if (!(this instanceof PathVisitor2)) {\n      throw new Error(\n        \"PathVisitor constructor cannot be invoked without 'new'\"\n      );\n    }\n    this._reusableContextStack = [];\n    this._methodNameTable = computeMethodNameTable(this);\n    this._shouldVisitComments = hasOwn$3.call(this._methodNameTable, \"Block\") || hasOwn$3.call(this._methodNameTable, \"Line\");\n    this.Context = makeContextConstructor(this);\n    this._visiting = false;\n    this._changeReported = false;\n  };\n  function computeMethodNameTable(visitor) {\n    var typeNames = /* @__PURE__ */ Object.create(null);\n    for (var methodName in visitor) {\n      if (/^visit[A-Z]/.test(methodName)) {\n        typeNames[methodName.slice(\"visit\".length)] = true;\n      }\n    }\n    var supertypeTable = types.computeSupertypeLookupTable(typeNames);\n    var methodNameTable = /* @__PURE__ */ Object.create(null);\n    var typeNameKeys = Object.keys(supertypeTable);\n    var typeNameCount = typeNameKeys.length;\n    for (var i = 0; i < typeNameCount; ++i) {\n      var typeName = typeNameKeys[i];\n      methodName = \"visit\" + supertypeTable[typeName];\n      if (isFunction.check(visitor[methodName])) {\n        methodNameTable[typeName] = methodName;\n      }\n    }\n    return methodNameTable;\n  }\n  PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {\n    if (methods instanceof PathVisitor) {\n      return methods;\n    }\n    if (!isObject.check(methods)) {\n      return new PathVisitor();\n    }\n    const Visitor = function Visitor2() {\n      if (!(this instanceof Visitor2)) {\n        throw new Error(\n          \"Visitor constructor cannot be invoked without 'new'\"\n        );\n      }\n      PathVisitor.call(this);\n    };\n    var Vp = Visitor.prototype = Object.create(PVp);\n    Vp.constructor = Visitor;\n    extend(Vp, methods);\n    extend(Visitor, PathVisitor);\n    isFunction.assert(Visitor.fromMethodsObject);\n    isFunction.assert(Visitor.visit);\n    return new Visitor();\n  };\n  function extend(target, source) {\n    for (var property in source) {\n      if (hasOwn$3.call(source, property)) {\n        target[property] = source[property];\n      }\n    }\n    return target;\n  }\n  PathVisitor.visit = function visit(node, methods) {\n    return PathVisitor.fromMethodsObject(methods).visit(node);\n  };\n  var PVp = PathVisitor.prototype;\n  PVp.visit = function() {\n    if (this._visiting) {\n      throw new Error(\n        \"Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.\"\n      );\n    }\n    this._visiting = true;\n    this._changeReported = false;\n    this._abortRequested = false;\n    var argc = arguments.length;\n    var args = new Array(argc);\n    for (var i = 0; i < argc; ++i) {\n      args[i] = arguments[i];\n    }\n    if (!(args[0] instanceof NodePath2)) {\n      args[0] = new NodePath2({ root: args[0] }).get(\"root\");\n    }\n    this.reset.apply(this, args);\n    var didNotThrow;\n    try {\n      var root = this.visitWithoutReset(args[0]);\n      didNotThrow = true;\n    } finally {\n      this._visiting = false;\n      if (!didNotThrow && this._abortRequested) {\n        return args[0].value;\n      }\n    }\n    return root;\n  };\n  PVp.AbortRequest = function AbortRequest() {\n  };\n  PVp.abort = function() {\n    var visitor = this;\n    visitor._abortRequested = true;\n    var request = new visitor.AbortRequest();\n    request.cancel = function() {\n      visitor._abortRequested = false;\n    };\n    throw request;\n  };\n  PVp.reset = function(_path) {\n  };\n  PVp.visitWithoutReset = function(path) {\n    if (this instanceof this.Context) {\n      return this.visitor.visitWithoutReset(path);\n    }\n    if (!(path instanceof NodePath2)) {\n      throw new Error(\"\");\n    }\n    var value = path.value;\n    var methodName = value && typeof value === \"object\" && typeof value.type === \"string\" && this._methodNameTable[value.type];\n    if (methodName) {\n      var context = this.acquireContext(path);\n      try {\n        return context.invokeVisitorMethod(methodName);\n      } finally {\n        this.releaseContext(context);\n      }\n    } else {\n      return visitChildren(path, this);\n    }\n  };\n  function visitChildren(path, visitor) {\n    if (!(path instanceof NodePath2)) {\n      throw new Error(\"\");\n    }\n    if (!(visitor instanceof PathVisitor)) {\n      throw new Error(\"\");\n    }\n    var value = path.value;\n    if (isArray.check(value)) {\n      path.each(visitor.visitWithoutReset, visitor);\n    } else if (!isObject.check(value)) ; else {\n      var childNames = types.getFieldNames(value);\n      if (visitor._shouldVisitComments && value.comments && childNames.indexOf(\"comments\") < 0) {\n        childNames.push(\"comments\");\n      }\n      var childCount = childNames.length;\n      var childPaths = [];\n      for (var i = 0; i < childCount; ++i) {\n        var childName = childNames[i];\n        if (!hasOwn$3.call(value, childName)) {\n          value[childName] = types.getFieldValue(value, childName);\n        }\n        childPaths.push(path.get(childName));\n      }\n      for (var i = 0; i < childCount; ++i) {\n        visitor.visitWithoutReset(childPaths[i]);\n      }\n    }\n    return path.value;\n  }\n  PVp.acquireContext = function(path) {\n    if (this._reusableContextStack.length === 0) {\n      return new this.Context(path);\n    }\n    return this._reusableContextStack.pop().reset(path);\n  };\n  PVp.releaseContext = function(context) {\n    if (!(context instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n    this._reusableContextStack.push(context);\n    context.currentPath = null;\n  };\n  PVp.reportChanged = function() {\n    this._changeReported = true;\n  };\n  PVp.wasChangeReported = function() {\n    return this._changeReported;\n  };\n  function makeContextConstructor(visitor) {\n    function Context(path) {\n      if (!(this instanceof Context)) {\n        throw new Error(\"\");\n      }\n      if (!(this instanceof PathVisitor)) {\n        throw new Error(\"\");\n      }\n      if (!(path instanceof NodePath2)) {\n        throw new Error(\"\");\n      }\n      Object.defineProperty(this, \"visitor\", {\n        value: visitor,\n        writable: false,\n        enumerable: true,\n        configurable: false\n      });\n      this.currentPath = path;\n      this.needToCallTraverse = true;\n      Object.seal(this);\n    }\n    if (!(visitor instanceof PathVisitor)) {\n      throw new Error(\"\");\n    }\n    var Cp = Context.prototype = Object.create(visitor);\n    Cp.constructor = Context;\n    extend(Cp, sharedContextProtoMethods);\n    return Context;\n  }\n  var sharedContextProtoMethods = /* @__PURE__ */ Object.create(null);\n  sharedContextProtoMethods.reset = function reset(path) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n    if (!(path instanceof NodePath2)) {\n      throw new Error(\"\");\n    }\n    this.currentPath = path;\n    this.needToCallTraverse = true;\n    return this;\n  };\n  sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n    if (!(this.currentPath instanceof NodePath2)) {\n      throw new Error(\"\");\n    }\n    var result = this.visitor[methodName].call(this, this.currentPath);\n    if (result === false) {\n      this.needToCallTraverse = false;\n    } else if (result !== undefined$1) {\n      this.currentPath = this.currentPath.replace(result)[0];\n      if (this.needToCallTraverse) {\n        this.traverse(this.currentPath);\n      }\n    }\n    if (this.needToCallTraverse !== false) {\n      throw new Error(\n        \"Must either call this.traverse or return false in \" + methodName\n      );\n    }\n    var path = this.currentPath;\n    return path && path.value;\n  };\n  sharedContextProtoMethods.traverse = function traverse(path, newVisitor) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n    if (!(path instanceof NodePath2)) {\n      throw new Error(\"\");\n    }\n    if (!(this.currentPath instanceof NodePath2)) {\n      throw new Error(\"\");\n    }\n    this.needToCallTraverse = false;\n    return visitChildren(path, PathVisitor.fromMethodsObject(\n      newVisitor || this.visitor\n    ));\n  };\n  sharedContextProtoMethods.visit = function visit(path, newVisitor) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n    if (!(path instanceof NodePath2)) {\n      throw new Error(\"\");\n    }\n    if (!(this.currentPath instanceof NodePath2)) {\n      throw new Error(\"\");\n    }\n    this.needToCallTraverse = false;\n    return PathVisitor.fromMethodsObject(\n      newVisitor || this.visitor\n    ).visitWithoutReset(path);\n  };\n  sharedContextProtoMethods.reportChanged = function reportChanged() {\n    this.visitor.reportChanged();\n  };\n  sharedContextProtoMethods.abort = function abort() {\n    this.needToCallTraverse = false;\n    this.visitor.abort();\n  };\n  return PathVisitor;\n}\nmaybeSetModuleExports(() => module);\n\nfunction equivPlugin(fork) {\n  var types = fork.use(typesPlugin);\n  var getFieldNames = types.getFieldNames;\n  var getFieldValue = types.getFieldValue;\n  var isArray = types.builtInTypes.array;\n  var isObject = types.builtInTypes.object;\n  var isDate = types.builtInTypes.Date;\n  var isRegExp = types.builtInTypes.RegExp;\n  var hasOwn = Object.prototype.hasOwnProperty;\n  function astNodesAreEquivalent(a, b, problemPath) {\n    if (isArray.check(problemPath)) {\n      problemPath.length = 0;\n    } else {\n      problemPath = null;\n    }\n    return areEquivalent(a, b, problemPath);\n  }\n  astNodesAreEquivalent.assert = function(a, b) {\n    var problemPath = [];\n    if (!astNodesAreEquivalent(a, b, problemPath)) {\n      if (problemPath.length === 0) {\n        if (a !== b) {\n          throw new Error(\"Nodes must be equal\");\n        }\n      } else {\n        throw new Error(\n          \"Nodes differ in the following path: \" + problemPath.map(subscriptForProperty).join(\"\")\n        );\n      }\n    }\n  };\n  function subscriptForProperty(property) {\n    if (/[_$a-z][_$a-z0-9]*/i.test(property)) {\n      return \".\" + property;\n    }\n    return \"[\" + JSON.stringify(property) + \"]\";\n  }\n  function areEquivalent(a, b, problemPath) {\n    if (a === b) {\n      return true;\n    }\n    if (isArray.check(a)) {\n      return arraysAreEquivalent(a, b, problemPath);\n    }\n    if (isObject.check(a)) {\n      return objectsAreEquivalent(a, b, problemPath);\n    }\n    if (isDate.check(a)) {\n      return isDate.check(b) && +a === +b;\n    }\n    if (isRegExp.check(a)) {\n      return isRegExp.check(b) && (a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase);\n    }\n    return a == b;\n  }\n  function arraysAreEquivalent(a, b, problemPath) {\n    isArray.assert(a);\n    var aLength = a.length;\n    if (!isArray.check(b) || b.length !== aLength) {\n      if (problemPath) {\n        problemPath.push(\"length\");\n      }\n      return false;\n    }\n    for (var i = 0; i < aLength; ++i) {\n      if (problemPath) {\n        problemPath.push(i);\n      }\n      if (i in a !== i in b) {\n        return false;\n      }\n      if (!areEquivalent(a[i], b[i], problemPath)) {\n        return false;\n      }\n      if (problemPath) {\n        var problemPathTail = problemPath.pop();\n        if (problemPathTail !== i) {\n          throw new Error(\"\" + problemPathTail);\n        }\n      }\n    }\n    return true;\n  }\n  function objectsAreEquivalent(a, b, problemPath) {\n    isObject.assert(a);\n    if (!isObject.check(b)) {\n      return false;\n    }\n    if (a.type !== b.type) {\n      if (problemPath) {\n        problemPath.push(\"type\");\n      }\n      return false;\n    }\n    var aNames = getFieldNames(a);\n    var aNameCount = aNames.length;\n    var bNames = getFieldNames(b);\n    var bNameCount = bNames.length;\n    if (aNameCount === bNameCount) {\n      for (var i = 0; i < aNameCount; ++i) {\n        var name = aNames[i];\n        var aChild = getFieldValue(a, name);\n        var bChild = getFieldValue(b, name);\n        if (problemPath) {\n          problemPath.push(name);\n        }\n        if (!areEquivalent(aChild, bChild, problemPath)) {\n          return false;\n        }\n        if (problemPath) {\n          var problemPathTail = problemPath.pop();\n          if (problemPathTail !== name) {\n            throw new Error(\"\" + problemPathTail);\n          }\n        }\n      }\n      return true;\n    }\n    if (!problemPath) {\n      return false;\n    }\n    var seenNames = /* @__PURE__ */ Object.create(null);\n    for (i = 0; i < aNameCount; ++i) {\n      seenNames[aNames[i]] = true;\n    }\n    for (i = 0; i < bNameCount; ++i) {\n      name = bNames[i];\n      if (!hasOwn.call(seenNames, name)) {\n        problemPath.push(name);\n        return false;\n      }\n      delete seenNames[name];\n    }\n    for (name in seenNames) {\n      problemPath.push(name);\n      break;\n    }\n    return false;\n  }\n  return astNodesAreEquivalent;\n}\nmaybeSetModuleExports(() => module);\n\nfunction fork(plugins) {\n  const fork = createFork();\n  const types = fork.use(typesPlugin);\n  plugins.forEach(fork.use);\n  types.finalize();\n  const PathVisitor = fork.use(pathVisitorPlugin);\n  return {\n    Type: types.Type,\n    builtInTypes: types.builtInTypes,\n    namedTypes: types.namedTypes,\n    builders: types.builders,\n    defineMethod: types.defineMethod,\n    getFieldNames: types.getFieldNames,\n    getFieldValue: types.getFieldValue,\n    eachField: types.eachField,\n    someField: types.someField,\n    getSupertypeNames: types.getSupertypeNames,\n    getBuilderName: types.getBuilderName,\n    astNodesAreEquivalent: fork.use(equivPlugin),\n    finalize: types.finalize,\n    Path: fork.use(pathPlugin),\n    NodePath: fork.use(nodePathPlugin),\n    PathVisitor,\n    use: fork.use,\n    visit: PathVisitor.visit\n  };\n}\nfunction createFork() {\n  const used = [];\n  const usedResult = [];\n  function use(plugin) {\n    var idx = used.indexOf(plugin);\n    if (idx === -1) {\n      idx = used.length;\n      used.push(plugin);\n      usedResult[idx] = plugin(fork);\n    }\n    return usedResult[idx];\n  }\n  var fork = { use };\n  return fork;\n}\nmaybeSetModuleExports(() => module);\n\nfunction coreOpsDef() {\n  return {\n    BinaryOperators: [\n      \"==\",\n      \"!=\",\n      \"===\",\n      \"!==\",\n      \"<\",\n      \"<=\",\n      \">\",\n      \">=\",\n      \"<<\",\n      \">>\",\n      \">>>\",\n      \"+\",\n      \"-\",\n      \"*\",\n      \"/\",\n      \"%\",\n      \"&\",\n      \"|\",\n      \"^\",\n      \"in\",\n      \"instanceof\"\n    ],\n    AssignmentOperators: [\n      \"=\",\n      \"+=\",\n      \"-=\",\n      \"*=\",\n      \"/=\",\n      \"%=\",\n      \"<<=\",\n      \">>=\",\n      \">>>=\",\n      \"|=\",\n      \"^=\",\n      \"&=\"\n    ],\n    LogicalOperators: [\n      \"||\",\n      \"&&\"\n    ]\n  };\n}\nmaybeSetModuleExports(() => module);\n\nfunction es2016OpsDef(fork) {\n  const result = fork.use(coreOpsDef);\n  if (result.BinaryOperators.indexOf(\"**\") < 0) {\n    result.BinaryOperators.push(\"**\");\n  }\n  if (result.AssignmentOperators.indexOf(\"**=\") < 0) {\n    result.AssignmentOperators.push(\"**=\");\n  }\n  return result;\n}\nmaybeSetModuleExports(() => module);\n\nfunction es2020OpsDef(fork) {\n  const result = fork.use(es2016OpsDef);\n  if (result.LogicalOperators.indexOf(\"??\") < 0) {\n    result.LogicalOperators.push(\"??\");\n  }\n  return result;\n}\nmaybeSetModuleExports(() => module);\n\nfunction es2021OpsDef(fork) {\n  const result = fork.use(es2020OpsDef);\n  result.LogicalOperators.forEach((op) => {\n    const assignOp = op + \"=\";\n    if (result.AssignmentOperators.indexOf(assignOp) < 0) {\n      result.AssignmentOperators.push(assignOp);\n    }\n  });\n  return result;\n}\nmaybeSetModuleExports(() => module);\n\nfunction coreDef(fork) {\n  var types = fork.use(typesPlugin);\n  var Type = types.Type;\n  var def = Type.def;\n  var or = Type.or;\n  var shared = fork.use(sharedPlugin);\n  var defaults = shared.defaults;\n  var geq = shared.geq;\n  const {\n    BinaryOperators,\n    AssignmentOperators,\n    LogicalOperators\n  } = fork.use(coreOpsDef);\n  def(\"Printable\").field(\"loc\", or(\n    def(\"SourceLocation\"),\n    null\n  ), defaults[\"null\"], true);\n  def(\"Node\").bases(\"Printable\").field(\"type\", String).field(\"comments\", or(\n    [def(\"Comment\")],\n    null\n  ), defaults[\"null\"], true);\n  def(\"SourceLocation\").field(\"start\", def(\"Position\")).field(\"end\", def(\"Position\")).field(\"source\", or(String, null), defaults[\"null\"]);\n  def(\"Position\").field(\"line\", geq(1)).field(\"column\", geq(0));\n  def(\"File\").bases(\"Node\").build(\"program\", \"name\").field(\"program\", def(\"Program\")).field(\"name\", or(String, null), defaults[\"null\"]);\n  def(\"Program\").bases(\"Node\").build(\"body\").field(\"body\", [def(\"Statement\")]);\n  def(\"Function\").bases(\"Node\").field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"]).field(\"params\", [def(\"Pattern\")]).field(\"body\", def(\"BlockStatement\")).field(\"generator\", Boolean, defaults[\"false\"]).field(\"async\", Boolean, defaults[\"false\"]);\n  def(\"Statement\").bases(\"Node\");\n  def(\"EmptyStatement\").bases(\"Statement\").build();\n  def(\"BlockStatement\").bases(\"Statement\").build(\"body\").field(\"body\", [def(\"Statement\")]);\n  def(\"ExpressionStatement\").bases(\"Statement\").build(\"expression\").field(\"expression\", def(\"Expression\"));\n  def(\"IfStatement\").bases(\"Statement\").build(\"test\", \"consequent\", \"alternate\").field(\"test\", def(\"Expression\")).field(\"consequent\", def(\"Statement\")).field(\"alternate\", or(def(\"Statement\"), null), defaults[\"null\"]);\n  def(\"LabeledStatement\").bases(\"Statement\").build(\"label\", \"body\").field(\"label\", def(\"Identifier\")).field(\"body\", def(\"Statement\"));\n  def(\"BreakStatement\").bases(\"Statement\").build(\"label\").field(\"label\", or(def(\"Identifier\"), null), defaults[\"null\"]);\n  def(\"ContinueStatement\").bases(\"Statement\").build(\"label\").field(\"label\", or(def(\"Identifier\"), null), defaults[\"null\"]);\n  def(\"WithStatement\").bases(\"Statement\").build(\"object\", \"body\").field(\"object\", def(\"Expression\")).field(\"body\", def(\"Statement\"));\n  def(\"SwitchStatement\").bases(\"Statement\").build(\"discriminant\", \"cases\", \"lexical\").field(\"discriminant\", def(\"Expression\")).field(\"cases\", [def(\"SwitchCase\")]).field(\"lexical\", Boolean, defaults[\"false\"]);\n  def(\"ReturnStatement\").bases(\"Statement\").build(\"argument\").field(\"argument\", or(def(\"Expression\"), null));\n  def(\"ThrowStatement\").bases(\"Statement\").build(\"argument\").field(\"argument\", def(\"Expression\"));\n  def(\"TryStatement\").bases(\"Statement\").build(\"block\", \"handler\", \"finalizer\").field(\"block\", def(\"BlockStatement\")).field(\"handler\", or(def(\"CatchClause\"), null), function() {\n    return this.handlers && this.handlers[0] || null;\n  }).field(\"handlers\", [def(\"CatchClause\")], function() {\n    return this.handler ? [this.handler] : [];\n  }, true).field(\"guardedHandlers\", [def(\"CatchClause\")], defaults.emptyArray).field(\"finalizer\", or(def(\"BlockStatement\"), null), defaults[\"null\"]);\n  def(\"CatchClause\").bases(\"Node\").build(\"param\", \"guard\", \"body\").field(\"param\", def(\"Pattern\")).field(\"guard\", or(def(\"Expression\"), null), defaults[\"null\"]).field(\"body\", def(\"BlockStatement\"));\n  def(\"WhileStatement\").bases(\"Statement\").build(\"test\", \"body\").field(\"test\", def(\"Expression\")).field(\"body\", def(\"Statement\"));\n  def(\"DoWhileStatement\").bases(\"Statement\").build(\"body\", \"test\").field(\"body\", def(\"Statement\")).field(\"test\", def(\"Expression\"));\n  def(\"ForStatement\").bases(\"Statement\").build(\"init\", \"test\", \"update\", \"body\").field(\"init\", or(\n    def(\"VariableDeclaration\"),\n    def(\"Expression\"),\n    null\n  )).field(\"test\", or(def(\"Expression\"), null)).field(\"update\", or(def(\"Expression\"), null)).field(\"body\", def(\"Statement\"));\n  def(\"ForInStatement\").bases(\"Statement\").build(\"left\", \"right\", \"body\").field(\"left\", or(\n    def(\"VariableDeclaration\"),\n    def(\"Expression\")\n  )).field(\"right\", def(\"Expression\")).field(\"body\", def(\"Statement\"));\n  def(\"DebuggerStatement\").bases(\"Statement\").build();\n  def(\"Declaration\").bases(\"Statement\");\n  def(\"FunctionDeclaration\").bases(\"Function\", \"Declaration\").build(\"id\", \"params\", \"body\").field(\"id\", def(\"Identifier\"));\n  def(\"FunctionExpression\").bases(\"Function\", \"Expression\").build(\"id\", \"params\", \"body\");\n  def(\"VariableDeclaration\").bases(\"Declaration\").build(\"kind\", \"declarations\").field(\"kind\", or(\"var\", \"let\", \"const\")).field(\"declarations\", [def(\"VariableDeclarator\")]);\n  def(\"VariableDeclarator\").bases(\"Node\").build(\"id\", \"init\").field(\"id\", def(\"Pattern\")).field(\"init\", or(def(\"Expression\"), null), defaults[\"null\"]);\n  def(\"Expression\").bases(\"Node\");\n  def(\"ThisExpression\").bases(\"Expression\").build();\n  def(\"ArrayExpression\").bases(\"Expression\").build(\"elements\").field(\"elements\", [or(def(\"Expression\"), null)]);\n  def(\"ObjectExpression\").bases(\"Expression\").build(\"properties\").field(\"properties\", [def(\"Property\")]);\n  def(\"Property\").bases(\"Node\").build(\"kind\", \"key\", \"value\").field(\"kind\", or(\"init\", \"get\", \"set\")).field(\"key\", or(def(\"Literal\"), def(\"Identifier\"))).field(\"value\", def(\"Expression\"));\n  def(\"SequenceExpression\").bases(\"Expression\").build(\"expressions\").field(\"expressions\", [def(\"Expression\")]);\n  var UnaryOperator = or(\n    \"-\",\n    \"+\",\n    \"!\",\n    \"~\",\n    \"typeof\",\n    \"void\",\n    \"delete\"\n  );\n  def(\"UnaryExpression\").bases(\"Expression\").build(\"operator\", \"argument\", \"prefix\").field(\"operator\", UnaryOperator).field(\"argument\", def(\"Expression\")).field(\"prefix\", Boolean, defaults[\"true\"]);\n  const BinaryOperator = or(...BinaryOperators);\n  def(\"BinaryExpression\").bases(\"Expression\").build(\"operator\", \"left\", \"right\").field(\"operator\", BinaryOperator).field(\"left\", def(\"Expression\")).field(\"right\", def(\"Expression\"));\n  const AssignmentOperator = or(...AssignmentOperators);\n  def(\"AssignmentExpression\").bases(\"Expression\").build(\"operator\", \"left\", \"right\").field(\"operator\", AssignmentOperator).field(\"left\", or(def(\"Pattern\"), def(\"MemberExpression\"))).field(\"right\", def(\"Expression\"));\n  var UpdateOperator = or(\"++\", \"--\");\n  def(\"UpdateExpression\").bases(\"Expression\").build(\"operator\", \"argument\", \"prefix\").field(\"operator\", UpdateOperator).field(\"argument\", def(\"Expression\")).field(\"prefix\", Boolean);\n  var LogicalOperator = or(...LogicalOperators);\n  def(\"LogicalExpression\").bases(\"Expression\").build(\"operator\", \"left\", \"right\").field(\"operator\", LogicalOperator).field(\"left\", def(\"Expression\")).field(\"right\", def(\"Expression\"));\n  def(\"ConditionalExpression\").bases(\"Expression\").build(\"test\", \"consequent\", \"alternate\").field(\"test\", def(\"Expression\")).field(\"consequent\", def(\"Expression\")).field(\"alternate\", def(\"Expression\"));\n  def(\"NewExpression\").bases(\"Expression\").build(\"callee\", \"arguments\").field(\"callee\", def(\"Expression\")).field(\"arguments\", [def(\"Expression\")]);\n  def(\"CallExpression\").bases(\"Expression\").build(\"callee\", \"arguments\").field(\"callee\", def(\"Expression\")).field(\"arguments\", [def(\"Expression\")]);\n  def(\"MemberExpression\").bases(\"Expression\").build(\"object\", \"property\", \"computed\").field(\"object\", def(\"Expression\")).field(\"property\", or(def(\"Identifier\"), def(\"Expression\"))).field(\"computed\", Boolean, function() {\n    var type = this.property.type;\n    if (type === \"Literal\" || type === \"MemberExpression\" || type === \"BinaryExpression\") {\n      return true;\n    }\n    return false;\n  });\n  def(\"Pattern\").bases(\"Node\");\n  def(\"SwitchCase\").bases(\"Node\").build(\"test\", \"consequent\").field(\"test\", or(def(\"Expression\"), null)).field(\"consequent\", [def(\"Statement\")]);\n  def(\"Identifier\").bases(\"Expression\", \"Pattern\").build(\"name\").field(\"name\", String).field(\"optional\", Boolean, defaults[\"false\"]);\n  def(\"Literal\").bases(\"Expression\").build(\"value\").field(\"value\", or(String, Boolean, null, Number, RegExp, BigInt));\n  def(\"Comment\").bases(\"Printable\").field(\"value\", String).field(\"leading\", Boolean, defaults[\"true\"]).field(\"trailing\", Boolean, defaults[\"false\"]);\n}\nmaybeSetModuleExports(() => module);\n\nfunction es6Def(fork) {\n  fork.use(coreDef);\n  const types = fork.use(typesPlugin);\n  const def = types.Type.def;\n  const or = types.Type.or;\n  const defaults = fork.use(sharedPlugin).defaults;\n  def(\"Function\").field(\"generator\", Boolean, defaults[\"false\"]).field(\"expression\", Boolean, defaults[\"false\"]).field(\"defaults\", [or(def(\"Expression\"), null)], defaults.emptyArray).field(\"rest\", or(def(\"Identifier\"), null), defaults[\"null\"]);\n  def(\"RestElement\").bases(\"Pattern\").build(\"argument\").field(\"argument\", def(\"Pattern\")).field(\n    \"typeAnnotation\",\n    // for Babylon. Flow parser puts it on the identifier\n    or(def(\"TypeAnnotation\"), def(\"TSTypeAnnotation\"), null),\n    defaults[\"null\"]\n  );\n  def(\"SpreadElementPattern\").bases(\"Pattern\").build(\"argument\").field(\"argument\", def(\"Pattern\"));\n  def(\"FunctionDeclaration\").build(\"id\", \"params\", \"body\", \"generator\", \"expression\").field(\"id\", or(def(\"Identifier\"), null));\n  def(\"FunctionExpression\").build(\"id\", \"params\", \"body\", \"generator\", \"expression\");\n  def(\"ArrowFunctionExpression\").bases(\"Function\", \"Expression\").build(\"params\", \"body\", \"expression\").field(\"id\", null, defaults[\"null\"]).field(\"body\", or(def(\"BlockStatement\"), def(\"Expression\"))).field(\"generator\", false, defaults[\"false\"]);\n  def(\"ForOfStatement\").bases(\"Statement\").build(\"left\", \"right\", \"body\").field(\"left\", or(\n    def(\"VariableDeclaration\"),\n    def(\"Pattern\")\n  )).field(\"right\", def(\"Expression\")).field(\"body\", def(\"Statement\"));\n  def(\"YieldExpression\").bases(\"Expression\").build(\"argument\", \"delegate\").field(\"argument\", or(def(\"Expression\"), null)).field(\"delegate\", Boolean, defaults[\"false\"]);\n  def(\"GeneratorExpression\").bases(\"Expression\").build(\"body\", \"blocks\", \"filter\").field(\"body\", def(\"Expression\")).field(\"blocks\", [def(\"ComprehensionBlock\")]).field(\"filter\", or(def(\"Expression\"), null));\n  def(\"ComprehensionExpression\").bases(\"Expression\").build(\"body\", \"blocks\", \"filter\").field(\"body\", def(\"Expression\")).field(\"blocks\", [def(\"ComprehensionBlock\")]).field(\"filter\", or(def(\"Expression\"), null));\n  def(\"ComprehensionBlock\").bases(\"Node\").build(\"left\", \"right\", \"each\").field(\"left\", def(\"Pattern\")).field(\"right\", def(\"Expression\")).field(\"each\", Boolean);\n  def(\"Property\").field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\"))).field(\"value\", or(def(\"Expression\"), def(\"Pattern\"))).field(\"method\", Boolean, defaults[\"false\"]).field(\"shorthand\", Boolean, defaults[\"false\"]).field(\"computed\", Boolean, defaults[\"false\"]);\n  def(\"ObjectProperty\").field(\"shorthand\", Boolean, defaults[\"false\"]);\n  def(\"PropertyPattern\").bases(\"Pattern\").build(\"key\", \"pattern\").field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\"))).field(\"pattern\", def(\"Pattern\")).field(\"computed\", Boolean, defaults[\"false\"]);\n  def(\"ObjectPattern\").bases(\"Pattern\").build(\"properties\").field(\"properties\", [or(def(\"PropertyPattern\"), def(\"Property\"))]);\n  def(\"ArrayPattern\").bases(\"Pattern\").build(\"elements\").field(\"elements\", [or(def(\"Pattern\"), null)]);\n  def(\"SpreadElement\").bases(\"Node\").build(\"argument\").field(\"argument\", def(\"Expression\"));\n  def(\"ArrayExpression\").field(\"elements\", [or(\n    def(\"Expression\"),\n    def(\"SpreadElement\"),\n    def(\"RestElement\"),\n    null\n  )]);\n  def(\"NewExpression\").field(\"arguments\", [or(def(\"Expression\"), def(\"SpreadElement\"))]);\n  def(\"CallExpression\").field(\"arguments\", [or(def(\"Expression\"), def(\"SpreadElement\"))]);\n  def(\"AssignmentPattern\").bases(\"Pattern\").build(\"left\", \"right\").field(\"left\", def(\"Pattern\")).field(\"right\", def(\"Expression\"));\n  def(\"MethodDefinition\").bases(\"Declaration\").build(\"kind\", \"key\", \"value\", \"static\").field(\"kind\", or(\"constructor\", \"method\", \"get\", \"set\")).field(\"key\", def(\"Expression\")).field(\"value\", def(\"Function\")).field(\"computed\", Boolean, defaults[\"false\"]).field(\"static\", Boolean, defaults[\"false\"]);\n  const ClassBodyElement = or(\n    def(\"MethodDefinition\"),\n    def(\"VariableDeclarator\"),\n    def(\"ClassPropertyDefinition\"),\n    def(\"ClassProperty\"),\n    def(\"StaticBlock\")\n  );\n  def(\"ClassProperty\").bases(\"Declaration\").build(\"key\").field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\"))).field(\"computed\", Boolean, defaults[\"false\"]);\n  def(\"ClassPropertyDefinition\").bases(\"Declaration\").build(\"definition\").field(\"definition\", ClassBodyElement);\n  def(\"ClassBody\").bases(\"Declaration\").build(\"body\").field(\"body\", [ClassBodyElement]);\n  def(\"ClassDeclaration\").bases(\"Declaration\").build(\"id\", \"body\", \"superClass\").field(\"id\", or(def(\"Identifier\"), null)).field(\"body\", def(\"ClassBody\")).field(\"superClass\", or(def(\"Expression\"), null), defaults[\"null\"]);\n  def(\"ClassExpression\").bases(\"Expression\").build(\"id\", \"body\", \"superClass\").field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"]).field(\"body\", def(\"ClassBody\")).field(\"superClass\", or(def(\"Expression\"), null), defaults[\"null\"]);\n  def(\"Super\").bases(\"Expression\").build();\n  def(\"Specifier\").bases(\"Node\");\n  def(\"ModuleSpecifier\").bases(\"Specifier\").field(\"local\", or(def(\"Identifier\"), null), defaults[\"null\"]).field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"]).field(\"name\", or(def(\"Identifier\"), null), defaults[\"null\"]);\n  def(\"ImportSpecifier\").bases(\"ModuleSpecifier\").build(\"imported\", \"local\").field(\"imported\", def(\"Identifier\"));\n  def(\"ImportDefaultSpecifier\").bases(\"ModuleSpecifier\").build(\"local\");\n  def(\"ImportNamespaceSpecifier\").bases(\"ModuleSpecifier\").build(\"local\");\n  def(\"ImportDeclaration\").bases(\"Declaration\").build(\"specifiers\", \"source\", \"importKind\").field(\"specifiers\", [or(\n    def(\"ImportSpecifier\"),\n    def(\"ImportNamespaceSpecifier\"),\n    def(\"ImportDefaultSpecifier\")\n  )], defaults.emptyArray).field(\"source\", def(\"Literal\")).field(\"importKind\", or(\n    \"value\",\n    \"type\"\n  ), function() {\n    return \"value\";\n  });\n  def(\"ExportNamedDeclaration\").bases(\"Declaration\").build(\"declaration\", \"specifiers\", \"source\").field(\"declaration\", or(def(\"Declaration\"), null)).field(\"specifiers\", [def(\"ExportSpecifier\")], defaults.emptyArray).field(\"source\", or(def(\"Literal\"), null), defaults[\"null\"]);\n  def(\"ExportSpecifier\").bases(\"ModuleSpecifier\").build(\"local\", \"exported\").field(\"exported\", def(\"Identifier\"));\n  def(\"ExportDefaultDeclaration\").bases(\"Declaration\").build(\"declaration\").field(\"declaration\", or(def(\"Declaration\"), def(\"Expression\")));\n  def(\"ExportAllDeclaration\").bases(\"Declaration\").build(\"source\").field(\"source\", def(\"Literal\"));\n  def(\"TaggedTemplateExpression\").bases(\"Expression\").build(\"tag\", \"quasi\").field(\"tag\", def(\"Expression\")).field(\"quasi\", def(\"TemplateLiteral\"));\n  def(\"TemplateLiteral\").bases(\"Expression\").build(\"quasis\", \"expressions\").field(\"quasis\", [def(\"TemplateElement\")]).field(\"expressions\", [def(\"Expression\")]);\n  def(\"TemplateElement\").bases(\"Node\").build(\"value\", \"tail\").field(\"value\", { \"cooked\": String, \"raw\": String }).field(\"tail\", Boolean);\n  def(\"MetaProperty\").bases(\"Expression\").build(\"meta\", \"property\").field(\"meta\", def(\"Identifier\")).field(\"property\", def(\"Identifier\"));\n}\nmaybeSetModuleExports(() => module);\n\nfunction es2016Def(fork) {\n  fork.use(es2016OpsDef);\n  fork.use(es6Def);\n}\nmaybeSetModuleExports(() => module);\n\nfunction es2017Def(fork) {\n  fork.use(es2016Def);\n  const types = fork.use(typesPlugin);\n  const def = types.Type.def;\n  const defaults = fork.use(sharedPlugin).defaults;\n  def(\"Function\").field(\"async\", Boolean, defaults[\"false\"]);\n  def(\"AwaitExpression\").bases(\"Expression\").build(\"argument\").field(\"argument\", def(\"Expression\"));\n}\nmaybeSetModuleExports(() => module);\n\nfunction es2018Def(fork) {\n  fork.use(es2017Def);\n  const types = fork.use(typesPlugin);\n  const def = types.Type.def;\n  const or = types.Type.or;\n  const defaults = fork.use(sharedPlugin).defaults;\n  def(\"ForOfStatement\").field(\"await\", Boolean, defaults[\"false\"]);\n  def(\"SpreadProperty\").bases(\"Node\").build(\"argument\").field(\"argument\", def(\"Expression\"));\n  def(\"ObjectExpression\").field(\"properties\", [or(\n    def(\"Property\"),\n    def(\"SpreadProperty\"),\n    // Legacy\n    def(\"SpreadElement\")\n  )]);\n  def(\"TemplateElement\").field(\"value\", { \"cooked\": or(String, null), \"raw\": String });\n  def(\"SpreadPropertyPattern\").bases(\"Pattern\").build(\"argument\").field(\"argument\", def(\"Pattern\"));\n  def(\"ObjectPattern\").field(\"properties\", [or(def(\"PropertyPattern\"), def(\"Property\"), def(\"RestElement\"), def(\"SpreadPropertyPattern\"))]);\n}\nmaybeSetModuleExports(() => module);\n\nfunction es2019Def(fork) {\n  fork.use(es2018Def);\n  const types = fork.use(typesPlugin);\n  const def = types.Type.def;\n  const or = types.Type.or;\n  const defaults = fork.use(sharedPlugin).defaults;\n  def(\"CatchClause\").field(\"param\", or(def(\"Pattern\"), null), defaults[\"null\"]);\n}\nmaybeSetModuleExports(() => module);\n\nfunction es2020Def(fork) {\n  fork.use(es2020OpsDef);\n  fork.use(es2019Def);\n  const types = fork.use(typesPlugin);\n  const def = types.Type.def;\n  const or = types.Type.or;\n  const shared = fork.use(sharedPlugin);\n  const defaults = shared.defaults;\n  def(\"ImportExpression\").bases(\"Expression\").build(\"source\").field(\"source\", def(\"Expression\"));\n  def(\"ExportAllDeclaration\").bases(\"Declaration\").build(\"source\", \"exported\").field(\"source\", def(\"Literal\")).field(\"exported\", or(\n    def(\"Identifier\"),\n    null,\n    void 0\n  ), defaults[\"null\"]);\n  def(\"ChainElement\").bases(\"Node\").field(\"optional\", Boolean, defaults[\"false\"]);\n  def(\"CallExpression\").bases(\"Expression\", \"ChainElement\");\n  def(\"MemberExpression\").bases(\"Expression\", \"ChainElement\");\n  def(\"ChainExpression\").bases(\"Expression\").build(\"expression\").field(\"expression\", def(\"ChainElement\"));\n  def(\"OptionalCallExpression\").bases(\"CallExpression\").build(\"callee\", \"arguments\", \"optional\").field(\"optional\", Boolean, defaults[\"true\"]);\n  def(\"OptionalMemberExpression\").bases(\"MemberExpression\").build(\"object\", \"property\", \"computed\", \"optional\").field(\"optional\", Boolean, defaults[\"true\"]);\n}\nmaybeSetModuleExports(() => module);\n\nfunction es2021Def(fork) {\n  fork.use(es2021OpsDef);\n  fork.use(es2020Def);\n}\nmaybeSetModuleExports(() => module);\n\nfunction es2022Def(fork) {\n  fork.use(es2021Def);\n  const types = fork.use(typesPlugin);\n  const def = types.Type.def;\n  def(\"StaticBlock\").bases(\"Declaration\").build(\"body\").field(\"body\", [def(\"Statement\")]);\n}\nmaybeSetModuleExports(() => module);\n\nfunction esProposalsDef(fork) {\n  fork.use(es2022Def);\n  const types = fork.use(typesPlugin);\n  const Type = types.Type;\n  const def = types.Type.def;\n  const or = Type.or;\n  const shared = fork.use(sharedPlugin);\n  const defaults = shared.defaults;\n  def(\"AwaitExpression\").build(\"argument\", \"all\").field(\"argument\", or(def(\"Expression\"), null)).field(\"all\", Boolean, defaults[\"false\"]);\n  def(\"Decorator\").bases(\"Node\").build(\"expression\").field(\"expression\", def(\"Expression\"));\n  def(\"Property\").field(\n    \"decorators\",\n    or([def(\"Decorator\")], null),\n    defaults[\"null\"]\n  );\n  def(\"MethodDefinition\").field(\n    \"decorators\",\n    or([def(\"Decorator\")], null),\n    defaults[\"null\"]\n  );\n  def(\"PrivateName\").bases(\"Expression\", \"Pattern\").build(\"id\").field(\"id\", def(\"Identifier\"));\n  def(\"ClassPrivateProperty\").bases(\"ClassProperty\").build(\"key\", \"value\").field(\"key\", def(\"PrivateName\")).field(\"value\", or(def(\"Expression\"), null), defaults[\"null\"]);\n  def(\"ImportAttribute\").bases(\"Node\").build(\"key\", \"value\").field(\"key\", or(def(\"Identifier\"), def(\"Literal\"))).field(\"value\", def(\"Expression\"));\n  [\n    \"ImportDeclaration\",\n    \"ExportAllDeclaration\",\n    \"ExportNamedDeclaration\"\n  ].forEach((decl) => {\n    def(decl).field(\n      \"assertions\",\n      [def(\"ImportAttribute\")],\n      defaults.emptyArray\n    );\n  });\n  def(\"RecordExpression\").bases(\"Expression\").build(\"properties\").field(\"properties\", [or(\n    def(\"ObjectProperty\"),\n    def(\"ObjectMethod\"),\n    def(\"SpreadElement\")\n  )]);\n  def(\"TupleExpression\").bases(\"Expression\").build(\"elements\").field(\"elements\", [or(\n    def(\"Expression\"),\n    def(\"SpreadElement\"),\n    null\n  )]);\n  def(\"ModuleExpression\").bases(\"Node\").build(\"body\").field(\"body\", def(\"Program\"));\n}\nmaybeSetModuleExports(() => module);\n\nfunction jsxDef(fork) {\n  fork.use(esProposalsDef);\n  const types = fork.use(typesPlugin);\n  const def = types.Type.def;\n  const or = types.Type.or;\n  const defaults = fork.use(sharedPlugin).defaults;\n  def(\"JSXAttribute\").bases(\"Node\").build(\"name\", \"value\").field(\"name\", or(def(\"JSXIdentifier\"), def(\"JSXNamespacedName\"))).field(\"value\", or(\n    def(\"Literal\"),\n    // attr=\"value\"\n    def(\"JSXExpressionContainer\"),\n    // attr={value}\n    def(\"JSXElement\"),\n    // attr=<div />\n    def(\"JSXFragment\"),\n    // attr=<></>\n    null\n    // attr= or just attr\n  ), defaults[\"null\"]);\n  def(\"JSXIdentifier\").bases(\"Identifier\").build(\"name\").field(\"name\", String);\n  def(\"JSXNamespacedName\").bases(\"Node\").build(\"namespace\", \"name\").field(\"namespace\", def(\"JSXIdentifier\")).field(\"name\", def(\"JSXIdentifier\"));\n  def(\"JSXMemberExpression\").bases(\"MemberExpression\").build(\"object\", \"property\").field(\"object\", or(def(\"JSXIdentifier\"), def(\"JSXMemberExpression\"))).field(\"property\", def(\"JSXIdentifier\")).field(\"computed\", Boolean, defaults.false);\n  const JSXElementName = or(\n    def(\"JSXIdentifier\"),\n    def(\"JSXNamespacedName\"),\n    def(\"JSXMemberExpression\")\n  );\n  def(\"JSXSpreadAttribute\").bases(\"Node\").build(\"argument\").field(\"argument\", def(\"Expression\"));\n  const JSXAttributes = [or(\n    def(\"JSXAttribute\"),\n    def(\"JSXSpreadAttribute\")\n  )];\n  def(\"JSXExpressionContainer\").bases(\"Expression\").build(\"expression\").field(\"expression\", or(def(\"Expression\"), def(\"JSXEmptyExpression\")));\n  const JSXChildren = [or(\n    def(\"JSXText\"),\n    def(\"JSXExpressionContainer\"),\n    def(\"JSXSpreadChild\"),\n    def(\"JSXElement\"),\n    def(\"JSXFragment\"),\n    def(\"Literal\")\n    // Legacy: Esprima should return JSXText instead.\n  )];\n  def(\"JSXElement\").bases(\"Expression\").build(\"openingElement\", \"closingElement\", \"children\").field(\"openingElement\", def(\"JSXOpeningElement\")).field(\"closingElement\", or(def(\"JSXClosingElement\"), null), defaults[\"null\"]).field(\"children\", JSXChildren, defaults.emptyArray).field(\"name\", JSXElementName, function() {\n    return this.openingElement.name;\n  }, true).field(\"selfClosing\", Boolean, function() {\n    return this.openingElement.selfClosing;\n  }, true).field(\"attributes\", JSXAttributes, function() {\n    return this.openingElement.attributes;\n  }, true);\n  def(\"JSXOpeningElement\").bases(\"Node\").build(\"name\", \"attributes\", \"selfClosing\").field(\"name\", JSXElementName).field(\"attributes\", JSXAttributes, defaults.emptyArray).field(\"selfClosing\", Boolean, defaults[\"false\"]);\n  def(\"JSXClosingElement\").bases(\"Node\").build(\"name\").field(\"name\", JSXElementName);\n  def(\"JSXFragment\").bases(\"Expression\").build(\"openingFragment\", \"closingFragment\", \"children\").field(\"openingFragment\", def(\"JSXOpeningFragment\")).field(\"closingFragment\", def(\"JSXClosingFragment\")).field(\"children\", JSXChildren, defaults.emptyArray);\n  def(\"JSXOpeningFragment\").bases(\"Node\").build();\n  def(\"JSXClosingFragment\").bases(\"Node\").build();\n  def(\"JSXText\").bases(\"Literal\").build(\"value\", \"raw\").field(\"value\", String).field(\"raw\", String, function() {\n    return this.value;\n  });\n  def(\"JSXEmptyExpression\").bases(\"Node\").build();\n  def(\"JSXSpreadChild\").bases(\"Node\").build(\"expression\").field(\"expression\", def(\"Expression\"));\n}\nmaybeSetModuleExports(() => module);\n\nfunction typeAnnotationsDef(fork) {\n  var types = fork.use(typesPlugin);\n  var def = types.Type.def;\n  var or = types.Type.or;\n  var defaults = fork.use(sharedPlugin).defaults;\n  var TypeAnnotation = or(\n    def(\"TypeAnnotation\"),\n    def(\"TSTypeAnnotation\"),\n    null\n  );\n  var TypeParamDecl = or(\n    def(\"TypeParameterDeclaration\"),\n    def(\"TSTypeParameterDeclaration\"),\n    null\n  );\n  def(\"Identifier\").field(\"typeAnnotation\", TypeAnnotation, defaults[\"null\"]);\n  def(\"ObjectPattern\").field(\"typeAnnotation\", TypeAnnotation, defaults[\"null\"]);\n  def(\"Function\").field(\"returnType\", TypeAnnotation, defaults[\"null\"]).field(\"typeParameters\", TypeParamDecl, defaults[\"null\"]);\n  def(\"ClassProperty\").build(\"key\", \"value\", \"typeAnnotation\", \"static\").field(\"value\", or(def(\"Expression\"), null)).field(\"static\", Boolean, defaults[\"false\"]).field(\"typeAnnotation\", TypeAnnotation, defaults[\"null\"]);\n  [\n    \"ClassDeclaration\",\n    \"ClassExpression\"\n  ].forEach((typeName) => {\n    def(typeName).field(\"typeParameters\", TypeParamDecl, defaults[\"null\"]).field(\n      \"superTypeParameters\",\n      or(\n        def(\"TypeParameterInstantiation\"),\n        def(\"TSTypeParameterInstantiation\"),\n        null\n      ),\n      defaults[\"null\"]\n    ).field(\n      \"implements\",\n      or(\n        [def(\"ClassImplements\")],\n        [def(\"TSExpressionWithTypeArguments\")]\n      ),\n      defaults.emptyArray\n    );\n  });\n}\nmaybeSetModuleExports(() => module);\n\nfunction flowDef(fork) {\n  fork.use(esProposalsDef);\n  fork.use(typeAnnotationsDef);\n  const types = fork.use(typesPlugin);\n  const def = types.Type.def;\n  const or = types.Type.or;\n  const defaults = fork.use(sharedPlugin).defaults;\n  def(\"Flow\").bases(\"Node\");\n  def(\"FlowType\").bases(\"Flow\");\n  def(\"AnyTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"EmptyTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"MixedTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"VoidTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"SymbolTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"NumberTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"BigIntTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"NumberLiteralTypeAnnotation\").bases(\"FlowType\").build(\"value\", \"raw\").field(\"value\", Number).field(\"raw\", String);\n  def(\"NumericLiteralTypeAnnotation\").bases(\"FlowType\").build(\"value\", \"raw\").field(\"value\", Number).field(\"raw\", String);\n  def(\"BigIntLiteralTypeAnnotation\").bases(\"FlowType\").build(\"value\", \"raw\").field(\"value\", null).field(\"raw\", String);\n  def(\"StringTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"StringLiteralTypeAnnotation\").bases(\"FlowType\").build(\"value\", \"raw\").field(\"value\", String).field(\"raw\", String);\n  def(\"BooleanTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"BooleanLiteralTypeAnnotation\").bases(\"FlowType\").build(\"value\", \"raw\").field(\"value\", Boolean).field(\"raw\", String);\n  def(\"TypeAnnotation\").bases(\"Node\").build(\"typeAnnotation\").field(\"typeAnnotation\", def(\"FlowType\"));\n  def(\"NullableTypeAnnotation\").bases(\"FlowType\").build(\"typeAnnotation\").field(\"typeAnnotation\", def(\"FlowType\"));\n  def(\"NullLiteralTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"NullTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"ThisTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"ExistsTypeAnnotation\").bases(\"FlowType\").build();\n  def(\"ExistentialTypeParam\").bases(\"FlowType\").build();\n  def(\"FunctionTypeAnnotation\").bases(\"FlowType\").build(\"params\", \"returnType\", \"rest\", \"typeParameters\").field(\"params\", [def(\"FunctionTypeParam\")]).field(\"returnType\", def(\"FlowType\")).field(\"rest\", or(def(\"FunctionTypeParam\"), null)).field(\"typeParameters\", or(def(\"TypeParameterDeclaration\"), null));\n  def(\"FunctionTypeParam\").bases(\"Node\").build(\"name\", \"typeAnnotation\", \"optional\").field(\"name\", or(def(\"Identifier\"), null)).field(\"typeAnnotation\", def(\"FlowType\")).field(\"optional\", Boolean);\n  def(\"ArrayTypeAnnotation\").bases(\"FlowType\").build(\"elementType\").field(\"elementType\", def(\"FlowType\"));\n  def(\"ObjectTypeAnnotation\").bases(\"FlowType\").build(\"properties\", \"indexers\", \"callProperties\").field(\"properties\", [\n    or(\n      def(\"ObjectTypeProperty\"),\n      def(\"ObjectTypeSpreadProperty\")\n    )\n  ]).field(\"indexers\", [def(\"ObjectTypeIndexer\")], defaults.emptyArray).field(\n    \"callProperties\",\n    [def(\"ObjectTypeCallProperty\")],\n    defaults.emptyArray\n  ).field(\"inexact\", or(Boolean, void 0), defaults[\"undefined\"]).field(\"exact\", Boolean, defaults[\"false\"]).field(\"internalSlots\", [def(\"ObjectTypeInternalSlot\")], defaults.emptyArray);\n  def(\"Variance\").bases(\"Node\").build(\"kind\").field(\"kind\", or(\"plus\", \"minus\"));\n  const LegacyVariance = or(\n    def(\"Variance\"),\n    \"plus\",\n    \"minus\",\n    null\n  );\n  def(\"ObjectTypeProperty\").bases(\"Node\").build(\"key\", \"value\", \"optional\").field(\"key\", or(def(\"Literal\"), def(\"Identifier\"))).field(\"value\", def(\"FlowType\")).field(\"optional\", Boolean).field(\"variance\", LegacyVariance, defaults[\"null\"]);\n  def(\"ObjectTypeIndexer\").bases(\"Node\").build(\"id\", \"key\", \"value\").field(\"id\", def(\"Identifier\")).field(\"key\", def(\"FlowType\")).field(\"value\", def(\"FlowType\")).field(\"variance\", LegacyVariance, defaults[\"null\"]).field(\"static\", Boolean, defaults[\"false\"]);\n  def(\"ObjectTypeCallProperty\").bases(\"Node\").build(\"value\").field(\"value\", def(\"FunctionTypeAnnotation\")).field(\"static\", Boolean, defaults[\"false\"]);\n  def(\"QualifiedTypeIdentifier\").bases(\"Node\").build(\"qualification\", \"id\").field(\n    \"qualification\",\n    or(\n      def(\"Identifier\"),\n      def(\"QualifiedTypeIdentifier\")\n    )\n  ).field(\"id\", def(\"Identifier\"));\n  def(\"GenericTypeAnnotation\").bases(\"FlowType\").build(\"id\", \"typeParameters\").field(\"id\", or(def(\"Identifier\"), def(\"QualifiedTypeIdentifier\"))).field(\"typeParameters\", or(def(\"TypeParameterInstantiation\"), null));\n  def(\"MemberTypeAnnotation\").bases(\"FlowType\").build(\"object\", \"property\").field(\"object\", def(\"Identifier\")).field(\n    \"property\",\n    or(\n      def(\"MemberTypeAnnotation\"),\n      def(\"GenericTypeAnnotation\")\n    )\n  );\n  def(\"IndexedAccessType\").bases(\"FlowType\").build(\"objectType\", \"indexType\").field(\"objectType\", def(\"FlowType\")).field(\"indexType\", def(\"FlowType\"));\n  def(\"OptionalIndexedAccessType\").bases(\"FlowType\").build(\"objectType\", \"indexType\", \"optional\").field(\"objectType\", def(\"FlowType\")).field(\"indexType\", def(\"FlowType\")).field(\"optional\", Boolean);\n  def(\"UnionTypeAnnotation\").bases(\"FlowType\").build(\"types\").field(\"types\", [def(\"FlowType\")]);\n  def(\"IntersectionTypeAnnotation\").bases(\"FlowType\").build(\"types\").field(\"types\", [def(\"FlowType\")]);\n  def(\"TypeofTypeAnnotation\").bases(\"FlowType\").build(\"argument\").field(\"argument\", def(\"FlowType\"));\n  def(\"ObjectTypeSpreadProperty\").bases(\"Node\").build(\"argument\").field(\"argument\", def(\"FlowType\"));\n  def(\"ObjectTypeInternalSlot\").bases(\"Node\").build(\"id\", \"value\", \"optional\", \"static\", \"method\").field(\"id\", def(\"Identifier\")).field(\"value\", def(\"FlowType\")).field(\"optional\", Boolean).field(\"static\", Boolean).field(\"method\", Boolean);\n  def(\"TypeParameterDeclaration\").bases(\"Node\").build(\"params\").field(\"params\", [def(\"TypeParameter\")]);\n  def(\"TypeParameterInstantiation\").bases(\"Node\").build(\"params\").field(\"params\", [def(\"FlowType\")]);\n  def(\"TypeParameter\").bases(\"FlowType\").build(\"name\", \"variance\", \"bound\", \"default\").field(\"name\", String).field(\"variance\", LegacyVariance, defaults[\"null\"]).field(\"bound\", or(def(\"TypeAnnotation\"), null), defaults[\"null\"]).field(\"default\", or(def(\"FlowType\"), null), defaults[\"null\"]);\n  def(\"ClassProperty\").field(\"variance\", LegacyVariance, defaults[\"null\"]);\n  def(\"ClassImplements\").bases(\"Node\").build(\"id\").field(\"id\", def(\"Identifier\")).field(\"superClass\", or(def(\"Expression\"), null), defaults[\"null\"]).field(\n    \"typeParameters\",\n    or(def(\"TypeParameterInstantiation\"), null),\n    defaults[\"null\"]\n  );\n  def(\"InterfaceTypeAnnotation\").bases(\"FlowType\").build(\"body\", \"extends\").field(\"body\", def(\"ObjectTypeAnnotation\")).field(\"extends\", or([def(\"InterfaceExtends\")], null), defaults[\"null\"]);\n  def(\"InterfaceDeclaration\").bases(\"Declaration\").build(\"id\", \"body\", \"extends\").field(\"id\", def(\"Identifier\")).field(\n    \"typeParameters\",\n    or(def(\"TypeParameterDeclaration\"), null),\n    defaults[\"null\"]\n  ).field(\"body\", def(\"ObjectTypeAnnotation\")).field(\"extends\", [def(\"InterfaceExtends\")]);\n  def(\"DeclareInterface\").bases(\"InterfaceDeclaration\").build(\"id\", \"body\", \"extends\");\n  def(\"InterfaceExtends\").bases(\"Node\").build(\"id\").field(\"id\", def(\"Identifier\")).field(\n    \"typeParameters\",\n    or(def(\"TypeParameterInstantiation\"), null),\n    defaults[\"null\"]\n  );\n  def(\"TypeAlias\").bases(\"Declaration\").build(\"id\", \"typeParameters\", \"right\").field(\"id\", def(\"Identifier\")).field(\"typeParameters\", or(def(\"TypeParameterDeclaration\"), null)).field(\"right\", def(\"FlowType\"));\n  def(\"DeclareTypeAlias\").bases(\"TypeAlias\").build(\"id\", \"typeParameters\", \"right\");\n  def(\"OpaqueType\").bases(\"Declaration\").build(\"id\", \"typeParameters\", \"impltype\", \"supertype\").field(\"id\", def(\"Identifier\")).field(\"typeParameters\", or(def(\"TypeParameterDeclaration\"), null)).field(\"impltype\", def(\"FlowType\")).field(\"supertype\", or(def(\"FlowType\"), null));\n  def(\"DeclareOpaqueType\").bases(\"OpaqueType\").build(\"id\", \"typeParameters\", \"supertype\").field(\"impltype\", or(def(\"FlowType\"), null));\n  def(\"TypeCastExpression\").bases(\"Expression\").build(\"expression\", \"typeAnnotation\").field(\"expression\", def(\"Expression\")).field(\"typeAnnotation\", def(\"TypeAnnotation\"));\n  def(\"TupleTypeAnnotation\").bases(\"FlowType\").build(\"types\").field(\"types\", [def(\"FlowType\")]);\n  def(\"DeclareVariable\").bases(\"Statement\").build(\"id\").field(\"id\", def(\"Identifier\"));\n  def(\"DeclareFunction\").bases(\"Statement\").build(\"id\").field(\"id\", def(\"Identifier\")).field(\"predicate\", or(def(\"FlowPredicate\"), null), defaults[\"null\"]);\n  def(\"DeclareClass\").bases(\"InterfaceDeclaration\").build(\"id\");\n  def(\"DeclareModule\").bases(\"Statement\").build(\"id\", \"body\").field(\"id\", or(def(\"Identifier\"), def(\"Literal\"))).field(\"body\", def(\"BlockStatement\"));\n  def(\"DeclareModuleExports\").bases(\"Statement\").build(\"typeAnnotation\").field(\"typeAnnotation\", def(\"TypeAnnotation\"));\n  def(\"DeclareExportDeclaration\").bases(\"Declaration\").build(\"default\", \"declaration\", \"specifiers\", \"source\").field(\"default\", Boolean).field(\"declaration\", or(\n    def(\"DeclareVariable\"),\n    def(\"DeclareFunction\"),\n    def(\"DeclareClass\"),\n    def(\"FlowType\"),\n    // Implies default.\n    def(\"TypeAlias\"),\n    // Implies named type\n    def(\"DeclareOpaqueType\"),\n    // Implies named opaque type\n    def(\"InterfaceDeclaration\"),\n    null\n  )).field(\"specifiers\", [or(\n    def(\"ExportSpecifier\"),\n    def(\"ExportBatchSpecifier\")\n  )], defaults.emptyArray).field(\"source\", or(\n    def(\"Literal\"),\n    null\n  ), defaults[\"null\"]);\n  def(\"DeclareExportAllDeclaration\").bases(\"Declaration\").build(\"source\").field(\"source\", or(\n    def(\"Literal\"),\n    null\n  ), defaults[\"null\"]);\n  def(\"ImportDeclaration\").field(\"importKind\", or(\"value\", \"type\", \"typeof\"), () => \"value\");\n  def(\"FlowPredicate\").bases(\"Flow\");\n  def(\"InferredPredicate\").bases(\"FlowPredicate\").build();\n  def(\"DeclaredPredicate\").bases(\"FlowPredicate\").build(\"value\").field(\"value\", def(\"Expression\"));\n  def(\"Function\").field(\"predicate\", or(def(\"FlowPredicate\"), null), defaults[\"null\"]);\n  def(\"CallExpression\").field(\"typeArguments\", or(\n    null,\n    def(\"TypeParameterInstantiation\")\n  ), defaults[\"null\"]);\n  def(\"NewExpression\").field(\"typeArguments\", or(\n    null,\n    def(\"TypeParameterInstantiation\")\n  ), defaults[\"null\"]);\n  def(\"EnumDeclaration\").bases(\"Declaration\").build(\"id\", \"body\").field(\"id\", def(\"Identifier\")).field(\"body\", or(\n    def(\"EnumBooleanBody\"),\n    def(\"EnumNumberBody\"),\n    def(\"EnumStringBody\"),\n    def(\"EnumSymbolBody\")\n  ));\n  def(\"EnumBooleanBody\").build(\"members\", \"explicitType\").field(\"members\", [def(\"EnumBooleanMember\")]).field(\"explicitType\", Boolean);\n  def(\"EnumNumberBody\").build(\"members\", \"explicitType\").field(\"members\", [def(\"EnumNumberMember\")]).field(\"explicitType\", Boolean);\n  def(\"EnumStringBody\").build(\"members\", \"explicitType\").field(\"members\", or([def(\"EnumStringMember\")], [def(\"EnumDefaultedMember\")])).field(\"explicitType\", Boolean);\n  def(\"EnumSymbolBody\").build(\"members\").field(\"members\", [def(\"EnumDefaultedMember\")]);\n  def(\"EnumBooleanMember\").build(\"id\", \"init\").field(\"id\", def(\"Identifier\")).field(\"init\", or(def(\"Literal\"), Boolean));\n  def(\"EnumNumberMember\").build(\"id\", \"init\").field(\"id\", def(\"Identifier\")).field(\"init\", def(\"Literal\"));\n  def(\"EnumStringMember\").build(\"id\", \"init\").field(\"id\", def(\"Identifier\")).field(\"init\", def(\"Literal\"));\n  def(\"EnumDefaultedMember\").build(\"id\").field(\"id\", def(\"Identifier\"));\n}\nmaybeSetModuleExports(() => module);\n\nfunction esprimaDef(fork) {\n  fork.use(esProposalsDef);\n  var types = fork.use(typesPlugin);\n  var defaults = fork.use(sharedPlugin).defaults;\n  var def = types.Type.def;\n  var or = types.Type.or;\n  def(\"VariableDeclaration\").field(\"declarations\", [or(\n    def(\"VariableDeclarator\"),\n    def(\"Identifier\")\n    // Esprima deviation.\n  )]);\n  def(\"Property\").field(\"value\", or(\n    def(\"Expression\"),\n    def(\"Pattern\")\n    // Esprima deviation.\n  ));\n  def(\"ArrayPattern\").field(\"elements\", [or(\n    def(\"Pattern\"),\n    def(\"SpreadElement\"),\n    null\n  )]);\n  def(\"ObjectPattern\").field(\"properties\", [or(\n    def(\"Property\"),\n    def(\"PropertyPattern\"),\n    def(\"SpreadPropertyPattern\"),\n    def(\"SpreadProperty\")\n    // Used by Esprima.\n  )]);\n  def(\"ExportSpecifier\").bases(\"ModuleSpecifier\").build(\"id\", \"name\");\n  def(\"ExportBatchSpecifier\").bases(\"Specifier\").build();\n  def(\"ExportDeclaration\").bases(\"Declaration\").build(\"default\", \"declaration\", \"specifiers\", \"source\").field(\"default\", Boolean).field(\"declaration\", or(\n    def(\"Declaration\"),\n    def(\"Expression\"),\n    // Implies default.\n    null\n  )).field(\"specifiers\", [or(\n    def(\"ExportSpecifier\"),\n    def(\"ExportBatchSpecifier\")\n  )], defaults.emptyArray).field(\"source\", or(\n    def(\"Literal\"),\n    null\n  ), defaults[\"null\"]);\n  def(\"Block\").bases(\"Comment\").build(\n    \"value\",\n    /*optional:*/\n    \"leading\",\n    \"trailing\"\n  );\n  def(\"Line\").bases(\"Comment\").build(\n    \"value\",\n    /*optional:*/\n    \"leading\",\n    \"trailing\"\n  );\n}\nmaybeSetModuleExports(() => module);\n\nfunction babelCoreDef(fork) {\n  fork.use(esProposalsDef);\n  const types = fork.use(typesPlugin);\n  const defaults = fork.use(sharedPlugin).defaults;\n  const def = types.Type.def;\n  const or = types.Type.or;\n  const {\n    undefined: isUndefined\n  } = types.builtInTypes;\n  def(\"Noop\").bases(\"Statement\").build();\n  def(\"DoExpression\").bases(\"Expression\").build(\"body\").field(\"body\", [def(\"Statement\")]);\n  def(\"BindExpression\").bases(\"Expression\").build(\"object\", \"callee\").field(\"object\", or(def(\"Expression\"), null)).field(\"callee\", def(\"Expression\"));\n  def(\"ParenthesizedExpression\").bases(\"Expression\").build(\"expression\").field(\"expression\", def(\"Expression\"));\n  def(\"ExportNamespaceSpecifier\").bases(\"Specifier\").build(\"exported\").field(\"exported\", def(\"Identifier\"));\n  def(\"ExportDefaultSpecifier\").bases(\"Specifier\").build(\"exported\").field(\"exported\", def(\"Identifier\"));\n  def(\"CommentBlock\").bases(\"Comment\").build(\n    \"value\",\n    /*optional:*/\n    \"leading\",\n    \"trailing\"\n  );\n  def(\"CommentLine\").bases(\"Comment\").build(\n    \"value\",\n    /*optional:*/\n    \"leading\",\n    \"trailing\"\n  );\n  def(\"Directive\").bases(\"Node\").build(\"value\").field(\"value\", def(\"DirectiveLiteral\"));\n  def(\"DirectiveLiteral\").bases(\"Node\", \"Expression\").build(\"value\").field(\"value\", String, defaults[\"use strict\"]);\n  def(\"InterpreterDirective\").bases(\"Node\").build(\"value\").field(\"value\", String);\n  def(\"BlockStatement\").bases(\"Statement\").build(\"body\").field(\"body\", [def(\"Statement\")]).field(\"directives\", [def(\"Directive\")], defaults.emptyArray);\n  def(\"Program\").bases(\"Node\").build(\"body\").field(\"body\", [def(\"Statement\")]).field(\"directives\", [def(\"Directive\")], defaults.emptyArray).field(\"interpreter\", or(def(\"InterpreterDirective\"), null), defaults[\"null\"]);\n  function makeLiteralExtra(rawValueType = String, toRaw) {\n    return [\n      \"extra\",\n      {\n        rawValue: rawValueType,\n        raw: String\n      },\n      function getDefault() {\n        const value = types.getFieldValue(this, \"value\");\n        return {\n          rawValue: value,\n          raw: toRaw ? toRaw(value) : String(value)\n        };\n      }\n    ];\n  }\n  def(\"StringLiteral\").bases(\"Literal\").build(\"value\").field(\"value\", String).field(...makeLiteralExtra(String, (val) => JSON.stringify(val)));\n  def(\"NumericLiteral\").bases(\"Literal\").build(\"value\").field(\"value\", Number).field(\"raw\", or(String, null), defaults[\"null\"]).field(...makeLiteralExtra(Number));\n  def(\"BigIntLiteral\").bases(\"Literal\").build(\"value\").field(\"value\", or(String, Number)).field(...makeLiteralExtra(String, (val) => val + \"n\"));\n  def(\"DecimalLiteral\").bases(\"Literal\").build(\"value\").field(\"value\", String).field(...makeLiteralExtra(String, (val) => val + \"m\"));\n  def(\"NullLiteral\").bases(\"Literal\").build().field(\"value\", null, defaults[\"null\"]);\n  def(\"BooleanLiteral\").bases(\"Literal\").build(\"value\").field(\"value\", Boolean);\n  def(\"RegExpLiteral\").bases(\"Literal\").build(\"pattern\", \"flags\").field(\"pattern\", String).field(\"flags\", String).field(\"value\", RegExp, function() {\n    return new RegExp(this.pattern, this.flags);\n  }).field(...makeLiteralExtra(\n    or(RegExp, isUndefined),\n    (exp) => `/${exp.pattern}/${exp.flags || \"\"}`\n  )).field(\"regex\", {\n    pattern: String,\n    flags: String\n  }, function() {\n    return {\n      pattern: this.pattern,\n      flags: this.flags\n    };\n  });\n  var ObjectExpressionProperty = or(\n    def(\"Property\"),\n    def(\"ObjectMethod\"),\n    def(\"ObjectProperty\"),\n    def(\"SpreadProperty\"),\n    def(\"SpreadElement\")\n  );\n  def(\"ObjectExpression\").bases(\"Expression\").build(\"properties\").field(\"properties\", [ObjectExpressionProperty]);\n  def(\"ObjectMethod\").bases(\"Node\", \"Function\").build(\"kind\", \"key\", \"params\", \"body\", \"computed\").field(\"kind\", or(\"method\", \"get\", \"set\")).field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\"))).field(\"params\", [def(\"Pattern\")]).field(\"body\", def(\"BlockStatement\")).field(\"computed\", Boolean, defaults[\"false\"]).field(\"generator\", Boolean, defaults[\"false\"]).field(\"async\", Boolean, defaults[\"false\"]).field(\n    \"accessibility\",\n    // TypeScript\n    or(def(\"Literal\"), null),\n    defaults[\"null\"]\n  ).field(\n    \"decorators\",\n    or([def(\"Decorator\")], null),\n    defaults[\"null\"]\n  );\n  def(\"ObjectProperty\").bases(\"Node\").build(\"key\", \"value\").field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\"))).field(\"value\", or(def(\"Expression\"), def(\"Pattern\"))).field(\n    \"accessibility\",\n    // TypeScript\n    or(def(\"Literal\"), null),\n    defaults[\"null\"]\n  ).field(\"computed\", Boolean, defaults[\"false\"]);\n  var ClassBodyElement = or(\n    def(\"MethodDefinition\"),\n    def(\"VariableDeclarator\"),\n    def(\"ClassPropertyDefinition\"),\n    def(\"ClassProperty\"),\n    def(\"ClassPrivateProperty\"),\n    def(\"ClassMethod\"),\n    def(\"ClassPrivateMethod\"),\n    def(\"ClassAccessorProperty\"),\n    def(\"StaticBlock\")\n  );\n  def(\"ClassBody\").bases(\"Declaration\").build(\"body\").field(\"body\", [ClassBodyElement]);\n  def(\"ClassMethod\").bases(\"Declaration\", \"Function\").build(\"kind\", \"key\", \"params\", \"body\", \"computed\", \"static\").field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\")));\n  def(\"ClassPrivateMethod\").bases(\"Declaration\", \"Function\").build(\"key\", \"params\", \"body\", \"kind\", \"computed\", \"static\").field(\"key\", def(\"PrivateName\"));\n  def(\"ClassAccessorProperty\").bases(\"Declaration\").build(\"key\", \"value\", \"decorators\", \"computed\", \"static\").field(\"key\", or(\n    def(\"Literal\"),\n    def(\"Identifier\"),\n    def(\"PrivateName\"),\n    // Only when .computed is true (TODO enforce this)\n    def(\"Expression\")\n  )).field(\"value\", or(def(\"Expression\"), null), defaults[\"null\"]);\n  [\n    \"ClassMethod\",\n    \"ClassPrivateMethod\"\n  ].forEach((typeName) => {\n    def(typeName).field(\"kind\", or(\"get\", \"set\", \"method\", \"constructor\"), () => \"method\").field(\"body\", def(\"BlockStatement\")).field(\"access\", or(\"public\", \"private\", \"protected\", null), defaults[\"null\"]);\n  });\n  [\n    \"ClassMethod\",\n    \"ClassPrivateMethod\",\n    \"ClassAccessorProperty\"\n  ].forEach((typeName) => {\n    def(typeName).field(\"computed\", Boolean, defaults[\"false\"]).field(\"static\", Boolean, defaults[\"false\"]).field(\"abstract\", Boolean, defaults[\"false\"]).field(\"accessibility\", or(\"public\", \"private\", \"protected\", null), defaults[\"null\"]).field(\"decorators\", or([def(\"Decorator\")], null), defaults[\"null\"]).field(\"definite\", Boolean, defaults[\"false\"]).field(\"optional\", Boolean, defaults[\"false\"]).field(\"override\", Boolean, defaults[\"false\"]).field(\"readonly\", Boolean, defaults[\"false\"]);\n  });\n  var ObjectPatternProperty = or(\n    def(\"Property\"),\n    def(\"PropertyPattern\"),\n    def(\"SpreadPropertyPattern\"),\n    def(\"SpreadProperty\"),\n    // Used by Esprima\n    def(\"ObjectProperty\"),\n    // Babel 6\n    def(\"RestProperty\"),\n    // Babel 6\n    def(\"RestElement\")\n    // Babel 6\n  );\n  def(\"ObjectPattern\").bases(\"Pattern\").build(\"properties\").field(\"properties\", [ObjectPatternProperty]).field(\n    \"decorators\",\n    or([def(\"Decorator\")], null),\n    defaults[\"null\"]\n  );\n  def(\"SpreadProperty\").bases(\"Node\").build(\"argument\").field(\"argument\", def(\"Expression\"));\n  def(\"RestProperty\").bases(\"Node\").build(\"argument\").field(\"argument\", def(\"Expression\"));\n  def(\"ForAwaitStatement\").bases(\"Statement\").build(\"left\", \"right\", \"body\").field(\"left\", or(\n    def(\"VariableDeclaration\"),\n    def(\"Expression\")\n  )).field(\"right\", def(\"Expression\")).field(\"body\", def(\"Statement\"));\n  def(\"Import\").bases(\"Expression\").build();\n}\nmaybeSetModuleExports(() => module);\n\nfunction babelDef(fork) {\n  const types = fork.use(typesPlugin);\n  const def = types.Type.def;\n  fork.use(babelCoreDef);\n  fork.use(flowDef);\n  def(\"V8IntrinsicIdentifier\").bases(\"Expression\").build(\"name\").field(\"name\", String);\n  def(\"TopicReference\").bases(\"Expression\").build();\n}\nmaybeSetModuleExports(() => module);\n\nfunction typescriptDef(fork) {\n  fork.use(babelCoreDef);\n  fork.use(typeAnnotationsDef);\n  var types = fork.use(typesPlugin);\n  var n = types.namedTypes;\n  var def = types.Type.def;\n  var or = types.Type.or;\n  var defaults = fork.use(sharedPlugin).defaults;\n  var StringLiteral = types.Type.from(function(value, deep) {\n    if (n.StringLiteral && n.StringLiteral.check(value, deep)) {\n      return true;\n    }\n    if (n.Literal && n.Literal.check(value, deep) && typeof value.value === \"string\") {\n      return true;\n    }\n    return false;\n  }, \"StringLiteral\");\n  def(\"TSType\").bases(\"Node\");\n  var TSEntityName = or(\n    def(\"Identifier\"),\n    def(\"TSQualifiedName\")\n  );\n  def(\"TSTypeReference\").bases(\"TSType\", \"TSHasOptionalTypeParameterInstantiation\").build(\"typeName\", \"typeParameters\").field(\"typeName\", TSEntityName);\n  def(\"TSHasOptionalTypeParameterInstantiation\").field(\n    \"typeParameters\",\n    or(def(\"TSTypeParameterInstantiation\"), null),\n    defaults[\"null\"]\n  );\n  def(\"TSHasOptionalTypeParameters\").field(\n    \"typeParameters\",\n    or(def(\"TSTypeParameterDeclaration\"), null, void 0),\n    defaults[\"null\"]\n  );\n  def(\"TSHasOptionalTypeAnnotation\").field(\n    \"typeAnnotation\",\n    or(def(\"TSTypeAnnotation\"), null),\n    defaults[\"null\"]\n  );\n  def(\"TSQualifiedName\").bases(\"Node\").build(\"left\", \"right\").field(\"left\", TSEntityName).field(\"right\", TSEntityName);\n  def(\"TSAsExpression\").bases(\"Expression\", \"Pattern\").build(\"expression\", \"typeAnnotation\").field(\"expression\", def(\"Expression\")).field(\"typeAnnotation\", def(\"TSType\")).field(\n    \"extra\",\n    or({ parenthesized: Boolean }, null),\n    defaults[\"null\"]\n  );\n  def(\"TSTypeCastExpression\").bases(\"Expression\").build(\"expression\", \"typeAnnotation\").field(\"expression\", def(\"Expression\")).field(\"typeAnnotation\", def(\"TSType\"));\n  def(\"TSSatisfiesExpression\").bases(\"Expression\", \"Pattern\").build(\"expression\", \"typeAnnotation\").field(\"expression\", def(\"Expression\")).field(\"typeAnnotation\", def(\"TSType\"));\n  def(\"TSNonNullExpression\").bases(\"Expression\", \"Pattern\").build(\"expression\").field(\"expression\", def(\"Expression\"));\n  [\n    // Define all the simple keyword types.\n    \"TSAnyKeyword\",\n    \"TSBigIntKeyword\",\n    \"TSBooleanKeyword\",\n    \"TSNeverKeyword\",\n    \"TSNullKeyword\",\n    \"TSNumberKeyword\",\n    \"TSObjectKeyword\",\n    \"TSStringKeyword\",\n    \"TSSymbolKeyword\",\n    \"TSUndefinedKeyword\",\n    \"TSUnknownKeyword\",\n    \"TSVoidKeyword\",\n    \"TSIntrinsicKeyword\",\n    \"TSThisType\"\n  ].forEach((keywordType) => {\n    def(keywordType).bases(\"TSType\").build();\n  });\n  def(\"TSArrayType\").bases(\"TSType\").build(\"elementType\").field(\"elementType\", def(\"TSType\"));\n  def(\"TSLiteralType\").bases(\"TSType\").build(\"literal\").field(\"literal\", or(\n    def(\"NumericLiteral\"),\n    def(\"StringLiteral\"),\n    def(\"BooleanLiteral\"),\n    def(\"TemplateLiteral\"),\n    def(\"UnaryExpression\"),\n    def(\"BigIntLiteral\")\n  ));\n  def(\"TemplateLiteral\").field(\"expressions\", or(\n    [def(\"Expression\")],\n    [def(\"TSType\")]\n  ));\n  [\n    \"TSUnionType\",\n    \"TSIntersectionType\"\n  ].forEach((typeName) => {\n    def(typeName).bases(\"TSType\").build(\"types\").field(\"types\", [def(\"TSType\")]);\n  });\n  def(\"TSConditionalType\").bases(\"TSType\").build(\"checkType\", \"extendsType\", \"trueType\", \"falseType\").field(\"checkType\", def(\"TSType\")).field(\"extendsType\", def(\"TSType\")).field(\"trueType\", def(\"TSType\")).field(\"falseType\", def(\"TSType\"));\n  def(\"TSInferType\").bases(\"TSType\").build(\"typeParameter\").field(\"typeParameter\", def(\"TSTypeParameter\"));\n  def(\"TSParenthesizedType\").bases(\"TSType\").build(\"typeAnnotation\").field(\"typeAnnotation\", def(\"TSType\"));\n  var ParametersType = [or(\n    def(\"Identifier\"),\n    def(\"RestElement\"),\n    def(\"ArrayPattern\"),\n    def(\"ObjectPattern\")\n  )];\n  [\n    \"TSFunctionType\",\n    \"TSConstructorType\"\n  ].forEach((typeName) => {\n    def(typeName).bases(\n      \"TSType\",\n      \"TSHasOptionalTypeParameters\",\n      \"TSHasOptionalTypeAnnotation\"\n    ).build(\"parameters\").field(\"parameters\", ParametersType);\n  });\n  def(\"TSDeclareFunction\").bases(\"Declaration\", \"TSHasOptionalTypeParameters\").build(\"id\", \"params\", \"returnType\").field(\"declare\", Boolean, defaults[\"false\"]).field(\"async\", Boolean, defaults[\"false\"]).field(\"generator\", Boolean, defaults[\"false\"]).field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"]).field(\"params\", [def(\"Pattern\")]).field(\n    \"returnType\",\n    or(\n      def(\"TSTypeAnnotation\"),\n      def(\"Noop\"),\n      // Still used?\n      null\n    ),\n    defaults[\"null\"]\n  );\n  def(\"TSDeclareMethod\").bases(\"Declaration\", \"TSHasOptionalTypeParameters\").build(\"key\", \"params\", \"returnType\").field(\"async\", Boolean, defaults[\"false\"]).field(\"generator\", Boolean, defaults[\"false\"]).field(\"params\", [def(\"Pattern\")]).field(\"abstract\", Boolean, defaults[\"false\"]).field(\n    \"accessibility\",\n    or(\"public\", \"private\", \"protected\", void 0),\n    defaults[\"undefined\"]\n  ).field(\"static\", Boolean, defaults[\"false\"]).field(\"computed\", Boolean, defaults[\"false\"]).field(\"optional\", Boolean, defaults[\"false\"]).field(\"key\", or(\n    def(\"Identifier\"),\n    def(\"StringLiteral\"),\n    def(\"NumericLiteral\"),\n    // Only allowed if .computed is true.\n    def(\"Expression\")\n  )).field(\n    \"kind\",\n    or(\"get\", \"set\", \"method\", \"constructor\"),\n    function getDefault() {\n      return \"method\";\n    }\n  ).field(\n    \"access\",\n    // Not \"accessibility\"?\n    or(\"public\", \"private\", \"protected\", void 0),\n    defaults[\"undefined\"]\n  ).field(\n    \"decorators\",\n    or([def(\"Decorator\")], null),\n    defaults[\"null\"]\n  ).field(\n    \"returnType\",\n    or(\n      def(\"TSTypeAnnotation\"),\n      def(\"Noop\"),\n      // Still used?\n      null\n    ),\n    defaults[\"null\"]\n  );\n  def(\"TSMappedType\").bases(\"TSType\").build(\"typeParameter\", \"typeAnnotation\").field(\"readonly\", or(Boolean, \"+\", \"-\"), defaults[\"false\"]).field(\"typeParameter\", def(\"TSTypeParameter\")).field(\"optional\", or(Boolean, \"+\", \"-\"), defaults[\"false\"]).field(\n    \"typeAnnotation\",\n    or(def(\"TSType\"), null),\n    defaults[\"null\"]\n  );\n  def(\"TSTupleType\").bases(\"TSType\").build(\"elementTypes\").field(\"elementTypes\", [or(\n    def(\"TSType\"),\n    def(\"TSNamedTupleMember\")\n  )]);\n  def(\"TSNamedTupleMember\").bases(\"TSType\").build(\"label\", \"elementType\", \"optional\").field(\"label\", def(\"Identifier\")).field(\"optional\", Boolean, defaults[\"false\"]).field(\"elementType\", def(\"TSType\"));\n  def(\"TSRestType\").bases(\"TSType\").build(\"typeAnnotation\").field(\"typeAnnotation\", def(\"TSType\"));\n  def(\"TSOptionalType\").bases(\"TSType\").build(\"typeAnnotation\").field(\"typeAnnotation\", def(\"TSType\"));\n  def(\"TSIndexedAccessType\").bases(\"TSType\").build(\"objectType\", \"indexType\").field(\"objectType\", def(\"TSType\")).field(\"indexType\", def(\"TSType\"));\n  def(\"TSTypeOperator\").bases(\"TSType\").build(\"operator\").field(\"operator\", String).field(\"typeAnnotation\", def(\"TSType\"));\n  def(\"TSTypeAnnotation\").bases(\"Node\").build(\"typeAnnotation\").field(\n    \"typeAnnotation\",\n    or(\n      def(\"TSType\"),\n      def(\"TSTypeAnnotation\")\n    )\n  );\n  def(\"TSIndexSignature\").bases(\"Declaration\", \"TSHasOptionalTypeAnnotation\").build(\"parameters\", \"typeAnnotation\").field(\"parameters\", [def(\"Identifier\")]).field(\"readonly\", Boolean, defaults[\"false\"]);\n  def(\"TSPropertySignature\").bases(\"Declaration\", \"TSHasOptionalTypeAnnotation\").build(\"key\", \"typeAnnotation\", \"optional\").field(\"key\", def(\"Expression\")).field(\"computed\", Boolean, defaults[\"false\"]).field(\"readonly\", Boolean, defaults[\"false\"]).field(\"optional\", Boolean, defaults[\"false\"]).field(\n    \"initializer\",\n    or(def(\"Expression\"), null),\n    defaults[\"null\"]\n  );\n  def(\"TSMethodSignature\").bases(\n    \"Declaration\",\n    \"TSHasOptionalTypeParameters\",\n    \"TSHasOptionalTypeAnnotation\"\n  ).build(\"key\", \"parameters\", \"typeAnnotation\").field(\"key\", def(\"Expression\")).field(\"computed\", Boolean, defaults[\"false\"]).field(\"optional\", Boolean, defaults[\"false\"]).field(\"parameters\", ParametersType);\n  def(\"TSTypePredicate\").bases(\"TSTypeAnnotation\", \"TSType\").build(\"parameterName\", \"typeAnnotation\", \"asserts\").field(\n    \"parameterName\",\n    or(\n      def(\"Identifier\"),\n      def(\"TSThisType\")\n    )\n  ).field(\n    \"typeAnnotation\",\n    or(def(\"TSTypeAnnotation\"), null),\n    defaults[\"null\"]\n  ).field(\"asserts\", Boolean, defaults[\"false\"]);\n  [\n    \"TSCallSignatureDeclaration\",\n    \"TSConstructSignatureDeclaration\"\n  ].forEach((typeName) => {\n    def(typeName).bases(\n      \"Declaration\",\n      \"TSHasOptionalTypeParameters\",\n      \"TSHasOptionalTypeAnnotation\"\n    ).build(\"parameters\", \"typeAnnotation\").field(\"parameters\", ParametersType);\n  });\n  def(\"TSEnumMember\").bases(\"Node\").build(\"id\", \"initializer\").field(\"id\", or(def(\"Identifier\"), StringLiteral)).field(\n    \"initializer\",\n    or(def(\"Expression\"), null),\n    defaults[\"null\"]\n  );\n  def(\"TSTypeQuery\").bases(\"TSType\").build(\"exprName\").field(\"exprName\", or(TSEntityName, def(\"TSImportType\")));\n  var TSTypeMember = or(\n    def(\"TSCallSignatureDeclaration\"),\n    def(\"TSConstructSignatureDeclaration\"),\n    def(\"TSIndexSignature\"),\n    def(\"TSMethodSignature\"),\n    def(\"TSPropertySignature\")\n  );\n  def(\"TSTypeLiteral\").bases(\"TSType\").build(\"members\").field(\"members\", [TSTypeMember]);\n  def(\"TSTypeParameter\").bases(\"Identifier\").build(\"name\", \"constraint\", \"default\").field(\"name\", or(def(\"Identifier\"), String)).field(\"constraint\", or(def(\"TSType\"), void 0), defaults[\"undefined\"]).field(\"default\", or(def(\"TSType\"), void 0), defaults[\"undefined\"]);\n  def(\"TSTypeAssertion\").bases(\"Expression\", \"Pattern\").build(\"typeAnnotation\", \"expression\").field(\"typeAnnotation\", def(\"TSType\")).field(\"expression\", def(\"Expression\")).field(\n    \"extra\",\n    or({ parenthesized: Boolean }, null),\n    defaults[\"null\"]\n  );\n  def(\"TSTypeParameterDeclaration\").bases(\"Declaration\").build(\"params\").field(\"params\", [def(\"TSTypeParameter\")]);\n  def(\"TSInstantiationExpression\").bases(\"Expression\", \"TSHasOptionalTypeParameterInstantiation\").build(\"expression\", \"typeParameters\").field(\"expression\", def(\"Expression\"));\n  def(\"TSTypeParameterInstantiation\").bases(\"Node\").build(\"params\").field(\"params\", [def(\"TSType\")]);\n  def(\"TSEnumDeclaration\").bases(\"Declaration\").build(\"id\", \"members\").field(\"id\", def(\"Identifier\")).field(\"const\", Boolean, defaults[\"false\"]).field(\"declare\", Boolean, defaults[\"false\"]).field(\"members\", [def(\"TSEnumMember\")]).field(\n    \"initializer\",\n    or(def(\"Expression\"), null),\n    defaults[\"null\"]\n  );\n  def(\"TSTypeAliasDeclaration\").bases(\"Declaration\", \"TSHasOptionalTypeParameters\").build(\"id\", \"typeAnnotation\").field(\"id\", def(\"Identifier\")).field(\"declare\", Boolean, defaults[\"false\"]).field(\"typeAnnotation\", def(\"TSType\"));\n  def(\"TSModuleBlock\").bases(\"Node\").build(\"body\").field(\"body\", [def(\"Statement\")]);\n  def(\"TSModuleDeclaration\").bases(\"Declaration\").build(\"id\", \"body\").field(\"id\", or(StringLiteral, TSEntityName)).field(\"declare\", Boolean, defaults[\"false\"]).field(\"global\", Boolean, defaults[\"false\"]).field(\n    \"body\",\n    or(\n      def(\"TSModuleBlock\"),\n      def(\"TSModuleDeclaration\"),\n      null\n    ),\n    defaults[\"null\"]\n  );\n  def(\"TSImportType\").bases(\"TSType\", \"TSHasOptionalTypeParameterInstantiation\").build(\"argument\", \"qualifier\", \"typeParameters\").field(\"argument\", StringLiteral).field(\"qualifier\", or(TSEntityName, void 0), defaults[\"undefined\"]);\n  def(\"TSImportEqualsDeclaration\").bases(\"Declaration\").build(\"id\", \"moduleReference\").field(\"id\", def(\"Identifier\")).field(\"isExport\", Boolean, defaults[\"false\"]).field(\n    \"moduleReference\",\n    or(\n      TSEntityName,\n      def(\"TSExternalModuleReference\")\n    )\n  );\n  def(\"TSExternalModuleReference\").bases(\"Declaration\").build(\"expression\").field(\"expression\", StringLiteral);\n  def(\"TSExportAssignment\").bases(\"Statement\").build(\"expression\").field(\"expression\", def(\"Expression\"));\n  def(\"TSNamespaceExportDeclaration\").bases(\"Declaration\").build(\"id\").field(\"id\", def(\"Identifier\"));\n  def(\"TSInterfaceBody\").bases(\"Node\").build(\"body\").field(\"body\", [TSTypeMember]);\n  def(\"TSExpressionWithTypeArguments\").bases(\"TSType\", \"TSHasOptionalTypeParameterInstantiation\").build(\"expression\", \"typeParameters\").field(\"expression\", TSEntityName);\n  def(\"TSInterfaceDeclaration\").bases(\"Declaration\", \"TSHasOptionalTypeParameters\").build(\"id\", \"body\").field(\"id\", TSEntityName).field(\"declare\", Boolean, defaults[\"false\"]).field(\n    \"extends\",\n    or([def(\"TSExpressionWithTypeArguments\")], null),\n    defaults[\"null\"]\n  ).field(\"body\", def(\"TSInterfaceBody\"));\n  def(\"TSParameterProperty\").bases(\"Pattern\").build(\"parameter\").field(\n    \"accessibility\",\n    or(\"public\", \"private\", \"protected\", void 0),\n    defaults[\"undefined\"]\n  ).field(\"readonly\", Boolean, defaults[\"false\"]).field(\"parameter\", or(\n    def(\"Identifier\"),\n    def(\"AssignmentPattern\")\n  ));\n  def(\"ClassProperty\").field(\n    \"access\",\n    // Not \"accessibility\"?\n    or(\"public\", \"private\", \"protected\", void 0),\n    defaults[\"undefined\"]\n  );\n  def(\"ClassAccessorProperty\").bases(\"Declaration\", \"TSHasOptionalTypeAnnotation\");\n  def(\"ClassBody\").field(\"body\", [or(\n    def(\"MethodDefinition\"),\n    def(\"VariableDeclarator\"),\n    def(\"ClassPropertyDefinition\"),\n    def(\"ClassProperty\"),\n    def(\"ClassPrivateProperty\"),\n    def(\"ClassAccessorProperty\"),\n    def(\"ClassMethod\"),\n    def(\"ClassPrivateMethod\"),\n    def(\"StaticBlock\"),\n    // Just need to add these types:\n    def(\"TSDeclareMethod\"),\n    TSTypeMember\n  )]);\n}\nmaybeSetModuleExports(() => module);\n\nvar namedTypes$1;\n((namedTypes2) => {\n})(namedTypes$1 || (namedTypes$1 = {}));\n\nconst {\n  astNodesAreEquivalent,\n  builders: builders$1,\n  builtInTypes,\n  defineMethod,\n  eachField,\n  finalize,\n  getBuilderName,\n  getFieldNames,\n  getFieldValue,\n  getSupertypeNames,\n  namedTypes: n$3,\n  NodePath,\n  Path,\n  PathVisitor,\n  someField,\n  Type,\n  use,\n  visit\n} = fork([\n  // Feel free to add to or remove from this list of extension modules to\n  // configure the precise type hierarchy that you need.\n  esProposalsDef,\n  jsxDef,\n  flowDef,\n  esprimaDef,\n  babelDef,\n  typescriptDef\n]);\nObject.assign(namedTypes$1, n$3);\n\nconst n$2 = namedTypes$1;\nconst SourceMapConsumer = source_map_js__WEBPACK_IMPORTED_MODULE_2__.SourceMapConsumer;\nconst SourceMapGenerator = source_map_js__WEBPACK_IMPORTED_MODULE_2__.SourceMapGenerator;\nconst hasOwn$2 = Object.prototype.hasOwnProperty;\nfunction getLineTerminator() {\n  return \"\\n\";\n}\nfunction getOption(options, key, defaultValue) {\n  if (options && hasOwn$2.call(options, key)) {\n    return options[key];\n  }\n  return defaultValue;\n}\nfunction getUnionOfKeys(...args) {\n  const result = {};\n  const argc = args.length;\n  for (let i = 0; i < argc; ++i) {\n    const keys = Object.keys(args[i]);\n    const keyCount = keys.length;\n    for (let j = 0; j < keyCount; ++j) {\n      result[keys[j]] = true;\n    }\n  }\n  return result;\n}\nfunction comparePos(pos1, pos2) {\n  return pos1.line - pos2.line || pos1.column - pos2.column;\n}\nfunction copyPos(pos) {\n  return {\n    line: pos.line,\n    column: pos.column\n  };\n}\nfunction composeSourceMaps(formerMap, latterMap) {\n  if (formerMap) {\n    if (!latterMap) {\n      return formerMap;\n    }\n  } else {\n    return latterMap || null;\n  }\n  const smcFormer = new SourceMapConsumer(formerMap);\n  const smcLatter = new SourceMapConsumer(latterMap);\n  const smg = new SourceMapGenerator({\n    file: latterMap.file,\n    sourceRoot: latterMap.sourceRoot\n  });\n  const sourcesToContents = {};\n  smcLatter.eachMapping(function(mapping) {\n    const origPos = smcFormer.originalPositionFor({\n      line: mapping.originalLine,\n      column: mapping.originalColumn\n    });\n    const sourceName = origPos.source;\n    if (sourceName === null) {\n      return;\n    }\n    smg.addMapping({\n      source: sourceName,\n      original: copyPos(origPos),\n      generated: {\n        line: mapping.generatedLine,\n        column: mapping.generatedColumn\n      },\n      name: mapping.name\n    });\n    const sourceContent = smcFormer.sourceContentFor(sourceName);\n    if (sourceContent && !hasOwn$2.call(sourcesToContents, sourceName)) {\n      sourcesToContents[sourceName] = sourceContent;\n      smg.setSourceContent(sourceName, sourceContent);\n    }\n  });\n  return smg.toJSON();\n}\nfunction getTrueLoc(node, lines) {\n  if (!node.loc) {\n    return null;\n  }\n  const result = {\n    start: node.loc.start,\n    end: node.loc.end\n  };\n  function include(node2) {\n    expandLoc(result, node2.loc);\n  }\n  if (node.declaration && node.declaration.decorators && isExportDeclaration(node)) {\n    node.declaration.decorators.forEach(include);\n  }\n  if (comparePos(result.start, result.end) < 0) {\n    result.start = copyPos(result.start);\n    lines.skipSpaces(result.start, false, true);\n    if (comparePos(result.start, result.end) < 0) {\n      result.end = copyPos(result.end);\n      lines.skipSpaces(result.end, true, true);\n    }\n  }\n  if (node.comments) {\n    node.comments.forEach(include);\n  }\n  return result;\n}\nfunction expandLoc(parentLoc, childLoc) {\n  if (parentLoc && childLoc) {\n    if (comparePos(childLoc.start, parentLoc.start) < 0) {\n      parentLoc.start = childLoc.start;\n    }\n    if (comparePos(parentLoc.end, childLoc.end) < 0) {\n      parentLoc.end = childLoc.end;\n    }\n  }\n}\nfunction fixFaultyLocations(node, lines) {\n  const loc = node.loc;\n  if (loc) {\n    if (loc.start.line < 1) {\n      loc.start.line = 1;\n    }\n    if (loc.end.line < 1) {\n      loc.end.line = 1;\n    }\n  }\n  if (node.type === \"File\") {\n    loc.start = lines.firstPos();\n    loc.end = lines.lastPos();\n  }\n  fixForLoopHead(node, lines);\n  fixTemplateLiteral(node, lines);\n  if (loc && node.decorators) {\n    node.decorators.forEach(function(decorator) {\n      expandLoc(loc, decorator.loc);\n    });\n  } else if (node.declaration && isExportDeclaration(node)) {\n    node.declaration.loc = null;\n    const decorators = node.declaration.decorators;\n    if (decorators) {\n      decorators.forEach(function(decorator) {\n        expandLoc(loc, decorator.loc);\n      });\n    }\n  } else if (n$2.MethodDefinition && n$2.MethodDefinition.check(node) || n$2.Property.check(node) && (node.method || node.shorthand)) {\n    node.value.loc = null;\n    if (n$2.FunctionExpression.check(node.value)) {\n      node.value.id = null;\n    }\n  } else if (node.type === \"ObjectTypeProperty\") {\n    const loc2 = node.loc;\n    let end = loc2 && loc2.end;\n    if (end) {\n      end = copyPos(end);\n      if (lines.prevPos(end) && lines.charAt(end) === \",\") {\n        if (end = lines.skipSpaces(end, true, true)) {\n          loc2.end = end;\n        }\n      }\n    }\n  }\n}\nfunction fixForLoopHead(node, lines) {\n  if (node.type !== \"ForStatement\") {\n    return;\n  }\n  function fix(child) {\n    const loc = child && child.loc;\n    const start = loc && loc.start;\n    const end = loc && copyPos(loc.end);\n    while (start && end && comparePos(start, end) < 0) {\n      lines.prevPos(end);\n      if (lines.charAt(end) === \";\") {\n        loc.end.line = end.line;\n        loc.end.column = end.column;\n      } else {\n        break;\n      }\n    }\n  }\n  fix(node.init);\n  fix(node.test);\n  fix(node.update);\n}\nfunction fixTemplateLiteral(node, lines) {\n  if (node.type !== \"TemplateLiteral\") {\n    return;\n  }\n  if (node.quasis.length === 0) {\n    return;\n  }\n  if (node.loc) {\n    const afterLeftBackTickPos = copyPos(node.loc.start);\n    const firstQuasi = node.quasis[0];\n    if (comparePos(firstQuasi.loc.start, afterLeftBackTickPos) < 0) {\n      firstQuasi.loc.start = afterLeftBackTickPos;\n    }\n    const rightBackTickPos = copyPos(node.loc.end);\n    const lastQuasi = node.quasis[node.quasis.length - 1];\n    if (comparePos(rightBackTickPos, lastQuasi.loc.end) < 0) {\n      lastQuasi.loc.end = rightBackTickPos;\n    }\n  }\n  node.expressions.forEach(function(expr, i) {\n    const dollarCurlyPos = lines.skipSpaces(expr.loc.start, true, false);\n    if (lines.prevPos(dollarCurlyPos) && lines.charAt(dollarCurlyPos) === \"{\" && lines.prevPos(dollarCurlyPos) && lines.charAt(dollarCurlyPos) === \"$\") {\n      const quasiBefore = node.quasis[i];\n      if (comparePos(dollarCurlyPos, quasiBefore.loc.end) < 0) {\n        quasiBefore.loc.end = dollarCurlyPos;\n      }\n    }\n    const rightCurlyPos = lines.skipSpaces(expr.loc.end, false, false);\n    if (lines.charAt(rightCurlyPos) === \"}\") {\n      const quasiAfter = node.quasis[i + 1];\n      if (comparePos(quasiAfter.loc.start, rightCurlyPos) < 0) {\n        quasiAfter.loc.start = rightCurlyPos;\n      }\n    }\n  });\n}\nfunction isExportDeclaration(node) {\n  if (node)\n    switch (node.type) {\n      case \"ExportDeclaration\":\n      case \"ExportDefaultDeclaration\":\n      case \"ExportDefaultSpecifier\":\n      case \"DeclareExportDeclaration\":\n      case \"ExportNamedDeclaration\":\n      case \"ExportAllDeclaration\":\n        return true;\n    }\n  return false;\n}\nfunction getParentExportDeclaration(path) {\n  const parentNode = path.getParentNode();\n  if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {\n    return parentNode;\n  }\n  return null;\n}\nfunction isTrailingCommaEnabled(options, context) {\n  const trailingComma = options.trailingComma;\n  if (typeof trailingComma === \"object\") {\n    return !!trailingComma[context];\n  }\n  return !!trailingComma;\n}\n\nconst defaults = {\n  tabWidth: 4,\n  useTabs: false,\n  reuseWhitespace: true,\n  lineTerminator: getLineTerminator(),\n  wrapColumn: 74,\n  // Aspirational for now.\n  sourceFileName: null,\n  sourceMapName: null,\n  sourceRoot: null,\n  inputSourceMap: null,\n  range: false,\n  tolerant: true,\n  quote: null,\n  trailingComma: false,\n  arrayBracketSpacing: false,\n  objectCurlySpacing: true,\n  arrowParensAlways: false,\n  flowObjectCommas: true,\n  tokens: true\n};\nconst hasOwn$1 = defaults.hasOwnProperty;\nfunction normalize(opts) {\n  const options = opts || defaults;\n  function get(key) {\n    return hasOwn$1.call(options, key) ? options[key] : defaults[key];\n  }\n  return {\n    tabWidth: +get(\"tabWidth\"),\n    useTabs: !!get(\"useTabs\"),\n    reuseWhitespace: !!get(\"reuseWhitespace\"),\n    lineTerminator: get(\"lineTerminator\"),\n    wrapColumn: Math.max(get(\"wrapColumn\"), 0),\n    sourceFileName: get(\"sourceFileName\"),\n    sourceMapName: get(\"sourceMapName\"),\n    sourceRoot: get(\"sourceRoot\"),\n    inputSourceMap: get(\"inputSourceMap\"),\n    parser: get(\"esprima\") || get(\"parser\"),\n    range: get(\"range\"),\n    tolerant: get(\"tolerant\"),\n    quote: get(\"quote\"),\n    trailingComma: get(\"trailingComma\"),\n    arrayBracketSpacing: get(\"arrayBracketSpacing\"),\n    objectCurlySpacing: get(\"objectCurlySpacing\"),\n    arrowParensAlways: get(\"arrowParensAlways\"),\n    flowObjectCommas: get(\"flowObjectCommas\"),\n    tokens: !!get(\"tokens\")\n  };\n}\n\nclass Mapping {\n  constructor(sourceLines, sourceLoc, targetLoc = sourceLoc) {\n    this.sourceLines = sourceLines;\n    this.sourceLoc = sourceLoc;\n    this.targetLoc = targetLoc;\n  }\n  slice(lines, start, end = lines.lastPos()) {\n    const sourceLines = this.sourceLines;\n    let sourceLoc = this.sourceLoc;\n    let targetLoc = this.targetLoc;\n    function skip(name) {\n      const sourceFromPos = sourceLoc[name];\n      const targetFromPos = targetLoc[name];\n      let targetToPos = start;\n      if (name === \"end\") {\n        targetToPos = end;\n      }\n      return skipChars(\n        sourceLines,\n        sourceFromPos,\n        lines,\n        targetFromPos,\n        targetToPos\n      );\n    }\n    if (comparePos(start, targetLoc.start) <= 0) {\n      if (comparePos(targetLoc.end, end) <= 0) {\n        targetLoc = {\n          start: subtractPos(targetLoc.start, start.line, start.column),\n          end: subtractPos(targetLoc.end, start.line, start.column)\n        };\n      } else if (comparePos(end, targetLoc.start) <= 0) {\n        return null;\n      } else {\n        sourceLoc = {\n          start: sourceLoc.start,\n          end: skip(\"end\")\n        };\n        targetLoc = {\n          start: subtractPos(targetLoc.start, start.line, start.column),\n          end: subtractPos(end, start.line, start.column)\n        };\n      }\n    } else {\n      if (comparePos(targetLoc.end, start) <= 0) {\n        return null;\n      }\n      if (comparePos(targetLoc.end, end) <= 0) {\n        sourceLoc = {\n          start: skip(\"start\"),\n          end: sourceLoc.end\n        };\n        targetLoc = {\n          // Same as subtractPos(start, start.line, start.column):\n          start: { line: 1, column: 0 },\n          end: subtractPos(targetLoc.end, start.line, start.column)\n        };\n      } else {\n        sourceLoc = {\n          start: skip(\"start\"),\n          end: skip(\"end\")\n        };\n        targetLoc = {\n          // Same as subtractPos(start, start.line, start.column):\n          start: { line: 1, column: 0 },\n          end: subtractPos(end, start.line, start.column)\n        };\n      }\n    }\n    return new Mapping(this.sourceLines, sourceLoc, targetLoc);\n  }\n  add(line, column) {\n    return new Mapping(this.sourceLines, this.sourceLoc, {\n      start: addPos(this.targetLoc.start, line, column),\n      end: addPos(this.targetLoc.end, line, column)\n    });\n  }\n  subtract(line, column) {\n    return new Mapping(this.sourceLines, this.sourceLoc, {\n      start: subtractPos(this.targetLoc.start, line, column),\n      end: subtractPos(this.targetLoc.end, line, column)\n    });\n  }\n  indent(by, skipFirstLine = false, noNegativeColumns = false) {\n    if (by === 0) {\n      return this;\n    }\n    let targetLoc = this.targetLoc;\n    const startLine = targetLoc.start.line;\n    const endLine = targetLoc.end.line;\n    if (skipFirstLine && startLine === 1 && endLine === 1) {\n      return this;\n    }\n    targetLoc = {\n      start: targetLoc.start,\n      end: targetLoc.end\n    };\n    if (!skipFirstLine || startLine > 1) {\n      const startColumn = targetLoc.start.column + by;\n      targetLoc.start = {\n        line: startLine,\n        column: noNegativeColumns ? Math.max(0, startColumn) : startColumn\n      };\n    }\n    if (!skipFirstLine || endLine > 1) {\n      const endColumn = targetLoc.end.column + by;\n      targetLoc.end = {\n        line: endLine,\n        column: noNegativeColumns ? Math.max(0, endColumn) : endColumn\n      };\n    }\n    return new Mapping(this.sourceLines, this.sourceLoc, targetLoc);\n  }\n}\nfunction addPos(toPos, line, column) {\n  return {\n    line: toPos.line + line - 1,\n    column: toPos.line === 1 ? toPos.column + column : toPos.column\n  };\n}\nfunction subtractPos(fromPos, line, column) {\n  return {\n    line: fromPos.line - line + 1,\n    column: fromPos.line === line ? fromPos.column - column : fromPos.column\n  };\n}\nfunction skipChars(sourceLines, sourceFromPos, targetLines, targetFromPos, targetToPos) {\n  const targetComparison = comparePos(targetFromPos, targetToPos);\n  if (targetComparison === 0) {\n    return sourceFromPos;\n  }\n  let sourceCursor, targetCursor;\n  if (targetComparison < 0) {\n    sourceCursor = sourceLines.skipSpaces(sourceFromPos) || sourceLines.lastPos();\n    targetCursor = targetLines.skipSpaces(targetFromPos) || targetLines.lastPos();\n    const lineDiff = targetToPos.line - targetCursor.line;\n    sourceCursor.line += lineDiff;\n    targetCursor.line += lineDiff;\n    if (lineDiff > 0) {\n      sourceCursor.column = 0;\n      targetCursor.column = 0;\n    }\n    while (comparePos(targetCursor, targetToPos) < 0 && targetLines.nextPos(targetCursor, true)) {\n    }\n  } else {\n    sourceCursor = sourceLines.skipSpaces(sourceFromPos, true) || sourceLines.firstPos();\n    targetCursor = targetLines.skipSpaces(targetFromPos, true) || targetLines.firstPos();\n    const lineDiff = targetToPos.line - targetCursor.line;\n    sourceCursor.line += lineDiff;\n    targetCursor.line += lineDiff;\n    if (lineDiff < 0) {\n      sourceCursor.column = sourceLines.getLineLength(sourceCursor.line);\n      targetCursor.column = targetLines.getLineLength(targetCursor.line);\n    }\n    while (comparePos(targetToPos, targetCursor) < 0 && targetLines.prevPos(targetCursor, true)) {\n    }\n  }\n  return sourceCursor;\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass Lines {\n  constructor(infos, sourceFileName = null) {\n    this.infos = infos;\n    __publicField$1(this, \"length\");\n    __publicField$1(this, \"name\");\n    __publicField$1(this, \"mappings\", []);\n    __publicField$1(this, \"cachedSourceMap\", null);\n    __publicField$1(this, \"cachedTabWidth\");\n    this.length = infos.length;\n    this.name = sourceFileName || null;\n    if (this.name) {\n      this.mappings.push(\n        new Mapping(this, {\n          start: this.firstPos(),\n          end: this.lastPos()\n        })\n      );\n    }\n  }\n  toString(options) {\n    return this.sliceString(this.firstPos(), this.lastPos(), options);\n  }\n  getSourceMap(sourceMapName, sourceRoot) {\n    if (!sourceMapName) {\n      return null;\n    }\n    const targetLines = this;\n    function updateJSON(json) {\n      json = json || {};\n      json.file = sourceMapName;\n      if (sourceRoot) {\n        json.sourceRoot = sourceRoot;\n      }\n      return json;\n    }\n    if (targetLines.cachedSourceMap) {\n      return updateJSON(targetLines.cachedSourceMap.toJSON());\n    }\n    const smg = new source_map_js__WEBPACK_IMPORTED_MODULE_2__.SourceMapGenerator(updateJSON());\n    const sourcesToContents = {};\n    targetLines.mappings.forEach(function(mapping) {\n      const sourceCursor = mapping.sourceLines.skipSpaces(mapping.sourceLoc.start) || mapping.sourceLines.lastPos();\n      const targetCursor = targetLines.skipSpaces(mapping.targetLoc.start) || targetLines.lastPos();\n      while (comparePos(sourceCursor, mapping.sourceLoc.end) < 0 && comparePos(targetCursor, mapping.targetLoc.end) < 0) {\n        mapping.sourceLines.charAt(sourceCursor);\n        targetLines.charAt(targetCursor);\n        const sourceName = mapping.sourceLines.name;\n        smg.addMapping({\n          source: sourceName,\n          original: { line: sourceCursor.line, column: sourceCursor.column },\n          generated: { line: targetCursor.line, column: targetCursor.column }\n        });\n        if (!hasOwn.call(sourcesToContents, sourceName)) {\n          const sourceContent = mapping.sourceLines.toString();\n          smg.setSourceContent(sourceName, sourceContent);\n          sourcesToContents[sourceName] = sourceContent;\n        }\n        targetLines.nextPos(targetCursor, true);\n        mapping.sourceLines.nextPos(sourceCursor, true);\n      }\n    });\n    targetLines.cachedSourceMap = smg;\n    return smg.toJSON();\n  }\n  bootstrapCharAt(pos) {\n    const line = pos.line, column = pos.column, strings = this.toString().split(lineTerminatorSeqExp), string = strings[line - 1];\n    if (typeof string === \"undefined\")\n      return \"\";\n    if (column === string.length && line < strings.length)\n      return \"\\n\";\n    if (column >= string.length)\n      return \"\";\n    return string.charAt(column);\n  }\n  charAt(pos) {\n    let line = pos.line, column = pos.column, secret = this, infos = secret.infos, info = infos[line - 1], c = column;\n    if (typeof info === \"undefined\" || c < 0)\n      return \"\";\n    const indent = this.getIndentAt(line);\n    if (c < indent)\n      return \" \";\n    c += info.sliceStart - indent;\n    if (c === info.sliceEnd && line < this.length)\n      return \"\\n\";\n    if (c >= info.sliceEnd)\n      return \"\";\n    return info.line.charAt(c);\n  }\n  stripMargin(width, skipFirstLine) {\n    if (width === 0)\n      return this;\n    if (skipFirstLine && this.length === 1)\n      return this;\n    const lines = new Lines(\n      this.infos.map(function(info, i) {\n        if (info.line && (i > 0 || !skipFirstLine)) {\n          info = {\n            ...info,\n            indent: Math.max(0, info.indent - width)\n          };\n        }\n        return info;\n      })\n    );\n    if (this.mappings.length > 0) {\n      const newMappings = lines.mappings;\n      this.mappings.forEach(function(mapping) {\n        newMappings.push(mapping.indent(width, skipFirstLine, true));\n      });\n    }\n    return lines;\n  }\n  indent(by) {\n    if (by === 0) {\n      return this;\n    }\n    const lines = new Lines(\n      this.infos.map(function(info) {\n        if (info.line && !info.locked) {\n          info = {\n            ...info,\n            indent: info.indent + by\n          };\n        }\n        return info;\n      })\n    );\n    if (this.mappings.length > 0) {\n      const newMappings = lines.mappings;\n      this.mappings.forEach(function(mapping) {\n        newMappings.push(mapping.indent(by));\n      });\n    }\n    return lines;\n  }\n  indentTail(by) {\n    if (by === 0) {\n      return this;\n    }\n    if (this.length < 2) {\n      return this;\n    }\n    const lines = new Lines(\n      this.infos.map(function(info, i) {\n        if (i > 0 && info.line && !info.locked) {\n          info = {\n            ...info,\n            indent: info.indent + by\n          };\n        }\n        return info;\n      })\n    );\n    if (this.mappings.length > 0) {\n      const newMappings = lines.mappings;\n      this.mappings.forEach(function(mapping) {\n        newMappings.push(mapping.indent(by, true));\n      });\n    }\n    return lines;\n  }\n  lockIndentTail() {\n    if (this.length < 2) {\n      return this;\n    }\n    return new Lines(\n      this.infos.map((info, i) => ({\n        ...info,\n        locked: i > 0\n      }))\n    );\n  }\n  getIndentAt(line) {\n    return Math.max(this.infos[line - 1].indent, 0);\n  }\n  guessTabWidth() {\n    if (typeof this.cachedTabWidth === \"number\") {\n      return this.cachedTabWidth;\n    }\n    const counts = [];\n    let lastIndent = 0;\n    for (let line = 1, last = this.length; line <= last; ++line) {\n      const info = this.infos[line - 1];\n      const sliced = info.line.slice(info.sliceStart, info.sliceEnd);\n      if (isOnlyWhitespace(sliced)) {\n        continue;\n      }\n      const diff = Math.abs(info.indent - lastIndent);\n      counts[diff] = ~~counts[diff] + 1;\n      lastIndent = info.indent;\n    }\n    let maxCount = -1;\n    let result = 2;\n    for (let tabWidth = 1; tabWidth < counts.length; tabWidth += 1) {\n      if (hasOwn.call(counts, tabWidth) && counts[tabWidth] > maxCount) {\n        maxCount = counts[tabWidth];\n        result = tabWidth;\n      }\n    }\n    return this.cachedTabWidth = result;\n  }\n  // Determine if the list of lines has a first line that starts with a //\n  // or /* comment. If this is the case, the code may need to be wrapped in\n  // parens to avoid ASI issues.\n  startsWithComment() {\n    if (this.infos.length === 0) {\n      return false;\n    }\n    const firstLineInfo = this.infos[0], sliceStart = firstLineInfo.sliceStart, sliceEnd = firstLineInfo.sliceEnd, firstLine = firstLineInfo.line.slice(sliceStart, sliceEnd).trim();\n    return firstLine.length === 0 || firstLine.slice(0, 2) === \"//\" || firstLine.slice(0, 2) === \"/*\";\n  }\n  isOnlyWhitespace() {\n    return isOnlyWhitespace(this.toString());\n  }\n  isPrecededOnlyByWhitespace(pos) {\n    const info = this.infos[pos.line - 1];\n    const indent = Math.max(info.indent, 0);\n    const diff = pos.column - indent;\n    if (diff <= 0) {\n      return true;\n    }\n    const start = info.sliceStart;\n    const end = Math.min(start + diff, info.sliceEnd);\n    const prefix = info.line.slice(start, end);\n    return isOnlyWhitespace(prefix);\n  }\n  getLineLength(line) {\n    const info = this.infos[line - 1];\n    return this.getIndentAt(line) + info.sliceEnd - info.sliceStart;\n  }\n  nextPos(pos, skipSpaces = false) {\n    const l = Math.max(pos.line, 0), c = Math.max(pos.column, 0);\n    if (c < this.getLineLength(l)) {\n      pos.column += 1;\n      return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n    }\n    if (l < this.length) {\n      pos.line += 1;\n      pos.column = 0;\n      return skipSpaces ? !!this.skipSpaces(pos, false, true) : true;\n    }\n    return false;\n  }\n  prevPos(pos, skipSpaces = false) {\n    let l = pos.line, c = pos.column;\n    if (c < 1) {\n      l -= 1;\n      if (l < 1)\n        return false;\n      c = this.getLineLength(l);\n    } else {\n      c = Math.min(c - 1, this.getLineLength(l));\n    }\n    pos.line = l;\n    pos.column = c;\n    return skipSpaces ? !!this.skipSpaces(pos, true, true) : true;\n  }\n  firstPos() {\n    return { line: 1, column: 0 };\n  }\n  lastPos() {\n    return {\n      line: this.length,\n      column: this.getLineLength(this.length)\n    };\n  }\n  skipSpaces(pos, backward = false, modifyInPlace = false) {\n    if (pos) {\n      pos = modifyInPlace ? pos : {\n        line: pos.line,\n        column: pos.column\n      };\n    } else if (backward) {\n      pos = this.lastPos();\n    } else {\n      pos = this.firstPos();\n    }\n    if (backward) {\n      while (this.prevPos(pos)) {\n        if (!isOnlyWhitespace(this.charAt(pos)) && this.nextPos(pos)) {\n          return pos;\n        }\n      }\n      return null;\n    } else {\n      while (isOnlyWhitespace(this.charAt(pos))) {\n        if (!this.nextPos(pos)) {\n          return null;\n        }\n      }\n      return pos;\n    }\n  }\n  trimLeft() {\n    const pos = this.skipSpaces(this.firstPos(), false, true);\n    return pos ? this.slice(pos) : emptyLines;\n  }\n  trimRight() {\n    const pos = this.skipSpaces(this.lastPos(), true, true);\n    return pos ? this.slice(this.firstPos(), pos) : emptyLines;\n  }\n  trim() {\n    const start = this.skipSpaces(this.firstPos(), false, true);\n    if (start === null) {\n      return emptyLines;\n    }\n    const end = this.skipSpaces(this.lastPos(), true, true);\n    if (end === null) {\n      return emptyLines;\n    }\n    return this.slice(start, end);\n  }\n  eachPos(callback, startPos = this.firstPos(), skipSpaces = false) {\n    const pos = this.firstPos();\n    if (startPos) {\n      pos.line = startPos.line, pos.column = startPos.column;\n    }\n    if (skipSpaces && !this.skipSpaces(pos, false, true)) {\n      return;\n    }\n    do\n      callback.call(this, pos);\n    while (this.nextPos(pos, skipSpaces));\n  }\n  bootstrapSlice(start, end) {\n    const strings = this.toString().split(lineTerminatorSeqExp).slice(start.line - 1, end.line);\n    if (strings.length > 0) {\n      strings.push(strings.pop().slice(0, end.column));\n      strings[0] = strings[0].slice(start.column);\n    }\n    return fromString(strings.join(\"\\n\"));\n  }\n  slice(start, end) {\n    if (!end) {\n      if (!start) {\n        return this;\n      }\n      end = this.lastPos();\n    }\n    if (!start) {\n      throw new Error(\"cannot slice with end but not start\");\n    }\n    const sliced = this.infos.slice(start.line - 1, end.line);\n    if (start.line === end.line) {\n      sliced[0] = sliceInfo(sliced[0], start.column, end.column);\n    } else {\n      sliced[0] = sliceInfo(sliced[0], start.column);\n      sliced.push(sliceInfo(sliced.pop(), 0, end.column));\n    }\n    const lines = new Lines(sliced);\n    if (this.mappings.length > 0) {\n      const newMappings = lines.mappings;\n      this.mappings.forEach(function(mapping) {\n        const sliced2 = mapping.slice(this, start, end);\n        if (sliced2) {\n          newMappings.push(sliced2);\n        }\n      }, this);\n    }\n    return lines;\n  }\n  bootstrapSliceString(start, end, options) {\n    return this.slice(start, end).toString(options);\n  }\n  sliceString(start = this.firstPos(), end = this.lastPos(), options) {\n    const { tabWidth, useTabs, reuseWhitespace, lineTerminator } = normalize(options);\n    const parts = [];\n    for (let line = start.line; line <= end.line; ++line) {\n      let info = this.infos[line - 1];\n      if (line === start.line) {\n        if (line === end.line) {\n          info = sliceInfo(info, start.column, end.column);\n        } else {\n          info = sliceInfo(info, start.column);\n        }\n      } else if (line === end.line) {\n        info = sliceInfo(info, 0, end.column);\n      }\n      const indent = Math.max(info.indent, 0);\n      const before = info.line.slice(0, info.sliceStart);\n      if (reuseWhitespace && isOnlyWhitespace(before) && countSpaces(before, tabWidth) === indent) {\n        parts.push(info.line.slice(0, info.sliceEnd));\n        continue;\n      }\n      let tabs = 0;\n      let spaces = indent;\n      if (useTabs) {\n        tabs = Math.floor(indent / tabWidth);\n        spaces -= tabs * tabWidth;\n      }\n      let result = \"\";\n      if (tabs > 0) {\n        result += new Array(tabs + 1).join(\"\t\");\n      }\n      if (spaces > 0) {\n        result += new Array(spaces + 1).join(\" \");\n      }\n      result += info.line.slice(info.sliceStart, info.sliceEnd);\n      parts.push(result);\n    }\n    return parts.join(lineTerminator);\n  }\n  isEmpty() {\n    return this.length < 2 && this.getLineLength(1) < 1;\n  }\n  join(elements) {\n    const separator = this;\n    const infos = [];\n    const mappings = [];\n    let prevInfo;\n    function appendLines(linesOrNull) {\n      if (linesOrNull === null) {\n        return;\n      }\n      if (prevInfo) {\n        const info = linesOrNull.infos[0];\n        const indent = new Array(info.indent + 1).join(\" \");\n        const prevLine = infos.length;\n        const prevColumn = Math.max(prevInfo.indent, 0) + prevInfo.sliceEnd - prevInfo.sliceStart;\n        prevInfo.line = prevInfo.line.slice(0, prevInfo.sliceEnd) + indent + info.line.slice(info.sliceStart, info.sliceEnd);\n        prevInfo.locked = prevInfo.locked || info.locked;\n        prevInfo.sliceEnd = prevInfo.line.length;\n        if (linesOrNull.mappings.length > 0) {\n          linesOrNull.mappings.forEach(function(mapping) {\n            mappings.push(mapping.add(prevLine, prevColumn));\n          });\n        }\n      } else if (linesOrNull.mappings.length > 0) {\n        mappings.push.apply(mappings, linesOrNull.mappings);\n      }\n      linesOrNull.infos.forEach(function(info, i) {\n        if (!prevInfo || i > 0) {\n          prevInfo = { ...info };\n          infos.push(prevInfo);\n        }\n      });\n    }\n    function appendWithSeparator(linesOrNull, i) {\n      if (i > 0)\n        appendLines(separator);\n      appendLines(linesOrNull);\n    }\n    elements.map(function(elem) {\n      const lines2 = fromString(elem);\n      if (lines2.isEmpty())\n        return null;\n      return lines2;\n    }).forEach((linesOrNull, i) => {\n      if (separator.isEmpty()) {\n        appendLines(linesOrNull);\n      } else {\n        appendWithSeparator(linesOrNull, i);\n      }\n    });\n    if (infos.length < 1)\n      return emptyLines;\n    const lines = new Lines(infos);\n    lines.mappings = mappings;\n    return lines;\n  }\n  concat(...args) {\n    const list = [this];\n    list.push.apply(list, args);\n    return emptyLines.join(list);\n  }\n}\nconst fromStringCache = {};\nconst hasOwn = fromStringCache.hasOwnProperty;\nconst maxCacheKeyLen = 10;\nfunction countSpaces(spaces, tabWidth) {\n  let count = 0;\n  const len = spaces.length;\n  for (let i = 0; i < len; ++i) {\n    switch (spaces.charCodeAt(i)) {\n      case 9: {\n        const next = Math.ceil(count / tabWidth) * tabWidth;\n        if (next === count) {\n          count += tabWidth;\n        } else {\n          count = next;\n        }\n        break;\n      }\n      case 11:\n      case 12:\n      case 13:\n      case 65279:\n        break;\n      case 32:\n      default:\n        count += 1;\n        break;\n    }\n  }\n  return count;\n}\nconst leadingSpaceExp = /^\\s*/;\nconst lineTerminatorSeqExp = /\\u000D\\u000A|\\u000D(?!\\u000A)|\\u000A|\\u2028|\\u2029/;\nfunction fromString(string, options) {\n  if (string instanceof Lines)\n    return string;\n  string += \"\";\n  const tabWidth = options && options.tabWidth;\n  const tabless = string.indexOf(\"\t\") < 0;\n  const cacheable = !options && tabless && string.length <= maxCacheKeyLen;\n  if (cacheable && hasOwn.call(fromStringCache, string))\n    return fromStringCache[string];\n  const lines = new Lines(\n    string.split(lineTerminatorSeqExp).map(function(line) {\n      const spaces = leadingSpaceExp.exec(line)[0];\n      return {\n        line,\n        indent: countSpaces(spaces, tabWidth),\n        // Boolean indicating whether this line can be reindented.\n        locked: false,\n        sliceStart: spaces.length,\n        sliceEnd: line.length\n      };\n    }),\n    normalize(options).sourceFileName\n  );\n  if (cacheable)\n    fromStringCache[string] = lines;\n  return lines;\n}\nfunction isOnlyWhitespace(string) {\n  return !/\\S/.test(string);\n}\nfunction sliceInfo(info, startCol, endCol) {\n  let sliceStart = info.sliceStart;\n  let sliceEnd = info.sliceEnd;\n  let indent = Math.max(info.indent, 0);\n  let lineLength = indent + sliceEnd - sliceStart;\n  if (typeof endCol === \"undefined\") {\n    endCol = lineLength;\n  }\n  startCol = Math.max(startCol, 0);\n  endCol = Math.min(endCol, lineLength);\n  endCol = Math.max(endCol, startCol);\n  if (endCol < indent) {\n    indent = endCol;\n    sliceEnd = sliceStart;\n  } else {\n    sliceEnd -= lineLength - endCol;\n  }\n  lineLength = endCol;\n  lineLength -= startCol;\n  if (startCol < indent) {\n    indent -= startCol;\n  } else {\n    startCol -= indent;\n    indent = 0;\n    sliceStart += startCol;\n  }\n  if (info.indent === indent && info.sliceStart === sliceStart && info.sliceEnd === sliceEnd) {\n    return info;\n  }\n  return {\n    line: info.line,\n    indent,\n    // A destructive slice always unlocks indentation.\n    locked: false,\n    sliceStart,\n    sliceEnd\n  };\n}\nfunction concat(elements) {\n  return emptyLines.join(elements);\n}\nconst emptyLines = fromString(\"\");\n\nconst n$1 = namedTypes$1;\nconst isArray$3 = builtInTypes.array;\nconst isObject$3 = builtInTypes.object;\nconst childNodesCache = /* @__PURE__ */ new WeakMap();\nfunction getSortedChildNodes(node, lines, resultArray) {\n  if (!node) {\n    return resultArray;\n  }\n  fixFaultyLocations(node, lines);\n  if (resultArray) {\n    if (n$1.Node.check(node) && n$1.SourceLocation.check(node.loc)) {\n      let i = resultArray.length - 1;\n      for (; i >= 0; --i) {\n        const child = resultArray[i];\n        if (child && child.loc && comparePos(child.loc.end, node.loc.start) <= 0) {\n          break;\n        }\n      }\n      resultArray.splice(i + 1, 0, node);\n      return resultArray;\n    }\n  } else {\n    const childNodes = childNodesCache.get(node);\n    if (childNodes) {\n      return childNodes;\n    }\n  }\n  let names;\n  if (isArray$3.check(node)) {\n    names = Object.keys(node);\n  } else if (isObject$3.check(node)) {\n    names = getFieldNames(node);\n  } else {\n    return resultArray;\n  }\n  if (!resultArray) {\n    childNodesCache.set(node, resultArray = []);\n  }\n  for (let i = 0, nameCount = names.length; i < nameCount; ++i) {\n    getSortedChildNodes(node[names[i]], lines, resultArray);\n  }\n  return resultArray;\n}\nfunction decorateComment(node, comment, lines) {\n  const childNodes = getSortedChildNodes(node, lines);\n  let left = 0;\n  let right = childNodes && childNodes.length;\n  let precedingNode;\n  let followingNode;\n  while (typeof right === \"number\" && left < right) {\n    const middle = left + right >> 1;\n    const child = childNodes[middle];\n    if (comparePos(child.loc.start, comment.loc.start) <= 0 && comparePos(comment.loc.end, child.loc.end) <= 0) {\n      decorateComment(comment.enclosingNode = child, comment, lines);\n      return;\n    }\n    if (comparePos(child.loc.end, comment.loc.start) <= 0) {\n      precedingNode = child;\n      left = middle + 1;\n      continue;\n    }\n    if (comparePos(comment.loc.end, child.loc.start) <= 0) {\n      followingNode = child;\n      right = middle;\n      continue;\n    }\n    throw new Error(\"Comment location overlaps with node location\");\n  }\n  if (precedingNode) {\n    comment.precedingNode = precedingNode;\n  }\n  if (followingNode) {\n    comment.followingNode = followingNode;\n  }\n}\nfunction attach(comments, ast, lines) {\n  if (!isArray$3.check(comments)) {\n    return;\n  }\n  const tiesToBreak = [];\n  comments.forEach(function(comment) {\n    comment.loc.lines = lines;\n    decorateComment(ast, comment, lines);\n    const pn = comment.precedingNode;\n    const en = comment.enclosingNode;\n    const fn = comment.followingNode;\n    if (pn && fn) {\n      const tieCount = tiesToBreak.length;\n      if (tieCount > 0) {\n        const lastTie = tiesToBreak[tieCount - 1];\n        if (lastTie.followingNode !== comment.followingNode) {\n          breakTies(tiesToBreak, lines);\n        }\n      }\n      tiesToBreak.push(comment);\n    } else if (pn) {\n      breakTies(tiesToBreak, lines);\n      addTrailingComment(pn, comment);\n    } else if (fn) {\n      breakTies(tiesToBreak, lines);\n      addLeadingComment(fn, comment);\n    } else if (en) {\n      breakTies(tiesToBreak, lines);\n      addDanglingComment(en, comment);\n    } else {\n      throw new Error(\"AST contains no nodes at all?\");\n    }\n  });\n  breakTies(tiesToBreak, lines);\n  comments.forEach(function(comment) {\n    delete comment.precedingNode;\n    delete comment.enclosingNode;\n    delete comment.followingNode;\n  });\n}\nfunction breakTies(tiesToBreak, lines) {\n  const tieCount = tiesToBreak.length;\n  if (tieCount === 0) {\n    return;\n  }\n  const pn = tiesToBreak[0].precedingNode;\n  const fn = tiesToBreak[0].followingNode;\n  let gapEndPos = fn.loc.start;\n  let indexOfFirstLeadingComment = tieCount;\n  let comment;\n  for (; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {\n    comment = tiesToBreak[indexOfFirstLeadingComment - 1];\n    const gap = lines.sliceString(comment.loc.end, gapEndPos);\n    if (/\\S/.test(gap)) {\n      break;\n    }\n    gapEndPos = comment.loc.start;\n  }\n  while (indexOfFirstLeadingComment <= tieCount && (comment = tiesToBreak[indexOfFirstLeadingComment]) && // If the comment is a //-style comment and indented more\n  // deeply than the node itself, reconsider it as trailing.\n  (comment.type === \"Line\" || comment.type === \"CommentLine\") && comment.loc.start.column > fn.loc.start.column) {\n    ++indexOfFirstLeadingComment;\n  }\n  if (indexOfFirstLeadingComment) {\n    const { enclosingNode } = tiesToBreak[indexOfFirstLeadingComment - 1];\n    if (enclosingNode?.type === \"CallExpression\") {\n      --indexOfFirstLeadingComment;\n    }\n  }\n  tiesToBreak.forEach(function(comment2, i) {\n    if (i < indexOfFirstLeadingComment) {\n      addTrailingComment(pn, comment2);\n    } else {\n      addLeadingComment(fn, comment2);\n    }\n  });\n  tiesToBreak.length = 0;\n}\nfunction addCommentHelper(node, comment) {\n  const comments = node.comments || (node.comments = []);\n  comments.push(comment);\n}\nfunction addLeadingComment(node, comment) {\n  comment.leading = true;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\nfunction addDanglingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = false;\n  addCommentHelper(node, comment);\n}\nfunction addTrailingComment(node, comment) {\n  comment.leading = false;\n  comment.trailing = true;\n  addCommentHelper(node, comment);\n}\nfunction printLeadingComment(commentPath, print) {\n  const comment = commentPath.getValue();\n  n$1.Comment.assert(comment);\n  const loc = comment.loc;\n  const lines = loc && loc.lines;\n  const parts = [print(commentPath)];\n  if (comment.trailing) {\n    parts.push(\"\\n\");\n  } else if (lines instanceof Lines) {\n    const trailingSpace = lines.slice(\n      loc.end,\n      lines.skipSpaces(loc.end) || lines.lastPos()\n    );\n    if (trailingSpace.length === 1) {\n      parts.push(trailingSpace);\n    } else {\n      parts.push(new Array(trailingSpace.length).join(\"\\n\"));\n    }\n  } else {\n    parts.push(\"\\n\");\n  }\n  return concat(parts);\n}\nfunction printTrailingComment(commentPath, print) {\n  const comment = commentPath.getValue(commentPath);\n  n$1.Comment.assert(comment);\n  const loc = comment.loc;\n  const lines = loc && loc.lines;\n  const parts = [];\n  if (lines instanceof Lines) {\n    const fromPos = lines.skipSpaces(loc.start, true) || lines.firstPos();\n    const leadingSpace = lines.slice(fromPos, loc.start);\n    if (leadingSpace.length === 1) {\n      parts.push(leadingSpace);\n    } else {\n      parts.push(new Array(leadingSpace.length).join(\"\\n\"));\n    }\n  }\n  parts.push(print(commentPath));\n  return concat(parts);\n}\nfunction printComments(path, print) {\n  const value = path.getValue();\n  const innerLines = print(path);\n  const comments = n$1.Node.check(value) && getFieldValue(value, \"comments\");\n  if (!comments || comments.length === 0) {\n    return innerLines;\n  }\n  const leadingParts = [];\n  const trailingParts = [innerLines];\n  path.each(function(commentPath) {\n    const comment = commentPath.getValue();\n    const leading = getFieldValue(comment, \"leading\");\n    const trailing = getFieldValue(comment, \"trailing\");\n    if (leading || trailing && !(n$1.Statement.check(value) || comment.type === \"Block\" || comment.type === \"CommentBlock\")) {\n      leadingParts.push(printLeadingComment(commentPath, print));\n    } else if (trailing) {\n      trailingParts.push(printTrailingComment(commentPath, print));\n    }\n  }, \"comments\");\n  leadingParts.push.apply(leadingParts, trailingParts);\n  return concat(leadingParts);\n}\n\nconst b$5 = builders$1;\nconst isObject$2 = builtInTypes.object;\nconst isArray$2 = builtInTypes.array;\nfunction parse(source, options) {\n  options = normalize(options);\n  const lines = fromString(source, options);\n  const sourceWithoutTabs = lines.toString({\n    tabWidth: options.tabWidth,\n    reuseWhitespace: false,\n    useTabs: false\n  });\n  let comments = [];\n  const ast = options.parser.parse(sourceWithoutTabs, {\n    jsx: true,\n    loc: true,\n    locations: true,\n    range: options.range,\n    comment: true,\n    onComment: comments,\n    tolerant: getOption(options, \"tolerant\", true),\n    ecmaVersion: 6,\n    sourceType: getOption(options, \"sourceType\", \"module\")\n  });\n  const tokens = Array.isArray(ast.tokens) ? ast.tokens : false;\n  delete ast.tokens;\n  tokens.forEach(function(token) {\n    if (typeof token.value !== \"string\") {\n      token.value = lines.sliceString(token.loc.start, token.loc.end);\n    }\n  });\n  if (Array.isArray(ast.comments)) {\n    comments = ast.comments;\n    delete ast.comments;\n  }\n  if (ast.loc) {\n    fixFaultyLocations(ast, lines);\n  } else {\n    ast.loc = {\n      start: lines.firstPos(),\n      end: lines.lastPos()\n    };\n  }\n  ast.loc.lines = lines;\n  ast.loc.indent = 0;\n  let file;\n  let program;\n  if (ast.type === \"Program\") {\n    program = ast;\n    file = b$5.file(ast, options.sourceFileName || null);\n    file.loc = {\n      start: lines.firstPos(),\n      end: lines.lastPos(),\n      lines,\n      indent: 0\n    };\n  } else if (ast.type === \"File\") {\n    file = ast;\n    program = file.program;\n  }\n  if (options.tokens) {\n    file.tokens = tokens;\n  }\n  const trueProgramLoc = getTrueLoc(\n    {\n      type: program.type,\n      loc: program.loc,\n      body: [],\n      comments\n    },\n    lines\n  );\n  program.loc.start = trueProgramLoc.start;\n  program.loc.end = trueProgramLoc.end;\n  attach(comments, program.body.length ? file.program : file, lines);\n  return new TreeCopier(lines, tokens).copy(file);\n}\nconst TreeCopier = function TreeCopier2(lines, tokens) {\n  this.lines = lines;\n  this.tokens = tokens;\n  this.startTokenIndex = 0;\n  this.endTokenIndex = tokens.length;\n  this.indent = 0;\n  this.seen = /* @__PURE__ */ new Map();\n};\nconst TCp = TreeCopier.prototype;\nTCp.copy = function(node) {\n  if (this.seen.has(node)) {\n    return this.seen.get(node);\n  }\n  if (isArray$2.check(node)) {\n    const copy2 = new Array(node.length);\n    this.seen.set(node, copy2);\n    node.forEach(function(item, i) {\n      copy2[i] = this.copy(item);\n    }, this);\n    return copy2;\n  }\n  if (!isObject$2.check(node)) {\n    return node;\n  }\n  fixFaultyLocations(node, this.lines);\n  const copy = Object.create(Object.getPrototypeOf(node), {\n    original: {\n      // Provide a link from the copy to the original.\n      value: node,\n      configurable: false,\n      enumerable: false,\n      writable: true\n    }\n  });\n  this.seen.set(node, copy);\n  const loc = node.loc;\n  const oldIndent = this.indent;\n  let newIndent = oldIndent;\n  const oldStartTokenIndex = this.startTokenIndex;\n  const oldEndTokenIndex = this.endTokenIndex;\n  if (loc) {\n    if (node.type === \"Block\" || node.type === \"Line\" || node.type === \"CommentBlock\" || node.type === \"CommentLine\" || this.lines.isPrecededOnlyByWhitespace(loc.start)) {\n      newIndent = this.indent = loc.start.column;\n    }\n    loc.lines = this.lines;\n    loc.tokens = this.tokens;\n    loc.indent = newIndent;\n    this.findTokenRange(loc);\n  }\n  const keys = Object.keys(node);\n  const keyCount = keys.length;\n  for (let i = 0; i < keyCount; ++i) {\n    const key = keys[i];\n    if (key === \"loc\") {\n      copy[key] = node[key];\n    } else if (key === \"tokens\" && node.type === \"File\") {\n      copy[key] = node[key];\n    } else {\n      copy[key] = this.copy(node[key]);\n    }\n  }\n  this.indent = oldIndent;\n  this.startTokenIndex = oldStartTokenIndex;\n  this.endTokenIndex = oldEndTokenIndex;\n  return copy;\n};\nTCp.findTokenRange = function(loc) {\n  while (this.startTokenIndex > 0) {\n    const token = loc.tokens[this.startTokenIndex];\n    if (comparePos(loc.start, token.loc.start) < 0) {\n      --this.startTokenIndex;\n    } else\n      break;\n  }\n  while (this.endTokenIndex < loc.tokens.length) {\n    const token = loc.tokens[this.endTokenIndex];\n    if (comparePos(token.loc.end, loc.end) < 0) {\n      ++this.endTokenIndex;\n    } else\n      break;\n  }\n  while (this.startTokenIndex < this.endTokenIndex) {\n    const token = loc.tokens[this.startTokenIndex];\n    if (comparePos(token.loc.start, loc.start) < 0) {\n      ++this.startTokenIndex;\n    } else\n      break;\n  }\n  loc.start.token = this.startTokenIndex;\n  while (this.endTokenIndex > this.startTokenIndex) {\n    const token = loc.tokens[this.endTokenIndex - 1];\n    if (comparePos(loc.end, token.loc.end) < 0) {\n      --this.endTokenIndex;\n    } else\n      break;\n  }\n  loc.end.token = this.endTokenIndex;\n};\n\nconst n = namedTypes$1;\nconst isArray$1 = builtInTypes.array;\nconst isNumber = builtInTypes.number;\nconst PRECEDENCE = {};\n[\n  [\"??\"],\n  [\"||\"],\n  [\"&&\"],\n  [\"|\"],\n  [\"^\"],\n  [\"&\"],\n  [\"==\", \"===\", \"!=\", \"!==\"],\n  [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n  [\">>\", \"<<\", \">>>\"],\n  [\"+\", \"-\"],\n  [\"*\", \"/\", \"%\"],\n  [\"**\"]\n].forEach(function(tier, i) {\n  tier.forEach(function(op) {\n    PRECEDENCE[op] = i;\n  });\n});\nconst FastPath = function FastPath2(value) {\n  this.stack = [value];\n};\nconst FPp = FastPath.prototype;\nFastPath.from = function(obj) {\n  if (obj instanceof FastPath) {\n    return obj.copy();\n  }\n  if (obj instanceof NodePath) {\n    const copy2 = Object.create(FastPath.prototype);\n    const stack = [obj.value];\n    for (let pp; pp = obj.parentPath; obj = pp)\n      stack.push(obj.name, pp.value);\n    copy2.stack = stack.reverse();\n    return copy2;\n  }\n  return new FastPath(obj);\n};\nFPp.copy = function copy() {\n  const copy2 = Object.create(FastPath.prototype);\n  copy2.stack = this.stack.slice(0);\n  return copy2;\n};\nFPp.getName = function getName() {\n  const s = this.stack;\n  const len = s.length;\n  if (len > 1) {\n    return s[len - 2];\n  }\n  return null;\n};\nFPp.getValue = function getValue() {\n  const s = this.stack;\n  return s[s.length - 1];\n};\nFPp.valueIsDuplicate = function() {\n  const s = this.stack;\n  const valueIndex = s.length - 1;\n  return s.lastIndexOf(s[valueIndex], valueIndex - 1) >= 0;\n};\nfunction getNodeHelper(path, count) {\n  const s = path.stack;\n  for (let i = s.length - 1; i >= 0; i -= 2) {\n    const value = s[i];\n    if (n.Node.check(value) && --count < 0) {\n      return value;\n    }\n  }\n  return null;\n}\nFPp.getNode = function getNode(count = 0) {\n  return getNodeHelper(this, ~~count);\n};\nFPp.getParentNode = function getParentNode(count = 0) {\n  return getNodeHelper(this, ~~count + 1);\n};\nFPp.getRootValue = function getRootValue() {\n  const s = this.stack;\n  if (s.length % 2 === 0) {\n    return s[1];\n  }\n  return s[0];\n};\nFPp.call = function call(callback) {\n  const s = this.stack;\n  const origLen = s.length;\n  let value = s[origLen - 1];\n  const argc = arguments.length;\n  for (let i = 1; i < argc; ++i) {\n    const name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n  const result = callback(this);\n  s.length = origLen;\n  return result;\n};\nFPp.each = function each(callback) {\n  const s = this.stack;\n  const origLen = s.length;\n  let value = s[origLen - 1];\n  const argc = arguments.length;\n  for (let i = 1; i < argc; ++i) {\n    const name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n  for (let i = 0; i < value.length; ++i) {\n    if (i in value) {\n      s.push(i, value[i]);\n      callback(this);\n      s.length -= 2;\n    }\n  }\n  s.length = origLen;\n};\nFPp.map = function map(callback) {\n  const s = this.stack;\n  const origLen = s.length;\n  let value = s[origLen - 1];\n  const argc = arguments.length;\n  for (let i = 1; i < argc; ++i) {\n    const name = arguments[i];\n    value = value[name];\n    s.push(name, value);\n  }\n  const result = new Array(value.length);\n  for (let i = 0; i < value.length; ++i) {\n    if (i in value) {\n      s.push(i, value[i]);\n      result[i] = callback(this, i);\n      s.length -= 2;\n    }\n  }\n  s.length = origLen;\n  return result;\n};\nFPp.hasParens = function() {\n  const node = this.getNode();\n  const prevToken = this.getPrevToken(node);\n  if (!prevToken) {\n    return false;\n  }\n  const nextToken = this.getNextToken(node);\n  if (!nextToken) {\n    return false;\n  }\n  if (prevToken.value === \"(\") {\n    if (nextToken.value === \")\") {\n      return true;\n    }\n    const justNeedsOpeningParen = !this.canBeFirstInStatement() && this.firstInStatement() && !this.needsParens(true);\n    if (justNeedsOpeningParen) {\n      return true;\n    }\n  }\n  return false;\n};\nFPp.getPrevToken = function(node) {\n  node = node || this.getNode();\n  const loc = node && node.loc;\n  const tokens = loc && loc.tokens;\n  if (tokens && loc.start.token > 0) {\n    const token = tokens[loc.start.token - 1];\n    if (token) {\n      const rootLoc = this.getRootValue().loc;\n      if (comparePos(rootLoc.start, token.loc.start) <= 0) {\n        return token;\n      }\n    }\n  }\n  return null;\n};\nFPp.getNextToken = function(node) {\n  node = node || this.getNode();\n  const loc = node && node.loc;\n  const tokens = loc && loc.tokens;\n  if (tokens && loc.end.token < tokens.length) {\n    const token = tokens[loc.end.token];\n    if (token) {\n      const rootLoc = this.getRootValue().loc;\n      if (comparePos(token.loc.end, rootLoc.end) <= 0) {\n        return token;\n      }\n    }\n  }\n  return null;\n};\nFPp.needsParens = function(assumeExpressionContext) {\n  const node = this.getNode();\n  if (node.type === \"AssignmentExpression\" && node.left.type === \"ObjectPattern\") {\n    return true;\n  }\n  const parent = this.getParentNode();\n  const name = this.getName();\n  if (this.getValue() !== node) {\n    return false;\n  }\n  if (n.Statement.check(node)) {\n    return false;\n  }\n  if (node.type === \"Identifier\") {\n    return false;\n  }\n  if (parent && parent.type === \"ParenthesizedExpression\") {\n    return false;\n  }\n  if (node.extra && node.extra.parenthesized) {\n    return true;\n  }\n  if (!parent)\n    return false;\n  if (node.type === \"UnaryExpression\" && parent.type === \"BinaryExpression\" && name === \"left\" && parent.left === node && parent.operator === \"**\") {\n    return true;\n  }\n  switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n    case \"SpreadProperty\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      switch (parent.type) {\n        case \"CallExpression\":\n          return name === \"callee\" && parent.callee === node;\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n          return true;\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n        case \"BinaryExpression\":\n        case \"LogicalExpression\": {\n          const po = parent.operator;\n          const pp = PRECEDENCE[po];\n          const no = node.operator;\n          const np = PRECEDENCE[no];\n          if (pp > np) {\n            return true;\n          }\n          if (pp === np && name === \"right\") {\n            return true;\n          }\n          break;\n        }\n        default:\n          return false;\n      }\n      break;\n    case \"SequenceExpression\":\n      switch (parent.type) {\n        case \"ReturnStatement\":\n          return false;\n        case \"ForStatement\":\n          return false;\n        case \"ExpressionStatement\":\n          return name !== \"expression\";\n        default:\n          return true;\n      }\n    case \"OptionalIndexedAccessType\":\n      return node.optional && parent.type === \"IndexedAccessType\";\n    case \"IntersectionTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n      return parent.type === \"NullableTypeAnnotation\";\n    case \"Literal\":\n      return parent.type === \"MemberExpression\" && isNumber.check(node.value) && name === \"object\" && parent.object === node;\n    case \"NumericLiteral\":\n      return parent.type === \"MemberExpression\" && name === \"object\" && parent.object === node;\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"AssignmentExpression\":\n    case \"ConditionalExpression\":\n      switch (parent.type) {\n        case \"UnaryExpression\":\n        case \"SpreadElement\":\n        case \"SpreadProperty\":\n        case \"BinaryExpression\":\n        case \"LogicalExpression\":\n          return true;\n        case \"CallExpression\":\n        case \"NewExpression\":\n          return name === \"callee\" && parent.callee === node;\n        case \"ConditionalExpression\":\n          return name === \"test\" && parent.test === node;\n        case \"MemberExpression\":\n          return name === \"object\" && parent.object === node;\n        default:\n          return false;\n      }\n    case \"ArrowFunctionExpression\":\n      if (n.CallExpression.check(parent) && name === \"callee\" && parent.callee === node) {\n        return true;\n      }\n      if (n.MemberExpression.check(parent) && name === \"object\" && parent.object === node) {\n        return true;\n      }\n      if (n.TSAsExpression && n.TSAsExpression.check(parent) && name === \"expression\" && parent.expression === node) {\n        return true;\n      }\n      return isBinary(parent);\n    case \"ObjectExpression\":\n      if (parent.type === \"ArrowFunctionExpression\" && name === \"body\" && parent.body === node) {\n        return true;\n      }\n      break;\n    case \"TSAsExpression\":\n      if (parent.type === \"ArrowFunctionExpression\" && name === \"body\" && parent.body === node && node.expression.type === \"ObjectExpression\") {\n        return true;\n      }\n      break;\n    case \"CallExpression\":\n      if (name === \"declaration\" && n.ExportDefaultDeclaration.check(parent) && n.FunctionExpression.check(node.callee)) {\n        return true;\n      }\n  }\n  if (parent.type === \"NewExpression\" && name === \"callee\" && parent.callee === node) {\n    return containsCallExpression(node);\n  }\n  if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) {\n    return true;\n  }\n  return false;\n};\nfunction isBinary(node) {\n  return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n}\nfunction containsCallExpression(node) {\n  if (n.CallExpression.check(node)) {\n    return true;\n  }\n  if (isArray$1.check(node)) {\n    return node.some(containsCallExpression);\n  }\n  if (n.Node.check(node)) {\n    return someField(\n      node,\n      (_name, child) => containsCallExpression(child)\n    );\n  }\n  return false;\n}\nFPp.canBeFirstInStatement = function() {\n  const node = this.getNode();\n  if (n.FunctionExpression.check(node)) {\n    return false;\n  }\n  if (n.ObjectExpression.check(node)) {\n    return false;\n  }\n  if (n.ClassExpression.check(node)) {\n    return false;\n  }\n  return true;\n};\nFPp.firstInStatement = function() {\n  const s = this.stack;\n  let parentName, parent;\n  let childName, child;\n  for (let i = s.length - 1; i >= 0; i -= 2) {\n    if (n.Node.check(s[i])) {\n      childName = parentName;\n      child = parent;\n      parentName = s[i - 1];\n      parent = s[i];\n    }\n    if (!parent || !child) {\n      continue;\n    }\n    if (n.BlockStatement.check(parent) && parentName === \"body\" && childName === 0) {\n      return true;\n    }\n    if (n.ExpressionStatement.check(parent) && childName === \"expression\") {\n      return true;\n    }\n    if (n.AssignmentExpression.check(parent) && childName === \"left\") {\n      return true;\n    }\n    if (n.ArrowFunctionExpression.check(parent) && childName === \"body\") {\n      return true;\n    }\n    if (n.SequenceExpression.check(parent) && s[i + 1] === \"expressions\" && childName === 0) {\n      continue;\n    }\n    if (n.CallExpression.check(parent) && childName === \"callee\") {\n      continue;\n    }\n    if (n.MemberExpression.check(parent) && childName === \"object\") {\n      continue;\n    }\n    if (n.ConditionalExpression.check(parent) && childName === \"test\") {\n      continue;\n    }\n    if (isBinary(parent) && childName === \"left\") {\n      continue;\n    }\n    if (n.UnaryExpression.check(parent) && !parent.prefix && childName === \"argument\") {\n      continue;\n    }\n    return false;\n  }\n  return true;\n};\n\nconst Printable = namedTypes$1.Printable;\nconst Expression = namedTypes$1.Expression;\nconst ReturnStatement = namedTypes$1.ReturnStatement;\nconst SourceLocation = namedTypes$1.SourceLocation;\nconst isObject$1 = builtInTypes.object;\nconst isArray = builtInTypes.array;\nconst isString$1 = builtInTypes.string;\nconst riskyAdjoiningCharExp = /[0-9a-z_$]/i;\nconst Patcher = function Patcher2(lines) {\n  const self = this, replacements = [];\n  self.replace = function(loc, lines2) {\n    if (isString$1.check(lines2))\n      lines2 = fromString(lines2);\n    replacements.push({\n      lines: lines2,\n      start: loc.start,\n      end: loc.end\n    });\n  };\n  self.get = function(loc) {\n    loc = loc || {\n      start: { line: 1, column: 0 },\n      end: { line: lines.length, column: lines.getLineLength(lines.length) }\n    };\n    let sliceFrom = loc.start, toConcat = [];\n    function pushSlice(from, to) {\n      toConcat.push(lines.slice(from, to));\n    }\n    replacements.sort((a, b) => comparePos(a.start, b.start)).forEach(function(rep) {\n      if (comparePos(sliceFrom, rep.start) > 0) ; else {\n        pushSlice(sliceFrom, rep.start);\n        toConcat.push(rep.lines);\n        sliceFrom = rep.end;\n      }\n    });\n    pushSlice(sliceFrom, loc.end);\n    return concat(toConcat);\n  };\n};\nconst Pp = Patcher.prototype;\nPp.tryToReprintComments = function(newNode, oldNode, print) {\n  const patcher = this;\n  if (!newNode.comments && !oldNode.comments) {\n    return true;\n  }\n  const newPath = FastPath.from(newNode);\n  const oldPath = FastPath.from(oldNode);\n  newPath.stack.push(\"comments\", getSurroundingComments(newNode));\n  oldPath.stack.push(\"comments\", getSurroundingComments(oldNode));\n  const reprints = [];\n  const ableToReprintComments = findArrayReprints(newPath, oldPath, reprints);\n  if (ableToReprintComments && reprints.length > 0) {\n    reprints.forEach(function(reprint) {\n      const oldComment = reprint.oldPath.getValue();\n      patcher.replace(\n        oldComment.loc,\n        // Comments can't have .comments, so it doesn't matter whether we\n        // print with comments or without.\n        print(reprint.newPath).indentTail(oldComment.loc.indent)\n      );\n    });\n  }\n  return ableToReprintComments;\n};\nfunction getSurroundingComments(node) {\n  const result = [];\n  if (node.comments && node.comments.length > 0) {\n    node.comments.forEach(function(comment) {\n      if (comment.leading || comment.trailing) {\n        result.push(comment);\n      }\n    });\n  }\n  return result;\n}\nPp.deleteComments = function(node) {\n  if (!node.comments) {\n    return;\n  }\n  const patcher = this;\n  node.comments.forEach(function(comment) {\n    if (comment.leading) {\n      patcher.replace(\n        {\n          start: comment.loc.start,\n          end: node.loc.lines.skipSpaces(comment.loc.end, false, false)\n        },\n        \"\"\n      );\n    } else if (comment.trailing) {\n      patcher.replace(\n        {\n          start: node.loc.lines.skipSpaces(comment.loc.start, true, false),\n          end: comment.loc.end\n        },\n        \"\"\n      );\n    }\n  });\n};\nfunction getReprinter(path) {\n  const node = path.getValue();\n  if (!Printable.check(node))\n    return;\n  const orig = node.original;\n  const origLoc = orig && orig.loc;\n  const lines = origLoc && origLoc.lines;\n  const reprints = [];\n  if (!lines || !findReprints(path, reprints))\n    return;\n  return function(print) {\n    const patcher = new Patcher(lines);\n    reprints.forEach(function(reprint) {\n      const newNode = reprint.newPath.getValue();\n      const oldNode = reprint.oldPath.getValue();\n      SourceLocation.assert(oldNode.loc, true);\n      const needToPrintNewPathWithComments = !patcher.tryToReprintComments(\n        newNode,\n        oldNode,\n        print\n      );\n      if (needToPrintNewPathWithComments) {\n        patcher.deleteComments(oldNode);\n      }\n      let newLines = print(reprint.newPath, {\n        includeComments: needToPrintNewPathWithComments,\n        // If the oldNode we're replacing already had parentheses, we may\n        // not need to print the new node with any extra parentheses,\n        // because the existing parentheses will suffice. However, if the\n        // newNode has a different type than the oldNode, let the printer\n        // decide if reprint.newPath needs parentheses, as usual.\n        avoidRootParens: oldNode.type === newNode.type && reprint.oldPath.hasParens()\n      }).indentTail(oldNode.loc.indent);\n      const nls = needsLeadingSpace(lines, oldNode.loc, newLines);\n      const nts = needsTrailingSpace(lines, oldNode.loc, newLines);\n      if (nls || nts) {\n        const newParts = [];\n        nls && newParts.push(\" \");\n        newParts.push(newLines);\n        nts && newParts.push(\" \");\n        newLines = concat(newParts);\n      }\n      patcher.replace(oldNode.loc, newLines);\n    });\n    const patchedLines = patcher.get(origLoc).indentTail(-orig.loc.indent);\n    if (path.needsParens()) {\n      return concat([\"(\", patchedLines, \")\"]);\n    }\n    return patchedLines;\n  };\n}\nfunction needsLeadingSpace(oldLines, oldLoc, newLines) {\n  const posBeforeOldLoc = copyPos(oldLoc.start);\n  const charBeforeOldLoc = oldLines.prevPos(posBeforeOldLoc) && oldLines.charAt(posBeforeOldLoc);\n  const newFirstChar = newLines.charAt(newLines.firstPos());\n  return charBeforeOldLoc && riskyAdjoiningCharExp.test(charBeforeOldLoc) && newFirstChar && riskyAdjoiningCharExp.test(newFirstChar);\n}\nfunction needsTrailingSpace(oldLines, oldLoc, newLines) {\n  const charAfterOldLoc = oldLines.charAt(oldLoc.end);\n  const newLastPos = newLines.lastPos();\n  const newLastChar = newLines.prevPos(newLastPos) && newLines.charAt(newLastPos);\n  return newLastChar && riskyAdjoiningCharExp.test(newLastChar) && charAfterOldLoc && riskyAdjoiningCharExp.test(charAfterOldLoc);\n}\nfunction findReprints(newPath, reprints) {\n  const newNode = newPath.getValue();\n  Printable.assert(newNode);\n  const oldNode = newNode.original;\n  Printable.assert(oldNode);\n  if (newNode.type !== oldNode.type) {\n    return false;\n  }\n  const oldPath = new FastPath(oldNode);\n  const canReprint = findChildReprints(newPath, oldPath, reprints);\n  if (!canReprint) {\n    reprints.length = 0;\n  }\n  return canReprint;\n}\nfunction findAnyReprints(newPath, oldPath, reprints) {\n  const newNode = newPath.getValue();\n  const oldNode = oldPath.getValue();\n  if (newNode === oldNode)\n    return true;\n  if (isArray.check(newNode))\n    return findArrayReprints(newPath, oldPath, reprints);\n  if (isObject$1.check(newNode))\n    return findObjectReprints(newPath, oldPath, reprints);\n  return false;\n}\nfunction findArrayReprints(newPath, oldPath, reprints) {\n  const newNode = newPath.getValue();\n  const oldNode = oldPath.getValue();\n  if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {\n    return true;\n  }\n  isArray.assert(newNode);\n  const len = newNode.length;\n  if (!(isArray.check(oldNode) && oldNode.length === len))\n    return false;\n  for (let i = 0; i < len; ++i) {\n    newPath.stack.push(i, newNode[i]);\n    oldPath.stack.push(i, oldNode[i]);\n    const canReprint = findAnyReprints(newPath, oldPath, reprints);\n    newPath.stack.length -= 2;\n    oldPath.stack.length -= 2;\n    if (!canReprint) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction findObjectReprints(newPath, oldPath, reprints) {\n  const newNode = newPath.getValue();\n  isObject$1.assert(newNode);\n  if (newNode.original === null) {\n    return false;\n  }\n  const oldNode = oldPath.getValue();\n  if (!isObject$1.check(oldNode))\n    return false;\n  if (newNode === oldNode || newPath.valueIsDuplicate() || oldPath.valueIsDuplicate()) {\n    return true;\n  }\n  if (Printable.check(newNode)) {\n    if (!Printable.check(oldNode)) {\n      return false;\n    }\n    const newParentNode = newPath.getParentNode();\n    const oldParentNode = oldPath.getParentNode();\n    if (oldParentNode !== null && oldParentNode.type === \"FunctionTypeAnnotation\" && newParentNode !== null && newParentNode.type === \"FunctionTypeAnnotation\") {\n      const oldNeedsParens = oldParentNode.params.length !== 1 || !!oldParentNode.params[0].name;\n      const newNeedParens = newParentNode.params.length !== 1 || !!newParentNode.params[0].name;\n      if (!oldNeedsParens && newNeedParens) {\n        return false;\n      }\n    }\n    if (newNode.type === oldNode.type) {\n      const childReprints = [];\n      if (findChildReprints(newPath, oldPath, childReprints)) {\n        reprints.push.apply(reprints, childReprints);\n      } else if (oldNode.loc) {\n        reprints.push({\n          oldPath: oldPath.copy(),\n          newPath: newPath.copy()\n        });\n      } else {\n        return false;\n      }\n      return true;\n    }\n    if (Expression.check(newNode) && Expression.check(oldNode) && // If we have no .loc information for oldNode, then we won't be\n    // able to reprint it.\n    oldNode.loc) {\n      reprints.push({\n        oldPath: oldPath.copy(),\n        newPath: newPath.copy()\n      });\n      return true;\n    }\n    return false;\n  }\n  return findChildReprints(newPath, oldPath, reprints);\n}\nfunction findChildReprints(newPath, oldPath, reprints) {\n  const newNode = newPath.getValue();\n  const oldNode = oldPath.getValue();\n  isObject$1.assert(newNode);\n  isObject$1.assert(oldNode);\n  if (newNode.original === null) {\n    return false;\n  }\n  if (newPath.needsParens() && !oldPath.hasParens()) {\n    return false;\n  }\n  const keys = getUnionOfKeys(oldNode, newNode);\n  if (oldNode.type === \"File\" || newNode.type === \"File\") {\n    delete keys.tokens;\n  }\n  delete keys.loc;\n  const originalReprintCount = reprints.length;\n  for (let k in keys) {\n    if (k.charAt(0) === \"_\") {\n      continue;\n    }\n    newPath.stack.push(k, getFieldValue(newNode, k));\n    oldPath.stack.push(k, getFieldValue(oldNode, k));\n    const canReprint = findAnyReprints(newPath, oldPath, reprints);\n    newPath.stack.length -= 2;\n    oldPath.stack.length -= 2;\n    if (!canReprint) {\n      return false;\n    }\n  }\n  if (ReturnStatement.check(newPath.getNode()) && reprints.length > originalReprintCount) {\n    return false;\n  }\n  return true;\n}\n\nconst namedTypes = namedTypes$1;\nconst isString = builtInTypes.string;\nconst isObject = builtInTypes.object;\nconst PrintResult = function PrintResult2(code, sourceMap) {\n  isString.assert(code);\n  this.code = code;\n  if (sourceMap) {\n    isObject.assert(sourceMap);\n    this.map = sourceMap;\n  }\n};\nconst PRp = PrintResult.prototype;\nlet warnedAboutToString = false;\nPRp.toString = function() {\n  if (!warnedAboutToString) {\n    console.warn(\n      \"Deprecation warning: recast.print now returns an object with a .code property. You appear to be treating the object as a string, which might still work but is strongly discouraged.\"\n    );\n    warnedAboutToString = true;\n  }\n  return this.code;\n};\nconst emptyPrintResult = new PrintResult(\"\");\nconst Printer = function Printer2(config) {\n  const explicitTabWidth = config && config.tabWidth;\n  config = normalize(config);\n  config.sourceFileName = null;\n  function makePrintFunctionWith(options, overrides) {\n    options = Object.assign({}, options, overrides);\n    return (path) => print(path, options);\n  }\n  function print(path, options) {\n    options = options || {};\n    if (options.includeComments) {\n      return printComments(\n        path,\n        makePrintFunctionWith(options, {\n          includeComments: false\n        })\n      );\n    }\n    const oldTabWidth = config.tabWidth;\n    if (!explicitTabWidth) {\n      const loc = path.getNode().loc;\n      if (loc && loc.lines && loc.lines.guessTabWidth) {\n        config.tabWidth = loc.lines.guessTabWidth();\n      }\n    }\n    const reprinter = getReprinter(path);\n    const lines = reprinter ? (\n      // Since the print function that we pass to the reprinter will\n      // be used to print \"new\" nodes, it's tempting to think we\n      // should pass printRootGenerically instead of print, to avoid\n      // calling maybeReprint again, but that would be a mistake\n      // because the new nodes might not be entirely new, but merely\n      // moved from elsewhere in the AST. The print function is the\n      // right choice because it gives us the opportunity to reprint\n      // such nodes using their original source.\n      reprinter(print)\n    ) : genericPrint(\n      path,\n      config,\n      options,\n      makePrintFunctionWith(options, {\n        includeComments: true,\n        avoidRootParens: false\n      })\n    );\n    config.tabWidth = oldTabWidth;\n    return lines;\n  }\n  this.print = function(ast) {\n    if (!ast) {\n      return emptyPrintResult;\n    }\n    const lines = print(FastPath.from(ast), {\n      includeComments: true,\n      avoidRootParens: false\n    });\n    return new PrintResult(\n      lines.toString(config),\n      composeSourceMaps(\n        config.inputSourceMap,\n        lines.getSourceMap(config.sourceMapName, config.sourceRoot)\n      )\n    );\n  };\n  this.printGenerically = function(ast) {\n    if (!ast) {\n      return emptyPrintResult;\n    }\n    function printGenerically(path2) {\n      return printComments(\n        path2,\n        (path3) => genericPrint(\n          path3,\n          config,\n          {\n            includeComments: true,\n            avoidRootParens: false\n          },\n          printGenerically\n        )\n      );\n    }\n    const path = FastPath.from(ast);\n    const oldReuseWhitespace = config.reuseWhitespace;\n    config.reuseWhitespace = false;\n    const pr = new PrintResult(printGenerically(path).toString(config));\n    config.reuseWhitespace = oldReuseWhitespace;\n    return pr;\n  };\n};\nfunction genericPrint(path, config, options, printPath) {\n  const node = path.getValue();\n  const parts = [];\n  const linesWithoutParens = genericPrintNoParens(path, config, printPath);\n  if (!node || linesWithoutParens.isEmpty()) {\n    return linesWithoutParens;\n  }\n  let shouldAddParens = false;\n  const decoratorsLines = printDecorators(path, printPath);\n  if (decoratorsLines.isEmpty()) {\n    if (!options.avoidRootParens) {\n      shouldAddParens = path.needsParens();\n    }\n  } else {\n    parts.push(decoratorsLines);\n  }\n  if (shouldAddParens) {\n    parts.unshift(\"(\");\n  }\n  parts.push(linesWithoutParens);\n  if (shouldAddParens) {\n    parts.push(\")\");\n  }\n  return concat(parts);\n}\nfunction genericPrintNoParens(path, options, print) {\n  const n = path.getValue();\n  if (!n) {\n    return fromString(\"\");\n  }\n  if (typeof n === \"string\") {\n    return fromString(n, options);\n  }\n  namedTypes.Printable.assert(n);\n  const parts = [];\n  switch (n.type) {\n    case \"File\":\n      return path.call(print, \"program\");\n    case \"Program\":\n      if (n.directives) {\n        path.each(function(childPath) {\n          parts.push(print(childPath), \";\\n\");\n        }, \"directives\");\n      }\n      if (n.interpreter) {\n        parts.push(path.call(print, \"interpreter\"));\n      }\n      parts.push(\n        path.call(\n          (bodyPath) => printStatementSequence(bodyPath, options, print),\n          \"body\"\n        )\n      );\n      return concat(parts);\n    case \"Noop\":\n    case \"EmptyStatement\":\n      return fromString(\"\");\n    case \"ExpressionStatement\":\n      return concat([path.call(print, \"expression\"), \";\"]);\n    case \"ParenthesizedExpression\":\n      return concat([\"(\", path.call(print, \"expression\"), \")\"]);\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n    case \"AssignmentExpression\":\n      return fromString(\" \").join([\n        path.call(print, \"left\"),\n        n.operator,\n        path.call(print, \"right\")\n      ]);\n    case \"AssignmentPattern\":\n      return concat([\n        path.call(print, \"left\"),\n        \" = \",\n        path.call(print, \"right\")\n      ]);\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\": {\n      parts.push(path.call(print, \"object\"));\n      const property = path.call(print, \"property\");\n      const optional = getFieldValue(n, \"optional\");\n      if (n.computed) {\n        parts.push(optional ? \"?.[\" : \"[\", property, \"]\");\n      } else {\n        parts.push(optional ? \"?.\" : \".\", property);\n      }\n      return concat(parts);\n    }\n    case \"ChainExpression\":\n      return path.call(print, \"expression\");\n    case \"MetaProperty\":\n      return concat([\n        path.call(print, \"meta\"),\n        \".\",\n        path.call(print, \"property\")\n      ]);\n    case \"BindExpression\":\n      if (n.object) {\n        parts.push(path.call(print, \"object\"));\n      }\n      parts.push(\"::\", path.call(print, \"callee\"));\n      return concat(parts);\n    case \"Path\":\n      return fromString(\".\").join(n.body);\n    case \"Identifier\":\n      return concat([\n        fromString(n.name, options),\n        n.optional ? \"?\" : \"\",\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"SpreadElement\":\n    case \"SpreadElementPattern\":\n    case \"RestProperty\":\n    case \"SpreadProperty\":\n    case \"SpreadPropertyPattern\":\n    case \"ObjectTypeSpreadProperty\":\n    case \"RestElement\":\n      return concat([\n        \"...\",\n        path.call(print, \"argument\"),\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"TSDeclareFunction\":\n      if (n.declare) {\n        parts.push(\"declare \");\n      }\n      if (n.async) {\n        parts.push(\"async \");\n      }\n      parts.push(\"function\");\n      if (n.generator)\n        parts.push(\"*\");\n      if (n.id) {\n        parts.push(\n          \" \",\n          path.call(print, \"id\"),\n          path.call(print, \"typeParameters\")\n        );\n      } else {\n        if (n.typeParameters) {\n          parts.push(path.call(print, \"typeParameters\"));\n        }\n      }\n      parts.push(\n        \"(\",\n        printFunctionParams(path, options, print),\n        \")\",\n        path.call(print, \"returnType\")\n      );\n      if (n.body) {\n        parts.push(\" \", path.call(print, \"body\"));\n      }\n      return concat(parts);\n    case \"ArrowFunctionExpression\":\n      if (n.async) {\n        parts.push(\"async \");\n      }\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n      if (!options.arrowParensAlways && n.params.length === 1 && !n.rest && n.params[0].type === \"Identifier\" && !n.params[0].typeAnnotation && !n.returnType) {\n        parts.push(path.call(print, \"params\", 0));\n      } else {\n        parts.push(\n          \"(\",\n          printFunctionParams(path, options, print),\n          \")\",\n          path.call(print, \"returnType\")\n        );\n      }\n      parts.push(\" => \", path.call(print, \"body\"));\n      return concat(parts);\n    case \"MethodDefinition\":\n      return printMethod(path, options, print);\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      if (n.delegate)\n        parts.push(\"*\");\n      if (n.argument)\n        parts.push(\" \", path.call(print, \"argument\"));\n      return concat(parts);\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      if (n.all)\n        parts.push(\"*\");\n      if (n.argument)\n        parts.push(\" \", path.call(print, \"argument\"));\n      return concat(parts);\n    case \"ModuleExpression\":\n      return concat([\n        \"module {\\n\",\n        path.call(print, \"body\").indent(options.tabWidth),\n        \"\\n}\"\n      ]);\n    case \"ModuleDeclaration\":\n      parts.push(\"module\", path.call(print, \"id\"));\n      if (n.source) {\n        parts.push(\"from\", path.call(print, \"source\"));\n      } else {\n        parts.push(path.call(print, \"body\"));\n      }\n      return fromString(\" \").join(parts);\n    case \"ImportSpecifier\":\n      if (n.importKind && n.importKind !== \"value\") {\n        parts.push(n.importKind + \" \");\n      }\n      if (n.imported) {\n        parts.push(path.call(print, \"imported\"));\n        if (n.local && n.local.name !== n.imported.name) {\n          parts.push(\" as \", path.call(print, \"local\"));\n        }\n      } else if (n.id) {\n        parts.push(path.call(print, \"id\"));\n        if (n.name) {\n          parts.push(\" as \", path.call(print, \"name\"));\n        }\n      }\n      return concat(parts);\n    case \"ExportSpecifier\":\n      if (n.exportKind && n.exportKind !== \"value\") {\n        parts.push(n.exportKind + \" \");\n      }\n      if (n.local) {\n        parts.push(path.call(print, \"local\"));\n        if (n.exported && n.exported.name !== n.local.name) {\n          parts.push(\" as \", path.call(print, \"exported\"));\n        }\n      } else if (n.id) {\n        parts.push(path.call(print, \"id\"));\n        if (n.name) {\n          parts.push(\" as \", path.call(print, \"name\"));\n        }\n      }\n      return concat(parts);\n    case \"ExportBatchSpecifier\":\n      return fromString(\"*\");\n    case \"ImportNamespaceSpecifier\":\n      parts.push(\"* as \");\n      if (n.local) {\n        parts.push(path.call(print, \"local\"));\n      } else if (n.id) {\n        parts.push(path.call(print, \"id\"));\n      }\n      return concat(parts);\n    case \"ImportDefaultSpecifier\":\n      if (n.local) {\n        return path.call(print, \"local\");\n      }\n      return path.call(print, \"id\");\n    case \"TSExportAssignment\":\n      return concat([\"export = \", path.call(print, \"expression\")]);\n    case \"ExportDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      return printExportDeclaration(path, options, print);\n    case \"ExportAllDeclaration\":\n      parts.push(\"export *\");\n      if (n.exported) {\n        parts.push(\" as \", path.call(print, \"exported\"));\n      }\n      parts.push(\" from \", path.call(print, \"source\"), \";\");\n      return concat(parts);\n    case \"TSNamespaceExportDeclaration\":\n      parts.push(\"export as namespace \", path.call(print, \"id\"));\n      return maybeAddSemicolon(concat(parts));\n    case \"ExportNamespaceSpecifier\":\n      return concat([\"* as \", path.call(print, \"exported\")]);\n    case \"ExportDefaultSpecifier\":\n      return path.call(print, \"exported\");\n    case \"Import\":\n      return fromString(\"import\", options);\n    case \"ImportExpression\":\n      return concat([\"import(\", path.call(print, \"source\"), \")\"]);\n    case \"ImportDeclaration\": {\n      parts.push(\"import \");\n      if (n.importKind && n.importKind !== \"value\") {\n        parts.push(n.importKind + \" \");\n      }\n      if (n.specifiers && n.specifiers.length > 0) {\n        const unbracedSpecifiers = [];\n        const bracedSpecifiers = [];\n        path.each(function(specifierPath) {\n          const spec = specifierPath.getValue();\n          if (spec.type === \"ImportSpecifier\") {\n            bracedSpecifiers.push(print(specifierPath));\n          } else if (spec.type === \"ImportDefaultSpecifier\" || spec.type === \"ImportNamespaceSpecifier\") {\n            unbracedSpecifiers.push(print(specifierPath));\n          }\n        }, \"specifiers\");\n        unbracedSpecifiers.forEach((lines, i) => {\n          if (i > 0) {\n            parts.push(\", \");\n          }\n          parts.push(lines);\n        });\n        if (bracedSpecifiers.length > 0) {\n          let lines = fromString(\", \").join(bracedSpecifiers);\n          if (lines.getLineLength(1) > options.wrapColumn) {\n            lines = concat([\n              fromString(\",\\n\").join(bracedSpecifiers).indent(options.tabWidth),\n              \",\"\n            ]);\n          }\n          if (unbracedSpecifiers.length > 0) {\n            parts.push(\", \");\n          }\n          if (lines.length > 1) {\n            parts.push(\"{\\n\", lines, \"\\n}\");\n          } else if (options.objectCurlySpacing) {\n            parts.push(\"{ \", lines, \" }\");\n          } else {\n            parts.push(\"{\", lines, \"}\");\n          }\n        }\n        parts.push(\" from \");\n      }\n      parts.push(\n        path.call(print, \"source\"),\n        maybePrintImportAssertions(path, options, print),\n        \";\"\n      );\n      return concat(parts);\n    }\n    case \"ImportAttribute\":\n      return concat([path.call(print, \"key\"), \": \", path.call(print, \"value\")]);\n    case \"StaticBlock\":\n      parts.push(\"static \");\n    case \"BlockStatement\": {\n      const naked = path.call(\n        (bodyPath) => printStatementSequence(bodyPath, options, print),\n        \"body\"\n      );\n      if (naked.isEmpty()) {\n        if (!n.directives || n.directives.length === 0) {\n          parts.push(\"{}\");\n          return concat(parts);\n        }\n      }\n      parts.push(\"{\\n\");\n      if (n.directives) {\n        path.each(function(childPath) {\n          parts.push(\n            maybeAddSemicolon(print(childPath).indent(options.tabWidth)),\n            n.directives.length > 1 || !naked.isEmpty() ? \"\\n\" : \"\"\n          );\n        }, \"directives\");\n      }\n      parts.push(naked.indent(options.tabWidth));\n      parts.push(\"\\n}\");\n      return concat(parts);\n    }\n    case \"ReturnStatement\": {\n      parts.push(\"return\");\n      if (n.argument) {\n        const argLines = path.call(print, \"argument\");\n        if (argLines.startsWithComment() || argLines.length > 1 && namedTypes.JSXElement && namedTypes.JSXElement.check(n.argument)) {\n          parts.push(\" (\\n\", argLines.indent(options.tabWidth), \"\\n)\");\n        } else {\n          parts.push(\" \", argLines);\n        }\n      }\n      parts.push(\";\");\n      return concat(parts);\n    }\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n      parts.push(path.call(print, \"callee\"));\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n      if (n.typeArguments) {\n        parts.push(path.call(print, \"typeArguments\"));\n      }\n      if (getFieldValue(n, \"optional\")) {\n        parts.push(\"?.\");\n      }\n      parts.push(printArgumentsList(path, options, print));\n      return concat(parts);\n    case \"RecordExpression\":\n      parts.push(\"#\");\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n    case \"ObjectTypeAnnotation\": {\n      const isTypeAnnotation = n.type === \"ObjectTypeAnnotation\";\n      const separator = options.flowObjectCommas ? \",\" : isTypeAnnotation ? \";\" : \",\";\n      const fields = [];\n      let allowBreak = false;\n      if (isTypeAnnotation) {\n        fields.push(\"indexers\", \"callProperties\");\n        if (n.internalSlots != null) {\n          fields.push(\"internalSlots\");\n        }\n      }\n      fields.push(\"properties\");\n      let len = 0;\n      fields.forEach(function(field) {\n        len += n[field].length;\n      });\n      const oneLine = isTypeAnnotation && len === 1 || len === 0;\n      const leftBrace = n.exact ? \"{|\" : \"{\";\n      const rightBrace = n.exact ? \"|}\" : \"}\";\n      parts.push(oneLine ? leftBrace : leftBrace + \"\\n\");\n      const leftBraceIndex = parts.length - 1;\n      let i = 0;\n      fields.forEach(function(field) {\n        path.each(function(childPath) {\n          let lines = print(childPath);\n          if (!oneLine) {\n            lines = lines.indent(options.tabWidth);\n          }\n          const multiLine = !isTypeAnnotation && lines.length > 1;\n          if (multiLine && allowBreak) {\n            parts.push(\"\\n\");\n          }\n          parts.push(lines);\n          if (i < len - 1) {\n            parts.push(separator + (multiLine ? \"\\n\\n\" : \"\\n\"));\n            allowBreak = !multiLine;\n          } else if (len !== 1 && isTypeAnnotation) {\n            parts.push(separator);\n          } else if (!oneLine && isTrailingCommaEnabled(options, \"objects\") && childPath.getValue().type !== \"RestElement\") {\n            parts.push(separator);\n          }\n          i++;\n        }, field);\n      });\n      if (n.inexact) {\n        const line = fromString(\"...\", options);\n        if (oneLine) {\n          if (len > 0) {\n            parts.push(separator, \" \");\n          }\n          parts.push(line);\n        } else {\n          parts.push(\"\\n\", line.indent(options.tabWidth));\n        }\n      }\n      parts.push(oneLine ? rightBrace : \"\\n\" + rightBrace);\n      if (i !== 0 && oneLine && options.objectCurlySpacing) {\n        parts[leftBraceIndex] = leftBrace + \" \";\n        parts[parts.length - 1] = \" \" + rightBrace;\n      }\n      if (n.typeAnnotation) {\n        parts.push(path.call(print, \"typeAnnotation\"));\n      }\n      return concat(parts);\n    }\n    case \"PropertyPattern\":\n      return concat([\n        path.call(print, \"key\"),\n        \": \",\n        path.call(print, \"pattern\")\n      ]);\n    case \"ObjectProperty\":\n    case \"Property\": {\n      if (n.method || n.kind === \"get\" || n.kind === \"set\") {\n        return printMethod(path, options, print);\n      }\n      if (n.shorthand && n.value.type === \"AssignmentPattern\") {\n        return path.call(print, \"value\");\n      }\n      const key = path.call(print, \"key\");\n      if (n.computed) {\n        parts.push(\"[\", key, \"]\");\n      } else {\n        parts.push(key);\n      }\n      if (!n.shorthand || n.key.name !== n.value.name) {\n        parts.push(\": \", path.call(print, \"value\"));\n      }\n      return concat(parts);\n    }\n    case \"ClassMethod\":\n    case \"ObjectMethod\":\n    case \"ClassPrivateMethod\":\n    case \"TSDeclareMethod\":\n      return printMethod(path, options, print);\n    case \"PrivateName\":\n      return concat([\"#\", path.call(print, \"id\")]);\n    case \"Decorator\":\n      return concat([\"@\", path.call(print, \"expression\")]);\n    case \"TupleExpression\":\n      parts.push(\"#\");\n    case \"ArrayExpression\":\n    case \"ArrayPattern\": {\n      const elems = n.elements;\n      const len = elems.length;\n      const printed = path.map(print, \"elements\");\n      const joined = fromString(\", \").join(printed);\n      const oneLine = joined.getLineLength(1) <= options.wrapColumn;\n      if (oneLine) {\n        if (options.arrayBracketSpacing) {\n          parts.push(\"[ \");\n        } else {\n          parts.push(\"[\");\n        }\n      } else {\n        parts.push(\"[\\n\");\n      }\n      path.each(function(elemPath) {\n        const i = elemPath.getName();\n        const elem = elemPath.getValue();\n        if (!elem) {\n          parts.push(\",\");\n        } else {\n          let lines = printed[i];\n          if (oneLine) {\n            if (i > 0)\n              parts.push(\" \");\n          } else {\n            lines = lines.indent(options.tabWidth);\n          }\n          parts.push(lines);\n          if (i < len - 1 || !oneLine && isTrailingCommaEnabled(options, \"arrays\"))\n            parts.push(\",\");\n          if (!oneLine)\n            parts.push(\"\\n\");\n        }\n      }, \"elements\");\n      if (oneLine && options.arrayBracketSpacing) {\n        parts.push(\" ]\");\n      } else {\n        parts.push(\"]\");\n      }\n      if (n.typeAnnotation) {\n        parts.push(path.call(print, \"typeAnnotation\"));\n      }\n      return concat(parts);\n    }\n    case \"SequenceExpression\":\n      return fromString(\", \").join(path.map(print, \"expressions\"));\n    case \"ThisExpression\":\n      return fromString(\"this\");\n    case \"Super\":\n      return fromString(\"super\");\n    case \"NullLiteral\":\n      return fromString(\"null\");\n    case \"RegExpLiteral\":\n      return fromString(\n        getPossibleRaw(n) || `/${n.pattern}/${n.flags || \"\"}`,\n        options\n      );\n    case \"BigIntLiteral\":\n      return fromString(getPossibleRaw(n) || n.value + \"n\", options);\n    case \"NumericLiteral\":\n      return fromString(getPossibleRaw(n) || n.value, options);\n    case \"DecimalLiteral\":\n      return fromString(getPossibleRaw(n) || n.value + \"m\", options);\n    case \"StringLiteral\":\n      return fromString(nodeStr(n.value, options));\n    case \"BooleanLiteral\":\n    case \"Literal\":\n      return fromString(\n        getPossibleRaw(n) || (typeof n.value === \"string\" ? nodeStr(n.value, options) : n.value),\n        options\n      );\n    case \"Directive\":\n      return path.call(print, \"value\");\n    case \"DirectiveLiteral\":\n      return fromString(\n        getPossibleRaw(n) || nodeStr(n.value, options),\n        options\n      );\n    case \"InterpreterDirective\":\n      return fromString(`#!${n.value}\n`, options);\n    case \"ModuleSpecifier\":\n      if (n.local) {\n        throw new Error(\"The ESTree ModuleSpecifier type should be abstract\");\n      }\n      return fromString(nodeStr(n.value, options), options);\n    case \"UnaryExpression\":\n      parts.push(n.operator);\n      if (/[a-z]$/.test(n.operator))\n        parts.push(\" \");\n      parts.push(path.call(print, \"argument\"));\n      return concat(parts);\n    case \"UpdateExpression\":\n      parts.push(path.call(print, \"argument\"), n.operator);\n      if (n.prefix)\n        parts.reverse();\n      return concat(parts);\n    case \"ConditionalExpression\":\n      return concat([\n        path.call(print, \"test\"),\n        \" ? \",\n        path.call(print, \"consequent\"),\n        \" : \",\n        path.call(print, \"alternate\")\n      ]);\n    case \"NewExpression\": {\n      parts.push(\"new \", path.call(print, \"callee\"));\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n      if (n.typeArguments) {\n        parts.push(path.call(print, \"typeArguments\"));\n      }\n      const args = n.arguments;\n      if (args) {\n        parts.push(printArgumentsList(path, options, print));\n      }\n      return concat(parts);\n    }\n    case \"VariableDeclaration\": {\n      if (n.declare) {\n        parts.push(\"declare \");\n      }\n      parts.push(n.kind, \" \");\n      let maxLen = 0;\n      const printed = path.map(function(childPath) {\n        const lines = print(childPath);\n        maxLen = Math.max(lines.length, maxLen);\n        return lines;\n      }, \"declarations\");\n      if (maxLen === 1) {\n        parts.push(fromString(\", \").join(printed));\n      } else if (printed.length > 1) {\n        parts.push(\n          fromString(\",\\n\").join(printed).indentTail(n.kind.length + 1)\n        );\n      } else {\n        parts.push(printed[0]);\n      }\n      const parentNode = path.getParentNode();\n      if (!namedTypes.ForStatement.check(parentNode) && !namedTypes.ForInStatement.check(parentNode) && !(namedTypes.ForOfStatement && namedTypes.ForOfStatement.check(parentNode)) && !(namedTypes.ForAwaitStatement && namedTypes.ForAwaitStatement.check(parentNode))) {\n        parts.push(\";\");\n      }\n      return concat(parts);\n    }\n    case \"VariableDeclarator\":\n      return n.init ? fromString(\" = \").join([\n        path.call(print, \"id\"),\n        path.call(print, \"init\")\n      ]) : path.call(print, \"id\");\n    case \"WithStatement\":\n      return concat([\n        \"with (\",\n        path.call(print, \"object\"),\n        \") \",\n        path.call(print, \"body\")\n      ]);\n    case \"IfStatement\": {\n      const con = adjustClause(path.call(print, \"consequent\"), options);\n      parts.push(\"if (\", path.call(print, \"test\"), \")\", con);\n      if (n.alternate)\n        parts.push(\n          endsWithBrace(con) ? \" else\" : \"\\nelse\",\n          adjustClause(path.call(print, \"alternate\"), options)\n        );\n      return concat(parts);\n    }\n    case \"ForStatement\": {\n      const init = path.call(print, \"init\");\n      const sep = init.length > 1 ? \";\\n\" : \"; \";\n      const forParen = \"for (\";\n      const indented = fromString(sep).join([init, path.call(print, \"test\"), path.call(print, \"update\")]).indentTail(forParen.length);\n      const head = concat([forParen, indented, \")\"]);\n      let clause = adjustClause(path.call(print, \"body\"), options);\n      parts.push(head);\n      if (head.length > 1) {\n        parts.push(\"\\n\");\n        clause = clause.trimLeft();\n      }\n      parts.push(clause);\n      return concat(parts);\n    }\n    case \"WhileStatement\":\n      return concat([\n        \"while (\",\n        path.call(print, \"test\"),\n        \")\",\n        adjustClause(path.call(print, \"body\"), options)\n      ]);\n    case \"ForInStatement\":\n      return concat([\n        n.each ? \"for each (\" : \"for (\",\n        path.call(print, \"left\"),\n        \" in \",\n        path.call(print, \"right\"),\n        \")\",\n        adjustClause(path.call(print, \"body\"), options)\n      ]);\n    case \"ForOfStatement\":\n    case \"ForAwaitStatement\":\n      parts.push(\"for \");\n      if (n.await || n.type === \"ForAwaitStatement\") {\n        parts.push(\"await \");\n      }\n      parts.push(\n        \"(\",\n        path.call(print, \"left\"),\n        \" of \",\n        path.call(print, \"right\"),\n        \")\",\n        adjustClause(path.call(print, \"body\"), options)\n      );\n      return concat(parts);\n    case \"DoWhileStatement\": {\n      const doBody = concat([\n        \"do\",\n        adjustClause(path.call(print, \"body\"), options)\n      ]);\n      parts.push(doBody);\n      if (endsWithBrace(doBody))\n        parts.push(\" while\");\n      else\n        parts.push(\"\\nwhile\");\n      parts.push(\" (\", path.call(print, \"test\"), \");\");\n      return concat(parts);\n    }\n    case \"DoExpression\": {\n      const statements = path.call(\n        (bodyPath) => printStatementSequence(bodyPath, options, print),\n        \"body\"\n      );\n      return concat([\"do {\\n\", statements.indent(options.tabWidth), \"\\n}\"]);\n    }\n    case \"BreakStatement\":\n      parts.push(\"break\");\n      if (n.label)\n        parts.push(\" \", path.call(print, \"label\"));\n      parts.push(\";\");\n      return concat(parts);\n    case \"ContinueStatement\":\n      parts.push(\"continue\");\n      if (n.label)\n        parts.push(\" \", path.call(print, \"label\"));\n      parts.push(\";\");\n      return concat(parts);\n    case \"LabeledStatement\":\n      return concat([\n        path.call(print, \"label\"),\n        \":\\n\",\n        path.call(print, \"body\")\n      ]);\n    case \"TryStatement\":\n      parts.push(\"try \", path.call(print, \"block\"));\n      if (n.handler) {\n        parts.push(\" \", path.call(print, \"handler\"));\n      } else if (n.handlers) {\n        path.each(function(handlerPath) {\n          parts.push(\" \", print(handlerPath));\n        }, \"handlers\");\n      }\n      if (n.finalizer) {\n        parts.push(\" finally \", path.call(print, \"finalizer\"));\n      }\n      return concat(parts);\n    case \"CatchClause\":\n      parts.push(\"catch \");\n      if (n.param) {\n        parts.push(\"(\", path.call(print, \"param\"));\n      }\n      if (n.guard) {\n        parts.push(\" if \", path.call(print, \"guard\"));\n      }\n      if (n.param) {\n        parts.push(\") \");\n      }\n      parts.push(path.call(print, \"body\"));\n      return concat(parts);\n    case \"ThrowStatement\":\n      return concat([\"throw \", path.call(print, \"argument\"), \";\"]);\n    case \"SwitchStatement\":\n      return concat([\n        \"switch (\",\n        path.call(print, \"discriminant\"),\n        \") {\\n\",\n        fromString(\"\\n\").join(path.map(print, \"cases\")),\n        \"\\n}\"\n      ]);\n    case \"SwitchCase\":\n      if (n.test)\n        parts.push(\"case \", path.call(print, \"test\"), \":\");\n      else\n        parts.push(\"default:\");\n      if (n.consequent.length > 0) {\n        parts.push(\n          \"\\n\",\n          path.call(\n            (consequentPath) => printStatementSequence(consequentPath, options, print),\n            \"consequent\"\n          ).indent(options.tabWidth)\n        );\n      }\n      return concat(parts);\n    case \"DebuggerStatement\":\n      return fromString(\"debugger;\");\n    case \"JSXAttribute\":\n      parts.push(path.call(print, \"name\"));\n      if (n.value)\n        parts.push(\"=\", path.call(print, \"value\"));\n      return concat(parts);\n    case \"JSXIdentifier\":\n      return fromString(n.name, options);\n    case \"JSXNamespacedName\":\n      return fromString(\":\").join([\n        path.call(print, \"namespace\"),\n        path.call(print, \"name\")\n      ]);\n    case \"JSXMemberExpression\":\n      return fromString(\".\").join([\n        path.call(print, \"object\"),\n        path.call(print, \"property\")\n      ]);\n    case \"JSXSpreadAttribute\":\n      return concat([\"{...\", path.call(print, \"argument\"), \"}\"]);\n    case \"JSXSpreadChild\":\n      return concat([\"{...\", path.call(print, \"expression\"), \"}\"]);\n    case \"JSXExpressionContainer\":\n      return concat([\"{\", path.call(print, \"expression\"), \"}\"]);\n    case \"JSXElement\":\n    case \"JSXFragment\": {\n      const openingPropName = \"opening\" + (n.type === \"JSXElement\" ? \"Element\" : \"Fragment\");\n      const closingPropName = \"closing\" + (n.type === \"JSXElement\" ? \"Element\" : \"Fragment\");\n      const openingLines = path.call(print, openingPropName);\n      if (n[openingPropName].selfClosing) {\n        return openingLines;\n      }\n      const childLines = concat(\n        path.map(function(childPath) {\n          const child = childPath.getValue();\n          if (namedTypes.Literal.check(child) && typeof child.value === \"string\") {\n            if (/\\S/.test(child.value)) {\n              return child.value.replace(/^\\s+|\\s+$/g, \"\");\n            } else if (/\\n/.test(child.value)) {\n              return \"\\n\";\n            }\n          }\n          return print(childPath);\n        }, \"children\")\n      ).indentTail(options.tabWidth);\n      const closingLines = path.call(print, closingPropName);\n      return concat([openingLines, childLines, closingLines]);\n    }\n    case \"JSXOpeningElement\": {\n      parts.push(\"<\", path.call(print, \"name\"));\n      const attrParts = [];\n      path.each(function(attrPath) {\n        attrParts.push(\" \", print(attrPath));\n      }, \"attributes\");\n      let attrLines = concat(attrParts);\n      const needLineWrap = attrLines.length > 1 || attrLines.getLineLength(1) > options.wrapColumn;\n      if (needLineWrap) {\n        attrParts.forEach(function(part, i) {\n          if (part === \" \") {\n            attrParts[i] = \"\\n\";\n          }\n        });\n        attrLines = concat(attrParts).indentTail(options.tabWidth);\n      }\n      parts.push(attrLines, n.selfClosing ? \" />\" : \">\");\n      return concat(parts);\n    }\n    case \"JSXClosingElement\":\n      return concat([\"</\", path.call(print, \"name\"), \">\"]);\n    case \"JSXOpeningFragment\":\n      return fromString(\"<>\");\n    case \"JSXClosingFragment\":\n      return fromString(\"</>\");\n    case \"JSXText\":\n      return fromString(n.value, options);\n    case \"JSXEmptyExpression\":\n      return fromString(\"\");\n    case \"TypeAnnotatedIdentifier\":\n      return concat([\n        path.call(print, \"annotation\"),\n        \" \",\n        path.call(print, \"identifier\")\n      ]);\n    case \"ClassBody\":\n      if (n.body.length === 0) {\n        return fromString(\"{}\");\n      }\n      return concat([\n        \"{\\n\",\n        path.call(\n          (bodyPath) => printStatementSequence(bodyPath, options, print),\n          \"body\"\n        ).indent(options.tabWidth),\n        \"\\n}\"\n      ]);\n    case \"ClassPropertyDefinition\":\n      parts.push(\"static \", path.call(print, \"definition\"));\n      if (!namedTypes.MethodDefinition.check(n.definition))\n        parts.push(\";\");\n      return concat(parts);\n    case \"ClassProperty\": {\n      if (n.declare) {\n        parts.push(\"declare \");\n      }\n      const access = n.accessibility || n.access;\n      if (typeof access === \"string\") {\n        parts.push(access, \" \");\n      }\n      if (n.static) {\n        parts.push(\"static \");\n      }\n      if (n.abstract) {\n        parts.push(\"abstract \");\n      }\n      if (n.readonly) {\n        parts.push(\"readonly \");\n      }\n      let key = path.call(print, \"key\");\n      if (n.computed) {\n        key = concat([\"[\", key, \"]\"]);\n      }\n      if (n.variance) {\n        key = concat([printVariance(path, print), key]);\n      }\n      parts.push(key);\n      if (n.optional) {\n        parts.push(\"?\");\n      }\n      if (n.definite) {\n        parts.push(\"!\");\n      }\n      if (n.typeAnnotation) {\n        parts.push(path.call(print, \"typeAnnotation\"));\n      }\n      if (n.value) {\n        parts.push(\" = \", path.call(print, \"value\"));\n      }\n      parts.push(\";\");\n      return concat(parts);\n    }\n    case \"ClassPrivateProperty\":\n      if (n.static) {\n        parts.push(\"static \");\n      }\n      parts.push(path.call(print, \"key\"));\n      if (n.typeAnnotation) {\n        parts.push(path.call(print, \"typeAnnotation\"));\n      }\n      if (n.value) {\n        parts.push(\" = \", path.call(print, \"value\"));\n      }\n      parts.push(\";\");\n      return concat(parts);\n    case \"ClassAccessorProperty\": {\n      parts.push(\n        ...printClassMemberModifiers(n),\n        \"accessor \"\n      );\n      if (n.computed) {\n        parts.push(\"[\", path.call(print, \"key\"), \"]\");\n      } else {\n        parts.push(path.call(print, \"key\"));\n      }\n      if (n.optional) {\n        parts.push(\"?\");\n      }\n      if (n.definite) {\n        parts.push(\"!\");\n      }\n      if (n.typeAnnotation) {\n        parts.push(path.call(print, \"typeAnnotation\"));\n      }\n      if (n.value) {\n        parts.push(\" = \", path.call(print, \"value\"));\n      }\n      parts.push(\";\");\n      return concat(parts);\n    }\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n    case \"DeclareClass\":\n      if (n.declare) {\n        parts.push(\"declare \");\n      }\n      if (n.abstract) {\n        parts.push(\"abstract \");\n      }\n      parts.push(\"class\");\n      if (n.id) {\n        parts.push(\" \", path.call(print, \"id\"));\n      }\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n      if (n.superClass) {\n        parts.push(\n          \" extends \",\n          path.call(print, \"superClass\"),\n          path.call(print, \"superTypeParameters\")\n        );\n      }\n      if (n.extends && n.extends.length > 0) {\n        parts.push(\n          \" extends \",\n          fromString(\", \").join(path.map(print, \"extends\"))\n        );\n      }\n      if (n[\"implements\"] && n[\"implements\"].length > 0) {\n        parts.push(\n          \" implements \",\n          fromString(\", \").join(path.map(print, \"implements\"))\n        );\n      }\n      parts.push(\" \", path.call(print, \"body\"));\n      if (n.type === \"DeclareClass\") {\n        return printFlowDeclaration(path, parts);\n      } else {\n        return concat(parts);\n      }\n    case \"TemplateElement\":\n      return fromString(n.value.raw, options).lockIndentTail();\n    case \"TemplateLiteral\": {\n      const expressions = path.map(print, \"expressions\");\n      parts.push(\"`\");\n      path.each(function(childPath) {\n        const i = childPath.getName();\n        parts.push(print(childPath));\n        if (i < expressions.length) {\n          parts.push(\"${\", expressions[i], \"}\");\n        }\n      }, \"quasis\");\n      parts.push(\"`\");\n      return concat(parts).lockIndentTail();\n    }\n    case \"TaggedTemplateExpression\":\n      return concat([path.call(print, \"tag\"), path.call(print, \"quasi\")]);\n    case \"Node\":\n    case \"Printable\":\n    case \"SourceLocation\":\n    case \"Position\":\n    case \"Statement\":\n    case \"Function\":\n    case \"Pattern\":\n    case \"Expression\":\n    case \"Declaration\":\n    case \"Specifier\":\n    case \"NamedSpecifier\":\n    case \"Comment\":\n    case \"Flow\":\n    case \"FlowType\":\n    case \"FlowPredicate\":\n    case \"MemberTypeAnnotation\":\n    case \"Type\":\n    case \"TSHasOptionalTypeParameterInstantiation\":\n    case \"TSHasOptionalTypeParameters\":\n    case \"TSHasOptionalTypeAnnotation\":\n    case \"ChainElement\":\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n    case \"CommentBlock\":\n    case \"Block\":\n      return concat([\"/*\", fromString(n.value, options), \"*/\"]);\n    case \"CommentLine\":\n    case \"Line\":\n      return concat([\"//\", fromString(n.value, options)]);\n    case \"TypeAnnotation\":\n      if (n.typeAnnotation) {\n        if (n.typeAnnotation.type !== \"FunctionTypeAnnotation\") {\n          parts.push(\": \");\n        }\n        parts.push(path.call(print, \"typeAnnotation\"));\n        return concat(parts);\n      }\n      return fromString(\"\");\n    case \"ExistentialTypeParam\":\n    case \"ExistsTypeAnnotation\":\n      return fromString(\"*\", options);\n    case \"EmptyTypeAnnotation\":\n      return fromString(\"empty\", options);\n    case \"AnyTypeAnnotation\":\n      return fromString(\"any\", options);\n    case \"MixedTypeAnnotation\":\n      return fromString(\"mixed\", options);\n    case \"ArrayTypeAnnotation\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n    case \"TupleTypeAnnotation\": {\n      const printed = path.map(print, \"types\");\n      const joined = fromString(\", \").join(printed);\n      const oneLine = joined.getLineLength(1) <= options.wrapColumn;\n      if (oneLine) {\n        if (options.arrayBracketSpacing) {\n          parts.push(\"[ \");\n        } else {\n          parts.push(\"[\");\n        }\n      } else {\n        parts.push(\"[\\n\");\n      }\n      path.each(function(elemPath) {\n        const i = elemPath.getName();\n        const elem = elemPath.getValue();\n        if (!elem) {\n          parts.push(\",\");\n        } else {\n          let lines = printed[i];\n          if (oneLine) {\n            if (i > 0)\n              parts.push(\" \");\n          } else {\n            lines = lines.indent(options.tabWidth);\n          }\n          parts.push(lines);\n          if (i < n.types.length - 1 || !oneLine && isTrailingCommaEnabled(options, \"arrays\"))\n            parts.push(\",\");\n          if (!oneLine)\n            parts.push(\"\\n\");\n        }\n      }, \"types\");\n      if (oneLine && options.arrayBracketSpacing) {\n        parts.push(\" ]\");\n      } else {\n        parts.push(\"]\");\n      }\n      return concat(parts);\n    }\n    case \"BooleanTypeAnnotation\":\n      return fromString(\"boolean\", options);\n    case \"BooleanLiteralTypeAnnotation\":\n      return fromString(\"\" + n.value, options);\n    case \"InterfaceTypeAnnotation\":\n      parts.push(\"interface\");\n      if (n.extends && n.extends.length > 0) {\n        parts.push(\n          \" extends \",\n          fromString(\", \").join(path.map(print, \"extends\"))\n        );\n      }\n      parts.push(\" \", path.call(print, \"body\"));\n      return concat(parts);\n    case \"DeclareFunction\":\n      return printFlowDeclaration(path, [\n        \"function \",\n        path.call(print, \"id\"),\n        \";\"\n      ]);\n    case \"DeclareModule\":\n      return printFlowDeclaration(path, [\n        \"module \",\n        path.call(print, \"id\"),\n        \" \",\n        path.call(print, \"body\")\n      ]);\n    case \"DeclareModuleExports\":\n      return printFlowDeclaration(path, [\n        \"module.exports\",\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"DeclareVariable\":\n      return printFlowDeclaration(path, [\"var \", path.call(print, \"id\"), \";\"]);\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n      return concat([\"declare \", printExportDeclaration(path, options, print)]);\n    case \"EnumDeclaration\":\n      return concat([\n        \"enum \",\n        path.call(print, \"id\"),\n        path.call(print, \"body\")\n      ]);\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\": {\n      if (n.type === \"EnumSymbolBody\" || n.explicitType) {\n        parts.push(\n          \" of \",\n          // EnumBooleanBody => boolean, etc.\n          n.type.slice(4, -4).toLowerCase()\n        );\n      }\n      parts.push(\n        \" {\\n\",\n        fromString(\"\\n\").join(path.map(print, \"members\")).indent(options.tabWidth),\n        \"\\n}\"\n      );\n      return concat(parts);\n    }\n    case \"EnumDefaultedMember\":\n      return concat([path.call(print, \"id\"), \",\"]);\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n      return concat([\n        path.call(print, \"id\"),\n        \" = \",\n        path.call(print, \"init\"),\n        \",\"\n      ]);\n    case \"InferredPredicate\":\n      return fromString(\"%checks\", options);\n    case \"DeclaredPredicate\":\n      return concat([\"%checks(\", path.call(print, \"value\"), \")\"]);\n    case \"FunctionTypeAnnotation\": {\n      const parent = path.getParentNode(0);\n      const isArrowFunctionTypeAnnotation = !(namedTypes.ObjectTypeCallProperty.check(parent) || namedTypes.ObjectTypeInternalSlot.check(parent) && parent.method || namedTypes.DeclareFunction.check(path.getParentNode(2)));\n      const needsColon = isArrowFunctionTypeAnnotation && !namedTypes.FunctionTypeParam.check(parent) && !namedTypes.TypeAlias.check(parent);\n      if (needsColon) {\n        parts.push(\": \");\n      }\n      const hasTypeParameters = !!n.typeParameters;\n      const needsParens = hasTypeParameters || n.params.length !== 1 || n.params[0].name;\n      parts.push(\n        hasTypeParameters ? path.call(print, \"typeParameters\") : \"\",\n        needsParens ? \"(\" : \"\",\n        printFunctionParams(path, options, print),\n        needsParens ? \")\" : \"\"\n      );\n      if (n.returnType) {\n        parts.push(\n          isArrowFunctionTypeAnnotation ? \" => \" : \": \",\n          path.call(print, \"returnType\")\n        );\n      }\n      return concat(parts);\n    }\n    case \"FunctionTypeParam\": {\n      const name = path.call(print, \"name\");\n      parts.push(name);\n      if (n.optional) {\n        parts.push(\"?\");\n      }\n      if (name.infos[0].line) {\n        parts.push(\": \");\n      }\n      parts.push(path.call(print, \"typeAnnotation\"));\n      return concat(parts);\n    }\n    case \"GenericTypeAnnotation\":\n      return concat([\n        path.call(print, \"id\"),\n        path.call(print, \"typeParameters\")\n      ]);\n    case \"DeclareInterface\":\n      parts.push(\"declare \");\n    case \"InterfaceDeclaration\":\n    case \"TSInterfaceDeclaration\":\n      if (n.declare) {\n        parts.push(\"declare \");\n      }\n      parts.push(\n        \"interface \",\n        path.call(print, \"id\"),\n        path.call(print, \"typeParameters\"),\n        \" \"\n      );\n      if (n[\"extends\"] && n[\"extends\"].length > 0) {\n        parts.push(\n          \"extends \",\n          fromString(\", \").join(path.map(print, \"extends\")),\n          \" \"\n        );\n      }\n      if (n.body) {\n        parts.push(path.call(print, \"body\"));\n      }\n      return concat(parts);\n    case \"ClassImplements\":\n    case \"InterfaceExtends\":\n      return concat([\n        path.call(print, \"id\"),\n        path.call(print, \"typeParameters\")\n      ]);\n    case \"IntersectionTypeAnnotation\":\n      return fromString(\" & \").join(path.map(print, \"types\"));\n    case \"NullableTypeAnnotation\":\n      return concat([\"?\", path.call(print, \"typeAnnotation\")]);\n    case \"NullLiteralTypeAnnotation\":\n      return fromString(\"null\", options);\n    case \"ThisTypeAnnotation\":\n      return fromString(\"this\", options);\n    case \"NumberTypeAnnotation\":\n      return fromString(\"number\", options);\n    case \"ObjectTypeCallProperty\":\n      return path.call(print, \"value\");\n    case \"ObjectTypeIndexer\":\n      if (n.static) {\n        parts.push(\"static \");\n      }\n      parts.push(printVariance(path, print), \"[\");\n      if (n.id) {\n        parts.push(path.call(print, \"id\"), \": \");\n      }\n      parts.push(path.call(print, \"key\"), \"]: \", path.call(print, \"value\"));\n      return concat(parts);\n    case \"ObjectTypeProperty\":\n      return concat([\n        printVariance(path, print),\n        path.call(print, \"key\"),\n        n.optional ? \"?\" : \"\",\n        \": \",\n        path.call(print, \"value\")\n      ]);\n    case \"ObjectTypeInternalSlot\":\n      return concat([\n        n.static ? \"static \" : \"\",\n        \"[[\",\n        path.call(print, \"id\"),\n        \"]]\",\n        n.optional ? \"?\" : \"\",\n        n.value.type !== \"FunctionTypeAnnotation\" ? \": \" : \"\",\n        path.call(print, \"value\")\n      ]);\n    case \"QualifiedTypeIdentifier\":\n      return concat([\n        path.call(print, \"qualification\"),\n        \".\",\n        path.call(print, \"id\")\n      ]);\n    case \"StringLiteralTypeAnnotation\":\n      return fromString(nodeStr(n.value, options), options);\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumericLiteralTypeAnnotation\":\n      return fromString(JSON.stringify(n.value), options);\n    case \"BigIntLiteralTypeAnnotation\":\n      return fromString(n.raw, options);\n    case \"StringTypeAnnotation\":\n      return fromString(\"string\", options);\n    case \"DeclareTypeAlias\":\n      parts.push(\"declare \");\n    case \"TypeAlias\":\n      return concat([\n        \"type \",\n        path.call(print, \"id\"),\n        path.call(print, \"typeParameters\"),\n        \" = \",\n        path.call(print, \"right\"),\n        \";\"\n      ]);\n    case \"DeclareOpaqueType\":\n      parts.push(\"declare \");\n    case \"OpaqueType\":\n      parts.push(\n        \"opaque type \",\n        path.call(print, \"id\"),\n        path.call(print, \"typeParameters\")\n      );\n      if (n[\"supertype\"]) {\n        parts.push(\": \", path.call(print, \"supertype\"));\n      }\n      if (n[\"impltype\"]) {\n        parts.push(\" = \", path.call(print, \"impltype\"));\n      }\n      parts.push(\";\");\n      return concat(parts);\n    case \"TypeCastExpression\":\n      return concat([\n        \"(\",\n        path.call(print, \"expression\"),\n        path.call(print, \"typeAnnotation\"),\n        \")\"\n      ]);\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n      return concat([\n        \"<\",\n        fromString(\", \").join(path.map(print, \"params\")),\n        \">\"\n      ]);\n    case \"Variance\":\n      if (n.kind === \"plus\") {\n        return fromString(\"+\");\n      }\n      if (n.kind === \"minus\") {\n        return fromString(\"-\");\n      }\n      return fromString(\"\");\n    case \"TypeParameter\":\n      if (n.variance) {\n        parts.push(printVariance(path, print));\n      }\n      parts.push(path.call(print, \"name\"));\n      if (n.bound) {\n        parts.push(path.call(print, \"bound\"));\n      }\n      if (n[\"default\"]) {\n        parts.push(\"=\", path.call(print, \"default\"));\n      }\n      return concat(parts);\n    case \"TypeofTypeAnnotation\":\n      return concat([\n        fromString(\"typeof \", options),\n        path.call(print, \"argument\")\n      ]);\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      return concat([\n        path.call(print, \"objectType\"),\n        n.optional ? \"?.\" : \"\",\n        \"[\",\n        path.call(print, \"indexType\"),\n        \"]\"\n      ]);\n    case \"UnionTypeAnnotation\":\n      return fromString(\" | \").join(path.map(print, \"types\"));\n    case \"VoidTypeAnnotation\":\n      return fromString(\"void\", options);\n    case \"NullTypeAnnotation\":\n      return fromString(\"null\", options);\n    case \"SymbolTypeAnnotation\":\n      return fromString(\"symbol\", options);\n    case \"BigIntTypeAnnotation\":\n      return fromString(\"bigint\", options);\n    case \"TSType\":\n      throw new Error(\"unprintable type: \" + JSON.stringify(n.type));\n    case \"TSNumberKeyword\":\n      return fromString(\"number\", options);\n    case \"TSBigIntKeyword\":\n      return fromString(\"bigint\", options);\n    case \"TSObjectKeyword\":\n      return fromString(\"object\", options);\n    case \"TSBooleanKeyword\":\n      return fromString(\"boolean\", options);\n    case \"TSStringKeyword\":\n      return fromString(\"string\", options);\n    case \"TSSymbolKeyword\":\n      return fromString(\"symbol\", options);\n    case \"TSAnyKeyword\":\n      return fromString(\"any\", options);\n    case \"TSVoidKeyword\":\n      return fromString(\"void\", options);\n    case \"TSIntrinsicKeyword\":\n      return fromString(\"intrinsic\", options);\n    case \"TSThisType\":\n      return fromString(\"this\", options);\n    case \"TSNullKeyword\":\n      return fromString(\"null\", options);\n    case \"TSUndefinedKeyword\":\n      return fromString(\"undefined\", options);\n    case \"TSUnknownKeyword\":\n      return fromString(\"unknown\", options);\n    case \"TSNeverKeyword\":\n      return fromString(\"never\", options);\n    case \"TSArrayType\":\n      return concat([path.call(print, \"elementType\"), \"[]\"]);\n    case \"TSLiteralType\":\n      return path.call(print, \"literal\");\n    case \"TSUnionType\":\n      return fromString(\" | \").join(path.map(print, \"types\"));\n    case \"TSIntersectionType\":\n      return fromString(\" & \").join(path.map(print, \"types\"));\n    case \"TSConditionalType\":\n      parts.push(\n        path.call(print, \"checkType\"),\n        \" extends \",\n        path.call(print, \"extendsType\"),\n        \" ? \",\n        path.call(print, \"trueType\"),\n        \" : \",\n        path.call(print, \"falseType\")\n      );\n      return concat(parts);\n    case \"TSInferType\":\n      parts.push(\"infer \", path.call(print, \"typeParameter\"));\n      return concat(parts);\n    case \"TSParenthesizedType\":\n      return concat([\"(\", path.call(print, \"typeAnnotation\"), \")\"]);\n    case \"TSFunctionType\":\n      return concat([\n        path.call(print, \"typeParameters\"),\n        \"(\",\n        printFunctionParams(path, options, print),\n        \") => \",\n        path.call(print, \"typeAnnotation\", \"typeAnnotation\")\n      ]);\n    case \"TSConstructorType\":\n      return concat([\n        \"new \",\n        path.call(print, \"typeParameters\"),\n        \"(\",\n        printFunctionParams(path, options, print),\n        \") => \",\n        path.call(print, \"typeAnnotation\", \"typeAnnotation\")\n      ]);\n    case \"TSMappedType\": {\n      parts.push(\n        n.readonly ? \"readonly \" : \"\",\n        \"[\",\n        path.call(print, \"typeParameter\"),\n        \"]\",\n        n.optional ? \"?\" : \"\"\n      );\n      if (n.typeAnnotation) {\n        parts.push(\": \", path.call(print, \"typeAnnotation\"), \";\");\n      }\n      return concat([\"{\\n\", concat(parts).indent(options.tabWidth), \"\\n}\"]);\n    }\n    case \"TSTupleType\":\n      return concat([\n        \"[\",\n        fromString(\", \").join(path.map(print, \"elementTypes\")),\n        \"]\"\n      ]);\n    case \"TSNamedTupleMember\":\n      parts.push(path.call(print, \"label\"));\n      if (n.optional) {\n        parts.push(\"?\");\n      }\n      parts.push(\": \", path.call(print, \"elementType\"));\n      return concat(parts);\n    case \"TSRestType\":\n      return concat([\"...\", path.call(print, \"typeAnnotation\")]);\n    case \"TSOptionalType\":\n      return concat([path.call(print, \"typeAnnotation\"), \"?\"]);\n    case \"TSIndexedAccessType\":\n      return concat([\n        path.call(print, \"objectType\"),\n        \"[\",\n        path.call(print, \"indexType\"),\n        \"]\"\n      ]);\n    case \"TSTypeOperator\":\n      return concat([\n        path.call(print, \"operator\"),\n        \" \",\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"TSTypeLiteral\": {\n      const members = fromString(\"\\n\").join(\n        path.map(print, \"members\").map((member) => {\n          if (lastNonSpaceCharacter(member) !== \";\") {\n            return member.concat(\";\");\n          }\n          return member;\n        })\n      );\n      if (members.isEmpty()) {\n        return fromString(\"{}\", options);\n      }\n      parts.push(\"{\\n\", members.indent(options.tabWidth), \"\\n}\");\n      return concat(parts);\n    }\n    case \"TSEnumMember\":\n      parts.push(path.call(print, \"id\"));\n      if (n.initializer) {\n        parts.push(\" = \", path.call(print, \"initializer\"));\n      }\n      return concat(parts);\n    case \"TSTypeQuery\":\n      return concat([\"typeof \", path.call(print, \"exprName\")]);\n    case \"TSParameterProperty\":\n      if (n.accessibility) {\n        parts.push(n.accessibility, \" \");\n      }\n      if (n.export) {\n        parts.push(\"export \");\n      }\n      if (n.static) {\n        parts.push(\"static \");\n      }\n      if (n.readonly) {\n        parts.push(\"readonly \");\n      }\n      parts.push(path.call(print, \"parameter\"));\n      return concat(parts);\n    case \"TSTypeReference\":\n      return concat([\n        path.call(print, \"typeName\"),\n        path.call(print, \"typeParameters\")\n      ]);\n    case \"TSQualifiedName\":\n      return concat([path.call(print, \"left\"), \".\", path.call(print, \"right\")]);\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\": {\n      const expression = path.call(print, \"expression\");\n      parts.push(\n        expression,\n        n.type === \"TSSatisfiesExpression\" ? \" satisfies \" : \" as \",\n        path.call(print, \"typeAnnotation\")\n      );\n      return concat(parts);\n    }\n    case \"TSTypeCastExpression\":\n      return concat([\n        path.call(print, \"expression\"),\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"TSNonNullExpression\":\n      return concat([path.call(print, \"expression\"), \"!\"]);\n    case \"TSTypeAnnotation\":\n      return concat([\": \", path.call(print, \"typeAnnotation\")]);\n    case \"TSIndexSignature\":\n      return concat([\n        n.readonly ? \"readonly \" : \"\",\n        \"[\",\n        path.map(print, \"parameters\"),\n        \"]\",\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"TSPropertySignature\":\n      parts.push(printVariance(path, print), n.readonly ? \"readonly \" : \"\");\n      if (n.computed) {\n        parts.push(\"[\", path.call(print, \"key\"), \"]\");\n      } else {\n        parts.push(path.call(print, \"key\"));\n      }\n      parts.push(n.optional ? \"?\" : \"\", path.call(print, \"typeAnnotation\"));\n      return concat(parts);\n    case \"TSMethodSignature\":\n      if (n.computed) {\n        parts.push(\"[\", path.call(print, \"key\"), \"]\");\n      } else {\n        parts.push(path.call(print, \"key\"));\n      }\n      if (n.optional) {\n        parts.push(\"?\");\n      }\n      parts.push(\n        path.call(print, \"typeParameters\"),\n        \"(\",\n        printFunctionParams(path, options, print),\n        \")\",\n        path.call(print, \"typeAnnotation\")\n      );\n      return concat(parts);\n    case \"TSTypePredicate\":\n      if (n.asserts) {\n        parts.push(\"asserts \");\n      }\n      parts.push(path.call(print, \"parameterName\"));\n      if (n.typeAnnotation) {\n        parts.push(\n          \" is \",\n          path.call(print, \"typeAnnotation\", \"typeAnnotation\")\n        );\n      }\n      return concat(parts);\n    case \"TSCallSignatureDeclaration\":\n      return concat([\n        path.call(print, \"typeParameters\"),\n        \"(\",\n        printFunctionParams(path, options, print),\n        \")\",\n        path.call(print, \"typeAnnotation\")\n      ]);\n    case \"TSConstructSignatureDeclaration\":\n      if (n.typeParameters) {\n        parts.push(\"new\", path.call(print, \"typeParameters\"));\n      } else {\n        parts.push(\"new \");\n      }\n      parts.push(\n        \"(\",\n        printFunctionParams(path, options, print),\n        \")\",\n        path.call(print, \"typeAnnotation\")\n      );\n      return concat(parts);\n    case \"TSTypeAliasDeclaration\":\n      return concat([\n        n.declare ? \"declare \" : \"\",\n        \"type \",\n        path.call(print, \"id\"),\n        path.call(print, \"typeParameters\"),\n        \" = \",\n        path.call(print, \"typeAnnotation\"),\n        \";\"\n      ]);\n    case \"TSTypeParameter\": {\n      parts.push(path.call(print, \"name\"));\n      const parent = path.getParentNode(0);\n      const isInMappedType = namedTypes.TSMappedType.check(parent);\n      if (n.constraint) {\n        parts.push(\n          isInMappedType ? \" in \" : \" extends \",\n          path.call(print, \"constraint\")\n        );\n      }\n      if (n[\"default\"]) {\n        parts.push(\" = \", path.call(print, \"default\"));\n      }\n      return concat(parts);\n    }\n    case \"TSTypeAssertion\": {\n      parts.push(\n        \"<\",\n        path.call(print, \"typeAnnotation\"),\n        \"> \",\n        path.call(print, \"expression\")\n      );\n      return concat(parts);\n    }\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameterInstantiation\":\n      return concat([\n        \"<\",\n        fromString(\", \").join(path.map(print, \"params\")),\n        \">\"\n      ]);\n    case \"TSEnumDeclaration\": {\n      parts.push(\n        n.declare ? \"declare \" : \"\",\n        n.const ? \"const \" : \"\",\n        \"enum \",\n        path.call(print, \"id\")\n      );\n      const memberLines = fromString(\",\\n\").join(path.map(print, \"members\"));\n      if (memberLines.isEmpty()) {\n        parts.push(\" {}\");\n      } else {\n        parts.push(\" {\\n\", memberLines.indent(options.tabWidth), \"\\n}\");\n      }\n      return concat(parts);\n    }\n    case \"TSExpressionWithTypeArguments\":\n      return concat([\n        path.call(print, \"expression\"),\n        path.call(print, \"typeParameters\")\n      ]);\n    case \"TSInterfaceBody\": {\n      const lines = fromString(\"\\n\").join(\n        path.map(print, \"body\").map((element) => {\n          if (lastNonSpaceCharacter(element) !== \";\") {\n            return element.concat(\";\");\n          }\n          return element;\n        })\n      );\n      if (lines.isEmpty()) {\n        return fromString(\"{}\", options);\n      }\n      return concat([\"{\\n\", lines.indent(options.tabWidth), \"\\n}\"]);\n    }\n    case \"TSImportType\":\n      parts.push(\"import(\", path.call(print, \"argument\"), \")\");\n      if (n.qualifier) {\n        parts.push(\".\", path.call(print, \"qualifier\"));\n      }\n      if (n.typeParameters) {\n        parts.push(path.call(print, \"typeParameters\"));\n      }\n      return concat(parts);\n    case \"TSImportEqualsDeclaration\":\n      if (n.isExport) {\n        parts.push(\"export \");\n      }\n      parts.push(\n        \"import \",\n        path.call(print, \"id\"),\n        \" = \",\n        path.call(print, \"moduleReference\")\n      );\n      return maybeAddSemicolon(concat(parts));\n    case \"TSExternalModuleReference\":\n      return concat([\"require(\", path.call(print, \"expression\"), \")\"]);\n    case \"TSModuleDeclaration\": {\n      const parent = path.getParentNode();\n      if (parent.type === \"TSModuleDeclaration\") {\n        parts.push(\".\");\n      } else {\n        if (n.declare) {\n          parts.push(\"declare \");\n        }\n        if (!n.global) {\n          const isExternal = n.id.type === \"StringLiteral\" || n.id.type === \"Literal\" && typeof n.id.value === \"string\";\n          if (isExternal) {\n            parts.push(\"module \");\n          } else if (n.loc && n.loc.lines && n.id.loc) {\n            const prefix = n.loc.lines.sliceString(n.loc.start, n.id.loc.start);\n            if (prefix.indexOf(\"module\") >= 0) {\n              parts.push(\"module \");\n            } else {\n              parts.push(\"namespace \");\n            }\n          } else {\n            parts.push(\"namespace \");\n          }\n        }\n      }\n      parts.push(path.call(print, \"id\"));\n      if (n.body) {\n        parts.push(\" \");\n        parts.push(path.call(print, \"body\"));\n      }\n      return concat(parts);\n    }\n    case \"TSModuleBlock\": {\n      const naked = path.call(\n        (bodyPath) => printStatementSequence(bodyPath, options, print),\n        \"body\"\n      );\n      if (naked.isEmpty()) {\n        parts.push(\"{}\");\n      } else {\n        parts.push(\"{\\n\", naked.indent(options.tabWidth), \"\\n}\");\n      }\n      return concat(parts);\n    }\n    case \"TSInstantiationExpression\": {\n      parts.push(\n        path.call(print, \"expression\"),\n        path.call(print, \"typeParameters\")\n      );\n      return concat(parts);\n    }\n    case \"V8IntrinsicIdentifier\":\n      return concat([\"%\", path.call(print, \"name\")]);\n    case \"TopicReference\":\n      return fromString(\"#\");\n    case \"ClassHeritage\":\n    case \"ComprehensionBlock\":\n    case \"ComprehensionExpression\":\n    case \"Glob\":\n    case \"GeneratorExpression\":\n    case \"LetStatement\":\n    case \"LetExpression\":\n    case \"GraphExpression\":\n    case \"GraphIndexExpression\":\n    case \"XMLDefaultDeclaration\":\n    case \"XMLAnyName\":\n    case \"XMLQualifiedIdentifier\":\n    case \"XMLFunctionQualifiedIdentifier\":\n    case \"XMLAttributeSelector\":\n    case \"XMLFilterExpression\":\n    case \"XML\":\n    case \"XMLElement\":\n    case \"XMLList\":\n    case \"XMLEscape\":\n    case \"XMLText\":\n    case \"XMLStartTag\":\n    case \"XMLEndTag\":\n    case \"XMLPointTag\":\n    case \"XMLName\":\n    case \"XMLAttribute\":\n    case \"XMLCdata\":\n    case \"XMLComment\":\n    case \"XMLProcessingInstruction\":\n    default:\n      debugger;\n      throw new Error(\"unknown type: \" + JSON.stringify(n.type));\n  }\n}\nfunction printDecorators(path, printPath) {\n  const parts = [];\n  const node = path.getValue();\n  if (node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration, it will be\n  // responsible for printing node.decorators.\n  !getParentExportDeclaration(path)) {\n    path.each(function(decoratorPath) {\n      parts.push(printPath(decoratorPath), \"\\n\");\n    }, \"decorators\");\n  } else if (isExportDeclaration(node) && node.declaration && node.declaration.decorators) {\n    path.each(\n      function(decoratorPath) {\n        parts.push(printPath(decoratorPath), \"\\n\");\n      },\n      \"declaration\",\n      \"decorators\"\n    );\n  }\n  return concat(parts);\n}\nfunction printStatementSequence(path, options, print) {\n  const filtered = [];\n  path.each(function(stmtPath) {\n    const stmt = stmtPath.getValue();\n    if (!stmt) {\n      return;\n    }\n    if (stmt.type === \"EmptyStatement\" && !(stmt.comments && stmt.comments.length > 0)) {\n      return;\n    }\n    if (namedTypes.Comment.check(stmt)) ; else if (namedTypes.Statement.check(stmt)) ; else {\n      isString.assert(stmt);\n    }\n    filtered.push({\n      node: stmt,\n      printed: print(stmtPath)\n    });\n  });\n  let prevTrailingSpace = null;\n  const len = filtered.length;\n  const parts = [];\n  filtered.forEach(function(info, i) {\n    const printed = info.printed;\n    const stmt = info.node;\n    const multiLine = printed.length > 1;\n    const notFirst = i > 0;\n    const notLast = i < len - 1;\n    let leadingSpace;\n    let trailingSpace;\n    const lines = stmt && stmt.loc && stmt.loc.lines;\n    const trueLoc = lines && options.reuseWhitespace && getTrueLoc(stmt, lines);\n    if (notFirst) {\n      if (trueLoc) {\n        const beforeStart = lines.skipSpaces(trueLoc.start, true);\n        const beforeStartLine = beforeStart ? beforeStart.line : 1;\n        const leadingGap = trueLoc.start.line - beforeStartLine;\n        leadingSpace = Array(leadingGap + 1).join(\"\\n\");\n      } else {\n        leadingSpace = multiLine ? \"\\n\\n\" : \"\\n\";\n      }\n    } else {\n      leadingSpace = \"\";\n    }\n    if (notLast) {\n      if (trueLoc) {\n        const afterEnd = lines.skipSpaces(trueLoc.end);\n        const afterEndLine = afterEnd ? afterEnd.line : lines.length;\n        const trailingGap = afterEndLine - trueLoc.end.line;\n        trailingSpace = Array(trailingGap + 1).join(\"\\n\");\n      } else {\n        trailingSpace = multiLine ? \"\\n\\n\" : \"\\n\";\n      }\n    } else {\n      trailingSpace = \"\";\n    }\n    parts.push(maxSpace(prevTrailingSpace, leadingSpace), printed);\n    if (notLast) {\n      prevTrailingSpace = trailingSpace;\n    } else if (trailingSpace) {\n      parts.push(trailingSpace);\n    }\n  });\n  return concat(parts);\n}\nfunction maxSpace(s1, s2) {\n  if (!s1 && !s2) {\n    return fromString(\"\");\n  }\n  if (!s1) {\n    return fromString(s2);\n  }\n  if (!s2) {\n    return fromString(s1);\n  }\n  const spaceLines1 = fromString(s1);\n  const spaceLines2 = fromString(s2);\n  if (spaceLines2.length > spaceLines1.length) {\n    return spaceLines2;\n  }\n  return spaceLines1;\n}\nfunction printClassMemberModifiers(node) {\n  const parts = [];\n  if (node.declare) {\n    parts.push(\"declare \");\n  }\n  const access = node.accessibility || node.access;\n  if (typeof access === \"string\") {\n    parts.push(access, \" \");\n  }\n  if (node.static) {\n    parts.push(\"static \");\n  }\n  if (node.override) {\n    parts.push(\"override \");\n  }\n  if (node.abstract) {\n    parts.push(\"abstract \");\n  }\n  if (node.readonly) {\n    parts.push(\"readonly \");\n  }\n  return parts;\n}\nfunction printMethod(path, options, print) {\n  const node = path.getNode();\n  const kind = node.kind;\n  const parts = [];\n  let nodeValue = node.value;\n  if (!namedTypes.FunctionExpression.check(nodeValue)) {\n    nodeValue = node;\n  }\n  parts.push(...printClassMemberModifiers(node));\n  if (nodeValue.async) {\n    parts.push(\"async \");\n  }\n  if (nodeValue.generator) {\n    parts.push(\"*\");\n  }\n  if (kind === \"get\" || kind === \"set\") {\n    parts.push(kind, \" \");\n  }\n  let key = path.call(print, \"key\");\n  if (node.computed) {\n    key = concat([\"[\", key, \"]\"]);\n  }\n  parts.push(key);\n  if (node.optional) {\n    parts.push(\"?\");\n  }\n  if (node === nodeValue) {\n    parts.push(\n      path.call(print, \"typeParameters\"),\n      \"(\",\n      printFunctionParams(path, options, print),\n      \")\",\n      path.call(print, \"returnType\")\n    );\n    if (node.body) {\n      parts.push(\" \", path.call(print, \"body\"));\n    } else {\n      parts.push(\";\");\n    }\n  } else {\n    parts.push(\n      path.call(print, \"value\", \"typeParameters\"),\n      \"(\",\n      path.call(\n        (valuePath) => printFunctionParams(valuePath, options, print),\n        \"value\"\n      ),\n      \")\",\n      path.call(print, \"value\", \"returnType\")\n    );\n    if (nodeValue.body) {\n      parts.push(\" \", path.call(print, \"value\", \"body\"));\n    } else {\n      parts.push(\";\");\n    }\n  }\n  return concat(parts);\n}\nfunction printArgumentsList(path, options, print) {\n  const printed = path.map(print, \"arguments\");\n  const trailingComma = isTrailingCommaEnabled(options, \"parameters\");\n  let joined = fromString(\", \").join(printed);\n  if (joined.getLineLength(1) > options.wrapColumn) {\n    joined = fromString(\",\\n\").join(printed);\n    return concat([\n      \"(\\n\",\n      joined.indent(options.tabWidth),\n      trailingComma ? \",\\n)\" : \"\\n)\"\n    ]);\n  }\n  return concat([\"(\", joined, \")\"]);\n}\nfunction printFunctionParams(path, options, print) {\n  const fun = path.getValue();\n  let params;\n  let printed = [];\n  if (fun.params) {\n    params = fun.params;\n    printed = path.map(print, \"params\");\n  } else if (fun.parameters) {\n    params = fun.parameters;\n    printed = path.map(print, \"parameters\");\n  }\n  if (fun.defaults) {\n    path.each(function(defExprPath) {\n      const i = defExprPath.getName();\n      const p = printed[i];\n      if (p && defExprPath.getValue()) {\n        printed[i] = concat([p, \" = \", print(defExprPath)]);\n      }\n    }, \"defaults\");\n  }\n  if (fun.rest) {\n    printed.push(concat([\"...\", path.call(print, \"rest\")]));\n  }\n  let joined = fromString(\", \").join(printed);\n  if (joined.length > 1 || joined.getLineLength(1) > options.wrapColumn) {\n    joined = fromString(\",\\n\").join(printed);\n    if (isTrailingCommaEnabled(options, \"parameters\") && !fun.rest && params[params.length - 1].type !== \"RestElement\") {\n      joined = concat([joined, \",\\n\"]);\n    } else {\n      joined = concat([joined, \"\\n\"]);\n    }\n    return concat([\"\\n\", joined.indent(options.tabWidth)]);\n  }\n  return joined;\n}\nfunction maybePrintImportAssertions(path, options, print) {\n  const n = path.getValue();\n  if (n.assertions && n.assertions.length > 0) {\n    const parts = [\" assert {\"];\n    const printed = path.map(print, \"assertions\");\n    const flat = fromString(\", \").join(printed);\n    if (flat.length > 1 || flat.getLineLength(1) > options.wrapColumn) {\n      parts.push(\n        \"\\n\",\n        fromString(\",\\n\").join(printed).indent(options.tabWidth),\n        \"\\n}\"\n      );\n    } else {\n      parts.push(\" \", flat, \" }\");\n    }\n    return concat(parts);\n  }\n  return fromString(\"\");\n}\nfunction printExportDeclaration(path, options, print) {\n  const decl = path.getValue();\n  const parts = [\"export \"];\n  if (decl.exportKind && decl.exportKind === \"type\") {\n    if (!decl.declaration) {\n      parts.push(\"type \");\n    }\n  }\n  const shouldPrintSpaces = options.objectCurlySpacing;\n  namedTypes.Declaration.assert(decl);\n  if (decl[\"default\"] || decl.type === \"ExportDefaultDeclaration\") {\n    parts.push(\"default \");\n  }\n  if (decl.declaration) {\n    parts.push(path.call(print, \"declaration\"));\n  } else if (decl.specifiers) {\n    if (decl.specifiers.length === 1 && decl.specifiers[0].type === \"ExportBatchSpecifier\") {\n      parts.push(\"*\");\n    } else if (decl.specifiers.length === 0) {\n      parts.push(\"{}\");\n    } else if (decl.specifiers[0].type === \"ExportDefaultSpecifier\") {\n      const unbracedSpecifiers = [];\n      const bracedSpecifiers = [];\n      path.each(function(specifierPath) {\n        const spec = specifierPath.getValue();\n        if (spec.type === \"ExportDefaultSpecifier\") {\n          unbracedSpecifiers.push(print(specifierPath));\n        } else {\n          bracedSpecifiers.push(print(specifierPath));\n        }\n      }, \"specifiers\");\n      unbracedSpecifiers.forEach((lines2, i) => {\n        if (i > 0) {\n          parts.push(\", \");\n        }\n        parts.push(lines2);\n      });\n      if (bracedSpecifiers.length > 0) {\n        let lines2 = fromString(\", \").join(bracedSpecifiers);\n        if (lines2.getLineLength(1) > options.wrapColumn) {\n          lines2 = concat([\n            fromString(\",\\n\").join(bracedSpecifiers).indent(options.tabWidth),\n            \",\"\n          ]);\n        }\n        if (unbracedSpecifiers.length > 0) {\n          parts.push(\", \");\n        }\n        if (lines2.length > 1) {\n          parts.push(\"{\\n\", lines2, \"\\n}\");\n        } else if (options.objectCurlySpacing) {\n          parts.push(\"{ \", lines2, \" }\");\n        } else {\n          parts.push(\"{\", lines2, \"}\");\n        }\n      }\n    } else {\n      parts.push(\n        shouldPrintSpaces ? \"{ \" : \"{\",\n        fromString(\", \").join(path.map(print, \"specifiers\")),\n        shouldPrintSpaces ? \" }\" : \"}\"\n      );\n    }\n    if (decl.source) {\n      parts.push(\n        \" from \",\n        path.call(print, \"source\"),\n        maybePrintImportAssertions(path, options, print)\n      );\n    }\n  }\n  let lines = concat(parts);\n  if (lastNonSpaceCharacter(lines) !== \";\" && !(decl.declaration && (decl.declaration.type === \"FunctionDeclaration\" || decl.declaration.type === \"ClassDeclaration\" || decl.declaration.type === \"TSModuleDeclaration\" || decl.declaration.type === \"TSInterfaceDeclaration\" || decl.declaration.type === \"TSEnumDeclaration\"))) {\n    lines = concat([lines, \";\"]);\n  }\n  return lines;\n}\nfunction printFlowDeclaration(path, parts) {\n  const parentExportDecl = getParentExportDeclaration(path);\n  if (parentExportDecl) ; else {\n    parts.unshift(\"declare \");\n  }\n  return concat(parts);\n}\nfunction printVariance(path, print) {\n  return path.call(function(variancePath) {\n    const value = variancePath.getValue();\n    if (value) {\n      if (value === \"plus\") {\n        return fromString(\"+\");\n      }\n      if (value === \"minus\") {\n        return fromString(\"-\");\n      }\n      return print(variancePath);\n    }\n    return fromString(\"\");\n  }, \"variance\");\n}\nfunction adjustClause(clause, options) {\n  if (clause.length > 1)\n    return concat([\" \", clause]);\n  return concat([\"\\n\", maybeAddSemicolon(clause).indent(options.tabWidth)]);\n}\nfunction lastNonSpaceCharacter(lines) {\n  const pos = lines.lastPos();\n  do {\n    const ch = lines.charAt(pos);\n    if (/\\S/.test(ch))\n      return ch;\n  } while (lines.prevPos(pos));\n}\nfunction endsWithBrace(lines) {\n  return lastNonSpaceCharacter(lines) === \"}\";\n}\nfunction swapQuotes(str) {\n  return str.replace(/['\"]/g, (m) => m === '\"' ? \"'\" : '\"');\n}\nfunction getPossibleRaw(node) {\n  const value = getFieldValue(node, \"value\");\n  const extra = getFieldValue(node, \"extra\");\n  if (extra && typeof extra.raw === \"string\" && value == extra.rawValue) {\n    return extra.raw;\n  }\n  if (node.type === \"Literal\") {\n    const raw = node.raw;\n    if (typeof raw === \"string\" && value == raw) {\n      return raw;\n    }\n  }\n}\nfunction jsSafeStringify(str) {\n  return JSON.stringify(str).replace(/[\\u2028\\u2029]/g, function(m) {\n    return \"\\\\u\" + m.charCodeAt(0).toString(16);\n  });\n}\nfunction nodeStr(str, options) {\n  isString.assert(str);\n  switch (options.quote) {\n    case \"auto\": {\n      const double = jsSafeStringify(str);\n      const single = swapQuotes(jsSafeStringify(swapQuotes(str)));\n      return double.length > single.length ? single : double;\n    }\n    case \"single\":\n      return swapQuotes(jsSafeStringify(swapQuotes(str)));\n    case \"double\":\n    default:\n      return jsSafeStringify(str);\n  }\n}\nfunction maybeAddSemicolon(lines) {\n  const eoc = lastNonSpaceCharacter(lines);\n  if (!eoc || \"\\n};\".indexOf(eoc) < 0)\n    return concat([lines, \";\"]);\n  return lines;\n}\n\nfunction print(node, options) {\n  return new Printer(options).print(node);\n}\n\nlet _babelParser;\nfunction getBabelParser() {\n  if (_babelParser) {\n    return _babelParser;\n  }\n  const babelOptions = _getBabelOptions();\n  _babelParser = {\n    parse(source, options) {\n      return _babel_parser__WEBPACK_IMPORTED_MODULE_3__.parse(source, {\n        ...babelOptions,\n        ...options\n      });\n    }\n  };\n  return _babelParser;\n}\nfunction _getBabelOptions() {\n  return {\n    sourceType: \"module\",\n    strictMode: false,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    startLine: 1,\n    tokens: true,\n    plugins: [\n      \"asyncGenerators\",\n      \"bigInt\",\n      \"classPrivateMethods\",\n      \"classPrivateProperties\",\n      \"classProperties\",\n      \"classStaticBlock\",\n      \"decimal\",\n      \"decorators-legacy\",\n      \"doExpressions\",\n      \"dynamicImport\",\n      \"exportDefaultFrom\",\n      \"exportExtensions\",\n      \"exportNamespaceFrom\",\n      \"functionBind\",\n      \"functionSent\",\n      \"importAssertions\",\n      \"importMeta\",\n      \"nullishCoalescingOperator\",\n      \"numericSeparator\",\n      \"objectRestSpread\",\n      \"optionalCatchBinding\",\n      \"optionalChaining\",\n      [\n        \"pipelineOperator\",\n        {\n          proposal: \"minimal\"\n        }\n      ],\n      [\n        \"recordAndTuple\",\n        {\n          syntaxType: \"hash\"\n        }\n      ],\n      \"throwExpressions\",\n      \"topLevelAwait\",\n      \"v8intrinsic\",\n      \"jsx\",\n      \"typescript\"\n    ]\n  };\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass MagicastError extends Error {\n  constructor(message, options) {\n    super(\"\");\n    __publicField(this, \"rawMessage\");\n    __publicField(this, \"options\");\n    this.name = \"MagicastError\";\n    this.rawMessage = message;\n    this.options = options;\n    if (options?.ast && options?.code && options.ast.loc) {\n      const { line, column } = options.ast.loc.start;\n      const lines = options.code.split(\"\\n\");\n      const start = Math.max(0, line - 3);\n      const end = Math.min(lines.length, line + 3);\n      const codeFrame = lines.slice(start, end).map((lineCode, i) => {\n        const number = (start + i + 1).toString().padStart(3, \" \");\n        lineCode = `${number} | ${lineCode}`;\n        if (start + i === line - 1) {\n          lineCode += `\n${\" \".repeat(6 + column)}^`;\n        }\n        return lineCode;\n      });\n      message += `\n\n${codeFrame.join(\"\\n\")}\n`;\n    }\n    this.message = message;\n  }\n}\n\nconst LITERALS_AST = /* @__PURE__ */ new Set([\n  \"Literal\",\n  \"StringLiteral\",\n  \"NumericLiteral\",\n  \"BooleanLiteral\",\n  \"NullLiteral\",\n  \"RegExpLiteral\",\n  \"BigIntLiteral\"\n]);\nconst LITERALS_TYPEOF = /* @__PURE__ */ new Set([\n  \"string\",\n  \"number\",\n  \"boolean\",\n  \"bigint\",\n  \"symbol\",\n  \"undefined\"\n]);\nconst b$4 = builders$1;\nfunction isValidPropName(name) {\n  return /^[$A-Z_a-z][\\w$]*$/.test(name);\n}\nconst PROXY_KEY = \"__magicast_proxy\";\nfunction literalToAst(value, seen = /* @__PURE__ */ new Set()) {\n  if (value === void 0) {\n    return b$4.identifier(\"undefined\");\n  }\n  if (value === null) {\n    return b$4.literal(null);\n  }\n  if (LITERALS_TYPEOF.has(typeof value)) {\n    return b$4.literal(value);\n  }\n  if (seen.has(value)) {\n    throw new MagicastError(\"Can not serialize circular reference\");\n  }\n  seen.add(value);\n  if (value[PROXY_KEY]) {\n    return value.$ast;\n  }\n  if (value instanceof RegExp) {\n    const regex = b$4.regExpLiteral(value.source, value.flags);\n    delete regex.extra.raw;\n    return regex;\n  }\n  if (value instanceof Set) {\n    return b$4.newExpression(b$4.identifier(\"Set\"), [\n      b$4.arrayExpression([...value].map((n) => literalToAst(n, seen)))\n    ]);\n  }\n  if (value instanceof Date) {\n    return b$4.newExpression(b$4.identifier(\"Date\"), [\n      b$4.literal(value.toISOString())\n    ]);\n  }\n  if (value instanceof Map) {\n    return b$4.newExpression(b$4.identifier(\"Map\"), [\n      b$4.arrayExpression(\n        [...value].map(([key, value2]) => {\n          return b$4.arrayExpression([\n            literalToAst(key, seen),\n            literalToAst(value2, seen)\n          ]);\n        })\n      )\n    ]);\n  }\n  if (Array.isArray(value)) {\n    return b$4.arrayExpression(\n      value.map((n) => literalToAst(n, seen))\n    );\n  }\n  if (typeof value === \"object\") {\n    return b$4.objectExpression(\n      Object.entries(value).map(([key, value2]) => {\n        return b$4.property(\n          \"init\",\n          /^[$A-Z_a-z][\\w$]*$/g.test(key) ? b$4.identifier(key) : b$4.literal(key),\n          literalToAst(value2, seen)\n        );\n      })\n    );\n  }\n  return b$4.literal(value);\n}\nfunction makeProxyUtils(node, extend = {}) {\n  const obj = extend;\n  obj[PROXY_KEY] = true;\n  obj.$ast = node;\n  obj.$type || (obj.$type = \"object\");\n  return obj;\n}\nconst propertyDescriptor = {\n  enumerable: true,\n  configurable: true\n};\nfunction createProxy(node, extend, handler) {\n  const utils = makeProxyUtils(node, extend);\n  return new Proxy(\n    {},\n    {\n      ownKeys() {\n        return Object.keys(utils).filter(\n          (i) => i !== PROXY_KEY && !i.startsWith(\"$\")\n        );\n      },\n      getOwnPropertyDescriptor() {\n        return propertyDescriptor;\n      },\n      has(_target, key) {\n        if (key in utils) {\n          return true;\n        }\n        return false;\n      },\n      ...handler,\n      get(target, key, receiver) {\n        if (key in utils) {\n          return utils[key];\n        }\n        if (handler.get) {\n          return handler.get(target, key, receiver);\n        }\n      },\n      set(target, key, value, receiver) {\n        if (key in utils) {\n          utils[key] = value;\n          return true;\n        }\n        if (handler.set) {\n          return handler.set(target, key, value, receiver);\n        }\n        return false;\n      }\n    }\n  );\n}\n\nconst b$3 = builders$1;\nconst _importProxyCache = /* @__PURE__ */ new WeakMap();\nfunction creatImportProxy(node, specifier, root) {\n  if (_importProxyCache.has(specifier)) {\n    return _importProxyCache.get(specifier);\n  }\n  const proxy = createProxy(\n    specifier,\n    {\n      get $declaration() {\n        return node;\n      },\n      get imported() {\n        if (specifier.type === \"ImportDefaultSpecifier\") {\n          return \"default\";\n        }\n        if (specifier.type === \"ImportNamespaceSpecifier\") {\n          return \"*\";\n        }\n        if (specifier.imported.type === \"Identifier\") {\n          return specifier.imported.name;\n        }\n        return specifier.imported.value;\n      },\n      set imported(value) {\n        if (specifier.type !== \"ImportSpecifier\") {\n          throw new MagicastError(\n            \"Changing import name is not yet implemented\"\n          );\n        }\n        if (specifier.imported.type === \"Identifier\") {\n          specifier.imported.name = value;\n        } else {\n          specifier.imported.value = value;\n        }\n      },\n      get local() {\n        return specifier.local.name;\n      },\n      set local(value) {\n        specifier.local.name = value;\n      },\n      get from() {\n        return node.source.value;\n      },\n      set from(value) {\n        if (value === node.source.value) {\n          return;\n        }\n        node.specifiers = node.specifiers.filter((s) => s !== specifier);\n        if (node.specifiers.length === 0) {\n          root.body = root.body.filter((s) => s !== node);\n        }\n        const declaration = root.body.find(\n          (i) => i.type === \"ImportDeclaration\" && i.source.value === value\n        );\n        if (declaration) {\n          declaration.specifiers.push(specifier);\n        } else {\n          root.body.unshift(\n            b$3.importDeclaration(\n              [specifier],\n              b$3.stringLiteral(value)\n            )\n          );\n        }\n      },\n      toJSON() {\n        return {\n          imported: this.imported,\n          local: this.local,\n          from: this.from\n        };\n      }\n    },\n    {\n      ownKeys() {\n        return [\"imported\", \"local\", \"from\", \"toJSON\"];\n      }\n    }\n  );\n  _importProxyCache.set(specifier, proxy);\n  return proxy;\n}\nfunction createImportsProxy(root, mod) {\n  const getAllImports = () => {\n    const imports = [];\n    for (const n of root.body) {\n      if (n.type === \"ImportDeclaration\") {\n        for (const specifier of n.specifiers) {\n          imports.push(creatImportProxy(n, specifier, root));\n        }\n      }\n    }\n    return imports;\n  };\n  const updateImport = (key, value, order) => {\n    const imports = getAllImports();\n    const item = imports.find((i) => i.local === key);\n    const local = value.local || key;\n    if (item) {\n      item.imported = value.imported;\n      item.local = local;\n      item.from = value.from;\n      return true;\n    }\n    const specifier = value.imported === \"default\" ? b$3.importDefaultSpecifier(b$3.identifier(local)) : value.imported === \"*\" ? b$3.importNamespaceSpecifier(b$3.identifier(local)) : b$3.importSpecifier(\n      b$3.identifier(value.imported),\n      b$3.identifier(local)\n    );\n    const declaration = imports.find(\n      (i) => i.from === value.from\n    )?.$declaration;\n    if (declaration) {\n      declaration.specifiers.push(specifier);\n    } else if (order === \"prepend\" || imports.length === 0) {\n      root.body.unshift(\n        b$3.importDeclaration([specifier], b$3.stringLiteral(value.from))\n      );\n    } else {\n      const lastImport = imports.at(-1).$declaration;\n      const lastImportIndex = root.body.indexOf(lastImport);\n      root.body.splice(\n        lastImportIndex + 1,\n        0,\n        b$3.importDeclaration([specifier], b$3.stringLiteral(value.from))\n      );\n    }\n    return true;\n  };\n  const removeImport = (key) => {\n    const item = getAllImports().find((i) => i.local === key);\n    if (!item) {\n      return false;\n    }\n    const node = item.$declaration;\n    const specifier = item.$ast;\n    node.specifiers = node.specifiers.filter((s) => s !== specifier);\n    if (node.specifiers.length === 0) {\n      root.body = root.body.filter((n) => n !== node);\n    }\n    return true;\n  };\n  const proxy = createProxy(\n    root,\n    {\n      $type: \"imports\",\n      $add(item) {\n        updateImport(item.local || item.imported, item, \"prepend\");\n      },\n      $prepend(item) {\n        updateImport(item.local || item.imported, item, \"prepend\");\n      },\n      $append(item) {\n        updateImport(item.local || item.imported, item, \"append\");\n      },\n      get $items() {\n        return getAllImports();\n      },\n      toJSON() {\n        return getAllImports().reduce((acc, i) => {\n          acc[i.local] = i;\n          return acc;\n        }, {});\n      }\n    },\n    {\n      get(_, prop) {\n        return getAllImports().find((i) => i.local === prop);\n      },\n      set(_, prop, value) {\n        return updateImport(prop, value, \"prepend\");\n      },\n      deleteProperty(_, prop) {\n        return removeImport(prop);\n      },\n      ownKeys() {\n        return getAllImports().map((i) => i.local);\n      },\n      has(_, prop) {\n        return getAllImports().some((i) => i.local === prop);\n      }\n    }\n  );\n  return proxy;\n}\n\nfunction proxifyArrayElements(node, elements, mod) {\n  const getItem = (key) => {\n    return elements[key];\n  };\n  const replaceItem = (key, value) => {\n    elements[key] = value;\n  };\n  return createProxy(\n    node,\n    {\n      $type: \"array\",\n      push(value) {\n        elements.push(literalToAst(value));\n      },\n      pop() {\n        return proxify(elements.pop(), mod);\n      },\n      unshift(value) {\n        elements.unshift(literalToAst(value));\n      },\n      shift() {\n        return proxify(elements.shift(), mod);\n      },\n      splice(start, deleteCount, ...items) {\n        const deleted = elements.splice(\n          start,\n          deleteCount,\n          ...items.map((n) => literalToAst(n))\n        );\n        return deleted.map((n) => proxify(n, mod));\n      },\n      find(predicate) {\n        return elements.map((n) => proxify(n, mod)).find(predicate);\n      },\n      findIndex(predicate) {\n        return elements.map((n) => proxify(n, mod)).findIndex(predicate);\n      },\n      includes(value) {\n        return elements.map((n) => proxify(n, mod)).includes(value);\n      },\n      toJSON() {\n        return elements.map((n) => proxify(n, mod));\n      }\n    },\n    {\n      get(_, key) {\n        if (key === \"length\") {\n          return elements.length;\n        }\n        if (key === Symbol.iterator) {\n          return function* () {\n            for (const item of elements) {\n              yield proxify(item, mod);\n            }\n          };\n        }\n        if (typeof key === \"symbol\") {\n          return;\n        }\n        const index = +key;\n        if (Number.isNaN(index)) {\n          return;\n        }\n        const prop = getItem(index);\n        if (prop) {\n          return proxify(prop, mod);\n        }\n      },\n      set(_, key, value) {\n        if (typeof key === \"symbol\") {\n          return false;\n        }\n        const index = +key;\n        if (Number.isNaN(index)) {\n          return false;\n        }\n        replaceItem(index, literalToAst(value));\n        return true;\n      },\n      deleteProperty(_, key) {\n        if (typeof key === \"symbol\") {\n          return false;\n        }\n        const index = +key;\n        if (Number.isNaN(index)) {\n          return false;\n        }\n        elements[index] = literalToAst(void 0);\n        return true;\n      },\n      ownKeys() {\n        return [\"length\", ...elements.map((_, i) => i.toString())];\n      }\n    }\n  );\n}\nfunction proxifyArray(node, mod) {\n  if (!(\"elements\" in node)) {\n    return void 0;\n  }\n  return proxifyArrayElements(node, node.elements, mod);\n}\n\nfunction proxifyFunctionCall(node, mod) {\n  if (node.type !== \"CallExpression\") {\n    throw new MagicastError(\"Not a function call\");\n  }\n  function stringifyExpression(node2) {\n    if (node2.type === \"Identifier\") {\n      return node2.name;\n    }\n    if (node2.type === \"MemberExpression\") {\n      return `${stringifyExpression(node2.object)}.${stringifyExpression(\n        node2.property\n      )}`;\n    }\n    throw new MagicastError(\"Not implemented\");\n  }\n  const argumentsProxy = proxifyArrayElements(node, node.arguments, mod);\n  return createProxy(\n    node,\n    {\n      $type: \"function-call\",\n      $callee: stringifyExpression(node.callee),\n      $args: argumentsProxy\n    },\n    {}\n  );\n}\n\nfunction proxifyArrowFunctionExpression(node, mod) {\n  if (node.type !== \"ArrowFunctionExpression\") {\n    throw new MagicastError(\"Not an arrow function expression\");\n  }\n  const parametersProxy = proxifyArrayElements(node, node.params, mod);\n  return createProxy(\n    node,\n    {\n      $type: \"arrow-function-expression\",\n      $params: parametersProxy,\n      $body: proxify(node.body, mod)\n    },\n    {}\n  );\n}\n\nconst b$2 = builders$1;\nfunction proxifyObject(node, mod) {\n  if (!(\"properties\" in node)) {\n    return void 0;\n  }\n  const getProp = (key) => {\n    for (const prop of node.properties) {\n      if (\"key\" in prop && \"name\" in prop.key && prop.key.name === key) {\n        return prop.value;\n      }\n      if (prop.type === \"ObjectProperty\" && (prop.key.type === \"StringLiteral\" || prop.key.type === \"NumericLiteral\" || prop.key.type === \"BooleanLiteral\") && prop.key.value.toString() === key) {\n        return prop.value.value ?? prop.value;\n      }\n    }\n  };\n  const getPropName = (prop, throwError = false) => {\n    if (\"key\" in prop && \"name\" in prop.key) {\n      return prop.key.name;\n    }\n    if (prop.type === \"ObjectProperty\" && (prop.key.type === \"StringLiteral\" || prop.key.type === \"NumericLiteral\" || prop.key.type === \"BooleanLiteral\")) {\n      return prop.key.value.toString();\n    }\n    if (throwError) {\n      throw new MagicastError(`Casting \"${prop.type}\" is not supported`, {\n        ast: prop,\n        code: mod?.$code\n      });\n    }\n  };\n  const replaceOrAddProp = (key, value) => {\n    const prop = node.properties.find(\n      (prop2) => getPropName(prop2) === key\n    );\n    if (prop) {\n      prop.value = value;\n    } else if (isValidPropName(key)) {\n      node.properties.push({\n        type: \"Property\",\n        key: {\n          type: \"Identifier\",\n          name: key\n        },\n        value\n      });\n    } else {\n      node.properties.push({\n        type: \"ObjectProperty\",\n        key: b$2.stringLiteral(key),\n        value\n      });\n    }\n  };\n  return createProxy(\n    node,\n    {\n      $type: \"object\",\n      toJSON() {\n        return node.properties.reduce((acc, prop) => {\n          if (\"key\" in prop && \"name\" in prop.key) {\n            acc[prop.key.name] = proxify(prop.value, mod);\n          }\n          return acc;\n        }, {});\n      }\n    },\n    {\n      get(_, key) {\n        const prop = getProp(key);\n        if (prop) {\n          return proxify(prop, mod);\n        }\n      },\n      set(_, key, value) {\n        if (typeof key !== \"string\") {\n          key = String(key);\n        }\n        replaceOrAddProp(key, literalToAst(value));\n        return true;\n      },\n      deleteProperty(_, key) {\n        if (typeof key !== \"string\") {\n          key = String(key);\n        }\n        const index = node.properties.findIndex(\n          (prop) => \"key\" in prop && \"name\" in prop.key && prop.key.name === key\n        );\n        if (index !== -1) {\n          node.properties.splice(index, 1);\n        }\n        return true;\n      },\n      ownKeys() {\n        return node.properties.map((prop) => getPropName(prop, true)).filter(Boolean);\n      }\n    }\n  );\n}\n\nfunction proxifyNewExpression(node, mod) {\n  if (node.type !== \"NewExpression\") {\n    throw new MagicastError(\"Not a new expression\");\n  }\n  function stringifyExpression(node2) {\n    if (node2.type === \"Identifier\") {\n      return node2.name;\n    }\n    if (node2.type === \"MemberExpression\") {\n      return `${stringifyExpression(node2.object)}.${stringifyExpression(\n        node2.property\n      )}`;\n    }\n    throw new MagicastError(\"Not implemented\");\n  }\n  const argumentsProxy = proxifyArrayElements(node, node.arguments, mod);\n  return createProxy(\n    node,\n    {\n      $type: \"new-expression\",\n      $callee: stringifyExpression(node.callee),\n      $args: argumentsProxy\n    },\n    {}\n  );\n}\n\nfunction proxifyIdentifier(node) {\n  if (node.type !== \"Identifier\") {\n    throw new MagicastError(\"Not an identifier\");\n  }\n  return createProxy(\n    node,\n    {\n      $type: \"identifier\",\n      $name: node.name\n    },\n    {}\n  );\n}\n\nfunction proxifyLogicalExpression(node) {\n  if (node.type !== \"LogicalExpression\") {\n    throw new MagicastError(\"Not a logical expression\");\n  }\n  return createProxy(\n    node,\n    {\n      $type: \"logicalExpression\"\n    },\n    {}\n  );\n}\n\nfunction proxifyMemberExpression(node) {\n  if (node.type !== \"MemberExpression\") {\n    throw new MagicastError(\"Not a member expression\");\n  }\n  return createProxy(\n    node,\n    {\n      $type: \"memberExpression\"\n    },\n    {}\n  );\n}\n\nconst _cache = /* @__PURE__ */ new WeakMap();\nfunction proxify(node, mod) {\n  if (LITERALS_TYPEOF.has(typeof node)) {\n    return node;\n  }\n  if (LITERALS_AST.has(node.type)) {\n    return node.value;\n  }\n  if (_cache.has(node)) {\n    return _cache.get(node);\n  }\n  let proxy;\n  switch (node.type) {\n    case \"ObjectExpression\": {\n      proxy = proxifyObject(node, mod);\n      break;\n    }\n    case \"ArrayExpression\": {\n      proxy = proxifyArray(node, mod);\n      break;\n    }\n    case \"CallExpression\": {\n      proxy = proxifyFunctionCall(node, mod);\n      break;\n    }\n    case \"ArrowFunctionExpression\": {\n      proxy = proxifyArrowFunctionExpression(node, mod);\n      break;\n    }\n    case \"NewExpression\": {\n      proxy = proxifyNewExpression(node, mod);\n      break;\n    }\n    case \"Identifier\": {\n      proxy = proxifyIdentifier(node);\n      break;\n    }\n    case \"LogicalExpression\": {\n      proxy = proxifyLogicalExpression(node);\n      break;\n    }\n    case \"MemberExpression\": {\n      proxy = proxifyMemberExpression(node);\n      break;\n    }\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\": {\n      proxy = proxify(node.expression, mod);\n      break;\n    }\n    default: {\n      throw new MagicastError(`Casting \"${node.type}\" is not supported`, {\n        ast: node,\n        code: mod?.$code\n      });\n    }\n  }\n  _cache.set(node, proxy);\n  return proxy;\n}\n\nconst b$1 = builders$1;\nfunction createExportsProxy(root, mod) {\n  const findExport = (key) => {\n    const type = key === \"default\" ? \"ExportDefaultDeclaration\" : \"ExportNamedDeclaration\";\n    for (const n of root.body) {\n      if (n.type === type) {\n        if (key === \"default\") {\n          return n.declaration;\n        }\n        if (n.declaration && \"declarations\" in n.declaration) {\n          const dec = n.declaration.declarations[0];\n          if (\"name\" in dec.id && dec.id.name === key) {\n            return dec.init;\n          }\n        }\n      }\n    }\n  };\n  const updateOrAddExport = (key, value) => {\n    const type = key === \"default\" ? \"ExportDefaultDeclaration\" : \"ExportNamedDeclaration\";\n    const node = literalToAst(value);\n    for (const n of root.body) {\n      if (n.type === type) {\n        if (key === \"default\") {\n          n.declaration = node;\n          return;\n        }\n        if (n.declaration && \"declarations\" in n.declaration) {\n          const dec = n.declaration.declarations[0];\n          if (\"name\" in dec.id && dec.id.name === key) {\n            dec.init = node;\n            return;\n          }\n        }\n      }\n    }\n    root.body.push(\n      key === \"default\" ? b$1.exportDefaultDeclaration(node) : b$1.exportNamedDeclaration(\n        b$1.variableDeclaration(\"const\", [\n          b$1.variableDeclarator(b$1.identifier(key), node)\n        ])\n      )\n    );\n  };\n  return createProxy(\n    root,\n    {\n      $type: \"exports\"\n    },\n    {\n      get(_, prop) {\n        const node = findExport(prop);\n        if (node) {\n          return proxify(node, mod);\n        }\n      },\n      set(_, prop, value) {\n        updateOrAddExport(prop, value);\n        return true;\n      },\n      ownKeys() {\n        return root.body.flatMap((i) => {\n          if (i.type === \"ExportDefaultDeclaration\") {\n            return [\"default\"];\n          }\n          if (i.type === \"ExportNamedDeclaration\" && i.declaration && \"declarations\" in i.declaration) {\n            return i.declaration.declarations.map(\n              (d) => \"name\" in d.id ? d.id.name : \"\"\n            );\n          }\n          return [];\n        }).filter(Boolean);\n      },\n      deleteProperty(_, prop) {\n        const type = prop === \"default\" ? \"ExportDefaultDeclaration\" : \"ExportNamedDeclaration\";\n        for (let i = 0; i < root.body.length; i++) {\n          const n = root.body[i];\n          if (n.type === type) {\n            if (prop === \"default\") {\n              root.body.splice(i, 1);\n              return true;\n            }\n            if (n.declaration && \"declarations\" in n.declaration) {\n              const dec = n.declaration.declarations[0];\n              if (\"name\" in dec.id && dec.id.name === prop) {\n                root.body.splice(i, 1);\n                return true;\n              }\n            }\n          }\n        }\n        return false;\n      }\n    }\n  );\n}\n\nfunction proxifyModule(ast, code) {\n  const root = ast.program;\n  if (root.type !== \"Program\") {\n    throw new MagicastError(`Cannot proxify ${ast.type} as module`);\n  }\n  const util = {\n    $code: code,\n    $type: \"module\"\n  };\n  const mod = createProxy(root, util, {\n    ownKeys() {\n      return [\"imports\", \"exports\", \"generate\"];\n    }\n  });\n  util.exports = createExportsProxy(root, mod);\n  util.imports = createImportsProxy(root);\n  util.generate = (options) => generateCode(mod, options);\n  return mod;\n}\n\nfunction detectCodeFormat(code, userStyles = {}) {\n  const detect = {\n    wrapColumn: userStyles.wrapColumn === void 0,\n    indent: userStyles.tabWidth === void 0 || userStyles.useTabs === void 0,\n    quote: userStyles.quote === void 0,\n    arrowParens: userStyles.arrowParensAlways === void 0,\n    trailingComma: userStyles.trailingComma === void 0\n  };\n  let codeIndent = 2;\n  let tabUsages = 0;\n  let semiUsages = 0;\n  let maxLineLength = 0;\n  let multiLineTrailingCommaUsages = 0;\n  const syntaxDetectRegex = /(?<doubleQuote>\"[^\"]+\")|(?<singleQuote>'[^']+')|(?<singleParam>\\([^),]+\\)\\s*=>)|(?<trailingComma>,\\s*[\\]}])/g;\n  const syntaxUsages = {\n    doubleQuote: 0,\n    singleQuote: 0,\n    singleParam: 0,\n    trailingComma: 0\n  };\n  const lines = (code || \"\").split(\"\\n\");\n  let previousLineTrailing = false;\n  for (const line of lines) {\n    const trimmitedLine = line.trim();\n    if (trimmitedLine.length === 0) {\n      continue;\n    }\n    if (detect.wrapColumn && line.length > maxLineLength) {\n      maxLineLength = line.length;\n    }\n    if (detect.indent) {\n      const lineIndent = line.match(/^\\s+/)?.[0] || \"\";\n      if (lineIndent.length > 0) {\n        if (lineIndent.length > 0 && lineIndent.length < codeIndent) {\n          codeIndent = lineIndent.length;\n        }\n        if (lineIndent[0] === \"\t\") {\n          tabUsages++;\n        } else if (lineIndent.length > 0) {\n          tabUsages--;\n        }\n      }\n    }\n    if (trimmitedLine.at(-1) === \";\") {\n      semiUsages++;\n    } else if (trimmitedLine.length > 0) {\n      semiUsages--;\n    }\n    if (detect.quote || detect.arrowParens) {\n      const matches = trimmitedLine.matchAll(syntaxDetectRegex);\n      for (const match of matches) {\n        if (!match.groups) {\n          continue;\n        }\n        for (const key in syntaxUsages) {\n          if (match.groups[key]) {\n            syntaxUsages[key]++;\n          }\n        }\n      }\n    }\n    if (detect.trailingComma) {\n      if (line.startsWith(\"}\") || line.startsWith(\"]\")) {\n        if (previousLineTrailing) {\n          multiLineTrailingCommaUsages++;\n        } else {\n          multiLineTrailingCommaUsages--;\n        }\n      }\n      previousLineTrailing = trimmitedLine.endsWith(\",\");\n    }\n  }\n  return {\n    wrapColumn: maxLineLength,\n    useTabs: tabUsages > 0,\n    tabWidth: codeIndent,\n    quote: syntaxUsages.singleQuote > syntaxUsages.doubleQuote ? \"single\" : \"double\",\n    arrowParensAlways: syntaxUsages.singleParam > 0,\n    trailingComma: multiLineTrailingCommaUsages > 0 || syntaxUsages.trailingComma > 0,\n    useSemi: semiUsages > 0,\n    arrayBracketSpacing: void 0,\n    // TODO\n    objectCurlySpacing: void 0,\n    // TODO\n    ...userStyles\n  };\n}\n\nfunction parseModule(code, options) {\n  const node = parse(code, {\n    parser: options?.parser || getBabelParser(),\n    ...options\n  });\n  return proxifyModule(node, code);\n}\nfunction parseExpression(code, options) {\n  const root = parse(\"(\" + code + \")\", {\n    parser: options?.parser || getBabelParser(),\n    ...options\n  });\n  let body = root.program.body[0];\n  if (body.type === \"ExpressionStatement\") {\n    body = body.expression;\n  }\n  if (body.extra?.parenthesized) {\n    body.extra.parenthesized = false;\n  }\n  const mod = {\n    $ast: root,\n    $code: \" \" + code + \" \",\n    $type: \"module\"\n  };\n  return proxify(body, mod);\n}\nfunction generateCode(node, options = {}) {\n  const ast = node.$ast || node;\n  const formatOptions = options.format === false || !(\"$code\" in node) ? {} : detectCodeFormat(node.$code, options.format);\n  const { code, map } = print(ast, {\n    ...options,\n    ...formatOptions\n  });\n  return { code, map };\n}\nasync function loadFile(filename, options = {}) {\n  const contents = await node_fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(filename, \"utf8\");\n  options.sourceFileName = options.sourceFileName ?? filename;\n  return parseModule(contents, options);\n}\nasync function writeFile(node, filename, options) {\n  const ast = \"$ast\" in node ? node.$ast : node;\n  const { code, map } = generateCode(ast, options);\n  await node_fs__WEBPACK_IMPORTED_MODULE_0__.promises.writeFile(filename, code);\n  if (map) {\n    await node_fs__WEBPACK_IMPORTED_MODULE_0__.promises.writeFile(filename + \".map\", map);\n  }\n}\n\nconst b = builders$1;\nconst builders = {\n  /**\n   * Create a function call node.\n   */\n  functionCall(callee, ...args) {\n    const node = b.callExpression(\n      b.identifier(callee),\n      args.map((i) => literalToAst(i))\n    );\n    return proxifyFunctionCall(node);\n  },\n  /**\n   * Create a new expression node.\n   */\n  newExpression(callee, ...args) {\n    const node = b.newExpression(\n      b.identifier(callee),\n      args.map((i) => literalToAst(i))\n    );\n    return proxifyNewExpression(node);\n  },\n  /**\n   * Create a proxified version of a literal value.\n   */\n  literal(value) {\n    return literalToAst(value);\n  },\n  /**\n   * Parse a raw expression and return a proxified version of it.\n   *\n   * ```ts\n   * const obj = builders.raw(\"{ foo: 1 }\");\n   * console.log(obj.foo); // 1\n   * ```\n   */\n  raw(code) {\n    return parseExpression(code);\n  }\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL21hZ2ljYXN0QDAuMy41L25vZGVfbW9kdWxlcy9tYWdpY2FzdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBbUM7QUFDdkI7QUFDMEI7QUFDTzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCwwQkFBMEI7QUFDOUU7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtGQUFrRiw2REFBNkQ7QUFDL0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQ0FBZ0M7QUFDOUM7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLEtBQUssa0JBQWtCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQkFBbUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxZQUFZO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0IsY0FBYyxtQkFBbUI7QUFDakMsa0JBQWtCLHVDQUF1QztBQUN6RCxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCLG9CQUFvQjtBQUNwQyxrQkFBa0IsV0FBVztBQUM3QixlQUFlO0FBQ2YsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1DQUFtQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpQ0FBaUM7QUFDaEg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsMkNBQTJDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsaUJBQWlCLFlBQVksR0FBRyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx3QkFBd0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHdCQUF3QjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDREQUEyQjtBQUNyRCwyQkFBMkIsNkRBQTRCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRkFBa0YsNkRBQTZEO0FBQy9JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDZEQUE0QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBc0Q7QUFDNUUsdUJBQXVCO0FBQ3ZCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGNBQWM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFxRDtBQUNqRTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGVBQWU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0NBQWdDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QyxZQUFZO0FBQ1osMEJBQTBCLGFBQWE7QUFDdkMsWUFBWTtBQUNaLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDLHNDQUFzQyxNQUFNO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxVQUFVLEdBQUcsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4Q0FBOEM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQ0FBc0M7QUFDN0Q7QUFDQSx1QkFBdUIsd0NBQXdDO0FBQy9EO0FBQ0EsdUJBQXVCLHFDQUFxQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0EsdUJBQXVCLGlEQUFpRDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsbUJBQW1CLDJDQUEyQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixRQUFRO0FBQ1Isc0JBQXNCLCtDQUErQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSx1QkFBdUIseUNBQXlDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLFFBQVE7QUFDUixxQkFBcUIseUNBQXlDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkNBQTZDO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CO0FBQ25CO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxNQUFNO0FBQ04sK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTixvQkFBb0I7QUFDcEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlCQUFpQjtBQUN4QyxVQUFVO0FBQ1Ysd0JBQXdCLGNBQWM7QUFDdEMsVUFBVTtBQUNWLHVCQUF1QixhQUFhO0FBQ3BDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQiw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0RBQWlCO0FBQzlCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxJQUFJLFNBQVM7QUFDM0M7QUFDQTtBQUNBLEVBQUUsdUJBQXVCO0FBQ3pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0MsR0FBRztBQUNyRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQ0FBa0MsR0FBRztBQUNyRDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLDRFQUE0RTtBQUM1RSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXO0FBQ1g7QUFDQSw4Q0FBOEM7QUFDOUMseUJBQXlCLDZDQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEIsUUFBUSw2Q0FBUTtBQUNoQjtBQUNBLFVBQVUsNkNBQVE7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFc0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90YW5nZW50LXBsYXlncm91bmQtbmV4dC8uLi9ub2RlX21vZHVsZXMvLnBucG0vbWFnaWNhc3RAMC4zLjUvbm9kZV9tb2R1bGVzL21hZ2ljYXN0L2Rpc3QvaW5kZXgubWpzP2EwNDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcHJvbWlzZXMgfSBmcm9tICdub2RlOmZzJztcbmltcG9ydCAnZnMnO1xuaW1wb3J0IHNvdXJjZU1hcCBmcm9tICdzb3VyY2UtbWFwLWpzJztcbmltcG9ydCAqIGFzIGJhYmVsUGFyc2VyIGZyb20gJ0BiYWJlbC9wYXJzZXInO1xuXG5mdW5jdGlvbiBzaGFyZWRQbHVnaW4oZm9yaykge1xuICB2YXIgdHlwZXMgPSBmb3JrLnVzZSh0eXBlc1BsdWdpbik7XG4gIHZhciBUeXBlID0gdHlwZXMuVHlwZTtcbiAgdmFyIGJ1aWx0aW4gPSB0eXBlcy5idWlsdEluVHlwZXM7XG4gIHZhciBpc051bWJlciA9IGJ1aWx0aW4ubnVtYmVyO1xuICBmdW5jdGlvbiBnZXEodGhhbikge1xuICAgIHJldHVybiBUeXBlLmZyb20oXG4gICAgICAodmFsdWUpID0+IGlzTnVtYmVyLmNoZWNrKHZhbHVlKSAmJiB2YWx1ZSA+PSB0aGFuLFxuICAgICAgaXNOdW1iZXIgKyBcIiA+PSBcIiArIHRoYW5cbiAgICApO1xuICB9XG4gIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgIC8vIEZ1bmN0aW9ucyB3ZXJlIHVzZWQgYmVjYXVzZSAoYW1vbmcgb3RoZXIgcmVhc29ucykgdGhhdCdzIHRoZSBtb3N0XG4gICAgLy8gZWxlZ2FudCB3YXkgdG8gYWxsb3cgZm9yIHRoZSBlbXB0eUFycmF5IG9uZSBhbHdheXMgdG8gZ2l2ZSBhIG5ld1xuICAgIC8vIGFycmF5IGluc3RhbmNlLlxuICAgIFwibnVsbFwiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgXCJlbXB0eUFycmF5XCI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgXCJmYWxzZVwiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIFwidHJ1ZVwiOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgXCJ1bmRlZmluZWRcIjogZnVuY3Rpb24oKSB7XG4gICAgfSxcbiAgICBcInVzZSBzdHJpY3RcIjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJ1c2Ugc3RyaWN0XCI7XG4gICAgfVxuICB9O1xuICB2YXIgbmFpdmVJc1ByaW1pdGl2ZSA9IFR5cGUub3IoXG4gICAgYnVpbHRpbi5zdHJpbmcsXG4gICAgYnVpbHRpbi5udW1iZXIsXG4gICAgYnVpbHRpbi5ib29sZWFuLFxuICAgIGJ1aWx0aW4ubnVsbCxcbiAgICBidWlsdGluLnVuZGVmaW5lZFxuICApO1xuICBjb25zdCBpc1ByaW1pdGl2ZSA9IFR5cGUuZnJvbShcbiAgICAodmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiIHx8IHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIG5haXZlSXNQcmltaXRpdmUudG9TdHJpbmcoKVxuICApO1xuICByZXR1cm4ge1xuICAgIGdlcSxcbiAgICBkZWZhdWx0cyxcbiAgICBpc1ByaW1pdGl2ZVxuICB9O1xufVxuZnVuY3Rpb24gbWF5YmVTZXRNb2R1bGVFeHBvcnRzKG1vZHVsZUdldHRlcikge1xuICB0cnkge1xuICAgIHZhciBub2RlTW9kdWxlID0gbW9kdWxlR2V0dGVyKCk7XG4gICAgdmFyIG9yaWdpbmFsRXhwb3J0cyA9IG5vZGVNb2R1bGUuZXhwb3J0cztcbiAgICB2YXIgZGVmYXVsdEV4cG9ydCA9IG9yaWdpbmFsRXhwb3J0c1tcImRlZmF1bHRcIl07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZGVmYXVsdEV4cG9ydCAmJiBkZWZhdWx0RXhwb3J0ICE9PSBvcmlnaW5hbEV4cG9ydHMgJiYgdHlwZW9mIG9yaWdpbmFsRXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIE9iamVjdC5hc3NpZ24oZGVmYXVsdEV4cG9ydCwgb3JpZ2luYWxFeHBvcnRzLCB7IFwiZGVmYXVsdFwiOiBkZWZhdWx0RXhwb3J0IH0pO1xuICAgIGlmIChvcmlnaW5hbEV4cG9ydHMuX19lc01vZHVsZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlZmF1bHRFeHBvcnQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIH1cbiAgICBub2RlTW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0RXhwb3J0O1xuICB9XG59XG5cbnZhciBfX2RlZlByb3AkMiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMiA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMihvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQyID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMihvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jb25zdCBPcCQxID0gT2JqZWN0LnByb3RvdHlwZTtcbmNvbnN0IG9ialRvU3RyID0gT3AkMS50b1N0cmluZztcbmNvbnN0IGhhc093biQ2ID0gT3AkMS5oYXNPd25Qcm9wZXJ0eTtcbmNsYXNzIEJhc2VUeXBlIHtcbiAgYXNzZXJ0KHZhbHVlLCBkZWVwKSB7XG4gICAgaWYgKCF0aGlzLmNoZWNrKHZhbHVlLCBkZWVwKSkge1xuICAgICAgdmFyIHN0ciA9IHNoYWxsb3dTdHJpbmdpZnkodmFsdWUpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHN0ciArIFwiIGRvZXMgbm90IG1hdGNoIHR5cGUgXCIgKyB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYXJyYXlPZigpIHtcbiAgICBjb25zdCBlbGVtVHlwZSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBBcnJheVR5cGUoZWxlbVR5cGUpO1xuICB9XG59XG5jbGFzcyBBcnJheVR5cGUgZXh0ZW5kcyBCYXNlVHlwZSB7XG4gIGNvbnN0cnVjdG9yKGVsZW1UeXBlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmVsZW1UeXBlID0gZWxlbVR5cGU7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwia2luZFwiLCBcIkFycmF5VHlwZVwiKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJbXCIgKyB0aGlzLmVsZW1UeXBlICsgXCJdXCI7XG4gIH1cbiAgY2hlY2sodmFsdWUsIGRlZXApIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoKGVsZW0pID0+IHRoaXMuZWxlbVR5cGUuY2hlY2soZWxlbSwgZGVlcCkpO1xuICB9XG59XG5jbGFzcyBJZGVudGl0eVR5cGUgZXh0ZW5kcyBCYXNlVHlwZSB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwia2luZFwiLCBcIklkZW50aXR5VHlwZVwiKTtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gU3RyaW5nKHRoaXMudmFsdWUpO1xuICB9XG4gIGNoZWNrKHZhbHVlLCBkZWVwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsdWUgPT09IHRoaXMudmFsdWU7XG4gICAgaWYgKCFyZXN1bHQgJiYgdHlwZW9mIGRlZXAgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZGVlcCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmNsYXNzIE9iamVjdFR5cGUgZXh0ZW5kcyBCYXNlVHlwZSB7XG4gIGNvbnN0cnVjdG9yKGZpZWxkcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwia2luZFwiLCBcIk9iamVjdFR5cGVcIik7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIFwieyBcIiArIHRoaXMuZmllbGRzLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcbiAgfVxuICBjaGVjayh2YWx1ZSwgZGVlcCkge1xuICAgIHJldHVybiBvYmpUb1N0ci5jYWxsKHZhbHVlKSA9PT0gb2JqVG9TdHIuY2FsbCh7fSkgJiYgdGhpcy5maWVsZHMuZXZlcnkoKGZpZWxkKSA9PiB7XG4gICAgICByZXR1cm4gZmllbGQudHlwZS5jaGVjayh2YWx1ZVtmaWVsZC5uYW1lXSwgZGVlcCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIE9yVHlwZSBleHRlbmRzIEJhc2VUeXBlIHtcbiAgY29uc3RydWN0b3IodHlwZXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJraW5kXCIsIFwiT3JUeXBlXCIpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGVzLmpvaW4oXCIgfCBcIik7XG4gIH1cbiAgY2hlY2sodmFsdWUsIGRlZXApIHtcbiAgICBpZiAodGhpcy50eXBlcy5zb21lKCh0eXBlKSA9PiB0eXBlLmNoZWNrKHZhbHVlLCAhIWRlZXApKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGVlcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBkZWVwKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jbGFzcyBQcmVkaWNhdGVUeXBlIGV4dGVuZHMgQmFzZVR5cGUge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBwcmVkaWNhdGUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwia2luZFwiLCBcIlByZWRpY2F0ZVR5cGVcIik7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgfVxuICBjaGVjayh2YWx1ZSwgZGVlcCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucHJlZGljYXRlKHZhbHVlLCBkZWVwKTtcbiAgICBpZiAoIXJlc3VsdCAmJiB0eXBlb2YgZGVlcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBkZWVwKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuY2xhc3MgRGVmIHtcbiAgY29uc3RydWN0b3IodHlwZSwgdHlwZU5hbWUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudHlwZU5hbWUgPSB0eXBlTmFtZTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJiYXNlTmFtZXNcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcIm93bkZpZWxkc1wiLCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgLy8gSW5jbHVkZXMgb3duIHR5cGVOYW1lLiBQb3B1bGF0ZWQgZHVyaW5nIGZpbmFsaXphdGlvbi5cbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJhbGxTdXBlcnR5cGVzXCIsIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAvLyBMaW5lYXIgaW5oZXJpdGFuY2UgaGllcmFyY2h5LiBQb3B1bGF0ZWQgZHVyaW5nIGZpbmFsaXphdGlvbi5cbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJzdXBlcnR5cGVMaXN0XCIsIFtdKTtcbiAgICAvLyBJbmNsdWRlcyBpbmhlcml0ZWQgZmllbGRzLlxuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcImFsbEZpZWxkc1wiLCAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgLy8gTm9uLWhpZGRlbiBrZXlzIG9mIGFsbEZpZWxkcy5cbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJmaWVsZE5hbWVzXCIsIFtdKTtcbiAgICAvLyBUaGlzIHByb3BlcnR5IHdpbGwgYmUgb3ZlcnJpZGRlbiBhcyB0cnVlIGJ5IGluZGl2aWR1YWwgRGVmIGluc3RhbmNlc1xuICAgIC8vIHdoZW4gdGhleSBhcmUgZmluYWxpemVkLlxuICAgIF9fcHVibGljRmllbGQkMih0aGlzLCBcImZpbmFsaXplZFwiLCBmYWxzZSk7XG4gICAgLy8gRmFsc2UgYnkgZGVmYXVsdCB1bnRpbCAuYnVpbGQoLi4uKSBpcyBjYWxsZWQgb24gYW4gaW5zdGFuY2UuXG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwiYnVpbGRhYmxlXCIsIGZhbHNlKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDIodGhpcywgXCJidWlsZFBhcmFtc1wiLCBbXSk7XG4gIH1cbiAgaXNTdXBlcnR5cGVPZih0aGF0KSB7XG4gICAgaWYgKHRoYXQgaW5zdGFuY2VvZiBEZWYpIHtcbiAgICAgIGlmICh0aGlzLmZpbmFsaXplZCAhPT0gdHJ1ZSB8fCB0aGF0LmZpbmFsaXplZCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzT3duJDYuY2FsbCh0aGF0LmFsbFN1cGVydHlwZXMsIHRoaXMudHlwZU5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodGhhdCArIFwiIGlzIG5vdCBhIERlZlwiKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tBbGxGaWVsZHModmFsdWUsIGRlZXApIHtcbiAgICB2YXIgYWxsRmllbGRzID0gdGhpcy5hbGxGaWVsZHM7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIHRoaXMudHlwZU5hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0ZpZWxkQnlOYW1lKG5hbWUpIHtcbiAgICAgIHZhciBmaWVsZCA9IGFsbEZpZWxkc1tuYW1lXTtcbiAgICAgIHZhciB0eXBlID0gZmllbGQudHlwZTtcbiAgICAgIHZhciBjaGlsZCA9IGZpZWxkLmdldFZhbHVlKHZhbHVlKTtcbiAgICAgIHJldHVybiB0eXBlLmNoZWNrKGNoaWxkLCBkZWVwKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhhbGxGaWVsZHMpLmV2ZXJ5KGNoZWNrRmllbGRCeU5hbWUpO1xuICB9XG4gIGJhc2VzKC4uLnN1cGVydHlwZU5hbWVzKSB7XG4gICAgdmFyIGJhc2VzID0gdGhpcy5iYXNlTmFtZXM7XG4gICAgaWYgKHRoaXMuZmluYWxpemVkKSB7XG4gICAgICBpZiAoc3VwZXJ0eXBlTmFtZXMubGVuZ3RoICE9PSBiYXNlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdXBlcnR5cGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoc3VwZXJ0eXBlTmFtZXNbaV0gIT09IGJhc2VzW2ldKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3VwZXJ0eXBlTmFtZXMuZm9yRWFjaCgoYmFzZU5hbWUpID0+IHtcbiAgICAgIGlmIChiYXNlcy5pbmRleE9mKGJhc2VOYW1lKSA8IDApIHtcbiAgICAgICAgYmFzZXMucHVzaChiYXNlTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmNsYXNzIEZpZWxkIHtcbiAgY29uc3RydWN0b3IobmFtZSwgdHlwZSwgZGVmYXVsdEZuLCBoaWRkZW4pIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5kZWZhdWx0Rm4gPSBkZWZhdWx0Rm47XG4gICAgX19wdWJsaWNGaWVsZCQyKHRoaXMsIFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuaGlkZGVuID0gISFoaWRkZW47XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMubmFtZSkgKyBcIjogXCIgKyB0aGlzLnR5cGU7XG4gIH1cbiAgZ2V0VmFsdWUob2JqKSB7XG4gICAgdmFyIHZhbHVlID0gb2JqW3RoaXMubmFtZV07XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMuZGVmYXVsdEZuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5kZWZhdWx0Rm4uY2FsbChvYmopO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoYWxsb3dTdHJpbmdpZnkodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiW1wiICsgdmFsdWUubWFwKHNoYWxsb3dTdHJpbmdpZnkpLmpvaW4oXCIsIFwiKSArIFwiXVwiO1xuICB9XG4gIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gXCJ7IFwiICsgT2JqZWN0LmtleXModmFsdWUpLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBrZXkgKyBcIjogXCIgKyB2YWx1ZVtrZXldO1xuICAgIH0pLmpvaW4oXCIsIFwiKSArIFwiIH1cIjtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xufVxuZnVuY3Rpb24gdHlwZXNQbHVnaW4oX2ZvcmspIHtcbiAgY29uc3QgVHlwZSA9IHtcbiAgICBvciguLi50eXBlcykge1xuICAgICAgcmV0dXJuIG5ldyBPclR5cGUodHlwZXMubWFwKCh0eXBlKSA9PiBUeXBlLmZyb20odHlwZSkpKTtcbiAgICB9LFxuICAgIGZyb20odmFsdWUsIG5hbWUpIHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5VHlwZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIElkZW50aXR5VHlwZSB8fCB2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdFR5cGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBPclR5cGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBQcmVkaWNhdGVUeXBlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERlZikge1xuICAgICAgICByZXR1cm4gdmFsdWUudHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5LmNoZWNrKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25seSBvbmUgZWxlbWVudCB0eXBlIGlzIHBlcm1pdHRlZCBmb3IgdHlwZWQgYXJyYXlzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQXJyYXlUeXBlKFR5cGUuZnJvbSh2YWx1ZVswXSkpO1xuICAgICAgfVxuICAgICAgaWYgKGlzT2JqZWN0LmNoZWNrKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdFR5cGUoT2JqZWN0LmtleXModmFsdWUpLm1hcCgobmFtZTIpID0+IHtcbiAgICAgICAgICByZXR1cm4gbmV3IEZpZWxkKG5hbWUyLCBUeXBlLmZyb20odmFsdWVbbmFtZTJdLCBuYW1lMikpO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdmFyIGJpY2ZJbmRleCA9IGJ1aWx0SW5DdG9yRm5zLmluZGV4T2YodmFsdWUpO1xuICAgICAgICBpZiAoYmljZkluZGV4ID49IDApIHtcbiAgICAgICAgICByZXR1cm4gYnVpbHRJbkN0b3JUeXBlc1tiaWNmSW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1pc3NpbmcgbmFtZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByZWRpY2F0ZVR5cGUobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBJZGVudGl0eVR5cGUodmFsdWUpO1xuICAgIH0sXG4gICAgLy8gRGVmaW5lIGEgdHlwZSB3aG9zZSBuYW1lIGlzIHJlZ2lzdGVyZWQgaW4gYSBuYW1lc3BhY2UgKHRoZSBkZWZDYWNoZSkgc29cbiAgICAvLyB0aGF0IGZ1dHVyZSBkZWZpbml0aW9ucyB3aWxsIHJldHVybiB0aGUgc2FtZSB0eXBlIGdpdmVuIHRoZSBzYW1lIG5hbWUuXG4gICAgLy8gSW4gcGFydGljdWxhciwgdGhpcyBzeXN0ZW0gYWxsb3dzIGZvciBjaXJjdWxhciBhbmQgZm9yd2FyZCBkZWZpbml0aW9ucy5cbiAgICAvLyBUaGUgRGVmIG9iamVjdCBkIHJldHVybmVkIGZyb20gVHlwZS5kZWYgbWF5IGJlIHVzZWQgdG8gY29uZmlndXJlIHRoZVxuICAgIC8vIHR5cGUgZC50eXBlIGJ5IGNhbGxpbmcgbWV0aG9kcyBzdWNoIGFzIGQuYmFzZXMsIGQuYnVpbGQsIGFuZCBkLmZpZWxkLlxuICAgIGRlZih0eXBlTmFtZSkge1xuICAgICAgcmV0dXJuIGhhc093biQ2LmNhbGwoZGVmQ2FjaGUsIHR5cGVOYW1lKSA/IGRlZkNhY2hlW3R5cGVOYW1lXSA6IGRlZkNhY2hlW3R5cGVOYW1lXSA9IG5ldyBEZWZJbXBsKHR5cGVOYW1lKTtcbiAgICB9LFxuICAgIGhhc0RlZih0eXBlTmFtZSkge1xuICAgICAgcmV0dXJuIGhhc093biQ2LmNhbGwoZGVmQ2FjaGUsIHR5cGVOYW1lKTtcbiAgICB9XG4gIH07XG4gIHZhciBidWlsdEluQ3RvckZucyA9IFtdO1xuICB2YXIgYnVpbHRJbkN0b3JUeXBlcyA9IFtdO1xuICBmdW5jdGlvbiBkZWZCdWlsdEluVHlwZShuYW1lLCBleGFtcGxlKSB7XG4gICAgY29uc3Qgb2JqU3RyID0gb2JqVG9TdHIuY2FsbChleGFtcGxlKTtcbiAgICBjb25zdCB0eXBlID0gbmV3IFByZWRpY2F0ZVR5cGUoXG4gICAgICBuYW1lLFxuICAgICAgKHZhbHVlKSA9PiBvYmpUb1N0ci5jYWxsKHZhbHVlKSA9PT0gb2JqU3RyXG4gICAgKTtcbiAgICBpZiAoZXhhbXBsZSAmJiB0eXBlb2YgZXhhbXBsZS5jb25zdHJ1Y3RvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBidWlsdEluQ3RvckZucy5wdXNoKGV4YW1wbGUuY29uc3RydWN0b3IpO1xuICAgICAgYnVpbHRJbkN0b3JUeXBlcy5wdXNoKHR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBjb25zdCBpc1N0cmluZyA9IGRlZkJ1aWx0SW5UeXBlKFwic3RyaW5nXCIsIFwidHJ1dGh5XCIpO1xuICBjb25zdCBpc0Z1bmN0aW9uID0gZGVmQnVpbHRJblR5cGUoXCJmdW5jdGlvblwiLCBmdW5jdGlvbigpIHtcbiAgfSk7XG4gIGNvbnN0IGlzQXJyYXkgPSBkZWZCdWlsdEluVHlwZShcImFycmF5XCIsIFtdKTtcbiAgY29uc3QgaXNPYmplY3QgPSBkZWZCdWlsdEluVHlwZShcIm9iamVjdFwiLCB7fSk7XG4gIGNvbnN0IGlzUmVnRXhwID0gZGVmQnVpbHRJblR5cGUoXCJSZWdFeHBcIiwgLy4vKTtcbiAgY29uc3QgaXNEYXRlID0gZGVmQnVpbHRJblR5cGUoXCJEYXRlXCIsIC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKTtcbiAgY29uc3QgaXNOdW1iZXIgPSBkZWZCdWlsdEluVHlwZShcIm51bWJlclwiLCAzKTtcbiAgY29uc3QgaXNCb29sZWFuID0gZGVmQnVpbHRJblR5cGUoXCJib29sZWFuXCIsIHRydWUpO1xuICBjb25zdCBpc051bGwgPSBkZWZCdWlsdEluVHlwZShcIm51bGxcIiwgbnVsbCk7XG4gIGNvbnN0IGlzVW5kZWZpbmVkID0gZGVmQnVpbHRJblR5cGUoXCJ1bmRlZmluZWRcIiwgdm9pZCAwKTtcbiAgY29uc3QgaXNCaWdJbnQgPSB0eXBlb2YgQmlnSW50ID09PSBcImZ1bmN0aW9uXCIgPyBkZWZCdWlsdEluVHlwZShcIkJpZ0ludFwiLCBCaWdJbnQoMTIzNCkpIDogbmV3IFByZWRpY2F0ZVR5cGUoXCJCaWdJbnRcIiwgKCkgPT4gZmFsc2UpO1xuICBjb25zdCBidWlsdEluVHlwZXMgPSB7XG4gICAgc3RyaW5nOiBpc1N0cmluZyxcbiAgICBmdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgICBhcnJheTogaXNBcnJheSxcbiAgICBvYmplY3Q6IGlzT2JqZWN0LFxuICAgIFJlZ0V4cDogaXNSZWdFeHAsXG4gICAgRGF0ZTogaXNEYXRlLFxuICAgIG51bWJlcjogaXNOdW1iZXIsXG4gICAgYm9vbGVhbjogaXNCb29sZWFuLFxuICAgIG51bGw6IGlzTnVsbCxcbiAgICB1bmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICAgIEJpZ0ludDogaXNCaWdJbnRcbiAgfTtcbiAgdmFyIGRlZkNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZ1bmN0aW9uIGRlZkZyb21WYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHZhciB0eXBlID0gdmFsdWUudHlwZTtcbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBoYXNPd24kNi5jYWxsKGRlZkNhY2hlLCB0eXBlKSkge1xuICAgICAgICB2YXIgZCA9IGRlZkNhY2hlW3R5cGVdO1xuICAgICAgICBpZiAoZC5maW5hbGl6ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjbGFzcyBEZWZJbXBsIGV4dGVuZHMgRGVmIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlTmFtZSkge1xuICAgICAgc3VwZXIoXG4gICAgICAgIG5ldyBQcmVkaWNhdGVUeXBlKHR5cGVOYW1lLCAodmFsdWUsIGRlZXApID0+IHRoaXMuY2hlY2sodmFsdWUsIGRlZXApKSxcbiAgICAgICAgdHlwZU5hbWVcbiAgICAgICk7XG4gICAgfVxuICAgIGNoZWNrKHZhbHVlLCBkZWVwKSB7XG4gICAgICBpZiAodGhpcy5maW5hbGl6ZWQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwicHJlbWF0dXJlbHkgY2hlY2tpbmcgdW5maW5hbGl6ZWQgdHlwZSBcIiArIHRoaXMudHlwZU5hbWVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIHZEZWYgPSBkZWZGcm9tVmFsdWUodmFsdWUpO1xuICAgICAgaWYgKCF2RGVmKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGVOYW1lID09PSBcIlNvdXJjZUxvY2F0aW9uXCIgfHwgdGhpcy50eXBlTmFtZSA9PT0gXCJQb3NpdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tBbGxGaWVsZHModmFsdWUsIGRlZXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChkZWVwICYmIHZEZWYgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tBbGxGaWVsZHModmFsdWUsIGRlZXApO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmlzU3VwZXJ0eXBlT2YodkRlZikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFkZWVwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZEZWYuY2hlY2tBbGxGaWVsZHModmFsdWUsIGRlZXApICYmIHRoaXMuY2hlY2tBbGxGaWVsZHModmFsdWUsIGZhbHNlKTtcbiAgICB9XG4gICAgYnVpbGQoLi4uYnVpbGRQYXJhbXMpIHtcbiAgICAgIHRoaXMuYnVpbGRQYXJhbXMgPSBidWlsZFBhcmFtcztcbiAgICAgIGlmICh0aGlzLmJ1aWxkYWJsZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMuZmllbGQoXCJ0eXBlXCIsIFN0cmluZywgKCkgPT4gdGhpcy50eXBlTmFtZSk7XG4gICAgICB0aGlzLmJ1aWxkYWJsZSA9IHRydWU7XG4gICAgICBjb25zdCBhZGRQYXJhbSA9IChidWlsdCwgcGFyYW0sIGFyZywgaXNBcmdBdmFpbGFibGUpID0+IHtcbiAgICAgICAgaWYgKGhhc093biQ2LmNhbGwoYnVpbHQsIHBhcmFtKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBhbGwgPSB0aGlzLmFsbEZpZWxkcztcbiAgICAgICAgaWYgKCFoYXNPd24kNi5jYWxsKGFsbCwgcGFyYW0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIgKyBwYXJhbSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpZWxkID0gYWxsW3BhcmFtXTtcbiAgICAgICAgdmFyIHR5cGUgPSBmaWVsZC50eXBlO1xuICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgIGlmIChpc0FyZ0F2YWlsYWJsZSkge1xuICAgICAgICAgIHZhbHVlID0gYXJnO1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLmRlZmF1bHRGbikge1xuICAgICAgICAgIHZhbHVlID0gZmllbGQuZGVmYXVsdEZuLmNhbGwoYnVpbHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJubyB2YWx1ZSBvciBkZWZhdWx0IGZ1bmN0aW9uIGdpdmVuIGZvciBmaWVsZCBcIiArIEpTT04uc3RyaW5naWZ5KHBhcmFtKSArIFwiIG9mIFwiICsgdGhpcy50eXBlTmFtZSArIFwiKFwiICsgdGhpcy5idWlsZFBhcmFtcy5tYXAoZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFsbFtuYW1lXTtcbiAgICAgICAgICB9KS5qb2luKFwiLCBcIikgKyBcIilcIjtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0eXBlLmNoZWNrKHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIHNoYWxsb3dTdHJpbmdpZnkodmFsdWUpICsgXCIgZG9lcyBub3QgbWF0Y2ggZmllbGQgXCIgKyBmaWVsZCArIFwiIG9mIHR5cGUgXCIgKyB0aGlzLnR5cGVOYW1lXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsdFtwYXJhbV0gPSB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBjb25zdCBidWlsZGVyID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgdmFyIGFyZ2MgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiYXR0ZW1wdGluZyB0byBpbnN0YW50aWF0ZSB1bmZpbmFsaXplZCB0eXBlIFwiICsgdGhpcy50eXBlTmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1aWx0ID0gT2JqZWN0LmNyZWF0ZShub2RlUHJvdG90eXBlKTtcbiAgICAgICAgdGhpcy5idWlsZFBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uKHBhcmFtLCBpKSB7XG4gICAgICAgICAgaWYgKGkgPCBhcmdjKSB7XG4gICAgICAgICAgICBhZGRQYXJhbShidWlsdCwgcGFyYW0sIGFyZ3NbaV0sIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRQYXJhbShidWlsdCwgcGFyYW0sIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFsbEZpZWxkcykuZm9yRWFjaChmdW5jdGlvbihwYXJhbSkge1xuICAgICAgICAgIGFkZFBhcmFtKGJ1aWx0LCBwYXJhbSwgbnVsbCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJ1aWx0LnR5cGUgIT09IHRoaXMudHlwZU5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWx0O1xuICAgICAgfTtcbiAgICAgIGJ1aWxkZXIuZnJvbSA9IChvYmopID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiYXR0ZW1wdGluZyB0byBpbnN0YW50aWF0ZSB1bmZpbmFsaXplZCB0eXBlIFwiICsgdGhpcy50eXBlTmFtZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ1aWx0ID0gT2JqZWN0LmNyZWF0ZShub2RlUHJvdG90eXBlKTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5hbGxGaWVsZHMpLmZvckVhY2goZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgICAgICBpZiAoaGFzT3duJDYuY2FsbChvYmosIHBhcmFtKSkge1xuICAgICAgICAgICAgYWRkUGFyYW0oYnVpbHQsIHBhcmFtLCBvYmpbcGFyYW1dLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWRkUGFyYW0oYnVpbHQsIHBhcmFtLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGJ1aWx0LnR5cGUgIT09IHRoaXMudHlwZU5hbWUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWx0O1xuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShidWlsZGVycywgZ2V0QnVpbGRlck5hbWUodGhpcy50eXBlTmFtZSksIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGJ1aWxkZXJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8vIFRoZSByZWFzb24gZmllbGRzIGFyZSBzcGVjaWZpZWQgdXNpbmcgLmZpZWxkKC4uLikgaW5zdGVhZCBvZiBhbiBvYmplY3RcbiAgICAvLyBsaXRlcmFsIHN5bnRheCBpcyBzb21ld2hhdCBzdWJ0bGU6IHRoZSBvYmplY3QgbGl0ZXJhbCBzeW50YXggd291bGRcbiAgICAvLyBzdXBwb3J0IG9ubHkgb25lIGtleSBhbmQgb25lIHZhbHVlLCBidXQgd2l0aCAuZmllbGQoLi4uKSB3ZSBjYW4gcGFzc1xuICAgIC8vIGFueSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHNwZWNpZnkgdGhlIGZpZWxkLlxuICAgIGZpZWxkKG5hbWUsIHR5cGUsIGRlZmF1bHRGbiwgaGlkZGVuKSB7XG4gICAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIklnbm9yaW5nIGF0dGVtcHQgdG8gcmVkZWZpbmUgZmllbGQgXCIgKyBKU09OLnN0cmluZ2lmeShuYW1lKSArIFwiIG9mIGZpbmFsaXplZCB0eXBlIFwiICsgSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlTmFtZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHRoaXMub3duRmllbGRzW25hbWVdID0gbmV3IEZpZWxkKG5hbWUsIFR5cGUuZnJvbSh0eXBlKSwgZGVmYXVsdEZuLCBoaWRkZW4pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmFsaXplKCkge1xuICAgICAgaWYgKCF0aGlzLmZpbmFsaXplZCkge1xuICAgICAgICB2YXIgYWxsRmllbGRzID0gdGhpcy5hbGxGaWVsZHM7XG4gICAgICAgIHZhciBhbGxTdXBlcnR5cGVzID0gdGhpcy5hbGxTdXBlcnR5cGVzO1xuICAgICAgICB0aGlzLmJhc2VOYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgdmFyIGRlZiA9IGRlZkNhY2hlW25hbWVdO1xuICAgICAgICAgIGlmIChkZWYgaW5zdGFuY2VvZiBEZWYpIHtcbiAgICAgICAgICAgIGRlZi5maW5hbGl6ZSgpO1xuICAgICAgICAgICAgZXh0ZW5kKGFsbEZpZWxkcywgZGVmLmFsbEZpZWxkcyk7XG4gICAgICAgICAgICBleHRlbmQoYWxsU3VwZXJ0eXBlcywgZGVmLmFsbFN1cGVydHlwZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwidW5rbm93biBzdXBlcnR5cGUgbmFtZSBcIiArIEpTT04uc3RyaW5naWZ5KG5hbWUpICsgXCIgZm9yIHN1YnR5cGUgXCIgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnR5cGVOYW1lKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBleHRlbmQoYWxsRmllbGRzLCB0aGlzLm93bkZpZWxkcyk7XG4gICAgICAgIGFsbFN1cGVydHlwZXNbdGhpcy50eXBlTmFtZV0gPSB0aGlzO1xuICAgICAgICB0aGlzLmZpZWxkTmFtZXMubGVuZ3RoID0gMDtcbiAgICAgICAgZm9yICh2YXIgZmllbGROYW1lIGluIGFsbEZpZWxkcykge1xuICAgICAgICAgIGlmIChoYXNPd24kNi5jYWxsKGFsbEZpZWxkcywgZmllbGROYW1lKSAmJiAhYWxsRmllbGRzW2ZpZWxkTmFtZV0uaGlkZGVuKSB7XG4gICAgICAgICAgICB0aGlzLmZpZWxkTmFtZXMucHVzaChmaWVsZE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmFtZWRUeXBlcywgdGhpcy50eXBlTmFtZSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgdmFsdWU6IHRoaXMudHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICBwb3B1bGF0ZVN1cGVydHlwZUxpc3QodGhpcy50eXBlTmFtZSwgdGhpcy5zdXBlcnR5cGVMaXN0KTtcbiAgICAgICAgaWYgKHRoaXMuYnVpbGRhYmxlICYmIHRoaXMuc3VwZXJ0eXBlTGlzdC5sYXN0SW5kZXhPZihcIkV4cHJlc3Npb25cIikgPj0gMCkge1xuICAgICAgICAgIHdyYXBFeHByZXNzaW9uQnVpbGRlcldpdGhTdGF0ZW1lbnQodGhpcy50eXBlTmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3VwZXJ0eXBlTmFtZXModHlwZU5hbWUpIHtcbiAgICBpZiAoIWhhc093biQ2LmNhbGwoZGVmQ2FjaGUsIHR5cGVOYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgIH1cbiAgICB2YXIgZCA9IGRlZkNhY2hlW3R5cGVOYW1lXTtcbiAgICBpZiAoZC5maW5hbGl6ZWQgIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGQuc3VwZXJ0eXBlTGlzdC5zbGljZSgxKTtcbiAgfVxuICBmdW5jdGlvbiBjb21wdXRlU3VwZXJ0eXBlTG9va3VwVGFibGUoY2FuZGlkYXRlcykge1xuICAgIHZhciB0YWJsZSA9IHt9O1xuICAgIHZhciB0eXBlTmFtZXMgPSBPYmplY3Qua2V5cyhkZWZDYWNoZSk7XG4gICAgdmFyIHR5cGVOYW1lQ291bnQgPSB0eXBlTmFtZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZU5hbWVDb3VudDsgKytpKSB7XG4gICAgICB2YXIgdHlwZU5hbWUgPSB0eXBlTmFtZXNbaV07XG4gICAgICB2YXIgZCA9IGRlZkNhY2hlW3R5cGVOYW1lXTtcbiAgICAgIGlmIChkLmZpbmFsaXplZCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIHR5cGVOYW1lKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZC5zdXBlcnR5cGVMaXN0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBzdXBlclR5cGVOYW1lID0gZC5zdXBlcnR5cGVMaXN0W2pdO1xuICAgICAgICBpZiAoaGFzT3duJDYuY2FsbChjYW5kaWRhdGVzLCBzdXBlclR5cGVOYW1lKSkge1xuICAgICAgICAgIHRhYmxlW3R5cGVOYW1lXSA9IHN1cGVyVHlwZU5hbWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlO1xuICB9XG4gIHZhciBidWlsZGVycyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgbm9kZVByb3RvdHlwZSA9IHt9O1xuICBmdW5jdGlvbiBkZWZpbmVNZXRob2QobmFtZSwgZnVuYykge1xuICAgIHZhciBvbGQgPSBub2RlUHJvdG90eXBlW25hbWVdO1xuICAgIGlmIChpc1VuZGVmaW5lZC5jaGVjayhmdW5jKSkge1xuICAgICAgZGVsZXRlIG5vZGVQcm90b3R5cGVbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzRnVuY3Rpb24uYXNzZXJ0KGZ1bmMpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGVQcm90b3R5cGUsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgLy8gRm9yIGRpc2NvdmVyYWJpbGl0eS5cbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAvLyBGb3IgZGVsZXRlIHByb3RvW25hbWVdLlxuICAgICAgICB2YWx1ZTogZnVuY1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvbGQ7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QnVpbGRlck5hbWUodHlwZU5hbWUpIHtcbiAgICByZXR1cm4gdHlwZU5hbWUucmVwbGFjZSgvXltBLVpdKy8sIGZ1bmN0aW9uKHVwcGVyQ2FzZVByZWZpeCkge1xuICAgICAgdmFyIGxlbiA9IHVwcGVyQ2FzZVByZWZpeC5sZW5ndGg7XG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gdXBwZXJDYXNlUHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIHVwcGVyQ2FzZVByZWZpeC5zbGljZShcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBsZW4gLSAxXG4gICAgICAgICAgKS50b0xvd2VyQ2FzZSgpICsgdXBwZXJDYXNlUHJlZml4LmNoYXJBdChsZW4gLSAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRTdGF0ZW1lbnRCdWlsZGVyTmFtZSh0eXBlTmFtZSkge1xuICAgIHR5cGVOYW1lID0gZ2V0QnVpbGRlck5hbWUodHlwZU5hbWUpO1xuICAgIHJldHVybiB0eXBlTmFtZS5yZXBsYWNlKC8oRXhwcmVzc2lvbik/JC8sIFwiU3RhdGVtZW50XCIpO1xuICB9XG4gIHZhciBuYW1lZFR5cGVzID0ge307XG4gIGZ1bmN0aW9uIGdldEZpZWxkTmFtZXMob2JqZWN0KSB7XG4gICAgdmFyIGQgPSBkZWZGcm9tVmFsdWUob2JqZWN0KTtcbiAgICBpZiAoZCkge1xuICAgICAgcmV0dXJuIGQuZmllbGROYW1lcy5zbGljZSgwKTtcbiAgICB9XG4gICAgaWYgKFwidHlwZVwiIGluIG9iamVjdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcImRpZCBub3QgcmVjb2duaXplIG9iamVjdCBvZiB0eXBlIFwiICsgSlNPTi5zdHJpbmdpZnkob2JqZWN0LnR5cGUpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgfVxuICBmdW5jdGlvbiBnZXRGaWVsZFZhbHVlKG9iamVjdCwgZmllbGROYW1lKSB7XG4gICAgdmFyIGQgPSBkZWZGcm9tVmFsdWUob2JqZWN0KTtcbiAgICBpZiAoZCkge1xuICAgICAgdmFyIGZpZWxkID0gZC5hbGxGaWVsZHNbZmllbGROYW1lXTtcbiAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICByZXR1cm4gZmllbGQuZ2V0VmFsdWUob2JqZWN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3RbZmllbGROYW1lXTtcbiAgfVxuICBmdW5jdGlvbiBlYWNoRmllbGQob2JqZWN0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIGdldEZpZWxkTmFtZXMob2JqZWN0KS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgbmFtZSwgZ2V0RmllbGRWYWx1ZShvYmplY3QsIG5hbWUpKTtcbiAgICB9LCBjb250ZXh0KTtcbiAgfVxuICBmdW5jdGlvbiBzb21lRmllbGQob2JqZWN0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHJldHVybiBnZXRGaWVsZE5hbWVzKG9iamVjdCkuc29tZShmdW5jdGlvbihuYW1lKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCBuYW1lLCBnZXRGaWVsZFZhbHVlKG9iamVjdCwgbmFtZSkpO1xuICAgIH0sIGNvbnRleHQpO1xuICB9XG4gIGZ1bmN0aW9uIHdyYXBFeHByZXNzaW9uQnVpbGRlcldpdGhTdGF0ZW1lbnQodHlwZU5hbWUpIHtcbiAgICB2YXIgd3JhcHBlck5hbWUgPSBnZXRTdGF0ZW1lbnRCdWlsZGVyTmFtZSh0eXBlTmFtZSk7XG4gICAgaWYgKGJ1aWxkZXJzW3dyYXBwZXJOYW1lXSlcbiAgICAgIHJldHVybjtcbiAgICB2YXIgd3JhcHBlZCA9IGJ1aWxkZXJzW2dldEJ1aWxkZXJOYW1lKHR5cGVOYW1lKV07XG4gICAgaWYgKCF3cmFwcGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGJ1aWxkZXIgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICByZXR1cm4gYnVpbGRlcnMuZXhwcmVzc2lvblN0YXRlbWVudCh3cmFwcGVkLmFwcGx5KGJ1aWxkZXJzLCBhcmdzKSk7XG4gICAgfTtcbiAgICBidWlsZGVyLmZyb20gPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICByZXR1cm4gYnVpbGRlcnMuZXhwcmVzc2lvblN0YXRlbWVudCh3cmFwcGVkLmZyb20uYXBwbHkoYnVpbGRlcnMsIGFyZ3MpKTtcbiAgICB9O1xuICAgIGJ1aWxkZXJzW3dyYXBwZXJOYW1lXSA9IGJ1aWxkZXI7XG4gIH1cbiAgZnVuY3Rpb24gcG9wdWxhdGVTdXBlcnR5cGVMaXN0KHR5cGVOYW1lLCBsaXN0KSB7XG4gICAgbGlzdC5sZW5ndGggPSAwO1xuICAgIGxpc3QucHVzaCh0eXBlTmFtZSk7XG4gICAgdmFyIGxhc3RTZWVuID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yICh2YXIgcG9zID0gMDsgcG9zIDwgbGlzdC5sZW5ndGg7ICsrcG9zKSB7XG4gICAgICB0eXBlTmFtZSA9IGxpc3RbcG9zXTtcbiAgICAgIHZhciBkID0gZGVmQ2FjaGVbdHlwZU5hbWVdO1xuICAgICAgaWYgKGQuZmluYWxpemVkICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd24kNi5jYWxsKGxhc3RTZWVuLCB0eXBlTmFtZSkpIHtcbiAgICAgICAgZGVsZXRlIGxpc3RbbGFzdFNlZW5bdHlwZU5hbWVdXTtcbiAgICAgIH1cbiAgICAgIGxhc3RTZWVuW3R5cGVOYW1lXSA9IHBvcztcbiAgICAgIGxpc3QucHVzaC5hcHBseShsaXN0LCBkLmJhc2VOYW1lcyk7XG4gICAgfVxuICAgIGZvciAodmFyIHRvID0gMCwgZnJvbSA9IHRvLCBsZW4gPSBsaXN0Lmxlbmd0aDsgZnJvbSA8IGxlbjsgKytmcm9tKSB7XG4gICAgICBpZiAoaGFzT3duJDYuY2FsbChsaXN0LCBmcm9tKSkge1xuICAgICAgICBsaXN0W3RvKytdID0gbGlzdFtmcm9tXTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGlzdC5sZW5ndGggPSB0bztcbiAgfVxuICBmdW5jdGlvbiBleHRlbmQoaW50bywgZnJvbSkge1xuICAgIE9iamVjdC5rZXlzKGZyb20pLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgaW50b1tuYW1lXSA9IGZyb21bbmFtZV07XG4gICAgfSk7XG4gICAgcmV0dXJuIGludG87XG4gIH1cbiAgZnVuY3Rpb24gZmluYWxpemUoKSB7XG4gICAgT2JqZWN0LmtleXMoZGVmQ2FjaGUpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgZGVmQ2FjaGVbbmFtZV0uZmluYWxpemUoKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIFR5cGUsXG4gICAgYnVpbHRJblR5cGVzLFxuICAgIGdldFN1cGVydHlwZU5hbWVzLFxuICAgIGNvbXB1dGVTdXBlcnR5cGVMb29rdXBUYWJsZSxcbiAgICBidWlsZGVycyxcbiAgICBkZWZpbmVNZXRob2QsXG4gICAgZ2V0QnVpbGRlck5hbWUsXG4gICAgZ2V0U3RhdGVtZW50QnVpbGRlck5hbWUsXG4gICAgbmFtZWRUeXBlcyxcbiAgICBnZXRGaWVsZE5hbWVzLFxuICAgIGdldEZpZWxkVmFsdWUsXG4gICAgZWFjaEZpZWxkLFxuICAgIHNvbWVGaWVsZCxcbiAgICBmaW5hbGl6ZVxuICB9O1xufVxubWF5YmVTZXRNb2R1bGVFeHBvcnRzKCgpID0+IG1vZHVsZSk7XG5cbnZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaGFzT3duJDUgPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHBhdGhQbHVnaW4oZm9yaykge1xuICB2YXIgdHlwZXMgPSBmb3JrLnVzZSh0eXBlc1BsdWdpbik7XG4gIHZhciBpc0FycmF5ID0gdHlwZXMuYnVpbHRJblR5cGVzLmFycmF5O1xuICB2YXIgaXNOdW1iZXIgPSB0eXBlcy5idWlsdEluVHlwZXMubnVtYmVyO1xuICBjb25zdCBQYXRoID0gZnVuY3Rpb24gUGF0aDIodmFsdWUsIHBhcmVudFBhdGgsIG5hbWUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGF0aDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIHdpdGhvdXQgJ25ldydcIik7XG4gICAgfVxuICAgIGlmIChwYXJlbnRQYXRoKSB7XG4gICAgICBpZiAoIShwYXJlbnRQYXRoIGluc3RhbmNlb2YgUGF0aDIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50UGF0aCA9IG51bGw7XG4gICAgICBuYW1lID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMucGFyZW50UGF0aCA9IHBhcmVudFBhdGg7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLl9fY2hpbGRDYWNoZSA9IG51bGw7XG4gIH07XG4gIHZhciBQcCA9IFBhdGgucHJvdG90eXBlO1xuICBmdW5jdGlvbiBnZXRDaGlsZENhY2hlKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5fX2NoaWxkQ2FjaGUgfHwgKHBhdGguX19jaGlsZENhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldENoaWxkUGF0aChwYXRoLCBuYW1lKSB7XG4gICAgdmFyIGNhY2hlID0gZ2V0Q2hpbGRDYWNoZShwYXRoKTtcbiAgICB2YXIgYWN0dWFsQ2hpbGRWYWx1ZSA9IHBhdGguZ2V0VmFsdWVQcm9wZXJ0eShuYW1lKTtcbiAgICB2YXIgY2hpbGRQYXRoID0gY2FjaGVbbmFtZV07XG4gICAgaWYgKCFoYXNPd24kNS5jYWxsKGNhY2hlLCBuYW1lKSB8fCAvLyBFbnN1cmUgY29uc2lzdGVuY3kgYmV0d2VlbiBjYWNoZSBhbmQgcmVhbGl0eS5cbiAgICBjaGlsZFBhdGgudmFsdWUgIT09IGFjdHVhbENoaWxkVmFsdWUpIHtcbiAgICAgIGNoaWxkUGF0aCA9IGNhY2hlW25hbWVdID0gbmV3IHBhdGguY29uc3RydWN0b3IoXG4gICAgICAgIGFjdHVhbENoaWxkVmFsdWUsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG5hbWVcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjaGlsZFBhdGg7XG4gIH1cbiAgUHAuZ2V0VmFsdWVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGdldFZhbHVlUHJvcGVydHkobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlW25hbWVdO1xuICB9O1xuICBQcC5nZXQgPSBmdW5jdGlvbiBnZXQoLi4ubmFtZXMpIHtcbiAgICB2YXIgcGF0aCA9IHRoaXM7XG4gICAgdmFyIGNvdW50ID0gbmFtZXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgcGF0aCA9IGdldENoaWxkUGF0aChwYXRoLCBuYW1lc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9O1xuICBQcC5lYWNoID0gZnVuY3Rpb24gZWFjaChjYWxsYmFjaywgY29udGV4dCkge1xuICAgIHZhciBjaGlsZFBhdGhzID0gW107XG4gICAgdmFyIGxlbiA9IHRoaXMudmFsdWUubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAoaGFzT3duJDUuY2FsbCh0aGlzLnZhbHVlLCBpKSkge1xuICAgICAgICBjaGlsZFBhdGhzW2ldID0gdGhpcy5nZXQoaSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZiAoaGFzT3duJDUuY2FsbChjaGlsZFBhdGhzLCBpKSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIGNoaWxkUGF0aHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgUHAubWFwID0gZnVuY3Rpb24gbWFwKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbihjaGlsZFBhdGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrLmNhbGwodGhpcywgY2hpbGRQYXRoKSk7XG4gICAgfSwgY29udGV4dCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgUHAuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHRoaXMuZWFjaChmdW5jdGlvbihjaGlsZFBhdGgpIHtcbiAgICAgIGlmIChjYWxsYmFjay5jYWxsKHRoaXMsIGNoaWxkUGF0aCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goY2hpbGRQYXRoKTtcbiAgICAgIH1cbiAgICB9LCBjb250ZXh0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBmdW5jdGlvbiBlbXB0eU1vdmVzKCkge1xuICB9XG4gIGZ1bmN0aW9uIGdldE1vdmVzKHBhdGgsIG9mZnNldCwgc3RhcnQsIGVuZCkge1xuICAgIGlzQXJyYXkuYXNzZXJ0KHBhdGgudmFsdWUpO1xuICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgIHJldHVybiBlbXB0eU1vdmVzO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gcGF0aC52YWx1ZS5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCA8IDEpIHtcbiAgICAgIHJldHVybiBlbXB0eU1vdmVzO1xuICAgIH1cbiAgICB2YXIgYXJnYyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgaWYgKGFyZ2MgPT09IDIpIHtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICB9IGVsc2UgaWYgKGFyZ2MgPT09IDMpIHtcbiAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIDApO1xuICAgICAgZW5kID0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgbGVuZ3RoKTtcbiAgICB9XG4gICAgaXNOdW1iZXIuYXNzZXJ0KHN0YXJ0KTtcbiAgICBpc051bWJlci5hc3NlcnQoZW5kKTtcbiAgICB2YXIgbW92ZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgY2FjaGUgPSBnZXRDaGlsZENhY2hlKHBhdGgpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICBpZiAoaGFzT3duJDUuY2FsbChwYXRoLnZhbHVlLCBpKSkge1xuICAgICAgICB2YXIgY2hpbGRQYXRoID0gcGF0aC5nZXQoaSk7XG4gICAgICAgIGlmIChjaGlsZFBhdGgubmFtZSAhPT0gaSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3SW5kZXggPSBpICsgb2Zmc2V0O1xuICAgICAgICBjaGlsZFBhdGgubmFtZSA9IG5ld0luZGV4O1xuICAgICAgICBtb3Zlc1tuZXdJbmRleF0gPSBjaGlsZFBhdGg7XG4gICAgICAgIGRlbGV0ZSBjYWNoZVtpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlIGNhY2hlLmxlbmd0aDtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBmb3IgKHZhciBuZXdJbmRleDIgaW4gbW92ZXMpIHtcbiAgICAgICAgdmFyIGNoaWxkUGF0aDIgPSBtb3Zlc1tuZXdJbmRleDJdO1xuICAgICAgICBpZiAoY2hpbGRQYXRoMi5uYW1lICE9PSArbmV3SW5kZXgyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlW25ld0luZGV4Ml0gPSBjaGlsZFBhdGgyO1xuICAgICAgICBwYXRoLnZhbHVlW25ld0luZGV4Ml0gPSBjaGlsZFBhdGgyLnZhbHVlO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgUHAuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICB2YXIgbW92ZSA9IGdldE1vdmVzKHRoaXMsIC0xKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy52YWx1ZS5zaGlmdCgpO1xuICAgIG1vdmUoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBQcC51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCguLi5hcmdzKSB7XG4gICAgdmFyIG1vdmUgPSBnZXRNb3Zlcyh0aGlzLCBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMudmFsdWUudW5zaGlmdC5hcHBseSh0aGlzLnZhbHVlLCBhcmdzKTtcbiAgICBtb3ZlKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgUHAucHVzaCA9IGZ1bmN0aW9uIHB1c2goLi4uYXJncykge1xuICAgIGlzQXJyYXkuYXNzZXJ0KHRoaXMudmFsdWUpO1xuICAgIGRlbGV0ZSBnZXRDaGlsZENhY2hlKHRoaXMpLmxlbmd0aDtcbiAgICByZXR1cm4gdGhpcy52YWx1ZS5wdXNoLmFwcGx5KHRoaXMudmFsdWUsIGFyZ3MpO1xuICB9O1xuICBQcC5wb3AgPSBmdW5jdGlvbiBwb3AoKSB7XG4gICAgaXNBcnJheS5hc3NlcnQodGhpcy52YWx1ZSk7XG4gICAgdmFyIGNhY2hlID0gZ2V0Q2hpbGRDYWNoZSh0aGlzKTtcbiAgICBkZWxldGUgY2FjaGVbdGhpcy52YWx1ZS5sZW5ndGggLSAxXTtcbiAgICBkZWxldGUgY2FjaGUubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLnZhbHVlLnBvcCgpO1xuICB9O1xuICBQcC5pbnNlcnRBdCA9IGZ1bmN0aW9uIGluc2VydEF0KGluZGV4KSB7XG4gICAgdmFyIGFyZ2MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBtb3ZlID0gZ2V0TW92ZXModGhpcywgYXJnYyAtIDEsIGluZGV4KTtcbiAgICBpZiAobW92ZSA9PT0gZW1wdHlNb3ZlcyAmJiBhcmdjIDw9IDEpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBpbmRleCA9IE1hdGgubWF4KGluZGV4LCAwKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ2M7ICsraSkge1xuICAgICAgdGhpcy52YWx1ZVtpbmRleCArIGkgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgbW92ZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBQcC5pbnNlcnRCZWZvcmUgPSBmdW5jdGlvbiBpbnNlcnRCZWZvcmUoLi4uYXJncykge1xuICAgIHZhciBwcCA9IHRoaXMucGFyZW50UGF0aDtcbiAgICB2YXIgYXJnYyA9IGFyZ3MubGVuZ3RoO1xuICAgIHZhciBpbnNlcnRBdEFyZ3MgPSBbdGhpcy5uYW1lXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ2M7ICsraSkge1xuICAgICAgaW5zZXJ0QXRBcmdzLnB1c2goYXJnc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBwcC5pbnNlcnRBdC5hcHBseShwcCwgaW5zZXJ0QXRBcmdzKTtcbiAgfTtcbiAgUHAuaW5zZXJ0QWZ0ZXIgPSBmdW5jdGlvbiBpbnNlcnRBZnRlciguLi5hcmdzKSB7XG4gICAgdmFyIHBwID0gdGhpcy5wYXJlbnRQYXRoO1xuICAgIHZhciBhcmdjID0gYXJncy5sZW5ndGg7XG4gICAgdmFyIGluc2VydEF0QXJncyA9IFt0aGlzLm5hbWUgKyAxXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ2M7ICsraSkge1xuICAgICAgaW5zZXJ0QXRBcmdzLnB1c2goYXJnc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBwcC5pbnNlcnRBdC5hcHBseShwcCwgaW5zZXJ0QXRBcmdzKTtcbiAgfTtcbiAgZnVuY3Rpb24gcmVwYWlyUmVsYXRpb25zaGlwV2l0aFBhcmVudChwYXRoKSB7XG4gICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIFBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgfVxuICAgIHZhciBwcCA9IHBhdGgucGFyZW50UGF0aDtcbiAgICBpZiAoIXBwKSB7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgdmFyIHBhcmVudFZhbHVlID0gcHAudmFsdWU7XG4gICAgdmFyIHBhcmVudENhY2hlID0gZ2V0Q2hpbGRDYWNoZShwcCk7XG4gICAgaWYgKHBhcmVudFZhbHVlW3BhdGgubmFtZV0gPT09IHBhdGgudmFsdWUpIHtcbiAgICAgIHBhcmVudENhY2hlW3BhdGgubmFtZV0gPSBwYXRoO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheS5jaGVjayhwYXJlbnRWYWx1ZSkpIHtcbiAgICAgIHZhciBpID0gcGFyZW50VmFsdWUuaW5kZXhPZihwYXRoLnZhbHVlKTtcbiAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgcGFyZW50Q2FjaGVbcGF0aC5uYW1lID0gaV0gPSBwYXRoO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRWYWx1ZVtwYXRoLm5hbWVdID0gcGF0aC52YWx1ZTtcbiAgICAgIHBhcmVudENhY2hlW3BhdGgubmFtZV0gPSBwYXRoO1xuICAgIH1cbiAgICBpZiAocGFyZW50VmFsdWVbcGF0aC5uYW1lXSAhPT0gcGF0aC52YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgIH1cbiAgICBpZiAocGF0aC5wYXJlbnRQYXRoLmdldChwYXRoLm5hbWUpICE9PSBwYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIFBwLnJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgcGFyZW50VmFsdWUgPSB0aGlzLnBhcmVudFBhdGgudmFsdWU7XG4gICAgdmFyIHBhcmVudENhY2hlID0gZ2V0Q2hpbGRDYWNoZSh0aGlzLnBhcmVudFBhdGgpO1xuICAgIHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmVwYWlyUmVsYXRpb25zaGlwV2l0aFBhcmVudCh0aGlzKTtcbiAgICBpZiAoaXNBcnJheS5jaGVjayhwYXJlbnRWYWx1ZSkpIHtcbiAgICAgIHZhciBvcmlnaW5hbExlbmd0aCA9IHBhcmVudFZhbHVlLmxlbmd0aDtcbiAgICAgIHZhciBtb3ZlID0gZ2V0TW92ZXModGhpcy5wYXJlbnRQYXRoLCBjb3VudCAtIDEsIHRoaXMubmFtZSArIDEpO1xuICAgICAgdmFyIHNwbGljZUFyZ3MgPSBbdGhpcy5uYW1lLCAxXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICBzcGxpY2VBcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHZhciBzcGxpY2VkT3V0ID0gcGFyZW50VmFsdWUuc3BsaWNlLmFwcGx5KHBhcmVudFZhbHVlLCBzcGxpY2VBcmdzKTtcbiAgICAgIGlmIChzcGxpY2VkT3V0WzBdICE9PSB0aGlzLnZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnRWYWx1ZS5sZW5ndGggIT09IG9yaWdpbmFsTGVuZ3RoIC0gMSArIGNvdW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgIH1cbiAgICAgIG1vdmUoKTtcbiAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgdGhpcy52YWx1ZTtcbiAgICAgICAgZGVsZXRlIHBhcmVudENhY2hlW3RoaXMubmFtZV07XG4gICAgICAgIHRoaXMuX19jaGlsZENhY2hlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJlbnRWYWx1ZVt0aGlzLm5hbWVdICE9PSByZXBsYWNlbWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnZhbHVlID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgdGhpcy5fX2NoaWxkQ2FjaGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XG4gICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMucGFyZW50UGF0aC5nZXQodGhpcy5uYW1lICsgaSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRzWzBdICE9PSB0aGlzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgaWYgKHRoaXMudmFsdWUgIT09IHJlcGxhY2VtZW50KSB7XG4gICAgICAgIHRoaXMuX19jaGlsZENhY2hlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMudmFsdWUgPSBwYXJlbnRWYWx1ZVt0aGlzLm5hbWVdID0gcmVwbGFjZW1lbnQ7XG4gICAgICByZXN1bHRzLnB1c2godGhpcyk7XG4gICAgfSBlbHNlIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgZGVsZXRlIHBhcmVudFZhbHVlW3RoaXMubmFtZV07XG4gICAgICBkZWxldGUgdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMuX19jaGlsZENhY2hlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlcGxhY2UgcGF0aFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG4gIHJldHVybiBQYXRoO1xufVxubWF5YmVTZXRNb2R1bGVFeHBvcnRzKCgpID0+IG1vZHVsZSk7XG5cbnZhciBoYXNPd24kNCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBzY29wZVBsdWdpbihmb3JrKSB7XG4gIHZhciB0eXBlcyA9IGZvcmsudXNlKHR5cGVzUGx1Z2luKTtcbiAgdmFyIFR5cGUgPSB0eXBlcy5UeXBlO1xuICB2YXIgbmFtZWRUeXBlcyA9IHR5cGVzLm5hbWVkVHlwZXM7XG4gIHZhciBOb2RlID0gbmFtZWRUeXBlcy5Ob2RlO1xuICB2YXIgRXhwcmVzc2lvbiA9IG5hbWVkVHlwZXMuRXhwcmVzc2lvbjtcbiAgdmFyIGlzQXJyYXkgPSB0eXBlcy5idWlsdEluVHlwZXMuYXJyYXk7XG4gIHZhciBiID0gdHlwZXMuYnVpbGRlcnM7XG4gIGNvbnN0IFNjb3BlID0gZnVuY3Rpb24gU2NvcGUyKHBhdGgsIHBhcmVudFNjb3BlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNjb3BlMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjb3BlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIHdpdGhvdXQgJ25ldydcIik7XG4gICAgfVxuICAgIGlmICghVHlwZVBhcmFtZXRlclNjb3BlVHlwZS5jaGVjayhwYXRoLnZhbHVlKSkge1xuICAgICAgU2NvcGVUeXBlLmFzc2VydChwYXRoLnZhbHVlKTtcbiAgICB9XG4gICAgdmFyIGRlcHRoO1xuICAgIGlmIChwYXJlbnRTY29wZSkge1xuICAgICAgaWYgKCEocGFyZW50U2NvcGUgaW5zdGFuY2VvZiBTY29wZTIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICAgIH1cbiAgICAgIGRlcHRoID0gcGFyZW50U2NvcGUuZGVwdGggKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnRTY29wZSA9IG51bGw7XG4gICAgICBkZXB0aCA9IDA7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIHBhdGg6IHsgdmFsdWU6IHBhdGggfSxcbiAgICAgIG5vZGU6IHsgdmFsdWU6IHBhdGgudmFsdWUgfSxcbiAgICAgIGlzR2xvYmFsOiB7IHZhbHVlOiAhcGFyZW50U2NvcGUsIGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgIGRlcHRoOiB7IHZhbHVlOiBkZXB0aCB9LFxuICAgICAgcGFyZW50OiB7IHZhbHVlOiBwYXJlbnRTY29wZSB9LFxuICAgICAgYmluZGluZ3M6IHsgdmFsdWU6IHt9IH0sXG4gICAgICB0eXBlczogeyB2YWx1ZToge30gfVxuICAgIH0pO1xuICB9O1xuICB2YXIgU2NvcGVUeXBlID0gVHlwZS5vcihcbiAgICAvLyBQcm9ncmFtIG5vZGVzIGludHJvZHVjZSBnbG9iYWwgc2NvcGVzLlxuICAgIG5hbWVkVHlwZXMuUHJvZ3JhbSxcbiAgICAvLyBGdW5jdGlvbiBpcyB0aGUgc3VwZXJ0eXBlIG9mIEZ1bmN0aW9uRXhwcmVzc2lvbixcbiAgICAvLyBGdW5jdGlvbkRlY2xhcmF0aW9uLCBBcnJvd0V4cHJlc3Npb24sIGV0Yy5cbiAgICBuYW1lZFR5cGVzLkZ1bmN0aW9uLFxuICAgIC8vIEluIGNhc2UgeW91IGRpZG4ndCBrbm93LCB0aGUgY2F1Z2h0IHBhcmFtZXRlciBzaGFkb3dzIGFueSB2YXJpYWJsZVxuICAgIC8vIG9mIHRoZSBzYW1lIG5hbWUgaW4gYW4gb3V0ZXIgc2NvcGUuXG4gICAgbmFtZWRUeXBlcy5DYXRjaENsYXVzZVxuICApO1xuICB2YXIgVHlwZVBhcmFtZXRlclNjb3BlVHlwZSA9IFR5cGUub3IoXG4gICAgbmFtZWRUeXBlcy5GdW5jdGlvbixcbiAgICBuYW1lZFR5cGVzLkNsYXNzRGVjbGFyYXRpb24sXG4gICAgbmFtZWRUeXBlcy5DbGFzc0V4cHJlc3Npb24sXG4gICAgbmFtZWRUeXBlcy5JbnRlcmZhY2VEZWNsYXJhdGlvbixcbiAgICBuYW1lZFR5cGVzLlRTSW50ZXJmYWNlRGVjbGFyYXRpb24sXG4gICAgbmFtZWRUeXBlcy5UeXBlQWxpYXMsXG4gICAgbmFtZWRUeXBlcy5UU1R5cGVBbGlhc0RlY2xhcmF0aW9uXG4gICk7XG4gIHZhciBGbG93T3JUU1R5cGVQYXJhbWV0ZXJUeXBlID0gVHlwZS5vcihcbiAgICBuYW1lZFR5cGVzLlR5cGVQYXJhbWV0ZXIsXG4gICAgbmFtZWRUeXBlcy5UU1R5cGVQYXJhbWV0ZXJcbiAgKTtcbiAgU2NvcGUuaXNFc3RhYmxpc2hlZEJ5ID0gZnVuY3Rpb24obm9kZSkge1xuICAgIHJldHVybiBTY29wZVR5cGUuY2hlY2sobm9kZSkgfHwgVHlwZVBhcmFtZXRlclNjb3BlVHlwZS5jaGVjayhub2RlKTtcbiAgfTtcbiAgdmFyIFNwID0gU2NvcGUucHJvdG90eXBlO1xuICBTcC5kaWRTY2FuID0gZmFsc2U7XG4gIFNwLmRlY2xhcmVzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHRoaXMuc2NhbigpO1xuICAgIHJldHVybiBoYXNPd24kNC5jYWxsKHRoaXMuYmluZGluZ3MsIG5hbWUpO1xuICB9O1xuICBTcC5kZWNsYXJlc1R5cGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdGhpcy5zY2FuKCk7XG4gICAgcmV0dXJuIGhhc093biQ0LmNhbGwodGhpcy50eXBlcywgbmFtZSk7XG4gIH07XG4gIFNwLmRlY2xhcmVUZW1wb3JhcnkgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBpZiAoIS9eW2EteiRfXS9pLnRlc3QocHJlZml4KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZWZpeCA9IFwidCRcIjtcbiAgICB9XG4gICAgcHJlZml4ICs9IHRoaXMuZGVwdGgudG9TdHJpbmcoMzYpICsgXCIkXCI7XG4gICAgdGhpcy5zY2FuKCk7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB3aGlsZSAodGhpcy5kZWNsYXJlcyhwcmVmaXggKyBpbmRleCkpIHtcbiAgICAgICsraW5kZXg7XG4gICAgfVxuICAgIHZhciBuYW1lID0gcHJlZml4ICsgaW5kZXg7XG4gICAgcmV0dXJuIHRoaXMuYmluZGluZ3NbbmFtZV0gPSB0eXBlcy5idWlsZGVycy5pZGVudGlmaWVyKG5hbWUpO1xuICB9O1xuICBTcC5pbmplY3RUZW1wb3JhcnkgPSBmdW5jdGlvbihpZGVudGlmaWVyLCBpbml0KSB7XG4gICAgaWRlbnRpZmllciB8fCAoaWRlbnRpZmllciA9IHRoaXMuZGVjbGFyZVRlbXBvcmFyeSgpKTtcbiAgICB2YXIgYm9keVBhdGggPSB0aGlzLnBhdGguZ2V0KFwiYm9keVwiKTtcbiAgICBpZiAobmFtZWRUeXBlcy5CbG9ja1N0YXRlbWVudC5jaGVjayhib2R5UGF0aC52YWx1ZSkpIHtcbiAgICAgIGJvZHlQYXRoID0gYm9keVBhdGguZ2V0KFwiYm9keVwiKTtcbiAgICB9XG4gICAgYm9keVBhdGgudW5zaGlmdChcbiAgICAgIGIudmFyaWFibGVEZWNsYXJhdGlvbihcbiAgICAgICAgXCJ2YXJcIixcbiAgICAgICAgW2IudmFyaWFibGVEZWNsYXJhdG9yKGlkZW50aWZpZXIsIGluaXQgfHwgbnVsbCldXG4gICAgICApXG4gICAgKTtcbiAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgfTtcbiAgU3Auc2NhbiA9IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgaWYgKGZvcmNlIHx8ICF0aGlzLmRpZFNjYW4pIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5iaW5kaW5ncykge1xuICAgICAgICBkZWxldGUgdGhpcy5iaW5kaW5nc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy50eXBlcykge1xuICAgICAgICBkZWxldGUgdGhpcy50eXBlc1tuYW1lXTtcbiAgICAgIH1cbiAgICAgIHNjYW5TY29wZSh0aGlzLnBhdGgsIHRoaXMuYmluZGluZ3MsIHRoaXMudHlwZXMpO1xuICAgICAgdGhpcy5kaWRTY2FuID0gdHJ1ZTtcbiAgICB9XG4gIH07XG4gIFNwLmdldEJpbmRpbmdzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY2FuKCk7XG4gICAgcmV0dXJuIHRoaXMuYmluZGluZ3M7XG4gIH07XG4gIFNwLmdldFR5cGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zY2FuKCk7XG4gICAgcmV0dXJuIHRoaXMudHlwZXM7XG4gIH07XG4gIGZ1bmN0aW9uIHNjYW5TY29wZShwYXRoLCBiaW5kaW5ncywgc2NvcGVUeXBlcykge1xuICAgIHZhciBub2RlID0gcGF0aC52YWx1ZTtcbiAgICBpZiAoVHlwZVBhcmFtZXRlclNjb3BlVHlwZS5jaGVjayhub2RlKSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gcGF0aC5nZXQoXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInBhcmFtc1wiKTtcbiAgICAgIGlmIChpc0FycmF5LmNoZWNrKHBhcmFtcy52YWx1ZSkpIHtcbiAgICAgICAgcGFyYW1zLmVhY2goKGNoaWxkUGF0aCkgPT4ge1xuICAgICAgICAgIGFkZFR5cGVQYXJhbWV0ZXIoY2hpbGRQYXRoLCBzY29wZVR5cGVzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChTY29wZVR5cGUuY2hlY2sobm9kZSkpIHtcbiAgICAgIGlmIChuYW1lZFR5cGVzLkNhdGNoQ2xhdXNlLmNoZWNrKG5vZGUpKSB7XG4gICAgICAgIGFkZFBhdHRlcm4ocGF0aC5nZXQoXCJwYXJhbVwiKSwgYmluZGluZ3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVjdXJzaXZlU2NhblNjb3BlKHBhdGgsIGJpbmRpbmdzLCBzY29wZVR5cGVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVjdXJzaXZlU2NhblNjb3BlKHBhdGgsIGJpbmRpbmdzLCBzY29wZVR5cGVzKSB7XG4gICAgdmFyIG5vZGUgPSBwYXRoLnZhbHVlO1xuICAgIGlmIChwYXRoLnBhcmVudCAmJiBuYW1lZFR5cGVzLkZ1bmN0aW9uRXhwcmVzc2lvbi5jaGVjayhwYXRoLnBhcmVudC5ub2RlKSAmJiBwYXRoLnBhcmVudC5ub2RlLmlkKSB7XG4gICAgICBhZGRQYXR0ZXJuKHBhdGgucGFyZW50LmdldChcImlkXCIpLCBiaW5kaW5ncyk7XG4gICAgfVxuICAgIGlmICghbm9kZSkgOyBlbHNlIGlmIChpc0FycmF5LmNoZWNrKG5vZGUpKSB7XG4gICAgICBwYXRoLmVhY2goKGNoaWxkUGF0aCkgPT4ge1xuICAgICAgICByZWN1cnNpdmVTY2FuQ2hpbGQoY2hpbGRQYXRoLCBiaW5kaW5ncywgc2NvcGVUeXBlcyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5hbWVkVHlwZXMuRnVuY3Rpb24uY2hlY2sobm9kZSkpIHtcbiAgICAgIHBhdGguZ2V0KFwicGFyYW1zXCIpLmVhY2goKHBhcmFtUGF0aCkgPT4ge1xuICAgICAgICBhZGRQYXR0ZXJuKHBhcmFtUGF0aCwgYmluZGluZ3MpO1xuICAgICAgfSk7XG4gICAgICByZWN1cnNpdmVTY2FuQ2hpbGQocGF0aC5nZXQoXCJib2R5XCIpLCBiaW5kaW5ncywgc2NvcGVUeXBlcyk7XG4gICAgICByZWN1cnNpdmVTY2FuU2NvcGUocGF0aC5nZXQoXCJ0eXBlUGFyYW1ldGVyc1wiKSwgYmluZGluZ3MsIHNjb3BlVHlwZXMpO1xuICAgIH0gZWxzZSBpZiAobmFtZWRUeXBlcy5UeXBlQWxpYXMgJiYgbmFtZWRUeXBlcy5UeXBlQWxpYXMuY2hlY2sobm9kZSkgfHwgbmFtZWRUeXBlcy5JbnRlcmZhY2VEZWNsYXJhdGlvbiAmJiBuYW1lZFR5cGVzLkludGVyZmFjZURlY2xhcmF0aW9uLmNoZWNrKG5vZGUpIHx8IG5hbWVkVHlwZXMuVFNUeXBlQWxpYXNEZWNsYXJhdGlvbiAmJiBuYW1lZFR5cGVzLlRTVHlwZUFsaWFzRGVjbGFyYXRpb24uY2hlY2sobm9kZSkgfHwgbmFtZWRUeXBlcy5UU0ludGVyZmFjZURlY2xhcmF0aW9uICYmIG5hbWVkVHlwZXMuVFNJbnRlcmZhY2VEZWNsYXJhdGlvbi5jaGVjayhub2RlKSkge1xuICAgICAgYWRkVHlwZVBhdHRlcm4ocGF0aC5nZXQoXCJpZFwiKSwgc2NvcGVUeXBlcyk7XG4gICAgfSBlbHNlIGlmIChuYW1lZFR5cGVzLlZhcmlhYmxlRGVjbGFyYXRvci5jaGVjayhub2RlKSkge1xuICAgICAgYWRkUGF0dGVybihwYXRoLmdldChcImlkXCIpLCBiaW5kaW5ncyk7XG4gICAgICByZWN1cnNpdmVTY2FuQ2hpbGQocGF0aC5nZXQoXCJpbml0XCIpLCBiaW5kaW5ncywgc2NvcGVUeXBlcyk7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiSW1wb3J0U3BlY2lmaWVyXCIgfHwgbm9kZS50eXBlID09PSBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiIHx8IG5vZGUudHlwZSA9PT0gXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpIHtcbiAgICAgIGFkZFBhdHRlcm4oXG4gICAgICAgIC8vIEVzcHJpbWEgdXNlZCB0byB1c2UgdGhlIC5uYW1lIGZpZWxkIHRvIHJlZmVyIHRvIHRoZSBsb2NhbFxuICAgICAgICAvLyBiaW5kaW5nIGlkZW50aWZpZXIgZm9yIEltcG9ydFNwZWNpZmllciBub2RlcywgYnV0IC5pZCBmb3JcbiAgICAgICAgLy8gSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyIGFuZCBJbXBvcnREZWZhdWx0U3BlY2lmaWVyIG5vZGVzLlxuICAgICAgICAvLyBFU1RyZWUvQWNvcm4vRVNwcmVlIHVzZSAubG9jYWwgZm9yIGFsbCB0aHJlZSBub2RlIHR5cGVzLlxuICAgICAgICBwYXRoLmdldChub2RlLmxvY2FsID8gXCJsb2NhbFwiIDogbm9kZS5uYW1lID8gXCJuYW1lXCIgOiBcImlkXCIpLFxuICAgICAgICBiaW5kaW5nc1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKE5vZGUuY2hlY2sobm9kZSkgJiYgIUV4cHJlc3Npb24uY2hlY2sobm9kZSkpIHtcbiAgICAgIHR5cGVzLmVhY2hGaWVsZChub2RlLCBmdW5jdGlvbihuYW1lLCBjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRQYXRoID0gcGF0aC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghcGF0aEhhc1ZhbHVlKGNoaWxkUGF0aCwgY2hpbGQpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJlY3Vyc2l2ZVNjYW5DaGlsZChjaGlsZFBhdGgsIGJpbmRpbmdzLCBzY29wZVR5cGVzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwYXRoSGFzVmFsdWUocGF0aCwgdmFsdWUpIHtcbiAgICBpZiAocGF0aC52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXRoLnZhbHVlKSAmJiBwYXRoLnZhbHVlLmxlbmd0aCA9PT0gMCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gcmVjdXJzaXZlU2NhbkNoaWxkKHBhdGgsIGJpbmRpbmdzLCBzY29wZVR5cGVzKSB7XG4gICAgdmFyIG5vZGUgPSBwYXRoLnZhbHVlO1xuICAgIGlmICghbm9kZSB8fCBFeHByZXNzaW9uLmNoZWNrKG5vZGUpKSA7IGVsc2UgaWYgKG5hbWVkVHlwZXMuRnVuY3Rpb25EZWNsYXJhdGlvbi5jaGVjayhub2RlKSAmJiBub2RlLmlkICE9PSBudWxsKSB7XG4gICAgICBhZGRQYXR0ZXJuKHBhdGguZ2V0KFwiaWRcIiksIGJpbmRpbmdzKTtcbiAgICB9IGVsc2UgaWYgKG5hbWVkVHlwZXMuQ2xhc3NEZWNsYXJhdGlvbiAmJiBuYW1lZFR5cGVzLkNsYXNzRGVjbGFyYXRpb24uY2hlY2sobm9kZSkgJiYgbm9kZS5pZCAhPT0gbnVsbCkge1xuICAgICAgYWRkUGF0dGVybihwYXRoLmdldChcImlkXCIpLCBiaW5kaW5ncyk7XG4gICAgICByZWN1cnNpdmVTY2FuU2NvcGUocGF0aC5nZXQoXCJ0eXBlUGFyYW1ldGVyc1wiKSwgYmluZGluZ3MsIHNjb3BlVHlwZXMpO1xuICAgIH0gZWxzZSBpZiAobmFtZWRUeXBlcy5JbnRlcmZhY2VEZWNsYXJhdGlvbiAmJiBuYW1lZFR5cGVzLkludGVyZmFjZURlY2xhcmF0aW9uLmNoZWNrKG5vZGUpIHx8IG5hbWVkVHlwZXMuVFNJbnRlcmZhY2VEZWNsYXJhdGlvbiAmJiBuYW1lZFR5cGVzLlRTSW50ZXJmYWNlRGVjbGFyYXRpb24uY2hlY2sobm9kZSkpIHtcbiAgICAgIGFkZFR5cGVQYXR0ZXJuKHBhdGguZ2V0KFwiaWRcIiksIHNjb3BlVHlwZXMpO1xuICAgIH0gZWxzZSBpZiAoU2NvcGVUeXBlLmNoZWNrKG5vZGUpKSB7XG4gICAgICBpZiAobmFtZWRUeXBlcy5DYXRjaENsYXVzZS5jaGVjayhub2RlKSAmJiAvLyBUT0RPIEJyb2FkZW4gdGhpcyB0byBhY2NlcHQgYW55IHBhdHRlcm4uXG4gICAgICBuYW1lZFR5cGVzLklkZW50aWZpZXIuY2hlY2sobm9kZS5wYXJhbSkpIHtcbiAgICAgICAgdmFyIGNhdGNoUGFyYW1OYW1lID0gbm9kZS5wYXJhbS5uYW1lO1xuICAgICAgICB2YXIgaGFkQmluZGluZyA9IGhhc093biQ0LmNhbGwoYmluZGluZ3MsIGNhdGNoUGFyYW1OYW1lKTtcbiAgICAgICAgcmVjdXJzaXZlU2NhblNjb3BlKHBhdGguZ2V0KFwiYm9keVwiKSwgYmluZGluZ3MsIHNjb3BlVHlwZXMpO1xuICAgICAgICBpZiAoIWhhZEJpbmRpbmcpIHtcbiAgICAgICAgICBkZWxldGUgYmluZGluZ3NbY2F0Y2hQYXJhbU5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3Vyc2l2ZVNjYW5TY29wZShwYXRoLCBiaW5kaW5ncywgc2NvcGVUeXBlcyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFkZFBhdHRlcm4ocGF0dGVyblBhdGgsIGJpbmRpbmdzKSB7XG4gICAgdmFyIHBhdHRlcm4gPSBwYXR0ZXJuUGF0aC52YWx1ZTtcbiAgICBuYW1lZFR5cGVzLlBhdHRlcm4uYXNzZXJ0KHBhdHRlcm4pO1xuICAgIGlmIChuYW1lZFR5cGVzLklkZW50aWZpZXIuY2hlY2socGF0dGVybikpIHtcbiAgICAgIGlmIChoYXNPd24kNC5jYWxsKGJpbmRpbmdzLCBwYXR0ZXJuLm5hbWUpKSB7XG4gICAgICAgIGJpbmRpbmdzW3BhdHRlcm4ubmFtZV0ucHVzaChwYXR0ZXJuUGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaW5kaW5nc1twYXR0ZXJuLm5hbWVdID0gW3BhdHRlcm5QYXRoXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5hbWVkVHlwZXMuQXNzaWdubWVudFBhdHRlcm4gJiYgbmFtZWRUeXBlcy5Bc3NpZ25tZW50UGF0dGVybi5jaGVjayhwYXR0ZXJuKSkge1xuICAgICAgYWRkUGF0dGVybihwYXR0ZXJuUGF0aC5nZXQoXCJsZWZ0XCIpLCBiaW5kaW5ncyk7XG4gICAgfSBlbHNlIGlmIChuYW1lZFR5cGVzLk9iamVjdFBhdHRlcm4gJiYgbmFtZWRUeXBlcy5PYmplY3RQYXR0ZXJuLmNoZWNrKHBhdHRlcm4pKSB7XG4gICAgICBwYXR0ZXJuUGF0aC5nZXQoXCJwcm9wZXJ0aWVzXCIpLmVhY2goZnVuY3Rpb24ocHJvcGVydHlQYXRoKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnR5UGF0aC52YWx1ZTtcbiAgICAgICAgaWYgKG5hbWVkVHlwZXMuUGF0dGVybi5jaGVjayhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBhZGRQYXR0ZXJuKHByb3BlcnR5UGF0aCwgYmluZGluZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWVkVHlwZXMuUHJvcGVydHkuY2hlY2socHJvcGVydHkpIHx8IG5hbWVkVHlwZXMuT2JqZWN0UHJvcGVydHkgJiYgbmFtZWRUeXBlcy5PYmplY3RQcm9wZXJ0eS5jaGVjayhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBhZGRQYXR0ZXJuKHByb3BlcnR5UGF0aC5nZXQoXCJ2YWx1ZVwiKSwgYmluZGluZ3MpO1xuICAgICAgICB9IGVsc2UgaWYgKG5hbWVkVHlwZXMuU3ByZWFkUHJvcGVydHkgJiYgbmFtZWRUeXBlcy5TcHJlYWRQcm9wZXJ0eS5jaGVjayhwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBhZGRQYXR0ZXJuKHByb3BlcnR5UGF0aC5nZXQoXCJhcmd1bWVudFwiKSwgYmluZGluZ3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG5hbWVkVHlwZXMuQXJyYXlQYXR0ZXJuICYmIG5hbWVkVHlwZXMuQXJyYXlQYXR0ZXJuLmNoZWNrKHBhdHRlcm4pKSB7XG4gICAgICBwYXR0ZXJuUGF0aC5nZXQoXCJlbGVtZW50c1wiKS5lYWNoKGZ1bmN0aW9uKGVsZW1lbnRQYXRoKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudFBhdGgudmFsdWU7XG4gICAgICAgIGlmIChuYW1lZFR5cGVzLlBhdHRlcm4uY2hlY2soZWxlbWVudCkpIHtcbiAgICAgICAgICBhZGRQYXR0ZXJuKGVsZW1lbnRQYXRoLCBiaW5kaW5ncyk7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZWRUeXBlcy5TcHJlYWRFbGVtZW50ICYmIG5hbWVkVHlwZXMuU3ByZWFkRWxlbWVudC5jaGVjayhlbGVtZW50KSkge1xuICAgICAgICAgIGFkZFBhdHRlcm4oZWxlbWVudFBhdGguZ2V0KFwiYXJndW1lbnRcIiksIGJpbmRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChuYW1lZFR5cGVzLlByb3BlcnR5UGF0dGVybiAmJiBuYW1lZFR5cGVzLlByb3BlcnR5UGF0dGVybi5jaGVjayhwYXR0ZXJuKSkge1xuICAgICAgYWRkUGF0dGVybihwYXR0ZXJuUGF0aC5nZXQoXCJwYXR0ZXJuXCIpLCBiaW5kaW5ncyk7XG4gICAgfSBlbHNlIGlmIChuYW1lZFR5cGVzLlNwcmVhZEVsZW1lbnRQYXR0ZXJuICYmIG5hbWVkVHlwZXMuU3ByZWFkRWxlbWVudFBhdHRlcm4uY2hlY2socGF0dGVybikgfHwgbmFtZWRUeXBlcy5SZXN0RWxlbWVudCAmJiBuYW1lZFR5cGVzLlJlc3RFbGVtZW50LmNoZWNrKHBhdHRlcm4pIHx8IG5hbWVkVHlwZXMuU3ByZWFkUHJvcGVydHlQYXR0ZXJuICYmIG5hbWVkVHlwZXMuU3ByZWFkUHJvcGVydHlQYXR0ZXJuLmNoZWNrKHBhdHRlcm4pKSB7XG4gICAgICBhZGRQYXR0ZXJuKHBhdHRlcm5QYXRoLmdldChcImFyZ3VtZW50XCIpLCBiaW5kaW5ncyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFkZFR5cGVQYXR0ZXJuKHBhdHRlcm5QYXRoLCB0eXBlczIpIHtcbiAgICB2YXIgcGF0dGVybiA9IHBhdHRlcm5QYXRoLnZhbHVlO1xuICAgIG5hbWVkVHlwZXMuUGF0dGVybi5hc3NlcnQocGF0dGVybik7XG4gICAgaWYgKG5hbWVkVHlwZXMuSWRlbnRpZmllci5jaGVjayhwYXR0ZXJuKSkge1xuICAgICAgaWYgKGhhc093biQ0LmNhbGwodHlwZXMyLCBwYXR0ZXJuLm5hbWUpKSB7XG4gICAgICAgIHR5cGVzMltwYXR0ZXJuLm5hbWVdLnB1c2gocGF0dGVyblBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZXMyW3BhdHRlcm4ubmFtZV0gPSBbcGF0dGVyblBhdGhdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhZGRUeXBlUGFyYW1ldGVyKHBhcmFtZXRlclBhdGgsIHR5cGVzMikge1xuICAgIHZhciBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJQYXRoLnZhbHVlO1xuICAgIEZsb3dPclRTVHlwZVBhcmFtZXRlclR5cGUuYXNzZXJ0KHBhcmFtZXRlcik7XG4gICAgaWYgKGhhc093biQ0LmNhbGwodHlwZXMyLCBwYXJhbWV0ZXIubmFtZSkpIHtcbiAgICAgIHR5cGVzMltwYXJhbWV0ZXIubmFtZV0ucHVzaChwYXJhbWV0ZXJQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZXMyW3BhcmFtZXRlci5uYW1lXSA9IFtwYXJhbWV0ZXJQYXRoXTtcbiAgICB9XG4gIH1cbiAgU3AubG9va3VwID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGZvciAodmFyIHNjb3BlID0gdGhpczsgc2NvcGU7IHNjb3BlID0gc2NvcGUucGFyZW50KVxuICAgICAgaWYgKHNjb3BlLmRlY2xhcmVzKG5hbWUpKVxuICAgICAgICBicmVhaztcbiAgICByZXR1cm4gc2NvcGU7XG4gIH07XG4gIFNwLmxvb2t1cFR5cGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZm9yICh2YXIgc2NvcGUgPSB0aGlzOyBzY29wZTsgc2NvcGUgPSBzY29wZS5wYXJlbnQpXG4gICAgICBpZiAoc2NvcGUuZGVjbGFyZXNUeXBlKG5hbWUpKVxuICAgICAgICBicmVhaztcbiAgICByZXR1cm4gc2NvcGU7XG4gIH07XG4gIFNwLmdldEdsb2JhbFNjb3BlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICB3aGlsZSAoIXNjb3BlLmlzR2xvYmFsKVxuICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgcmV0dXJuIHNjb3BlO1xuICB9O1xuICByZXR1cm4gU2NvcGU7XG59XG5tYXliZVNldE1vZHVsZUV4cG9ydHMoKCkgPT4gbW9kdWxlKTtcblxuZnVuY3Rpb24gbm9kZVBhdGhQbHVnaW4oZm9yaykge1xuICB2YXIgdHlwZXMgPSBmb3JrLnVzZSh0eXBlc1BsdWdpbik7XG4gIHZhciBuID0gdHlwZXMubmFtZWRUeXBlcztcbiAgdmFyIGIgPSB0eXBlcy5idWlsZGVycztcbiAgdmFyIGlzTnVtYmVyID0gdHlwZXMuYnVpbHRJblR5cGVzLm51bWJlcjtcbiAgdmFyIGlzQXJyYXkgPSB0eXBlcy5idWlsdEluVHlwZXMuYXJyYXk7XG4gIHZhciBQYXRoMiA9IGZvcmsudXNlKHBhdGhQbHVnaW4pO1xuICB2YXIgU2NvcGUyID0gZm9yay51c2Uoc2NvcGVQbHVnaW4pO1xuICBjb25zdCBOb2RlUGF0aCA9IGZ1bmN0aW9uIE5vZGVQYXRoMih2YWx1ZSwgcGFyZW50UGF0aCwgbmFtZSkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlUGF0aDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlUGF0aCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgaW52b2tlZCB3aXRob3V0ICduZXcnXCIpO1xuICAgIH1cbiAgICBQYXRoMi5jYWxsKHRoaXMsIHZhbHVlLCBwYXJlbnRQYXRoLCBuYW1lKTtcbiAgfTtcbiAgdmFyIE5QcCA9IE5vZGVQYXRoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUGF0aDIucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBOb2RlUGF0aCxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhOUHAsIHtcbiAgICBub2RlOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJub2RlXCIsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgLy8gRW5hYmxlIGRlbGV0aW9uLlxuICAgICAgICAgIHZhbHVlOiB0aGlzLl9jb21wdXRlTm9kZSgpXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGFyZW50OiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJwYXJlbnRcIiwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAvLyBFbmFibGUgZGVsZXRpb24uXG4gICAgICAgICAgdmFsdWU6IHRoaXMuX2NvbXB1dGVQYXJlbnQoKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgfVxuICAgIH0sXG4gICAgc2NvcGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInNjb3BlXCIsIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgLy8gRW5hYmxlIGRlbGV0aW9uLlxuICAgICAgICAgIHZhbHVlOiB0aGlzLl9jb21wdXRlU2NvcGUoKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgTlBwLnJlcGxhY2UgPSBmdW5jdGlvbigpIHtcbiAgICBkZWxldGUgdGhpcy5ub2RlO1xuICAgIGRlbGV0ZSB0aGlzLnBhcmVudDtcbiAgICBkZWxldGUgdGhpcy5zY29wZTtcbiAgICByZXR1cm4gUGF0aDIucHJvdG90eXBlLnJlcGxhY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgTlBwLnBydW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlbWFpbmluZ05vZGVQYXRoID0gdGhpcy5wYXJlbnQ7XG4gICAgdGhpcy5yZXBsYWNlKCk7XG4gICAgcmV0dXJuIGNsZWFuVXBOb2Rlc0FmdGVyUHJ1bmUocmVtYWluaW5nTm9kZVBhdGgpO1xuICB9O1xuICBOUHAuX2NvbXB1dGVOb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBpZiAobi5Ob2RlLmNoZWNrKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHAgPSB0aGlzLnBhcmVudFBhdGg7XG4gICAgcmV0dXJuIHBwICYmIHBwLm5vZGUgfHwgbnVsbDtcbiAgfTtcbiAgTlBwLl9jb21wdXRlUGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICB2YXIgcHAgPSB0aGlzLnBhcmVudFBhdGg7XG4gICAgaWYgKCFuLk5vZGUuY2hlY2sodmFsdWUpKSB7XG4gICAgICB3aGlsZSAocHAgJiYgIW4uTm9kZS5jaGVjayhwcC52YWx1ZSkpIHtcbiAgICAgICAgcHAgPSBwcC5wYXJlbnRQYXRoO1xuICAgICAgfVxuICAgICAgaWYgKHBwKSB7XG4gICAgICAgIHBwID0gcHAucGFyZW50UGF0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKHBwICYmICFuLk5vZGUuY2hlY2socHAudmFsdWUpKSB7XG4gICAgICBwcCA9IHBwLnBhcmVudFBhdGg7XG4gICAgfVxuICAgIHJldHVybiBwcCB8fCBudWxsO1xuICB9O1xuICBOUHAuX2NvbXB1dGVTY29wZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgdmFyIHBwID0gdGhpcy5wYXJlbnRQYXRoO1xuICAgIHZhciBzY29wZSA9IHBwICYmIHBwLnNjb3BlO1xuICAgIGlmIChuLk5vZGUuY2hlY2sodmFsdWUpICYmIFNjb3BlMi5pc0VzdGFibGlzaGVkQnkodmFsdWUpKSB7XG4gICAgICBzY29wZSA9IG5ldyBTY29wZTIodGhpcywgc2NvcGUpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGUgfHwgbnVsbDtcbiAgfTtcbiAgTlBwLmdldFZhbHVlUHJvcGVydHkgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHR5cGVzLmdldEZpZWxkVmFsdWUodGhpcy52YWx1ZSwgbmFtZSk7XG4gIH07XG4gIE5QcC5uZWVkc1BhcmVucyA9IGZ1bmN0aW9uKGFzc3VtZUV4cHJlc3Npb25Db250ZXh0KSB7XG4gICAgdmFyIHBwID0gdGhpcy5wYXJlbnRQYXRoO1xuICAgIGlmICghcHApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSB0aGlzLnZhbHVlO1xuICAgIGlmICghbi5FeHByZXNzaW9uLmNoZWNrKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHdoaWxlICghbi5Ob2RlLmNoZWNrKHBwLnZhbHVlKSkge1xuICAgICAgcHAgPSBwcC5wYXJlbnRQYXRoO1xuICAgICAgaWYgKCFwcCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBwcC52YWx1ZTtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJTcHJlYWRQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gcGFyZW50LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIHRoaXMubmFtZSA9PT0gXCJvYmplY3RcIiAmJiBwYXJlbnQub2JqZWN0ID09PSBub2RlO1xuICAgICAgY2FzZSBcIkJpbmFyeUV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09PSBcImNhbGxlZVwiICYmIHBhcmVudC5jYWxsZWUgPT09IG5vZGU7XG4gICAgICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgICAgY2FzZSBcIlNwcmVhZFByb3BlcnR5XCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gXCJvYmplY3RcIiAmJiBwYXJlbnQub2JqZWN0ID09PSBub2RlO1xuICAgICAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gbm9kZTtcbiAgICAgICAgICAgIGNvbnN0IHBvID0gcGFyZW50Lm9wZXJhdG9yO1xuICAgICAgICAgICAgY29uc3QgcHAyID0gUFJFQ0VERU5DRVtwb107XG4gICAgICAgICAgICBjb25zdCBubyA9IG4yLm9wZXJhdG9yO1xuICAgICAgICAgICAgY29uc3QgbnAgPSBQUkVDRURFTkNFW25vXTtcbiAgICAgICAgICAgIGlmIChwcDIgPiBucCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcDIgPT09IG5wICYmIHRoaXMubmFtZSA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgIGlmIChwYXJlbnQucmlnaHQgIT09IG4yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZXMgbXVzdCBiZSBlcXVhbFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiOlxuICAgICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIkZvclN0YXRlbWVudFwiOlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIGNhc2UgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lICE9PSBcImV4cHJlc3Npb25cIjtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJZaWVsZEV4cHJlc3Npb25cIjpcbiAgICAgICAgc3dpdGNoIChwYXJlbnQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkxvZ2ljYWxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgICAgY2FzZSBcIlNwcmVhZFByb3BlcnR5XCI6XG4gICAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiTmV3RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICBjYXNlIFwiWWllbGRFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgICByZXR1cm4gcGFyZW50LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIGlzTnVtYmVyLmNoZWNrKG5vZGUudmFsdWUpICYmIHRoaXMubmFtZSA9PT0gXCJvYmplY3RcIiAmJiBwYXJlbnQub2JqZWN0ID09PSBub2RlO1xuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6XG4gICAgICAgIHN3aXRjaCAocGFyZW50LnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgICAgY2FzZSBcIlNwcmVhZEVsZW1lbnRcIjpcbiAgICAgICAgICBjYXNlIFwiU3ByZWFkUHJvcGVydHlcIjpcbiAgICAgICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09PSBcImNhbGxlZVwiICYmIHBhcmVudC5jYWxsZWUgPT09IG5vZGU7XG4gICAgICAgICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSA9PT0gXCJ0ZXN0XCIgJiYgcGFyZW50LnRlc3QgPT09IG5vZGU7XG4gICAgICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUgPT09IFwib2JqZWN0XCIgJiYgcGFyZW50Lm9iamVjdCA9PT0gbm9kZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiTmV3RXhwcmVzc2lvblwiICYmIHRoaXMubmFtZSA9PT0gXCJjYWxsZWVcIiAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5zQ2FsbEV4cHJlc3Npb24obm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFzc3VtZUV4cHJlc3Npb25Db250ZXh0ICE9PSB0cnVlICYmICF0aGlzLmNhbkJlRmlyc3RJblN0YXRlbWVudCgpICYmIHRoaXMuZmlyc3RJblN0YXRlbWVudCgpKVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBmdW5jdGlvbiBpc0JpbmFyeShub2RlKSB7XG4gICAgcmV0dXJuIG4uQmluYXJ5RXhwcmVzc2lvbi5jaGVjayhub2RlKSB8fCBuLkxvZ2ljYWxFeHByZXNzaW9uLmNoZWNrKG5vZGUpO1xuICB9XG4gIHZhciBQUkVDRURFTkNFID0ge307XG4gIFtcbiAgICBbXCJ8fFwiXSxcbiAgICBbXCImJlwiXSxcbiAgICBbXCJ8XCJdLFxuICAgIFtcIl5cIl0sXG4gICAgW1wiJlwiXSxcbiAgICBbXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCJdLFxuICAgIFtcIjxcIiwgXCI+XCIsIFwiPD1cIiwgXCI+PVwiLCBcImluXCIsIFwiaW5zdGFuY2VvZlwiXSxcbiAgICBbXCI+PlwiLCBcIjw8XCIsIFwiPj4+XCJdLFxuICAgIFtcIitcIiwgXCItXCJdLFxuICAgIFtcIipcIiwgXCIvXCIsIFwiJVwiXVxuICBdLmZvckVhY2goZnVuY3Rpb24odGllciwgaSkge1xuICAgIHRpZXIuZm9yRWFjaChmdW5jdGlvbihvcCkge1xuICAgICAgUFJFQ0VERU5DRVtvcF0gPSBpO1xuICAgIH0pO1xuICB9KTtcbiAgZnVuY3Rpb24gY29udGFpbnNDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gICAgaWYgKG4uQ2FsbEV4cHJlc3Npb24uY2hlY2sobm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNBcnJheS5jaGVjayhub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGUuc29tZShjb250YWluc0NhbGxFeHByZXNzaW9uKTtcbiAgICB9XG4gICAgaWYgKG4uTm9kZS5jaGVjayhub2RlKSkge1xuICAgICAgcmV0dXJuIHR5cGVzLnNvbWVGaWVsZChub2RlLCBmdW5jdGlvbihfbmFtZSwgY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5zQ2FsbEV4cHJlc3Npb24oY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBOUHAuY2FuQmVGaXJzdEluU3RhdGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgcmV0dXJuICFuLkZ1bmN0aW9uRXhwcmVzc2lvbi5jaGVjayhub2RlKSAmJiAhbi5PYmplY3RFeHByZXNzaW9uLmNoZWNrKG5vZGUpO1xuICB9O1xuICBOUHAuZmlyc3RJblN0YXRlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmaXJzdEluU3RhdGVtZW50KHRoaXMpO1xuICB9O1xuICBmdW5jdGlvbiBmaXJzdEluU3RhdGVtZW50KHBhdGgpIHtcbiAgICBmb3IgKHZhciBub2RlLCBwYXJlbnQ7IHBhdGgucGFyZW50OyBwYXRoID0gcGF0aC5wYXJlbnQpIHtcbiAgICAgIG5vZGUgPSBwYXRoLm5vZGU7XG4gICAgICBwYXJlbnQgPSBwYXRoLnBhcmVudC5ub2RlO1xuICAgICAgaWYgKG4uQmxvY2tTdGF0ZW1lbnQuY2hlY2socGFyZW50KSAmJiBwYXRoLnBhcmVudC5uYW1lID09PSBcImJvZHlcIiAmJiBwYXRoLm5hbWUgPT09IDApIHtcbiAgICAgICAgaWYgKHBhcmVudC5ib2R5WzBdICE9PSBub2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZXMgbXVzdCBiZSBlcXVhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChuLkV4cHJlc3Npb25TdGF0ZW1lbnQuY2hlY2socGFyZW50KSAmJiBwYXRoLm5hbWUgPT09IFwiZXhwcmVzc2lvblwiKSB7XG4gICAgICAgIGlmIChwYXJlbnQuZXhwcmVzc2lvbiAhPT0gbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGVzIG11c3QgYmUgZXF1YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAobi5TZXF1ZW5jZUV4cHJlc3Npb24uY2hlY2socGFyZW50KSAmJiBwYXRoLnBhcmVudC5uYW1lID09PSBcImV4cHJlc3Npb25zXCIgJiYgcGF0aC5uYW1lID09PSAwKSB7XG4gICAgICAgIGlmIChwYXJlbnQuZXhwcmVzc2lvbnNbMF0gIT09IG5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlcyBtdXN0IGJlIGVxdWFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG4uQ2FsbEV4cHJlc3Npb24uY2hlY2socGFyZW50KSAmJiBwYXRoLm5hbWUgPT09IFwiY2FsbGVlXCIpIHtcbiAgICAgICAgaWYgKHBhcmVudC5jYWxsZWUgIT09IG5vZGUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlcyBtdXN0IGJlIGVxdWFsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG4uTWVtYmVyRXhwcmVzc2lvbi5jaGVjayhwYXJlbnQpICYmIHBhdGgubmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAocGFyZW50Lm9iamVjdCAhPT0gbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGVzIG11c3QgYmUgZXF1YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobi5Db25kaXRpb25hbEV4cHJlc3Npb24uY2hlY2socGFyZW50KSAmJiBwYXRoLm5hbWUgPT09IFwidGVzdFwiKSB7XG4gICAgICAgIGlmIChwYXJlbnQudGVzdCAhPT0gbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGVzIG11c3QgYmUgZXF1YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNCaW5hcnkocGFyZW50KSAmJiBwYXRoLm5hbWUgPT09IFwibGVmdFwiKSB7XG4gICAgICAgIGlmIChwYXJlbnQubGVmdCAhPT0gbm9kZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vZGVzIG11c3QgYmUgZXF1YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobi5VbmFyeUV4cHJlc3Npb24uY2hlY2socGFyZW50KSAmJiAhcGFyZW50LnByZWZpeCAmJiBwYXRoLm5hbWUgPT09IFwiYXJndW1lbnRcIikge1xuICAgICAgICBpZiAocGFyZW50LmFyZ3VtZW50ICE9PSBub2RlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZXMgbXVzdCBiZSBlcXVhbFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYW5VcE5vZGVzQWZ0ZXJQcnVuZShyZW1haW5pbmdOb2RlUGF0aCkge1xuICAgIGlmIChuLlZhcmlhYmxlRGVjbGFyYXRpb24uY2hlY2socmVtYWluaW5nTm9kZVBhdGgubm9kZSkpIHtcbiAgICAgIHZhciBkZWNsYXJhdGlvbnMgPSByZW1haW5pbmdOb2RlUGF0aC5nZXQoXCJkZWNsYXJhdGlvbnNcIikudmFsdWU7XG4gICAgICBpZiAoIWRlY2xhcmF0aW9ucyB8fCBkZWNsYXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiByZW1haW5pbmdOb2RlUGF0aC5wcnVuZSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobi5FeHByZXNzaW9uU3RhdGVtZW50LmNoZWNrKHJlbWFpbmluZ05vZGVQYXRoLm5vZGUpKSB7XG4gICAgICBpZiAoIXJlbWFpbmluZ05vZGVQYXRoLmdldChcImV4cHJlc3Npb25cIikudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHJlbWFpbmluZ05vZGVQYXRoLnBydW5lKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuLklmU3RhdGVtZW50LmNoZWNrKHJlbWFpbmluZ05vZGVQYXRoLm5vZGUpKSB7XG4gICAgICBjbGVhblVwSWZTdGF0ZW1lbnRBZnRlclBydW5lKHJlbWFpbmluZ05vZGVQYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlbWFpbmluZ05vZGVQYXRoO1xuICB9XG4gIGZ1bmN0aW9uIGNsZWFuVXBJZlN0YXRlbWVudEFmdGVyUHJ1bmUoaWZTdGF0ZW1lbnQpIHtcbiAgICB2YXIgdGVzdEV4cHJlc3Npb24gPSBpZlN0YXRlbWVudC5nZXQoXCJ0ZXN0XCIpLnZhbHVlO1xuICAgIHZhciBhbHRlcm5hdGUgPSBpZlN0YXRlbWVudC5nZXQoXCJhbHRlcm5hdGVcIikudmFsdWU7XG4gICAgdmFyIGNvbnNlcXVlbnQgPSBpZlN0YXRlbWVudC5nZXQoXCJjb25zZXF1ZW50XCIpLnZhbHVlO1xuICAgIGlmICghY29uc2VxdWVudCAmJiAhYWx0ZXJuYXRlKSB7XG4gICAgICB2YXIgdGVzdEV4cHJlc3Npb25TdGF0ZW1lbnQgPSBiLmV4cHJlc3Npb25TdGF0ZW1lbnQodGVzdEV4cHJlc3Npb24pO1xuICAgICAgaWZTdGF0ZW1lbnQucmVwbGFjZSh0ZXN0RXhwcmVzc2lvblN0YXRlbWVudCk7XG4gICAgfSBlbHNlIGlmICghY29uc2VxdWVudCAmJiBhbHRlcm5hdGUpIHtcbiAgICAgIHZhciBuZWdhdGVkVGVzdEV4cHJlc3Npb24gPSBiLnVuYXJ5RXhwcmVzc2lvbihcIiFcIiwgdGVzdEV4cHJlc3Npb24sIHRydWUpO1xuICAgICAgaWYgKG4uVW5hcnlFeHByZXNzaW9uLmNoZWNrKHRlc3RFeHByZXNzaW9uKSAmJiB0ZXN0RXhwcmVzc2lvbi5vcGVyYXRvciA9PT0gXCIhXCIpIHtcbiAgICAgICAgbmVnYXRlZFRlc3RFeHByZXNzaW9uID0gdGVzdEV4cHJlc3Npb24uYXJndW1lbnQ7XG4gICAgICB9XG4gICAgICBpZlN0YXRlbWVudC5nZXQoXCJ0ZXN0XCIpLnJlcGxhY2UobmVnYXRlZFRlc3RFeHByZXNzaW9uKTtcbiAgICAgIGlmU3RhdGVtZW50LmdldChcImNvbnNlcXVlbnRcIikucmVwbGFjZShhbHRlcm5hdGUpO1xuICAgICAgaWZTdGF0ZW1lbnQuZ2V0KFwiYWx0ZXJuYXRlXCIpLnJlcGxhY2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIE5vZGVQYXRoO1xufVxubWF5YmVTZXRNb2R1bGVFeHBvcnRzKCgpID0+IG1vZHVsZSk7XG5cbnZhciBoYXNPd24kMyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBwYXRoVmlzaXRvclBsdWdpbihmb3JrKSB7XG4gIHZhciB0eXBlcyA9IGZvcmsudXNlKHR5cGVzUGx1Z2luKTtcbiAgdmFyIE5vZGVQYXRoMiA9IGZvcmsudXNlKG5vZGVQYXRoUGx1Z2luKTtcbiAgdmFyIGlzQXJyYXkgPSB0eXBlcy5idWlsdEluVHlwZXMuYXJyYXk7XG4gIHZhciBpc09iamVjdCA9IHR5cGVzLmJ1aWx0SW5UeXBlcy5vYmplY3Q7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZXMuYnVpbHRJblR5cGVzLmZ1bmN0aW9uO1xuICB2YXIgdW5kZWZpbmVkJDE7XG4gIGNvbnN0IFBhdGhWaXNpdG9yID0gZnVuY3Rpb24gUGF0aFZpc2l0b3IyKCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXRoVmlzaXRvcjIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiUGF0aFZpc2l0b3IgY29uc3RydWN0b3IgY2Fubm90IGJlIGludm9rZWQgd2l0aG91dCAnbmV3J1wiXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLl9yZXVzYWJsZUNvbnRleHRTdGFjayA9IFtdO1xuICAgIHRoaXMuX21ldGhvZE5hbWVUYWJsZSA9IGNvbXB1dGVNZXRob2ROYW1lVGFibGUodGhpcyk7XG4gICAgdGhpcy5fc2hvdWxkVmlzaXRDb21tZW50cyA9IGhhc093biQzLmNhbGwodGhpcy5fbWV0aG9kTmFtZVRhYmxlLCBcIkJsb2NrXCIpIHx8IGhhc093biQzLmNhbGwodGhpcy5fbWV0aG9kTmFtZVRhYmxlLCBcIkxpbmVcIik7XG4gICAgdGhpcy5Db250ZXh0ID0gbWFrZUNvbnRleHRDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgICB0aGlzLl92aXNpdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2NoYW5nZVJlcG9ydGVkID0gZmFsc2U7XG4gIH07XG4gIGZ1bmN0aW9uIGNvbXB1dGVNZXRob2ROYW1lVGFibGUodmlzaXRvcikge1xuICAgIHZhciB0eXBlTmFtZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIHZpc2l0b3IpIHtcbiAgICAgIGlmICgvXnZpc2l0W0EtWl0vLnRlc3QobWV0aG9kTmFtZSkpIHtcbiAgICAgICAgdHlwZU5hbWVzW21ldGhvZE5hbWUuc2xpY2UoXCJ2aXNpdFwiLmxlbmd0aCldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN1cGVydHlwZVRhYmxlID0gdHlwZXMuY29tcHV0ZVN1cGVydHlwZUxvb2t1cFRhYmxlKHR5cGVOYW1lcyk7XG4gICAgdmFyIG1ldGhvZE5hbWVUYWJsZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciB0eXBlTmFtZUtleXMgPSBPYmplY3Qua2V5cyhzdXBlcnR5cGVUYWJsZSk7XG4gICAgdmFyIHR5cGVOYW1lQ291bnQgPSB0eXBlTmFtZUtleXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZU5hbWVDb3VudDsgKytpKSB7XG4gICAgICB2YXIgdHlwZU5hbWUgPSB0eXBlTmFtZUtleXNbaV07XG4gICAgICBtZXRob2ROYW1lID0gXCJ2aXNpdFwiICsgc3VwZXJ0eXBlVGFibGVbdHlwZU5hbWVdO1xuICAgICAgaWYgKGlzRnVuY3Rpb24uY2hlY2sodmlzaXRvclttZXRob2ROYW1lXSkpIHtcbiAgICAgICAgbWV0aG9kTmFtZVRhYmxlW3R5cGVOYW1lXSA9IG1ldGhvZE5hbWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtZXRob2ROYW1lVGFibGU7XG4gIH1cbiAgUGF0aFZpc2l0b3IuZnJvbU1ldGhvZHNPYmplY3QgPSBmdW5jdGlvbiBmcm9tTWV0aG9kc09iamVjdChtZXRob2RzKSB7XG4gICAgaWYgKG1ldGhvZHMgaW5zdGFuY2VvZiBQYXRoVmlzaXRvcikge1xuICAgICAgcmV0dXJuIG1ldGhvZHM7XG4gICAgfVxuICAgIGlmICghaXNPYmplY3QuY2hlY2sobWV0aG9kcykpIHtcbiAgICAgIHJldHVybiBuZXcgUGF0aFZpc2l0b3IoKTtcbiAgICB9XG4gICAgY29uc3QgVmlzaXRvciA9IGZ1bmN0aW9uIFZpc2l0b3IyKCkge1xuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFZpc2l0b3IyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJWaXNpdG9yIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBpbnZva2VkIHdpdGhvdXQgJ25ldydcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgUGF0aFZpc2l0b3IuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHZhciBWcCA9IFZpc2l0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQVnApO1xuICAgIFZwLmNvbnN0cnVjdG9yID0gVmlzaXRvcjtcbiAgICBleHRlbmQoVnAsIG1ldGhvZHMpO1xuICAgIGV4dGVuZChWaXNpdG9yLCBQYXRoVmlzaXRvcik7XG4gICAgaXNGdW5jdGlvbi5hc3NlcnQoVmlzaXRvci5mcm9tTWV0aG9kc09iamVjdCk7XG4gICAgaXNGdW5jdGlvbi5hc3NlcnQoVmlzaXRvci52aXNpdCk7XG4gICAgcmV0dXJuIG5ldyBWaXNpdG9yKCk7XG4gIH07XG4gIGZ1bmN0aW9uIGV4dGVuZCh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKGhhc093biQzLmNhbGwoc291cmNlLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XSA9IHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cbiAgUGF0aFZpc2l0b3IudmlzaXQgPSBmdW5jdGlvbiB2aXNpdChub2RlLCBtZXRob2RzKSB7XG4gICAgcmV0dXJuIFBhdGhWaXNpdG9yLmZyb21NZXRob2RzT2JqZWN0KG1ldGhvZHMpLnZpc2l0KG5vZGUpO1xuICB9O1xuICB2YXIgUFZwID0gUGF0aFZpc2l0b3IucHJvdG90eXBlO1xuICBQVnAudmlzaXQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fdmlzaXRpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJSZWN1cnNpdmVseSBjYWxsaW5nIHZpc2l0b3IudmlzaXQocGF0aCkgcmVzZXRzIHZpc2l0b3Igc3RhdGUuIFRyeSB0aGlzLnZpc2l0KHBhdGgpIG9yIHRoaXMudHJhdmVyc2UocGF0aCkgaW5zdGVhZC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5fdmlzaXRpbmcgPSB0cnVlO1xuICAgIHRoaXMuX2NoYW5nZVJlcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYWJvcnRSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICB2YXIgYXJnYyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJnYyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdjOyArK2kpIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIGlmICghKGFyZ3NbMF0gaW5zdGFuY2VvZiBOb2RlUGF0aDIpKSB7XG4gICAgICBhcmdzWzBdID0gbmV3IE5vZGVQYXRoMih7IHJvb3Q6IGFyZ3NbMF0gfSkuZ2V0KFwicm9vdFwiKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgZGlkTm90VGhyb3c7XG4gICAgdHJ5IHtcbiAgICAgIHZhciByb290ID0gdGhpcy52aXNpdFdpdGhvdXRSZXNldChhcmdzWzBdKTtcbiAgICAgIGRpZE5vdFRocm93ID0gdHJ1ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5fdmlzaXRpbmcgPSBmYWxzZTtcbiAgICAgIGlmICghZGlkTm90VGhyb3cgJiYgdGhpcy5fYWJvcnRSZXF1ZXN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbMF0udmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb290O1xuICB9O1xuICBQVnAuQWJvcnRSZXF1ZXN0ID0gZnVuY3Rpb24gQWJvcnRSZXF1ZXN0KCkge1xuICB9O1xuICBQVnAuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdmlzaXRvciA9IHRoaXM7XG4gICAgdmlzaXRvci5fYWJvcnRSZXF1ZXN0ZWQgPSB0cnVlO1xuICAgIHZhciByZXF1ZXN0ID0gbmV3IHZpc2l0b3IuQWJvcnRSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5jYW5jZWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZpc2l0b3IuX2Fib3J0UmVxdWVzdGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICB0aHJvdyByZXF1ZXN0O1xuICB9O1xuICBQVnAucmVzZXQgPSBmdW5jdGlvbihfcGF0aCkge1xuICB9O1xuICBQVnAudmlzaXRXaXRob3V0UmVzZXQgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiB0aGlzLkNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpc2l0b3IudmlzaXRXaXRob3V0UmVzZXQocGF0aCk7XG4gICAgfVxuICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBOb2RlUGF0aDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHBhdGgudmFsdWU7XG4gICAgdmFyIG1ldGhvZE5hbWUgPSB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgdGhpcy5fbWV0aG9kTmFtZVRhYmxlW3ZhbHVlLnR5cGVdO1xuICAgIGlmIChtZXRob2ROYW1lKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuYWNxdWlyZUNvbnRleHQocGF0aCk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5pbnZva2VWaXNpdG9yTWV0aG9kKG1ldGhvZE5hbWUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5yZWxlYXNlQ29udGV4dChjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZpc2l0Q2hpbGRyZW4ocGF0aCwgdGhpcyk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiB2aXNpdENoaWxkcmVuKHBhdGgsIHZpc2l0b3IpIHtcbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgTm9kZVBhdGgyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgIH1cbiAgICBpZiAoISh2aXNpdG9yIGluc3RhbmNlb2YgUGF0aFZpc2l0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHBhdGgudmFsdWU7XG4gICAgaWYgKGlzQXJyYXkuY2hlY2sodmFsdWUpKSB7XG4gICAgICBwYXRoLmVhY2godmlzaXRvci52aXNpdFdpdGhvdXRSZXNldCwgdmlzaXRvcik7XG4gICAgfSBlbHNlIGlmICghaXNPYmplY3QuY2hlY2sodmFsdWUpKSA7IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkTmFtZXMgPSB0eXBlcy5nZXRGaWVsZE5hbWVzKHZhbHVlKTtcbiAgICAgIGlmICh2aXNpdG9yLl9zaG91bGRWaXNpdENvbW1lbnRzICYmIHZhbHVlLmNvbW1lbnRzICYmIGNoaWxkTmFtZXMuaW5kZXhPZihcImNvbW1lbnRzXCIpIDwgMCkge1xuICAgICAgICBjaGlsZE5hbWVzLnB1c2goXCJjb21tZW50c1wiKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGlsZENvdW50ID0gY2hpbGROYW1lcy5sZW5ndGg7XG4gICAgICB2YXIgY2hpbGRQYXRocyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZENvdW50OyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkTmFtZSA9IGNoaWxkTmFtZXNbaV07XG4gICAgICAgIGlmICghaGFzT3duJDMuY2FsbCh2YWx1ZSwgY2hpbGROYW1lKSkge1xuICAgICAgICAgIHZhbHVlW2NoaWxkTmFtZV0gPSB0eXBlcy5nZXRGaWVsZFZhbHVlKHZhbHVlLCBjaGlsZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkUGF0aHMucHVzaChwYXRoLmdldChjaGlsZE5hbWUpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRDb3VudDsgKytpKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXRXaXRob3V0UmVzZXQoY2hpbGRQYXRoc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXRoLnZhbHVlO1xuICB9XG4gIFBWcC5hY3F1aXJlQ29udGV4dCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBpZiAodGhpcy5fcmV1c2FibGVDb250ZXh0U3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuQ29udGV4dChwYXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JldXNhYmxlQ29udGV4dFN0YWNrLnBvcCgpLnJlc2V0KHBhdGgpO1xuICB9O1xuICBQVnAucmVsZWFzZUNvbnRleHQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgaWYgKCEoY29udGV4dCBpbnN0YW5jZW9mIHRoaXMuQ29udGV4dCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5fcmV1c2FibGVDb250ZXh0U3RhY2sucHVzaChjb250ZXh0KTtcbiAgICBjb250ZXh0LmN1cnJlbnRQYXRoID0gbnVsbDtcbiAgfTtcbiAgUFZwLnJlcG9ydENoYW5nZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9jaGFuZ2VSZXBvcnRlZCA9IHRydWU7XG4gIH07XG4gIFBWcC53YXNDaGFuZ2VSZXBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFuZ2VSZXBvcnRlZDtcbiAgfTtcbiAgZnVuY3Rpb24gbWFrZUNvbnRleHRDb25zdHJ1Y3Rvcih2aXNpdG9yKSB7XG4gICAgZnVuY3Rpb24gQ29udGV4dChwYXRoKSB7XG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ29udGV4dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhdGhWaXNpdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICB9XG4gICAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgTm9kZVBhdGgyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2aXNpdG9yXCIsIHtcbiAgICAgICAgdmFsdWU6IHZpc2l0b3IsXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmN1cnJlbnRQYXRoID0gcGF0aDtcbiAgICAgIHRoaXMubmVlZFRvQ2FsbFRyYXZlcnNlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5zZWFsKHRoaXMpO1xuICAgIH1cbiAgICBpZiAoISh2aXNpdG9yIGluc3RhbmNlb2YgUGF0aFZpc2l0b3IpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgfVxuICAgIHZhciBDcCA9IENvbnRleHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh2aXNpdG9yKTtcbiAgICBDcC5jb25zdHJ1Y3RvciA9IENvbnRleHQ7XG4gICAgZXh0ZW5kKENwLCBzaGFyZWRDb250ZXh0UHJvdG9NZXRob2RzKTtcbiAgICByZXR1cm4gQ29udGV4dDtcbiAgfVxuICB2YXIgc2hhcmVkQ29udGV4dFByb3RvTWV0aG9kcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBzaGFyZWRDb250ZXh0UHJvdG9NZXRob2RzLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQocGF0aCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiB0aGlzLkNvbnRleHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgfVxuICAgIGlmICghKHBhdGggaW5zdGFuY2VvZiBOb2RlUGF0aDIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFBhdGggPSBwYXRoO1xuICAgIHRoaXMubmVlZFRvQ2FsbFRyYXZlcnNlID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgc2hhcmVkQ29udGV4dFByb3RvTWV0aG9kcy5pbnZva2VWaXNpdG9yTWV0aG9kID0gZnVuY3Rpb24gaW52b2tlVmlzaXRvck1ldGhvZChtZXRob2ROYW1lKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHRoaXMuQ29udGV4dCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICB9XG4gICAgaWYgKCEodGhpcy5jdXJyZW50UGF0aCBpbnN0YW5jZW9mIE5vZGVQYXRoMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMudmlzaXRvclttZXRob2ROYW1lXS5jYWxsKHRoaXMsIHRoaXMuY3VycmVudFBhdGgpO1xuICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLm5lZWRUb0NhbGxUcmF2ZXJzZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQkMSkge1xuICAgICAgdGhpcy5jdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGgucmVwbGFjZShyZXN1bHQpWzBdO1xuICAgICAgaWYgKHRoaXMubmVlZFRvQ2FsbFRyYXZlcnNlKSB7XG4gICAgICAgIHRoaXMudHJhdmVyc2UodGhpcy5jdXJyZW50UGF0aCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZWRUb0NhbGxUcmF2ZXJzZSAhPT0gZmFsc2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJNdXN0IGVpdGhlciBjYWxsIHRoaXMudHJhdmVyc2Ugb3IgcmV0dXJuIGZhbHNlIGluIFwiICsgbWV0aG9kTmFtZVxuICAgICAgKTtcbiAgICB9XG4gICAgdmFyIHBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xuICAgIHJldHVybiBwYXRoICYmIHBhdGgudmFsdWU7XG4gIH07XG4gIHNoYXJlZENvbnRleHRQcm90b01ldGhvZHMudHJhdmVyc2UgPSBmdW5jdGlvbiB0cmF2ZXJzZShwYXRoLCBuZXdWaXNpdG9yKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHRoaXMuQ29udGV4dCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICB9XG4gICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIE5vZGVQYXRoMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICB9XG4gICAgaWYgKCEodGhpcy5jdXJyZW50UGF0aCBpbnN0YW5jZW9mIE5vZGVQYXRoMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5uZWVkVG9DYWxsVHJhdmVyc2UgPSBmYWxzZTtcbiAgICByZXR1cm4gdmlzaXRDaGlsZHJlbihwYXRoLCBQYXRoVmlzaXRvci5mcm9tTWV0aG9kc09iamVjdChcbiAgICAgIG5ld1Zpc2l0b3IgfHwgdGhpcy52aXNpdG9yXG4gICAgKSk7XG4gIH07XG4gIHNoYXJlZENvbnRleHRQcm90b01ldGhvZHMudmlzaXQgPSBmdW5jdGlvbiB2aXNpdChwYXRoLCBuZXdWaXNpdG9yKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHRoaXMuQ29udGV4dCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICB9XG4gICAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIE5vZGVQYXRoMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICB9XG4gICAgaWYgKCEodGhpcy5jdXJyZW50UGF0aCBpbnN0YW5jZW9mIE5vZGVQYXRoMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5uZWVkVG9DYWxsVHJhdmVyc2UgPSBmYWxzZTtcbiAgICByZXR1cm4gUGF0aFZpc2l0b3IuZnJvbU1ldGhvZHNPYmplY3QoXG4gICAgICBuZXdWaXNpdG9yIHx8IHRoaXMudmlzaXRvclxuICAgICkudmlzaXRXaXRob3V0UmVzZXQocGF0aCk7XG4gIH07XG4gIHNoYXJlZENvbnRleHRQcm90b01ldGhvZHMucmVwb3J0Q2hhbmdlZCA9IGZ1bmN0aW9uIHJlcG9ydENoYW5nZWQoKSB7XG4gICAgdGhpcy52aXNpdG9yLnJlcG9ydENoYW5nZWQoKTtcbiAgfTtcbiAgc2hhcmVkQ29udGV4dFByb3RvTWV0aG9kcy5hYm9ydCA9IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIHRoaXMubmVlZFRvQ2FsbFRyYXZlcnNlID0gZmFsc2U7XG4gICAgdGhpcy52aXNpdG9yLmFib3J0KCk7XG4gIH07XG4gIHJldHVybiBQYXRoVmlzaXRvcjtcbn1cbm1heWJlU2V0TW9kdWxlRXhwb3J0cygoKSA9PiBtb2R1bGUpO1xuXG5mdW5jdGlvbiBlcXVpdlBsdWdpbihmb3JrKSB7XG4gIHZhciB0eXBlcyA9IGZvcmsudXNlKHR5cGVzUGx1Z2luKTtcbiAgdmFyIGdldEZpZWxkTmFtZXMgPSB0eXBlcy5nZXRGaWVsZE5hbWVzO1xuICB2YXIgZ2V0RmllbGRWYWx1ZSA9IHR5cGVzLmdldEZpZWxkVmFsdWU7XG4gIHZhciBpc0FycmF5ID0gdHlwZXMuYnVpbHRJblR5cGVzLmFycmF5O1xuICB2YXIgaXNPYmplY3QgPSB0eXBlcy5idWlsdEluVHlwZXMub2JqZWN0O1xuICB2YXIgaXNEYXRlID0gdHlwZXMuYnVpbHRJblR5cGVzLkRhdGU7XG4gIHZhciBpc1JlZ0V4cCA9IHR5cGVzLmJ1aWx0SW5UeXBlcy5SZWdFeHA7XG4gIHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICBmdW5jdGlvbiBhc3ROb2Rlc0FyZUVxdWl2YWxlbnQoYSwgYiwgcHJvYmxlbVBhdGgpIHtcbiAgICBpZiAoaXNBcnJheS5jaGVjayhwcm9ibGVtUGF0aCkpIHtcbiAgICAgIHByb2JsZW1QYXRoLmxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2JsZW1QYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGFyZUVxdWl2YWxlbnQoYSwgYiwgcHJvYmxlbVBhdGgpO1xuICB9XG4gIGFzdE5vZGVzQXJlRXF1aXZhbGVudC5hc3NlcnQgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHByb2JsZW1QYXRoID0gW107XG4gICAgaWYgKCFhc3ROb2Rlc0FyZUVxdWl2YWxlbnQoYSwgYiwgcHJvYmxlbVBhdGgpKSB7XG4gICAgICBpZiAocHJvYmxlbVBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZXMgbXVzdCBiZSBlcXVhbFwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiTm9kZXMgZGlmZmVyIGluIHRoZSBmb2xsb3dpbmcgcGF0aDogXCIgKyBwcm9ibGVtUGF0aC5tYXAoc3Vic2NyaXB0Rm9yUHJvcGVydHkpLmpvaW4oXCJcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGZ1bmN0aW9uIHN1YnNjcmlwdEZvclByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgaWYgKC9bXyRhLXpdW18kYS16MC05XSovaS50ZXN0KHByb3BlcnR5KSkge1xuICAgICAgcmV0dXJuIFwiLlwiICsgcHJvcGVydHk7XG4gICAgfVxuICAgIHJldHVybiBcIltcIiArIEpTT04uc3RyaW5naWZ5KHByb3BlcnR5KSArIFwiXVwiO1xuICB9XG4gIGZ1bmN0aW9uIGFyZUVxdWl2YWxlbnQoYSwgYiwgcHJvYmxlbVBhdGgpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc0FycmF5LmNoZWNrKGEpKSB7XG4gICAgICByZXR1cm4gYXJyYXlzQXJlRXF1aXZhbGVudChhLCBiLCBwcm9ibGVtUGF0aCk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdC5jaGVjayhhKSkge1xuICAgICAgcmV0dXJuIG9iamVjdHNBcmVFcXVpdmFsZW50KGEsIGIsIHByb2JsZW1QYXRoKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZS5jaGVjayhhKSkge1xuICAgICAgcmV0dXJuIGlzRGF0ZS5jaGVjayhiKSAmJiArYSA9PT0gK2I7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cC5jaGVjayhhKSkge1xuICAgICAgcmV0dXJuIGlzUmVnRXhwLmNoZWNrKGIpICYmIChhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5nbG9iYWwgPT09IGIuZ2xvYmFsICYmIGEubXVsdGlsaW5lID09PSBiLm11bHRpbGluZSAmJiBhLmlnbm9yZUNhc2UgPT09IGIuaWdub3JlQ2FzZSk7XG4gICAgfVxuICAgIHJldHVybiBhID09IGI7XG4gIH1cbiAgZnVuY3Rpb24gYXJyYXlzQXJlRXF1aXZhbGVudChhLCBiLCBwcm9ibGVtUGF0aCkge1xuICAgIGlzQXJyYXkuYXNzZXJ0KGEpO1xuICAgIHZhciBhTGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKCFpc0FycmF5LmNoZWNrKGIpIHx8IGIubGVuZ3RoICE9PSBhTGVuZ3RoKSB7XG4gICAgICBpZiAocHJvYmxlbVBhdGgpIHtcbiAgICAgICAgcHJvYmxlbVBhdGgucHVzaChcImxlbmd0aFwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhTGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChwcm9ibGVtUGF0aCkge1xuICAgICAgICBwcm9ibGVtUGF0aC5wdXNoKGkpO1xuICAgICAgfVxuICAgICAgaWYgKGkgaW4gYSAhPT0gaSBpbiBiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghYXJlRXF1aXZhbGVudChhW2ldLCBiW2ldLCBwcm9ibGVtUGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHByb2JsZW1QYXRoKSB7XG4gICAgICAgIHZhciBwcm9ibGVtUGF0aFRhaWwgPSBwcm9ibGVtUGF0aC5wb3AoKTtcbiAgICAgICAgaWYgKHByb2JsZW1QYXRoVGFpbCAhPT0gaSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiICsgcHJvYmxlbVBhdGhUYWlsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBmdW5jdGlvbiBvYmplY3RzQXJlRXF1aXZhbGVudChhLCBiLCBwcm9ibGVtUGF0aCkge1xuICAgIGlzT2JqZWN0LmFzc2VydChhKTtcbiAgICBpZiAoIWlzT2JqZWN0LmNoZWNrKGIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhLnR5cGUgIT09IGIudHlwZSkge1xuICAgICAgaWYgKHByb2JsZW1QYXRoKSB7XG4gICAgICAgIHByb2JsZW1QYXRoLnB1c2goXCJ0eXBlXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgYU5hbWVzID0gZ2V0RmllbGROYW1lcyhhKTtcbiAgICB2YXIgYU5hbWVDb3VudCA9IGFOYW1lcy5sZW5ndGg7XG4gICAgdmFyIGJOYW1lcyA9IGdldEZpZWxkTmFtZXMoYik7XG4gICAgdmFyIGJOYW1lQ291bnQgPSBiTmFtZXMubGVuZ3RoO1xuICAgIGlmIChhTmFtZUNvdW50ID09PSBiTmFtZUNvdW50KSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFOYW1lQ291bnQ7ICsraSkge1xuICAgICAgICB2YXIgbmFtZSA9IGFOYW1lc1tpXTtcbiAgICAgICAgdmFyIGFDaGlsZCA9IGdldEZpZWxkVmFsdWUoYSwgbmFtZSk7XG4gICAgICAgIHZhciBiQ2hpbGQgPSBnZXRGaWVsZFZhbHVlKGIsIG5hbWUpO1xuICAgICAgICBpZiAocHJvYmxlbVBhdGgpIHtcbiAgICAgICAgICBwcm9ibGVtUGF0aC5wdXNoKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYXJlRXF1aXZhbGVudChhQ2hpbGQsIGJDaGlsZCwgcHJvYmxlbVBhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ibGVtUGF0aCkge1xuICAgICAgICAgIHZhciBwcm9ibGVtUGF0aFRhaWwgPSBwcm9ibGVtUGF0aC5wb3AoKTtcbiAgICAgICAgICBpZiAocHJvYmxlbVBhdGhUYWlsICE9PSBuYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIHByb2JsZW1QYXRoVGFpbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFwcm9ibGVtUGF0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgc2Vlbk5hbWVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGFOYW1lQ291bnQ7ICsraSkge1xuICAgICAgc2Vlbk5hbWVzW2FOYW1lc1tpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgYk5hbWVDb3VudDsgKytpKSB7XG4gICAgICBuYW1lID0gYk5hbWVzW2ldO1xuICAgICAgaWYgKCFoYXNPd24uY2FsbChzZWVuTmFtZXMsIG5hbWUpKSB7XG4gICAgICAgIHByb2JsZW1QYXRoLnB1c2gobmFtZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSBzZWVuTmFtZXNbbmFtZV07XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiBzZWVuTmFtZXMpIHtcbiAgICAgIHByb2JsZW1QYXRoLnB1c2gobmFtZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBhc3ROb2Rlc0FyZUVxdWl2YWxlbnQ7XG59XG5tYXliZVNldE1vZHVsZUV4cG9ydHMoKCkgPT4gbW9kdWxlKTtcblxuZnVuY3Rpb24gZm9yayhwbHVnaW5zKSB7XG4gIGNvbnN0IGZvcmsgPSBjcmVhdGVGb3JrKCk7XG4gIGNvbnN0IHR5cGVzID0gZm9yay51c2UodHlwZXNQbHVnaW4pO1xuICBwbHVnaW5zLmZvckVhY2goZm9yay51c2UpO1xuICB0eXBlcy5maW5hbGl6ZSgpO1xuICBjb25zdCBQYXRoVmlzaXRvciA9IGZvcmsudXNlKHBhdGhWaXNpdG9yUGx1Z2luKTtcbiAgcmV0dXJuIHtcbiAgICBUeXBlOiB0eXBlcy5UeXBlLFxuICAgIGJ1aWx0SW5UeXBlczogdHlwZXMuYnVpbHRJblR5cGVzLFxuICAgIG5hbWVkVHlwZXM6IHR5cGVzLm5hbWVkVHlwZXMsXG4gICAgYnVpbGRlcnM6IHR5cGVzLmJ1aWxkZXJzLFxuICAgIGRlZmluZU1ldGhvZDogdHlwZXMuZGVmaW5lTWV0aG9kLFxuICAgIGdldEZpZWxkTmFtZXM6IHR5cGVzLmdldEZpZWxkTmFtZXMsXG4gICAgZ2V0RmllbGRWYWx1ZTogdHlwZXMuZ2V0RmllbGRWYWx1ZSxcbiAgICBlYWNoRmllbGQ6IHR5cGVzLmVhY2hGaWVsZCxcbiAgICBzb21lRmllbGQ6IHR5cGVzLnNvbWVGaWVsZCxcbiAgICBnZXRTdXBlcnR5cGVOYW1lczogdHlwZXMuZ2V0U3VwZXJ0eXBlTmFtZXMsXG4gICAgZ2V0QnVpbGRlck5hbWU6IHR5cGVzLmdldEJ1aWxkZXJOYW1lLFxuICAgIGFzdE5vZGVzQXJlRXF1aXZhbGVudDogZm9yay51c2UoZXF1aXZQbHVnaW4pLFxuICAgIGZpbmFsaXplOiB0eXBlcy5maW5hbGl6ZSxcbiAgICBQYXRoOiBmb3JrLnVzZShwYXRoUGx1Z2luKSxcbiAgICBOb2RlUGF0aDogZm9yay51c2Uobm9kZVBhdGhQbHVnaW4pLFxuICAgIFBhdGhWaXNpdG9yLFxuICAgIHVzZTogZm9yay51c2UsXG4gICAgdmlzaXQ6IFBhdGhWaXNpdG9yLnZpc2l0XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JrKCkge1xuICBjb25zdCB1c2VkID0gW107XG4gIGNvbnN0IHVzZWRSZXN1bHQgPSBbXTtcbiAgZnVuY3Rpb24gdXNlKHBsdWdpbikge1xuICAgIHZhciBpZHggPSB1c2VkLmluZGV4T2YocGx1Z2luKTtcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgaWR4ID0gdXNlZC5sZW5ndGg7XG4gICAgICB1c2VkLnB1c2gocGx1Z2luKTtcbiAgICAgIHVzZWRSZXN1bHRbaWR4XSA9IHBsdWdpbihmb3JrKTtcbiAgICB9XG4gICAgcmV0dXJuIHVzZWRSZXN1bHRbaWR4XTtcbiAgfVxuICB2YXIgZm9yayA9IHsgdXNlIH07XG4gIHJldHVybiBmb3JrO1xufVxubWF5YmVTZXRNb2R1bGVFeHBvcnRzKCgpID0+IG1vZHVsZSk7XG5cbmZ1bmN0aW9uIGNvcmVPcHNEZWYoKSB7XG4gIHJldHVybiB7XG4gICAgQmluYXJ5T3BlcmF0b3JzOiBbXG4gICAgICBcIj09XCIsXG4gICAgICBcIiE9XCIsXG4gICAgICBcIj09PVwiLFxuICAgICAgXCIhPT1cIixcbiAgICAgIFwiPFwiLFxuICAgICAgXCI8PVwiLFxuICAgICAgXCI+XCIsXG4gICAgICBcIj49XCIsXG4gICAgICBcIjw8XCIsXG4gICAgICBcIj4+XCIsXG4gICAgICBcIj4+PlwiLFxuICAgICAgXCIrXCIsXG4gICAgICBcIi1cIixcbiAgICAgIFwiKlwiLFxuICAgICAgXCIvXCIsXG4gICAgICBcIiVcIixcbiAgICAgIFwiJlwiLFxuICAgICAgXCJ8XCIsXG4gICAgICBcIl5cIixcbiAgICAgIFwiaW5cIixcbiAgICAgIFwiaW5zdGFuY2VvZlwiXG4gICAgXSxcbiAgICBBc3NpZ25tZW50T3BlcmF0b3JzOiBbXG4gICAgICBcIj1cIixcbiAgICAgIFwiKz1cIixcbiAgICAgIFwiLT1cIixcbiAgICAgIFwiKj1cIixcbiAgICAgIFwiLz1cIixcbiAgICAgIFwiJT1cIixcbiAgICAgIFwiPDw9XCIsXG4gICAgICBcIj4+PVwiLFxuICAgICAgXCI+Pj49XCIsXG4gICAgICBcInw9XCIsXG4gICAgICBcIl49XCIsXG4gICAgICBcIiY9XCJcbiAgICBdLFxuICAgIExvZ2ljYWxPcGVyYXRvcnM6IFtcbiAgICAgIFwifHxcIixcbiAgICAgIFwiJiZcIlxuICAgIF1cbiAgfTtcbn1cbm1heWJlU2V0TW9kdWxlRXhwb3J0cygoKSA9PiBtb2R1bGUpO1xuXG5mdW5jdGlvbiBlczIwMTZPcHNEZWYoZm9yaykge1xuICBjb25zdCByZXN1bHQgPSBmb3JrLnVzZShjb3JlT3BzRGVmKTtcbiAgaWYgKHJlc3VsdC5CaW5hcnlPcGVyYXRvcnMuaW5kZXhPZihcIioqXCIpIDwgMCkge1xuICAgIHJlc3VsdC5CaW5hcnlPcGVyYXRvcnMucHVzaChcIioqXCIpO1xuICB9XG4gIGlmIChyZXN1bHQuQXNzaWdubWVudE9wZXJhdG9ycy5pbmRleE9mKFwiKio9XCIpIDwgMCkge1xuICAgIHJlc3VsdC5Bc3NpZ25tZW50T3BlcmF0b3JzLnB1c2goXCIqKj1cIik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbm1heWJlU2V0TW9kdWxlRXhwb3J0cygoKSA9PiBtb2R1bGUpO1xuXG5mdW5jdGlvbiBlczIwMjBPcHNEZWYoZm9yaykge1xuICBjb25zdCByZXN1bHQgPSBmb3JrLnVzZShlczIwMTZPcHNEZWYpO1xuICBpZiAocmVzdWx0LkxvZ2ljYWxPcGVyYXRvcnMuaW5kZXhPZihcIj8/XCIpIDwgMCkge1xuICAgIHJlc3VsdC5Mb2dpY2FsT3BlcmF0b3JzLnB1c2goXCI/P1wiKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxubWF5YmVTZXRNb2R1bGVFeHBvcnRzKCgpID0+IG1vZHVsZSk7XG5cbmZ1bmN0aW9uIGVzMjAyMU9wc0RlZihmb3JrKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGZvcmsudXNlKGVzMjAyME9wc0RlZik7XG4gIHJlc3VsdC5Mb2dpY2FsT3BlcmF0b3JzLmZvckVhY2goKG9wKSA9PiB7XG4gICAgY29uc3QgYXNzaWduT3AgPSBvcCArIFwiPVwiO1xuICAgIGlmIChyZXN1bHQuQXNzaWdubWVudE9wZXJhdG9ycy5pbmRleE9mKGFzc2lnbk9wKSA8IDApIHtcbiAgICAgIHJlc3VsdC5Bc3NpZ25tZW50T3BlcmF0b3JzLnB1c2goYXNzaWduT3ApO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5tYXliZVNldE1vZHVsZUV4cG9ydHMoKCkgPT4gbW9kdWxlKTtcblxuZnVuY3Rpb24gY29yZURlZihmb3JrKSB7XG4gIHZhciB0eXBlcyA9IGZvcmsudXNlKHR5cGVzUGx1Z2luKTtcbiAgdmFyIFR5cGUgPSB0eXBlcy5UeXBlO1xuICB2YXIgZGVmID0gVHlwZS5kZWY7XG4gIHZhciBvciA9IFR5cGUub3I7XG4gIHZhciBzaGFyZWQgPSBmb3JrLnVzZShzaGFyZWRQbHVnaW4pO1xuICB2YXIgZGVmYXVsdHMgPSBzaGFyZWQuZGVmYXVsdHM7XG4gIHZhciBnZXEgPSBzaGFyZWQuZ2VxO1xuICBjb25zdCB7XG4gICAgQmluYXJ5T3BlcmF0b3JzLFxuICAgIEFzc2lnbm1lbnRPcGVyYXRvcnMsXG4gICAgTG9naWNhbE9wZXJhdG9yc1xuICB9ID0gZm9yay51c2UoY29yZU9wc0RlZik7XG4gIGRlZihcIlByaW50YWJsZVwiKS5maWVsZChcImxvY1wiLCBvcihcbiAgICBkZWYoXCJTb3VyY2VMb2NhdGlvblwiKSxcbiAgICBudWxsXG4gICksIGRlZmF1bHRzW1wibnVsbFwiXSwgdHJ1ZSk7XG4gIGRlZihcIk5vZGVcIikuYmFzZXMoXCJQcmludGFibGVcIikuZmllbGQoXCJ0eXBlXCIsIFN0cmluZykuZmllbGQoXCJjb21tZW50c1wiLCBvcihcbiAgICBbZGVmKFwiQ29tbWVudFwiKV0sXG4gICAgbnVsbFxuICApLCBkZWZhdWx0c1tcIm51bGxcIl0sIHRydWUpO1xuICBkZWYoXCJTb3VyY2VMb2NhdGlvblwiKS5maWVsZChcInN0YXJ0XCIsIGRlZihcIlBvc2l0aW9uXCIpKS5maWVsZChcImVuZFwiLCBkZWYoXCJQb3NpdGlvblwiKSkuZmllbGQoXCJzb3VyY2VcIiwgb3IoU3RyaW5nLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKTtcbiAgZGVmKFwiUG9zaXRpb25cIikuZmllbGQoXCJsaW5lXCIsIGdlcSgxKSkuZmllbGQoXCJjb2x1bW5cIiwgZ2VxKDApKTtcbiAgZGVmKFwiRmlsZVwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJwcm9ncmFtXCIsIFwibmFtZVwiKS5maWVsZChcInByb2dyYW1cIiwgZGVmKFwiUHJvZ3JhbVwiKSkuZmllbGQoXCJuYW1lXCIsIG9yKFN0cmluZywgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIlByb2dyYW1cIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwiYm9keVwiKS5maWVsZChcImJvZHlcIiwgW2RlZihcIlN0YXRlbWVudFwiKV0pO1xuICBkZWYoXCJGdW5jdGlvblwiKS5iYXNlcyhcIk5vZGVcIikuZmllbGQoXCJpZFwiLCBvcihkZWYoXCJJZGVudGlmaWVyXCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKS5maWVsZChcInBhcmFtc1wiLCBbZGVmKFwiUGF0dGVyblwiKV0pLmZpZWxkKFwiYm9keVwiLCBkZWYoXCJCbG9ja1N0YXRlbWVudFwiKSkuZmllbGQoXCJnZW5lcmF0b3JcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJhc3luY1wiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKTtcbiAgZGVmKFwiU3RhdGVtZW50XCIpLmJhc2VzKFwiTm9kZVwiKTtcbiAgZGVmKFwiRW1wdHlTdGF0ZW1lbnRcIikuYmFzZXMoXCJTdGF0ZW1lbnRcIikuYnVpbGQoKTtcbiAgZGVmKFwiQmxvY2tTdGF0ZW1lbnRcIikuYmFzZXMoXCJTdGF0ZW1lbnRcIikuYnVpbGQoXCJib2R5XCIpLmZpZWxkKFwiYm9keVwiLCBbZGVmKFwiU3RhdGVtZW50XCIpXSk7XG4gIGRlZihcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIikuYmFzZXMoXCJTdGF0ZW1lbnRcIikuYnVpbGQoXCJleHByZXNzaW9uXCIpLmZpZWxkKFwiZXhwcmVzc2lvblwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcbiAgZGVmKFwiSWZTdGF0ZW1lbnRcIikuYmFzZXMoXCJTdGF0ZW1lbnRcIikuYnVpbGQoXCJ0ZXN0XCIsIFwiY29uc2VxdWVudFwiLCBcImFsdGVybmF0ZVwiKS5maWVsZChcInRlc3RcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSkuZmllbGQoXCJjb25zZXF1ZW50XCIsIGRlZihcIlN0YXRlbWVudFwiKSkuZmllbGQoXCJhbHRlcm5hdGVcIiwgb3IoZGVmKFwiU3RhdGVtZW50XCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKTtcbiAgZGVmKFwiTGFiZWxlZFN0YXRlbWVudFwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZChcImxhYmVsXCIsIFwiYm9keVwiKS5maWVsZChcImxhYmVsXCIsIGRlZihcIklkZW50aWZpZXJcIikpLmZpZWxkKFwiYm9keVwiLCBkZWYoXCJTdGF0ZW1lbnRcIikpO1xuICBkZWYoXCJCcmVha1N0YXRlbWVudFwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZChcImxhYmVsXCIpLmZpZWxkKFwibGFiZWxcIiwgb3IoZGVmKFwiSWRlbnRpZmllclwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIkNvbnRpbnVlU3RhdGVtZW50XCIpLmJhc2VzKFwiU3RhdGVtZW50XCIpLmJ1aWxkKFwibGFiZWxcIikuZmllbGQoXCJsYWJlbFwiLCBvcihkZWYoXCJJZGVudGlmaWVyXCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKTtcbiAgZGVmKFwiV2l0aFN0YXRlbWVudFwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZChcIm9iamVjdFwiLCBcImJvZHlcIikuZmllbGQoXCJvYmplY3RcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSkuZmllbGQoXCJib2R5XCIsIGRlZihcIlN0YXRlbWVudFwiKSk7XG4gIGRlZihcIlN3aXRjaFN0YXRlbWVudFwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZChcImRpc2NyaW1pbmFudFwiLCBcImNhc2VzXCIsIFwibGV4aWNhbFwiKS5maWVsZChcImRpc2NyaW1pbmFudFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcImNhc2VzXCIsIFtkZWYoXCJTd2l0Y2hDYXNlXCIpXSkuZmllbGQoXCJsZXhpY2FsXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pO1xuICBkZWYoXCJSZXR1cm5TdGF0ZW1lbnRcIikuYmFzZXMoXCJTdGF0ZW1lbnRcIikuYnVpbGQoXCJhcmd1bWVudFwiKS5maWVsZChcImFyZ3VtZW50XCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIG51bGwpKTtcbiAgZGVmKFwiVGhyb3dTdGF0ZW1lbnRcIikuYmFzZXMoXCJTdGF0ZW1lbnRcIikuYnVpbGQoXCJhcmd1bWVudFwiKS5maWVsZChcImFyZ3VtZW50XCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuICBkZWYoXCJUcnlTdGF0ZW1lbnRcIikuYmFzZXMoXCJTdGF0ZW1lbnRcIikuYnVpbGQoXCJibG9ja1wiLCBcImhhbmRsZXJcIiwgXCJmaW5hbGl6ZXJcIikuZmllbGQoXCJibG9ja1wiLCBkZWYoXCJCbG9ja1N0YXRlbWVudFwiKSkuZmllbGQoXCJoYW5kbGVyXCIsIG9yKGRlZihcIkNhdGNoQ2xhdXNlXCIpLCBudWxsKSwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMgJiYgdGhpcy5oYW5kbGVyc1swXSB8fCBudWxsO1xuICB9KS5maWVsZChcImhhbmRsZXJzXCIsIFtkZWYoXCJDYXRjaENsYXVzZVwiKV0sIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZXIgPyBbdGhpcy5oYW5kbGVyXSA6IFtdO1xuICB9LCB0cnVlKS5maWVsZChcImd1YXJkZWRIYW5kbGVyc1wiLCBbZGVmKFwiQ2F0Y2hDbGF1c2VcIildLCBkZWZhdWx0cy5lbXB0eUFycmF5KS5maWVsZChcImZpbmFsaXplclwiLCBvcihkZWYoXCJCbG9ja1N0YXRlbWVudFwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIkNhdGNoQ2xhdXNlXCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZChcInBhcmFtXCIsIFwiZ3VhcmRcIiwgXCJib2R5XCIpLmZpZWxkKFwicGFyYW1cIiwgZGVmKFwiUGF0dGVyblwiKSkuZmllbGQoXCJndWFyZFwiLCBvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKS5maWVsZChcImJvZHlcIiwgZGVmKFwiQmxvY2tTdGF0ZW1lbnRcIikpO1xuICBkZWYoXCJXaGlsZVN0YXRlbWVudFwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZChcInRlc3RcIiwgXCJib2R5XCIpLmZpZWxkKFwidGVzdFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcImJvZHlcIiwgZGVmKFwiU3RhdGVtZW50XCIpKTtcbiAgZGVmKFwiRG9XaGlsZVN0YXRlbWVudFwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZChcImJvZHlcIiwgXCJ0ZXN0XCIpLmZpZWxkKFwiYm9keVwiLCBkZWYoXCJTdGF0ZW1lbnRcIikpLmZpZWxkKFwidGVzdFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcbiAgZGVmKFwiRm9yU3RhdGVtZW50XCIpLmJhc2VzKFwiU3RhdGVtZW50XCIpLmJ1aWxkKFwiaW5pdFwiLCBcInRlc3RcIiwgXCJ1cGRhdGVcIiwgXCJib2R5XCIpLmZpZWxkKFwiaW5pdFwiLCBvcihcbiAgICBkZWYoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpLFxuICAgIGRlZihcIkV4cHJlc3Npb25cIiksXG4gICAgbnVsbFxuICApKS5maWVsZChcInRlc3RcIiwgb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgbnVsbCkpLmZpZWxkKFwidXBkYXRlXCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIG51bGwpKS5maWVsZChcImJvZHlcIiwgZGVmKFwiU3RhdGVtZW50XCIpKTtcbiAgZGVmKFwiRm9ySW5TdGF0ZW1lbnRcIikuYmFzZXMoXCJTdGF0ZW1lbnRcIikuYnVpbGQoXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJib2R5XCIpLmZpZWxkKFwibGVmdFwiLCBvcihcbiAgICBkZWYoXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpLFxuICAgIGRlZihcIkV4cHJlc3Npb25cIilcbiAgKSkuZmllbGQoXCJyaWdodFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcImJvZHlcIiwgZGVmKFwiU3RhdGVtZW50XCIpKTtcbiAgZGVmKFwiRGVidWdnZXJTdGF0ZW1lbnRcIikuYmFzZXMoXCJTdGF0ZW1lbnRcIikuYnVpbGQoKTtcbiAgZGVmKFwiRGVjbGFyYXRpb25cIikuYmFzZXMoXCJTdGF0ZW1lbnRcIik7XG4gIGRlZihcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIikuYmFzZXMoXCJGdW5jdGlvblwiLCBcIkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwiaWRcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIpLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSk7XG4gIGRlZihcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKS5iYXNlcyhcIkZ1bmN0aW9uXCIsIFwiRXhwcmVzc2lvblwiKS5idWlsZChcImlkXCIsIFwicGFyYW1zXCIsIFwiYm9keVwiKTtcbiAgZGVmKFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwia2luZFwiLCBcImRlY2xhcmF0aW9uc1wiKS5maWVsZChcImtpbmRcIiwgb3IoXCJ2YXJcIiwgXCJsZXRcIiwgXCJjb25zdFwiKSkuZmllbGQoXCJkZWNsYXJhdGlvbnNcIiwgW2RlZihcIlZhcmlhYmxlRGVjbGFyYXRvclwiKV0pO1xuICBkZWYoXCJWYXJpYWJsZURlY2xhcmF0b3JcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwiaWRcIiwgXCJpbml0XCIpLmZpZWxkKFwiaWRcIiwgZGVmKFwiUGF0dGVyblwiKSkuZmllbGQoXCJpbml0XCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuICBkZWYoXCJFeHByZXNzaW9uXCIpLmJhc2VzKFwiTm9kZVwiKTtcbiAgZGVmKFwiVGhpc0V4cHJlc3Npb25cIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpLmJ1aWxkKCk7XG4gIGRlZihcIkFycmF5RXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJlbGVtZW50c1wiKS5maWVsZChcImVsZW1lbnRzXCIsIFtvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKV0pO1xuICBkZWYoXCJPYmplY3RFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcInByb3BlcnRpZXNcIikuZmllbGQoXCJwcm9wZXJ0aWVzXCIsIFtkZWYoXCJQcm9wZXJ0eVwiKV0pO1xuICBkZWYoXCJQcm9wZXJ0eVwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJraW5kXCIsIFwia2V5XCIsIFwidmFsdWVcIikuZmllbGQoXCJraW5kXCIsIG9yKFwiaW5pdFwiLCBcImdldFwiLCBcInNldFwiKSkuZmllbGQoXCJrZXlcIiwgb3IoZGVmKFwiTGl0ZXJhbFwiKSwgZGVmKFwiSWRlbnRpZmllclwiKSkpLmZpZWxkKFwidmFsdWVcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG4gIGRlZihcIlNlcXVlbmNlRXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJleHByZXNzaW9uc1wiKS5maWVsZChcImV4cHJlc3Npb25zXCIsIFtkZWYoXCJFeHByZXNzaW9uXCIpXSk7XG4gIHZhciBVbmFyeU9wZXJhdG9yID0gb3IoXG4gICAgXCItXCIsXG4gICAgXCIrXCIsXG4gICAgXCIhXCIsXG4gICAgXCJ+XCIsXG4gICAgXCJ0eXBlb2ZcIixcbiAgICBcInZvaWRcIixcbiAgICBcImRlbGV0ZVwiXG4gICk7XG4gIGRlZihcIlVuYXJ5RXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJvcGVyYXRvclwiLCBcImFyZ3VtZW50XCIsIFwicHJlZml4XCIpLmZpZWxkKFwib3BlcmF0b3JcIiwgVW5hcnlPcGVyYXRvcikuZmllbGQoXCJhcmd1bWVudFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcInByZWZpeFwiLCBCb29sZWFuLCBkZWZhdWx0c1tcInRydWVcIl0pO1xuICBjb25zdCBCaW5hcnlPcGVyYXRvciA9IG9yKC4uLkJpbmFyeU9wZXJhdG9ycyk7XG4gIGRlZihcIkJpbmFyeUV4cHJlc3Npb25cIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpLmJ1aWxkKFwib3BlcmF0b3JcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIikuZmllbGQoXCJvcGVyYXRvclwiLCBCaW5hcnlPcGVyYXRvcikuZmllbGQoXCJsZWZ0XCIsIGRlZihcIkV4cHJlc3Npb25cIikpLmZpZWxkKFwicmlnaHRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG4gIGNvbnN0IEFzc2lnbm1lbnRPcGVyYXRvciA9IG9yKC4uLkFzc2lnbm1lbnRPcGVyYXRvcnMpO1xuICBkZWYoXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJvcGVyYXRvclwiLCBcImxlZnRcIiwgXCJyaWdodFwiKS5maWVsZChcIm9wZXJhdG9yXCIsIEFzc2lnbm1lbnRPcGVyYXRvcikuZmllbGQoXCJsZWZ0XCIsIG9yKGRlZihcIlBhdHRlcm5cIiksIGRlZihcIk1lbWJlckV4cHJlc3Npb25cIikpKS5maWVsZChcInJpZ2h0XCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuICB2YXIgVXBkYXRlT3BlcmF0b3IgPSBvcihcIisrXCIsIFwiLS1cIik7XG4gIGRlZihcIlVwZGF0ZUV4cHJlc3Npb25cIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpLmJ1aWxkKFwib3BlcmF0b3JcIiwgXCJhcmd1bWVudFwiLCBcInByZWZpeFwiKS5maWVsZChcIm9wZXJhdG9yXCIsIFVwZGF0ZU9wZXJhdG9yKS5maWVsZChcImFyZ3VtZW50XCIsIGRlZihcIkV4cHJlc3Npb25cIikpLmZpZWxkKFwicHJlZml4XCIsIEJvb2xlYW4pO1xuICB2YXIgTG9naWNhbE9wZXJhdG9yID0gb3IoLi4uTG9naWNhbE9wZXJhdG9ycyk7XG4gIGRlZihcIkxvZ2ljYWxFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcIm9wZXJhdG9yXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIpLmZpZWxkKFwib3BlcmF0b3JcIiwgTG9naWNhbE9wZXJhdG9yKS5maWVsZChcImxlZnRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSkuZmllbGQoXCJyaWdodFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcbiAgZGVmKFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcInRlc3RcIiwgXCJjb25zZXF1ZW50XCIsIFwiYWx0ZXJuYXRlXCIpLmZpZWxkKFwidGVzdFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcImNvbnNlcXVlbnRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSkuZmllbGQoXCJhbHRlcm5hdGVcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG4gIGRlZihcIk5ld0V4cHJlc3Npb25cIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpLmJ1aWxkKFwiY2FsbGVlXCIsIFwiYXJndW1lbnRzXCIpLmZpZWxkKFwiY2FsbGVlXCIsIGRlZihcIkV4cHJlc3Npb25cIikpLmZpZWxkKFwiYXJndW1lbnRzXCIsIFtkZWYoXCJFeHByZXNzaW9uXCIpXSk7XG4gIGRlZihcIkNhbGxFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcImNhbGxlZVwiLCBcImFyZ3VtZW50c1wiKS5maWVsZChcImNhbGxlZVwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcImFyZ3VtZW50c1wiLCBbZGVmKFwiRXhwcmVzc2lvblwiKV0pO1xuICBkZWYoXCJNZW1iZXJFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcIm9iamVjdFwiLCBcInByb3BlcnR5XCIsIFwiY29tcHV0ZWRcIikuZmllbGQoXCJvYmplY3RcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSkuZmllbGQoXCJwcm9wZXJ0eVwiLCBvcihkZWYoXCJJZGVudGlmaWVyXCIpLCBkZWYoXCJFeHByZXNzaW9uXCIpKSkuZmllbGQoXCJjb21wdXRlZFwiLCBCb29sZWFuLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMucHJvcGVydHkudHlwZTtcbiAgICBpZiAodHlwZSA9PT0gXCJMaXRlcmFsXCIgfHwgdHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgdHlwZSA9PT0gXCJCaW5hcnlFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICBkZWYoXCJQYXR0ZXJuXCIpLmJhc2VzKFwiTm9kZVwiKTtcbiAgZGVmKFwiU3dpdGNoQ2FzZVwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJ0ZXN0XCIsIFwiY29uc2VxdWVudFwiKS5maWVsZChcInRlc3RcIiwgb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgbnVsbCkpLmZpZWxkKFwiY29uc2VxdWVudFwiLCBbZGVmKFwiU3RhdGVtZW50XCIpXSk7XG4gIGRlZihcIklkZW50aWZpZXJcIikuYmFzZXMoXCJFeHByZXNzaW9uXCIsIFwiUGF0dGVyblwiKS5idWlsZChcIm5hbWVcIikuZmllbGQoXCJuYW1lXCIsIFN0cmluZykuZmllbGQoXCJvcHRpb25hbFwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKTtcbiAgZGVmKFwiTGl0ZXJhbFwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJ2YWx1ZVwiKS5maWVsZChcInZhbHVlXCIsIG9yKFN0cmluZywgQm9vbGVhbiwgbnVsbCwgTnVtYmVyLCBSZWdFeHAsIEJpZ0ludCkpO1xuICBkZWYoXCJDb21tZW50XCIpLmJhc2VzKFwiUHJpbnRhYmxlXCIpLmZpZWxkKFwidmFsdWVcIiwgU3RyaW5nKS5maWVsZChcImxlYWRpbmdcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJ0cnVlXCJdKS5maWVsZChcInRyYWlsaW5nXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pO1xufVxubWF5YmVTZXRNb2R1bGVFeHBvcnRzKCgpID0+IG1vZHVsZSk7XG5cbmZ1bmN0aW9uIGVzNkRlZihmb3JrKSB7XG4gIGZvcmsudXNlKGNvcmVEZWYpO1xuICBjb25zdCB0eXBlcyA9IGZvcmsudXNlKHR5cGVzUGx1Z2luKTtcbiAgY29uc3QgZGVmID0gdHlwZXMuVHlwZS5kZWY7XG4gIGNvbnN0IG9yID0gdHlwZXMuVHlwZS5vcjtcbiAgY29uc3QgZGVmYXVsdHMgPSBmb3JrLnVzZShzaGFyZWRQbHVnaW4pLmRlZmF1bHRzO1xuICBkZWYoXCJGdW5jdGlvblwiKS5maWVsZChcImdlbmVyYXRvclwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcImV4cHJlc3Npb25cIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJkZWZhdWx0c1wiLCBbb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgbnVsbCldLCBkZWZhdWx0cy5lbXB0eUFycmF5KS5maWVsZChcInJlc3RcIiwgb3IoZGVmKFwiSWRlbnRpZmllclwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIlJlc3RFbGVtZW50XCIpLmJhc2VzKFwiUGF0dGVyblwiKS5idWlsZChcImFyZ3VtZW50XCIpLmZpZWxkKFwiYXJndW1lbnRcIiwgZGVmKFwiUGF0dGVyblwiKSkuZmllbGQoXG4gICAgXCJ0eXBlQW5ub3RhdGlvblwiLFxuICAgIC8vIGZvciBCYWJ5bG9uLiBGbG93IHBhcnNlciBwdXRzIGl0IG9uIHRoZSBpZGVudGlmaWVyXG4gICAgb3IoZGVmKFwiVHlwZUFubm90YXRpb25cIiksIGRlZihcIlRTVHlwZUFubm90YXRpb25cIiksIG51bGwpLFxuICAgIGRlZmF1bHRzW1wibnVsbFwiXVxuICApO1xuICBkZWYoXCJTcHJlYWRFbGVtZW50UGF0dGVyblwiKS5iYXNlcyhcIlBhdHRlcm5cIikuYnVpbGQoXCJhcmd1bWVudFwiKS5maWVsZChcImFyZ3VtZW50XCIsIGRlZihcIlBhdHRlcm5cIikpO1xuICBkZWYoXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwiaWRcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiZ2VuZXJhdG9yXCIsIFwiZXhwcmVzc2lvblwiKS5maWVsZChcImlkXCIsIG9yKGRlZihcIklkZW50aWZpZXJcIiksIG51bGwpKTtcbiAgZGVmKFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpLmJ1aWxkKFwiaWRcIiwgXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiZ2VuZXJhdG9yXCIsIFwiZXhwcmVzc2lvblwiKTtcbiAgZGVmKFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikuYmFzZXMoXCJGdW5jdGlvblwiLCBcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJwYXJhbXNcIiwgXCJib2R5XCIsIFwiZXhwcmVzc2lvblwiKS5maWVsZChcImlkXCIsIG51bGwsIGRlZmF1bHRzW1wibnVsbFwiXSkuZmllbGQoXCJib2R5XCIsIG9yKGRlZihcIkJsb2NrU3RhdGVtZW50XCIpLCBkZWYoXCJFeHByZXNzaW9uXCIpKSkuZmllbGQoXCJnZW5lcmF0b3JcIiwgZmFsc2UsIGRlZmF1bHRzW1wiZmFsc2VcIl0pO1xuICBkZWYoXCJGb3JPZlN0YXRlbWVudFwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZChcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvZHlcIikuZmllbGQoXCJsZWZ0XCIsIG9yKFxuICAgIGRlZihcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiksXG4gICAgZGVmKFwiUGF0dGVyblwiKVxuICApKS5maWVsZChcInJpZ2h0XCIsIGRlZihcIkV4cHJlc3Npb25cIikpLmZpZWxkKFwiYm9keVwiLCBkZWYoXCJTdGF0ZW1lbnRcIikpO1xuICBkZWYoXCJZaWVsZEV4cHJlc3Npb25cIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpLmJ1aWxkKFwiYXJndW1lbnRcIiwgXCJkZWxlZ2F0ZVwiKS5maWVsZChcImFyZ3VtZW50XCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIG51bGwpKS5maWVsZChcImRlbGVnYXRlXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pO1xuICBkZWYoXCJHZW5lcmF0b3JFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcImJvZHlcIiwgXCJibG9ja3NcIiwgXCJmaWx0ZXJcIikuZmllbGQoXCJib2R5XCIsIGRlZihcIkV4cHJlc3Npb25cIikpLmZpZWxkKFwiYmxvY2tzXCIsIFtkZWYoXCJDb21wcmVoZW5zaW9uQmxvY2tcIildKS5maWVsZChcImZpbHRlclwiLCBvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKSk7XG4gIGRlZihcIkNvbXByZWhlbnNpb25FeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcImJvZHlcIiwgXCJibG9ja3NcIiwgXCJmaWx0ZXJcIikuZmllbGQoXCJib2R5XCIsIGRlZihcIkV4cHJlc3Npb25cIikpLmZpZWxkKFwiYmxvY2tzXCIsIFtkZWYoXCJDb21wcmVoZW5zaW9uQmxvY2tcIildKS5maWVsZChcImZpbHRlclwiLCBvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKSk7XG4gIGRlZihcIkNvbXByZWhlbnNpb25CbG9ja1wiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJlYWNoXCIpLmZpZWxkKFwibGVmdFwiLCBkZWYoXCJQYXR0ZXJuXCIpKS5maWVsZChcInJpZ2h0XCIsIGRlZihcIkV4cHJlc3Npb25cIikpLmZpZWxkKFwiZWFjaFwiLCBCb29sZWFuKTtcbiAgZGVmKFwiUHJvcGVydHlcIikuZmllbGQoXCJrZXlcIiwgb3IoZGVmKFwiTGl0ZXJhbFwiKSwgZGVmKFwiSWRlbnRpZmllclwiKSwgZGVmKFwiRXhwcmVzc2lvblwiKSkpLmZpZWxkKFwidmFsdWVcIiwgb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgZGVmKFwiUGF0dGVyblwiKSkpLmZpZWxkKFwibWV0aG9kXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pLmZpZWxkKFwic2hvcnRoYW5kXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pLmZpZWxkKFwiY29tcHV0ZWRcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSk7XG4gIGRlZihcIk9iamVjdFByb3BlcnR5XCIpLmZpZWxkKFwic2hvcnRoYW5kXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pO1xuICBkZWYoXCJQcm9wZXJ0eVBhdHRlcm5cIikuYmFzZXMoXCJQYXR0ZXJuXCIpLmJ1aWxkKFwia2V5XCIsIFwicGF0dGVyblwiKS5maWVsZChcImtleVwiLCBvcihkZWYoXCJMaXRlcmFsXCIpLCBkZWYoXCJJZGVudGlmaWVyXCIpLCBkZWYoXCJFeHByZXNzaW9uXCIpKSkuZmllbGQoXCJwYXR0ZXJuXCIsIGRlZihcIlBhdHRlcm5cIikpLmZpZWxkKFwiY29tcHV0ZWRcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSk7XG4gIGRlZihcIk9iamVjdFBhdHRlcm5cIikuYmFzZXMoXCJQYXR0ZXJuXCIpLmJ1aWxkKFwicHJvcGVydGllc1wiKS5maWVsZChcInByb3BlcnRpZXNcIiwgW29yKGRlZihcIlByb3BlcnR5UGF0dGVyblwiKSwgZGVmKFwiUHJvcGVydHlcIikpXSk7XG4gIGRlZihcIkFycmF5UGF0dGVyblwiKS5iYXNlcyhcIlBhdHRlcm5cIikuYnVpbGQoXCJlbGVtZW50c1wiKS5maWVsZChcImVsZW1lbnRzXCIsIFtvcihkZWYoXCJQYXR0ZXJuXCIpLCBudWxsKV0pO1xuICBkZWYoXCJTcHJlYWRFbGVtZW50XCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZChcImFyZ3VtZW50XCIpLmZpZWxkKFwiYXJndW1lbnRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG4gIGRlZihcIkFycmF5RXhwcmVzc2lvblwiKS5maWVsZChcImVsZW1lbnRzXCIsIFtvcihcbiAgICBkZWYoXCJFeHByZXNzaW9uXCIpLFxuICAgIGRlZihcIlNwcmVhZEVsZW1lbnRcIiksXG4gICAgZGVmKFwiUmVzdEVsZW1lbnRcIiksXG4gICAgbnVsbFxuICApXSk7XG4gIGRlZihcIk5ld0V4cHJlc3Npb25cIikuZmllbGQoXCJhcmd1bWVudHNcIiwgW29yKGRlZihcIkV4cHJlc3Npb25cIiksIGRlZihcIlNwcmVhZEVsZW1lbnRcIikpXSk7XG4gIGRlZihcIkNhbGxFeHByZXNzaW9uXCIpLmZpZWxkKFwiYXJndW1lbnRzXCIsIFtvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBkZWYoXCJTcHJlYWRFbGVtZW50XCIpKV0pO1xuICBkZWYoXCJBc3NpZ25tZW50UGF0dGVyblwiKS5iYXNlcyhcIlBhdHRlcm5cIikuYnVpbGQoXCJsZWZ0XCIsIFwicmlnaHRcIikuZmllbGQoXCJsZWZ0XCIsIGRlZihcIlBhdHRlcm5cIikpLmZpZWxkKFwicmlnaHRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG4gIGRlZihcIk1ldGhvZERlZmluaXRpb25cIikuYmFzZXMoXCJEZWNsYXJhdGlvblwiKS5idWlsZChcImtpbmRcIiwgXCJrZXlcIiwgXCJ2YWx1ZVwiLCBcInN0YXRpY1wiKS5maWVsZChcImtpbmRcIiwgb3IoXCJjb25zdHJ1Y3RvclwiLCBcIm1ldGhvZFwiLCBcImdldFwiLCBcInNldFwiKSkuZmllbGQoXCJrZXlcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSkuZmllbGQoXCJ2YWx1ZVwiLCBkZWYoXCJGdW5jdGlvblwiKSkuZmllbGQoXCJjb21wdXRlZFwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcInN0YXRpY1wiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKTtcbiAgY29uc3QgQ2xhc3NCb2R5RWxlbWVudCA9IG9yKFxuICAgIGRlZihcIk1ldGhvZERlZmluaXRpb25cIiksXG4gICAgZGVmKFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpLFxuICAgIGRlZihcIkNsYXNzUHJvcGVydHlEZWZpbml0aW9uXCIpLFxuICAgIGRlZihcIkNsYXNzUHJvcGVydHlcIiksXG4gICAgZGVmKFwiU3RhdGljQmxvY2tcIilcbiAgKTtcbiAgZGVmKFwiQ2xhc3NQcm9wZXJ0eVwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwia2V5XCIpLmZpZWxkKFwia2V5XCIsIG9yKGRlZihcIkxpdGVyYWxcIiksIGRlZihcIklkZW50aWZpZXJcIiksIGRlZihcIkV4cHJlc3Npb25cIikpKS5maWVsZChcImNvbXB1dGVkXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pO1xuICBkZWYoXCJDbGFzc1Byb3BlcnR5RGVmaW5pdGlvblwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwiZGVmaW5pdGlvblwiKS5maWVsZChcImRlZmluaXRpb25cIiwgQ2xhc3NCb2R5RWxlbWVudCk7XG4gIGRlZihcIkNsYXNzQm9keVwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwiYm9keVwiKS5maWVsZChcImJvZHlcIiwgW0NsYXNzQm9keUVsZW1lbnRdKTtcbiAgZGVmKFwiQ2xhc3NEZWNsYXJhdGlvblwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwiaWRcIiwgXCJib2R5XCIsIFwic3VwZXJDbGFzc1wiKS5maWVsZChcImlkXCIsIG9yKGRlZihcIklkZW50aWZpZXJcIiksIG51bGwpKS5maWVsZChcImJvZHlcIiwgZGVmKFwiQ2xhc3NCb2R5XCIpKS5maWVsZChcInN1cGVyQ2xhc3NcIiwgb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIkNsYXNzRXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJpZFwiLCBcImJvZHlcIiwgXCJzdXBlckNsYXNzXCIpLmZpZWxkKFwiaWRcIiwgb3IoZGVmKFwiSWRlbnRpZmllclwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSkuZmllbGQoXCJib2R5XCIsIGRlZihcIkNsYXNzQm9keVwiKSkuZmllbGQoXCJzdXBlckNsYXNzXCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuICBkZWYoXCJTdXBlclwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoKTtcbiAgZGVmKFwiU3BlY2lmaWVyXCIpLmJhc2VzKFwiTm9kZVwiKTtcbiAgZGVmKFwiTW9kdWxlU3BlY2lmaWVyXCIpLmJhc2VzKFwiU3BlY2lmaWVyXCIpLmZpZWxkKFwibG9jYWxcIiwgb3IoZGVmKFwiSWRlbnRpZmllclwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSkuZmllbGQoXCJpZFwiLCBvcihkZWYoXCJJZGVudGlmaWVyXCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKS5maWVsZChcIm5hbWVcIiwgb3IoZGVmKFwiSWRlbnRpZmllclwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIkltcG9ydFNwZWNpZmllclwiKS5iYXNlcyhcIk1vZHVsZVNwZWNpZmllclwiKS5idWlsZChcImltcG9ydGVkXCIsIFwibG9jYWxcIikuZmllbGQoXCJpbXBvcnRlZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKTtcbiAgZGVmKFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKS5iYXNlcyhcIk1vZHVsZVNwZWNpZmllclwiKS5idWlsZChcImxvY2FsXCIpO1xuICBkZWYoXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikuYmFzZXMoXCJNb2R1bGVTcGVjaWZpZXJcIikuYnVpbGQoXCJsb2NhbFwiKTtcbiAgZGVmKFwiSW1wb3J0RGVjbGFyYXRpb25cIikuYmFzZXMoXCJEZWNsYXJhdGlvblwiKS5idWlsZChcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIiwgXCJpbXBvcnRLaW5kXCIpLmZpZWxkKFwic3BlY2lmaWVyc1wiLCBbb3IoXG4gICAgZGVmKFwiSW1wb3J0U3BlY2lmaWVyXCIpLFxuICAgIGRlZihcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSxcbiAgICBkZWYoXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXG4gICldLCBkZWZhdWx0cy5lbXB0eUFycmF5KS5maWVsZChcInNvdXJjZVwiLCBkZWYoXCJMaXRlcmFsXCIpKS5maWVsZChcImltcG9ydEtpbmRcIiwgb3IoXG4gICAgXCJ2YWx1ZVwiLFxuICAgIFwidHlwZVwiXG4gICksIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcInZhbHVlXCI7XG4gIH0pO1xuICBkZWYoXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpLmJhc2VzKFwiRGVjbGFyYXRpb25cIikuYnVpbGQoXCJkZWNsYXJhdGlvblwiLCBcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIikuZmllbGQoXCJkZWNsYXJhdGlvblwiLCBvcihkZWYoXCJEZWNsYXJhdGlvblwiKSwgbnVsbCkpLmZpZWxkKFwic3BlY2lmaWVyc1wiLCBbZGVmKFwiRXhwb3J0U3BlY2lmaWVyXCIpXSwgZGVmYXVsdHMuZW1wdHlBcnJheSkuZmllbGQoXCJzb3VyY2VcIiwgb3IoZGVmKFwiTGl0ZXJhbFwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIkV4cG9ydFNwZWNpZmllclwiKS5iYXNlcyhcIk1vZHVsZVNwZWNpZmllclwiKS5idWlsZChcImxvY2FsXCIsIFwiZXhwb3J0ZWRcIikuZmllbGQoXCJleHBvcnRlZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKTtcbiAgZGVmKFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpLmJhc2VzKFwiRGVjbGFyYXRpb25cIikuYnVpbGQoXCJkZWNsYXJhdGlvblwiKS5maWVsZChcImRlY2xhcmF0aW9uXCIsIG9yKGRlZihcIkRlY2xhcmF0aW9uXCIpLCBkZWYoXCJFeHByZXNzaW9uXCIpKSk7XG4gIGRlZihcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpLmJhc2VzKFwiRGVjbGFyYXRpb25cIikuYnVpbGQoXCJzb3VyY2VcIikuZmllbGQoXCJzb3VyY2VcIiwgZGVmKFwiTGl0ZXJhbFwiKSk7XG4gIGRlZihcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJ0YWdcIiwgXCJxdWFzaVwiKS5maWVsZChcInRhZ1wiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcInF1YXNpXCIsIGRlZihcIlRlbXBsYXRlTGl0ZXJhbFwiKSk7XG4gIGRlZihcIlRlbXBsYXRlTGl0ZXJhbFwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJxdWFzaXNcIiwgXCJleHByZXNzaW9uc1wiKS5maWVsZChcInF1YXNpc1wiLCBbZGVmKFwiVGVtcGxhdGVFbGVtZW50XCIpXSkuZmllbGQoXCJleHByZXNzaW9uc1wiLCBbZGVmKFwiRXhwcmVzc2lvblwiKV0pO1xuICBkZWYoXCJUZW1wbGF0ZUVsZW1lbnRcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwidmFsdWVcIiwgXCJ0YWlsXCIpLmZpZWxkKFwidmFsdWVcIiwgeyBcImNvb2tlZFwiOiBTdHJpbmcsIFwicmF3XCI6IFN0cmluZyB9KS5maWVsZChcInRhaWxcIiwgQm9vbGVhbik7XG4gIGRlZihcIk1ldGFQcm9wZXJ0eVwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJtZXRhXCIsIFwicHJvcGVydHlcIikuZmllbGQoXCJtZXRhXCIsIGRlZihcIklkZW50aWZpZXJcIikpLmZpZWxkKFwicHJvcGVydHlcIiwgZGVmKFwiSWRlbnRpZmllclwiKSk7XG59XG5tYXliZVNldE1vZHVsZUV4cG9ydHMoKCkgPT4gbW9kdWxlKTtcblxuZnVuY3Rpb24gZXMyMDE2RGVmKGZvcmspIHtcbiAgZm9yay51c2UoZXMyMDE2T3BzRGVmKTtcbiAgZm9yay51c2UoZXM2RGVmKTtcbn1cbm1heWJlU2V0TW9kdWxlRXhwb3J0cygoKSA9PiBtb2R1bGUpO1xuXG5mdW5jdGlvbiBlczIwMTdEZWYoZm9yaykge1xuICBmb3JrLnVzZShlczIwMTZEZWYpO1xuICBjb25zdCB0eXBlcyA9IGZvcmsudXNlKHR5cGVzUGx1Z2luKTtcbiAgY29uc3QgZGVmID0gdHlwZXMuVHlwZS5kZWY7XG4gIGNvbnN0IGRlZmF1bHRzID0gZm9yay51c2Uoc2hhcmVkUGx1Z2luKS5kZWZhdWx0cztcbiAgZGVmKFwiRnVuY3Rpb25cIikuZmllbGQoXCJhc3luY1wiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKTtcbiAgZGVmKFwiQXdhaXRFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcImFyZ3VtZW50XCIpLmZpZWxkKFwiYXJndW1lbnRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG59XG5tYXliZVNldE1vZHVsZUV4cG9ydHMoKCkgPT4gbW9kdWxlKTtcblxuZnVuY3Rpb24gZXMyMDE4RGVmKGZvcmspIHtcbiAgZm9yay51c2UoZXMyMDE3RGVmKTtcbiAgY29uc3QgdHlwZXMgPSBmb3JrLnVzZSh0eXBlc1BsdWdpbik7XG4gIGNvbnN0IGRlZiA9IHR5cGVzLlR5cGUuZGVmO1xuICBjb25zdCBvciA9IHR5cGVzLlR5cGUub3I7XG4gIGNvbnN0IGRlZmF1bHRzID0gZm9yay51c2Uoc2hhcmVkUGx1Z2luKS5kZWZhdWx0cztcbiAgZGVmKFwiRm9yT2ZTdGF0ZW1lbnRcIikuZmllbGQoXCJhd2FpdFwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKTtcbiAgZGVmKFwiU3ByZWFkUHJvcGVydHlcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwiYXJndW1lbnRcIikuZmllbGQoXCJhcmd1bWVudFwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcbiAgZGVmKFwiT2JqZWN0RXhwcmVzc2lvblwiKS5maWVsZChcInByb3BlcnRpZXNcIiwgW29yKFxuICAgIGRlZihcIlByb3BlcnR5XCIpLFxuICAgIGRlZihcIlNwcmVhZFByb3BlcnR5XCIpLFxuICAgIC8vIExlZ2FjeVxuICAgIGRlZihcIlNwcmVhZEVsZW1lbnRcIilcbiAgKV0pO1xuICBkZWYoXCJUZW1wbGF0ZUVsZW1lbnRcIikuZmllbGQoXCJ2YWx1ZVwiLCB7IFwiY29va2VkXCI6IG9yKFN0cmluZywgbnVsbCksIFwicmF3XCI6IFN0cmluZyB9KTtcbiAgZGVmKFwiU3ByZWFkUHJvcGVydHlQYXR0ZXJuXCIpLmJhc2VzKFwiUGF0dGVyblwiKS5idWlsZChcImFyZ3VtZW50XCIpLmZpZWxkKFwiYXJndW1lbnRcIiwgZGVmKFwiUGF0dGVyblwiKSk7XG4gIGRlZihcIk9iamVjdFBhdHRlcm5cIikuZmllbGQoXCJwcm9wZXJ0aWVzXCIsIFtvcihkZWYoXCJQcm9wZXJ0eVBhdHRlcm5cIiksIGRlZihcIlByb3BlcnR5XCIpLCBkZWYoXCJSZXN0RWxlbWVudFwiKSwgZGVmKFwiU3ByZWFkUHJvcGVydHlQYXR0ZXJuXCIpKV0pO1xufVxubWF5YmVTZXRNb2R1bGVFeHBvcnRzKCgpID0+IG1vZHVsZSk7XG5cbmZ1bmN0aW9uIGVzMjAxOURlZihmb3JrKSB7XG4gIGZvcmsudXNlKGVzMjAxOERlZik7XG4gIGNvbnN0IHR5cGVzID0gZm9yay51c2UodHlwZXNQbHVnaW4pO1xuICBjb25zdCBkZWYgPSB0eXBlcy5UeXBlLmRlZjtcbiAgY29uc3Qgb3IgPSB0eXBlcy5UeXBlLm9yO1xuICBjb25zdCBkZWZhdWx0cyA9IGZvcmsudXNlKHNoYXJlZFBsdWdpbikuZGVmYXVsdHM7XG4gIGRlZihcIkNhdGNoQ2xhdXNlXCIpLmZpZWxkKFwicGFyYW1cIiwgb3IoZGVmKFwiUGF0dGVyblwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG59XG5tYXliZVNldE1vZHVsZUV4cG9ydHMoKCkgPT4gbW9kdWxlKTtcblxuZnVuY3Rpb24gZXMyMDIwRGVmKGZvcmspIHtcbiAgZm9yay51c2UoZXMyMDIwT3BzRGVmKTtcbiAgZm9yay51c2UoZXMyMDE5RGVmKTtcbiAgY29uc3QgdHlwZXMgPSBmb3JrLnVzZSh0eXBlc1BsdWdpbik7XG4gIGNvbnN0IGRlZiA9IHR5cGVzLlR5cGUuZGVmO1xuICBjb25zdCBvciA9IHR5cGVzLlR5cGUub3I7XG4gIGNvbnN0IHNoYXJlZCA9IGZvcmsudXNlKHNoYXJlZFBsdWdpbik7XG4gIGNvbnN0IGRlZmF1bHRzID0gc2hhcmVkLmRlZmF1bHRzO1xuICBkZWYoXCJJbXBvcnRFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcInNvdXJjZVwiKS5maWVsZChcInNvdXJjZVwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcbiAgZGVmKFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIikuYmFzZXMoXCJEZWNsYXJhdGlvblwiKS5idWlsZChcInNvdXJjZVwiLCBcImV4cG9ydGVkXCIpLmZpZWxkKFwic291cmNlXCIsIGRlZihcIkxpdGVyYWxcIikpLmZpZWxkKFwiZXhwb3J0ZWRcIiwgb3IoXG4gICAgZGVmKFwiSWRlbnRpZmllclwiKSxcbiAgICBudWxsLFxuICAgIHZvaWQgMFxuICApLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuICBkZWYoXCJDaGFpbkVsZW1lbnRcIikuYmFzZXMoXCJOb2RlXCIpLmZpZWxkKFwib3B0aW9uYWxcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSk7XG4gIGRlZihcIkNhbGxFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiLCBcIkNoYWluRWxlbWVudFwiKTtcbiAgZGVmKFwiTWVtYmVyRXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIiwgXCJDaGFpbkVsZW1lbnRcIik7XG4gIGRlZihcIkNoYWluRXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJleHByZXNzaW9uXCIpLmZpZWxkKFwiZXhwcmVzc2lvblwiLCBkZWYoXCJDaGFpbkVsZW1lbnRcIikpO1xuICBkZWYoXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCIpLmJhc2VzKFwiQ2FsbEV4cHJlc3Npb25cIikuYnVpbGQoXCJjYWxsZWVcIiwgXCJhcmd1bWVudHNcIiwgXCJvcHRpb25hbFwiKS5maWVsZChcIm9wdGlvbmFsXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1widHJ1ZVwiXSk7XG4gIGRlZihcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKS5iYXNlcyhcIk1lbWJlckV4cHJlc3Npb25cIikuYnVpbGQoXCJvYmplY3RcIiwgXCJwcm9wZXJ0eVwiLCBcImNvbXB1dGVkXCIsIFwib3B0aW9uYWxcIikuZmllbGQoXCJvcHRpb25hbFwiLCBCb29sZWFuLCBkZWZhdWx0c1tcInRydWVcIl0pO1xufVxubWF5YmVTZXRNb2R1bGVFeHBvcnRzKCgpID0+IG1vZHVsZSk7XG5cbmZ1bmN0aW9uIGVzMjAyMURlZihmb3JrKSB7XG4gIGZvcmsudXNlKGVzMjAyMU9wc0RlZik7XG4gIGZvcmsudXNlKGVzMjAyMERlZik7XG59XG5tYXliZVNldE1vZHVsZUV4cG9ydHMoKCkgPT4gbW9kdWxlKTtcblxuZnVuY3Rpb24gZXMyMDIyRGVmKGZvcmspIHtcbiAgZm9yay51c2UoZXMyMDIxRGVmKTtcbiAgY29uc3QgdHlwZXMgPSBmb3JrLnVzZSh0eXBlc1BsdWdpbik7XG4gIGNvbnN0IGRlZiA9IHR5cGVzLlR5cGUuZGVmO1xuICBkZWYoXCJTdGF0aWNCbG9ja1wiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwiYm9keVwiKS5maWVsZChcImJvZHlcIiwgW2RlZihcIlN0YXRlbWVudFwiKV0pO1xufVxubWF5YmVTZXRNb2R1bGVFeHBvcnRzKCgpID0+IG1vZHVsZSk7XG5cbmZ1bmN0aW9uIGVzUHJvcG9zYWxzRGVmKGZvcmspIHtcbiAgZm9yay51c2UoZXMyMDIyRGVmKTtcbiAgY29uc3QgdHlwZXMgPSBmb3JrLnVzZSh0eXBlc1BsdWdpbik7XG4gIGNvbnN0IFR5cGUgPSB0eXBlcy5UeXBlO1xuICBjb25zdCBkZWYgPSB0eXBlcy5UeXBlLmRlZjtcbiAgY29uc3Qgb3IgPSBUeXBlLm9yO1xuICBjb25zdCBzaGFyZWQgPSBmb3JrLnVzZShzaGFyZWRQbHVnaW4pO1xuICBjb25zdCBkZWZhdWx0cyA9IHNoYXJlZC5kZWZhdWx0cztcbiAgZGVmKFwiQXdhaXRFeHByZXNzaW9uXCIpLmJ1aWxkKFwiYXJndW1lbnRcIiwgXCJhbGxcIikuZmllbGQoXCJhcmd1bWVudFwiLCBvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKSkuZmllbGQoXCJhbGxcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSk7XG4gIGRlZihcIkRlY29yYXRvclwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJleHByZXNzaW9uXCIpLmZpZWxkKFwiZXhwcmVzc2lvblwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcbiAgZGVmKFwiUHJvcGVydHlcIikuZmllbGQoXG4gICAgXCJkZWNvcmF0b3JzXCIsXG4gICAgb3IoW2RlZihcIkRlY29yYXRvclwiKV0sIG51bGwpLFxuICAgIGRlZmF1bHRzW1wibnVsbFwiXVxuICApO1xuICBkZWYoXCJNZXRob2REZWZpbml0aW9uXCIpLmZpZWxkKFxuICAgIFwiZGVjb3JhdG9yc1wiLFxuICAgIG9yKFtkZWYoXCJEZWNvcmF0b3JcIildLCBudWxsKSxcbiAgICBkZWZhdWx0c1tcIm51bGxcIl1cbiAgKTtcbiAgZGVmKFwiUHJpdmF0ZU5hbWVcIikuYmFzZXMoXCJFeHByZXNzaW9uXCIsIFwiUGF0dGVyblwiKS5idWlsZChcImlkXCIpLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSk7XG4gIGRlZihcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIpLmJhc2VzKFwiQ2xhc3NQcm9wZXJ0eVwiKS5idWlsZChcImtleVwiLCBcInZhbHVlXCIpLmZpZWxkKFwia2V5XCIsIGRlZihcIlByaXZhdGVOYW1lXCIpKS5maWVsZChcInZhbHVlXCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuICBkZWYoXCJJbXBvcnRBdHRyaWJ1dGVcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwia2V5XCIsIFwidmFsdWVcIikuZmllbGQoXCJrZXlcIiwgb3IoZGVmKFwiSWRlbnRpZmllclwiKSwgZGVmKFwiTGl0ZXJhbFwiKSkpLmZpZWxkKFwidmFsdWVcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG4gIFtcbiAgICBcIkltcG9ydERlY2xhcmF0aW9uXCIsXG4gICAgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiLFxuICAgIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiXG4gIF0uZm9yRWFjaCgoZGVjbCkgPT4ge1xuICAgIGRlZihkZWNsKS5maWVsZChcbiAgICAgIFwiYXNzZXJ0aW9uc1wiLFxuICAgICAgW2RlZihcIkltcG9ydEF0dHJpYnV0ZVwiKV0sXG4gICAgICBkZWZhdWx0cy5lbXB0eUFycmF5XG4gICAgKTtcbiAgfSk7XG4gIGRlZihcIlJlY29yZEV4cHJlc3Npb25cIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpLmJ1aWxkKFwicHJvcGVydGllc1wiKS5maWVsZChcInByb3BlcnRpZXNcIiwgW29yKFxuICAgIGRlZihcIk9iamVjdFByb3BlcnR5XCIpLFxuICAgIGRlZihcIk9iamVjdE1ldGhvZFwiKSxcbiAgICBkZWYoXCJTcHJlYWRFbGVtZW50XCIpXG4gICldKTtcbiAgZGVmKFwiVHVwbGVFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcImVsZW1lbnRzXCIpLmZpZWxkKFwiZWxlbWVudHNcIiwgW29yKFxuICAgIGRlZihcIkV4cHJlc3Npb25cIiksXG4gICAgZGVmKFwiU3ByZWFkRWxlbWVudFwiKSxcbiAgICBudWxsXG4gICldKTtcbiAgZGVmKFwiTW9kdWxlRXhwcmVzc2lvblwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJib2R5XCIpLmZpZWxkKFwiYm9keVwiLCBkZWYoXCJQcm9ncmFtXCIpKTtcbn1cbm1heWJlU2V0TW9kdWxlRXhwb3J0cygoKSA9PiBtb2R1bGUpO1xuXG5mdW5jdGlvbiBqc3hEZWYoZm9yaykge1xuICBmb3JrLnVzZShlc1Byb3Bvc2Fsc0RlZik7XG4gIGNvbnN0IHR5cGVzID0gZm9yay51c2UodHlwZXNQbHVnaW4pO1xuICBjb25zdCBkZWYgPSB0eXBlcy5UeXBlLmRlZjtcbiAgY29uc3Qgb3IgPSB0eXBlcy5UeXBlLm9yO1xuICBjb25zdCBkZWZhdWx0cyA9IGZvcmsudXNlKHNoYXJlZFBsdWdpbikuZGVmYXVsdHM7XG4gIGRlZihcIkpTWEF0dHJpYnV0ZVwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJuYW1lXCIsIFwidmFsdWVcIikuZmllbGQoXCJuYW1lXCIsIG9yKGRlZihcIkpTWElkZW50aWZpZXJcIiksIGRlZihcIkpTWE5hbWVzcGFjZWROYW1lXCIpKSkuZmllbGQoXCJ2YWx1ZVwiLCBvcihcbiAgICBkZWYoXCJMaXRlcmFsXCIpLFxuICAgIC8vIGF0dHI9XCJ2YWx1ZVwiXG4gICAgZGVmKFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiKSxcbiAgICAvLyBhdHRyPXt2YWx1ZX1cbiAgICBkZWYoXCJKU1hFbGVtZW50XCIpLFxuICAgIC8vIGF0dHI9PGRpdiAvPlxuICAgIGRlZihcIkpTWEZyYWdtZW50XCIpLFxuICAgIC8vIGF0dHI9PD48Lz5cbiAgICBudWxsXG4gICAgLy8gYXR0cj0gb3IganVzdCBhdHRyXG4gICksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIkpTWElkZW50aWZpZXJcIikuYmFzZXMoXCJJZGVudGlmaWVyXCIpLmJ1aWxkKFwibmFtZVwiKS5maWVsZChcIm5hbWVcIiwgU3RyaW5nKTtcbiAgZGVmKFwiSlNYTmFtZXNwYWNlZE5hbWVcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwibmFtZXNwYWNlXCIsIFwibmFtZVwiKS5maWVsZChcIm5hbWVzcGFjZVwiLCBkZWYoXCJKU1hJZGVudGlmaWVyXCIpKS5maWVsZChcIm5hbWVcIiwgZGVmKFwiSlNYSWRlbnRpZmllclwiKSk7XG4gIGRlZihcIkpTWE1lbWJlckV4cHJlc3Npb25cIikuYmFzZXMoXCJNZW1iZXJFeHByZXNzaW9uXCIpLmJ1aWxkKFwib2JqZWN0XCIsIFwicHJvcGVydHlcIikuZmllbGQoXCJvYmplY3RcIiwgb3IoZGVmKFwiSlNYSWRlbnRpZmllclwiKSwgZGVmKFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiKSkpLmZpZWxkKFwicHJvcGVydHlcIiwgZGVmKFwiSlNYSWRlbnRpZmllclwiKSkuZmllbGQoXCJjb21wdXRlZFwiLCBCb29sZWFuLCBkZWZhdWx0cy5mYWxzZSk7XG4gIGNvbnN0IEpTWEVsZW1lbnROYW1lID0gb3IoXG4gICAgZGVmKFwiSlNYSWRlbnRpZmllclwiKSxcbiAgICBkZWYoXCJKU1hOYW1lc3BhY2VkTmFtZVwiKSxcbiAgICBkZWYoXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIpXG4gICk7XG4gIGRlZihcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJhcmd1bWVudFwiKS5maWVsZChcImFyZ3VtZW50XCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuICBjb25zdCBKU1hBdHRyaWJ1dGVzID0gW29yKFxuICAgIGRlZihcIkpTWEF0dHJpYnV0ZVwiKSxcbiAgICBkZWYoXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIilcbiAgKV07XG4gIGRlZihcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpLmJ1aWxkKFwiZXhwcmVzc2lvblwiKS5maWVsZChcImV4cHJlc3Npb25cIiwgb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgZGVmKFwiSlNYRW1wdHlFeHByZXNzaW9uXCIpKSk7XG4gIGNvbnN0IEpTWENoaWxkcmVuID0gW29yKFxuICAgIGRlZihcIkpTWFRleHRcIiksXG4gICAgZGVmKFwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiKSxcbiAgICBkZWYoXCJKU1hTcHJlYWRDaGlsZFwiKSxcbiAgICBkZWYoXCJKU1hFbGVtZW50XCIpLFxuICAgIGRlZihcIkpTWEZyYWdtZW50XCIpLFxuICAgIGRlZihcIkxpdGVyYWxcIilcbiAgICAvLyBMZWdhY3k6IEVzcHJpbWEgc2hvdWxkIHJldHVybiBKU1hUZXh0IGluc3RlYWQuXG4gICldO1xuICBkZWYoXCJKU1hFbGVtZW50XCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcIm9wZW5pbmdFbGVtZW50XCIsIFwiY2xvc2luZ0VsZW1lbnRcIiwgXCJjaGlsZHJlblwiKS5maWVsZChcIm9wZW5pbmdFbGVtZW50XCIsIGRlZihcIkpTWE9wZW5pbmdFbGVtZW50XCIpKS5maWVsZChcImNsb3NpbmdFbGVtZW50XCIsIG9yKGRlZihcIkpTWENsb3NpbmdFbGVtZW50XCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKS5maWVsZChcImNoaWxkcmVuXCIsIEpTWENoaWxkcmVuLCBkZWZhdWx0cy5lbXB0eUFycmF5KS5maWVsZChcIm5hbWVcIiwgSlNYRWxlbWVudE5hbWUsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9wZW5pbmdFbGVtZW50Lm5hbWU7XG4gIH0sIHRydWUpLmZpZWxkKFwic2VsZkNsb3NpbmdcIiwgQm9vbGVhbiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub3BlbmluZ0VsZW1lbnQuc2VsZkNsb3Npbmc7XG4gIH0sIHRydWUpLmZpZWxkKFwiYXR0cmlidXRlc1wiLCBKU1hBdHRyaWJ1dGVzLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVuaW5nRWxlbWVudC5hdHRyaWJ1dGVzO1xuICB9LCB0cnVlKTtcbiAgZGVmKFwiSlNYT3BlbmluZ0VsZW1lbnRcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwibmFtZVwiLCBcImF0dHJpYnV0ZXNcIiwgXCJzZWxmQ2xvc2luZ1wiKS5maWVsZChcIm5hbWVcIiwgSlNYRWxlbWVudE5hbWUpLmZpZWxkKFwiYXR0cmlidXRlc1wiLCBKU1hBdHRyaWJ1dGVzLCBkZWZhdWx0cy5lbXB0eUFycmF5KS5maWVsZChcInNlbGZDbG9zaW5nXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pO1xuICBkZWYoXCJKU1hDbG9zaW5nRWxlbWVudFwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJuYW1lXCIpLmZpZWxkKFwibmFtZVwiLCBKU1hFbGVtZW50TmFtZSk7XG4gIGRlZihcIkpTWEZyYWdtZW50XCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcIm9wZW5pbmdGcmFnbWVudFwiLCBcImNsb3NpbmdGcmFnbWVudFwiLCBcImNoaWxkcmVuXCIpLmZpZWxkKFwib3BlbmluZ0ZyYWdtZW50XCIsIGRlZihcIkpTWE9wZW5pbmdGcmFnbWVudFwiKSkuZmllbGQoXCJjbG9zaW5nRnJhZ21lbnRcIiwgZGVmKFwiSlNYQ2xvc2luZ0ZyYWdtZW50XCIpKS5maWVsZChcImNoaWxkcmVuXCIsIEpTWENoaWxkcmVuLCBkZWZhdWx0cy5lbXB0eUFycmF5KTtcbiAgZGVmKFwiSlNYT3BlbmluZ0ZyYWdtZW50XCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZCgpO1xuICBkZWYoXCJKU1hDbG9zaW5nRnJhZ21lbnRcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKCk7XG4gIGRlZihcIkpTWFRleHRcIikuYmFzZXMoXCJMaXRlcmFsXCIpLmJ1aWxkKFwidmFsdWVcIiwgXCJyYXdcIikuZmllbGQoXCJ2YWx1ZVwiLCBTdHJpbmcpLmZpZWxkKFwicmF3XCIsIFN0cmluZywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH0pO1xuICBkZWYoXCJKU1hFbXB0eUV4cHJlc3Npb25cIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKCk7XG4gIGRlZihcIkpTWFNwcmVhZENoaWxkXCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZChcImV4cHJlc3Npb25cIikuZmllbGQoXCJleHByZXNzaW9uXCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xufVxubWF5YmVTZXRNb2R1bGVFeHBvcnRzKCgpID0+IG1vZHVsZSk7XG5cbmZ1bmN0aW9uIHR5cGVBbm5vdGF0aW9uc0RlZihmb3JrKSB7XG4gIHZhciB0eXBlcyA9IGZvcmsudXNlKHR5cGVzUGx1Z2luKTtcbiAgdmFyIGRlZiA9IHR5cGVzLlR5cGUuZGVmO1xuICB2YXIgb3IgPSB0eXBlcy5UeXBlLm9yO1xuICB2YXIgZGVmYXVsdHMgPSBmb3JrLnVzZShzaGFyZWRQbHVnaW4pLmRlZmF1bHRzO1xuICB2YXIgVHlwZUFubm90YXRpb24gPSBvcihcbiAgICBkZWYoXCJUeXBlQW5ub3RhdGlvblwiKSxcbiAgICBkZWYoXCJUU1R5cGVBbm5vdGF0aW9uXCIpLFxuICAgIG51bGxcbiAgKTtcbiAgdmFyIFR5cGVQYXJhbURlY2wgPSBvcihcbiAgICBkZWYoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgZGVmKFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksXG4gICAgbnVsbFxuICApO1xuICBkZWYoXCJJZGVudGlmaWVyXCIpLmZpZWxkKFwidHlwZUFubm90YXRpb25cIiwgVHlwZUFubm90YXRpb24sIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIk9iamVjdFBhdHRlcm5cIikuZmllbGQoXCJ0eXBlQW5ub3RhdGlvblwiLCBUeXBlQW5ub3RhdGlvbiwgZGVmYXVsdHNbXCJudWxsXCJdKTtcbiAgZGVmKFwiRnVuY3Rpb25cIikuZmllbGQoXCJyZXR1cm5UeXBlXCIsIFR5cGVBbm5vdGF0aW9uLCBkZWZhdWx0c1tcIm51bGxcIl0pLmZpZWxkKFwidHlwZVBhcmFtZXRlcnNcIiwgVHlwZVBhcmFtRGVjbCwgZGVmYXVsdHNbXCJudWxsXCJdKTtcbiAgZGVmKFwiQ2xhc3NQcm9wZXJ0eVwiKS5idWlsZChcImtleVwiLCBcInZhbHVlXCIsIFwidHlwZUFubm90YXRpb25cIiwgXCJzdGF0aWNcIikuZmllbGQoXCJ2YWx1ZVwiLCBvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKSkuZmllbGQoXCJzdGF0aWNcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJ0eXBlQW5ub3RhdGlvblwiLCBUeXBlQW5ub3RhdGlvbiwgZGVmYXVsdHNbXCJudWxsXCJdKTtcbiAgW1xuICAgIFwiQ2xhc3NEZWNsYXJhdGlvblwiLFxuICAgIFwiQ2xhc3NFeHByZXNzaW9uXCJcbiAgXS5mb3JFYWNoKCh0eXBlTmFtZSkgPT4ge1xuICAgIGRlZih0eXBlTmFtZSkuZmllbGQoXCJ0eXBlUGFyYW1ldGVyc1wiLCBUeXBlUGFyYW1EZWNsLCBkZWZhdWx0c1tcIm51bGxcIl0pLmZpZWxkKFxuICAgICAgXCJzdXBlclR5cGVQYXJhbWV0ZXJzXCIsXG4gICAgICBvcihcbiAgICAgICAgZGVmKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICAgIGRlZihcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksXG4gICAgICAgIG51bGxcbiAgICAgICksXG4gICAgICBkZWZhdWx0c1tcIm51bGxcIl1cbiAgICApLmZpZWxkKFxuICAgICAgXCJpbXBsZW1lbnRzXCIsXG4gICAgICBvcihcbiAgICAgICAgW2RlZihcIkNsYXNzSW1wbGVtZW50c1wiKV0sXG4gICAgICAgIFtkZWYoXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiKV1cbiAgICAgICksXG4gICAgICBkZWZhdWx0cy5lbXB0eUFycmF5XG4gICAgKTtcbiAgfSk7XG59XG5tYXliZVNldE1vZHVsZUV4cG9ydHMoKCkgPT4gbW9kdWxlKTtcblxuZnVuY3Rpb24gZmxvd0RlZihmb3JrKSB7XG4gIGZvcmsudXNlKGVzUHJvcG9zYWxzRGVmKTtcbiAgZm9yay51c2UodHlwZUFubm90YXRpb25zRGVmKTtcbiAgY29uc3QgdHlwZXMgPSBmb3JrLnVzZSh0eXBlc1BsdWdpbik7XG4gIGNvbnN0IGRlZiA9IHR5cGVzLlR5cGUuZGVmO1xuICBjb25zdCBvciA9IHR5cGVzLlR5cGUub3I7XG4gIGNvbnN0IGRlZmF1bHRzID0gZm9yay51c2Uoc2hhcmVkUGx1Z2luKS5kZWZhdWx0cztcbiAgZGVmKFwiRmxvd1wiKS5iYXNlcyhcIk5vZGVcIik7XG4gIGRlZihcIkZsb3dUeXBlXCIpLmJhc2VzKFwiRmxvd1wiKTtcbiAgZGVmKFwiQW55VHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZCgpO1xuICBkZWYoXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIpLmJhc2VzKFwiRmxvd1R5cGVcIikuYnVpbGQoKTtcbiAgZGVmKFwiTWl4ZWRUeXBlQW5ub3RhdGlvblwiKS5iYXNlcyhcIkZsb3dUeXBlXCIpLmJ1aWxkKCk7XG4gIGRlZihcIlZvaWRUeXBlQW5ub3RhdGlvblwiKS5iYXNlcyhcIkZsb3dUeXBlXCIpLmJ1aWxkKCk7XG4gIGRlZihcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCIpLmJhc2VzKFwiRmxvd1R5cGVcIikuYnVpbGQoKTtcbiAgZGVmKFwiTnVtYmVyVHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZCgpO1xuICBkZWYoXCJCaWdJbnRUeXBlQW5ub3RhdGlvblwiKS5iYXNlcyhcIkZsb3dUeXBlXCIpLmJ1aWxkKCk7XG4gIGRlZihcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKS5iYXNlcyhcIkZsb3dUeXBlXCIpLmJ1aWxkKFwidmFsdWVcIiwgXCJyYXdcIikuZmllbGQoXCJ2YWx1ZVwiLCBOdW1iZXIpLmZpZWxkKFwicmF3XCIsIFN0cmluZyk7XG4gIGRlZihcIk51bWVyaWNMaXRlcmFsVHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZChcInZhbHVlXCIsIFwicmF3XCIpLmZpZWxkKFwidmFsdWVcIiwgTnVtYmVyKS5maWVsZChcInJhd1wiLCBTdHJpbmcpO1xuICBkZWYoXCJCaWdJbnRMaXRlcmFsVHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZChcInZhbHVlXCIsIFwicmF3XCIpLmZpZWxkKFwidmFsdWVcIiwgbnVsbCkuZmllbGQoXCJyYXdcIiwgU3RyaW5nKTtcbiAgZGVmKFwiU3RyaW5nVHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZCgpO1xuICBkZWYoXCJTdHJpbmdMaXRlcmFsVHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZChcInZhbHVlXCIsIFwicmF3XCIpLmZpZWxkKFwidmFsdWVcIiwgU3RyaW5nKS5maWVsZChcInJhd1wiLCBTdHJpbmcpO1xuICBkZWYoXCJCb29sZWFuVHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZCgpO1xuICBkZWYoXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpLmJhc2VzKFwiRmxvd1R5cGVcIikuYnVpbGQoXCJ2YWx1ZVwiLCBcInJhd1wiKS5maWVsZChcInZhbHVlXCIsIEJvb2xlYW4pLmZpZWxkKFwicmF3XCIsIFN0cmluZyk7XG4gIGRlZihcIlR5cGVBbm5vdGF0aW9uXCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZChcInR5cGVBbm5vdGF0aW9uXCIpLmZpZWxkKFwidHlwZUFubm90YXRpb25cIiwgZGVmKFwiRmxvd1R5cGVcIikpO1xuICBkZWYoXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIpLmJhc2VzKFwiRmxvd1R5cGVcIikuYnVpbGQoXCJ0eXBlQW5ub3RhdGlvblwiKS5maWVsZChcInR5cGVBbm5vdGF0aW9uXCIsIGRlZihcIkZsb3dUeXBlXCIpKTtcbiAgZGVmKFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiKS5iYXNlcyhcIkZsb3dUeXBlXCIpLmJ1aWxkKCk7XG4gIGRlZihcIk51bGxUeXBlQW5ub3RhdGlvblwiKS5iYXNlcyhcIkZsb3dUeXBlXCIpLmJ1aWxkKCk7XG4gIGRlZihcIlRoaXNUeXBlQW5ub3RhdGlvblwiKS5iYXNlcyhcIkZsb3dUeXBlXCIpLmJ1aWxkKCk7XG4gIGRlZihcIkV4aXN0c1R5cGVBbm5vdGF0aW9uXCIpLmJhc2VzKFwiRmxvd1R5cGVcIikuYnVpbGQoKTtcbiAgZGVmKFwiRXhpc3RlbnRpYWxUeXBlUGFyYW1cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZCgpO1xuICBkZWYoXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpLmJhc2VzKFwiRmxvd1R5cGVcIikuYnVpbGQoXCJwYXJhbXNcIiwgXCJyZXR1cm5UeXBlXCIsIFwicmVzdFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIpLmZpZWxkKFwicGFyYW1zXCIsIFtkZWYoXCJGdW5jdGlvblR5cGVQYXJhbVwiKV0pLmZpZWxkKFwicmV0dXJuVHlwZVwiLCBkZWYoXCJGbG93VHlwZVwiKSkuZmllbGQoXCJyZXN0XCIsIG9yKGRlZihcIkZ1bmN0aW9uVHlwZVBhcmFtXCIpLCBudWxsKSkuZmllbGQoXCJ0eXBlUGFyYW1ldGVyc1wiLCBvcihkZWYoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksIG51bGwpKTtcbiAgZGVmKFwiRnVuY3Rpb25UeXBlUGFyYW1cIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwibmFtZVwiLCBcInR5cGVBbm5vdGF0aW9uXCIsIFwib3B0aW9uYWxcIikuZmllbGQoXCJuYW1lXCIsIG9yKGRlZihcIklkZW50aWZpZXJcIiksIG51bGwpKS5maWVsZChcInR5cGVBbm5vdGF0aW9uXCIsIGRlZihcIkZsb3dUeXBlXCIpKS5maWVsZChcIm9wdGlvbmFsXCIsIEJvb2xlYW4pO1xuICBkZWYoXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIpLmJhc2VzKFwiRmxvd1R5cGVcIikuYnVpbGQoXCJlbGVtZW50VHlwZVwiKS5maWVsZChcImVsZW1lbnRUeXBlXCIsIGRlZihcIkZsb3dUeXBlXCIpKTtcbiAgZGVmKFwiT2JqZWN0VHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZChcInByb3BlcnRpZXNcIiwgXCJpbmRleGVyc1wiLCBcImNhbGxQcm9wZXJ0aWVzXCIpLmZpZWxkKFwicHJvcGVydGllc1wiLCBbXG4gICAgb3IoXG4gICAgICBkZWYoXCJPYmplY3RUeXBlUHJvcGVydHlcIiksXG4gICAgICBkZWYoXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIilcbiAgICApXG4gIF0pLmZpZWxkKFwiaW5kZXhlcnNcIiwgW2RlZihcIk9iamVjdFR5cGVJbmRleGVyXCIpXSwgZGVmYXVsdHMuZW1wdHlBcnJheSkuZmllbGQoXG4gICAgXCJjYWxsUHJvcGVydGllc1wiLFxuICAgIFtkZWYoXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIpXSxcbiAgICBkZWZhdWx0cy5lbXB0eUFycmF5XG4gICkuZmllbGQoXCJpbmV4YWN0XCIsIG9yKEJvb2xlYW4sIHZvaWQgMCksIGRlZmF1bHRzW1widW5kZWZpbmVkXCJdKS5maWVsZChcImV4YWN0XCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pLmZpZWxkKFwiaW50ZXJuYWxTbG90c1wiLCBbZGVmKFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiKV0sIGRlZmF1bHRzLmVtcHR5QXJyYXkpO1xuICBkZWYoXCJWYXJpYW5jZVwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJraW5kXCIpLmZpZWxkKFwia2luZFwiLCBvcihcInBsdXNcIiwgXCJtaW51c1wiKSk7XG4gIGNvbnN0IExlZ2FjeVZhcmlhbmNlID0gb3IoXG4gICAgZGVmKFwiVmFyaWFuY2VcIiksXG4gICAgXCJwbHVzXCIsXG4gICAgXCJtaW51c1wiLFxuICAgIG51bGxcbiAgKTtcbiAgZGVmKFwiT2JqZWN0VHlwZVByb3BlcnR5XCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZChcImtleVwiLCBcInZhbHVlXCIsIFwib3B0aW9uYWxcIikuZmllbGQoXCJrZXlcIiwgb3IoZGVmKFwiTGl0ZXJhbFwiKSwgZGVmKFwiSWRlbnRpZmllclwiKSkpLmZpZWxkKFwidmFsdWVcIiwgZGVmKFwiRmxvd1R5cGVcIikpLmZpZWxkKFwib3B0aW9uYWxcIiwgQm9vbGVhbikuZmllbGQoXCJ2YXJpYW5jZVwiLCBMZWdhY3lWYXJpYW5jZSwgZGVmYXVsdHNbXCJudWxsXCJdKTtcbiAgZGVmKFwiT2JqZWN0VHlwZUluZGV4ZXJcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwiaWRcIiwgXCJrZXlcIiwgXCJ2YWx1ZVwiKS5maWVsZChcImlkXCIsIGRlZihcIklkZW50aWZpZXJcIikpLmZpZWxkKFwia2V5XCIsIGRlZihcIkZsb3dUeXBlXCIpKS5maWVsZChcInZhbHVlXCIsIGRlZihcIkZsb3dUeXBlXCIpKS5maWVsZChcInZhcmlhbmNlXCIsIExlZ2FjeVZhcmlhbmNlLCBkZWZhdWx0c1tcIm51bGxcIl0pLmZpZWxkKFwic3RhdGljXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pO1xuICBkZWYoXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZChcInZhbHVlXCIpLmZpZWxkKFwidmFsdWVcIiwgZGVmKFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKSkuZmllbGQoXCJzdGF0aWNcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSk7XG4gIGRlZihcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZChcInF1YWxpZmljYXRpb25cIiwgXCJpZFwiKS5maWVsZChcbiAgICBcInF1YWxpZmljYXRpb25cIixcbiAgICBvcihcbiAgICAgIGRlZihcIklkZW50aWZpZXJcIiksXG4gICAgICBkZWYoXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiKVxuICAgIClcbiAgKS5maWVsZChcImlkXCIsIGRlZihcIklkZW50aWZpZXJcIikpO1xuICBkZWYoXCJHZW5lcmljVHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZChcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIikuZmllbGQoXCJpZFwiLCBvcihkZWYoXCJJZGVudGlmaWVyXCIpLCBkZWYoXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiKSkpLmZpZWxkKFwidHlwZVBhcmFtZXRlcnNcIiwgb3IoZGVmKFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiksIG51bGwpKTtcbiAgZGVmKFwiTWVtYmVyVHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZChcIm9iamVjdFwiLCBcInByb3BlcnR5XCIpLmZpZWxkKFwib2JqZWN0XCIsIGRlZihcIklkZW50aWZpZXJcIikpLmZpZWxkKFxuICAgIFwicHJvcGVydHlcIixcbiAgICBvcihcbiAgICAgIGRlZihcIk1lbWJlclR5cGVBbm5vdGF0aW9uXCIpLFxuICAgICAgZGVmKFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIpXG4gICAgKVxuICApO1xuICBkZWYoXCJJbmRleGVkQWNjZXNzVHlwZVwiKS5iYXNlcyhcIkZsb3dUeXBlXCIpLmJ1aWxkKFwib2JqZWN0VHlwZVwiLCBcImluZGV4VHlwZVwiKS5maWVsZChcIm9iamVjdFR5cGVcIiwgZGVmKFwiRmxvd1R5cGVcIikpLmZpZWxkKFwiaW5kZXhUeXBlXCIsIGRlZihcIkZsb3dUeXBlXCIpKTtcbiAgZGVmKFwiT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZVwiKS5iYXNlcyhcIkZsb3dUeXBlXCIpLmJ1aWxkKFwib2JqZWN0VHlwZVwiLCBcImluZGV4VHlwZVwiLCBcIm9wdGlvbmFsXCIpLmZpZWxkKFwib2JqZWN0VHlwZVwiLCBkZWYoXCJGbG93VHlwZVwiKSkuZmllbGQoXCJpbmRleFR5cGVcIiwgZGVmKFwiRmxvd1R5cGVcIikpLmZpZWxkKFwib3B0aW9uYWxcIiwgQm9vbGVhbik7XG4gIGRlZihcIlVuaW9uVHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZChcInR5cGVzXCIpLmZpZWxkKFwidHlwZXNcIiwgW2RlZihcIkZsb3dUeXBlXCIpXSk7XG4gIGRlZihcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIpLmJhc2VzKFwiRmxvd1R5cGVcIikuYnVpbGQoXCJ0eXBlc1wiKS5maWVsZChcInR5cGVzXCIsIFtkZWYoXCJGbG93VHlwZVwiKV0pO1xuICBkZWYoXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiKS5iYXNlcyhcIkZsb3dUeXBlXCIpLmJ1aWxkKFwiYXJndW1lbnRcIikuZmllbGQoXCJhcmd1bWVudFwiLCBkZWYoXCJGbG93VHlwZVwiKSk7XG4gIGRlZihcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJhcmd1bWVudFwiKS5maWVsZChcImFyZ3VtZW50XCIsIGRlZihcIkZsb3dUeXBlXCIpKTtcbiAgZGVmKFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJpZFwiLCBcInZhbHVlXCIsIFwib3B0aW9uYWxcIiwgXCJzdGF0aWNcIiwgXCJtZXRob2RcIikuZmllbGQoXCJpZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKS5maWVsZChcInZhbHVlXCIsIGRlZihcIkZsb3dUeXBlXCIpKS5maWVsZChcIm9wdGlvbmFsXCIsIEJvb2xlYW4pLmZpZWxkKFwic3RhdGljXCIsIEJvb2xlYW4pLmZpZWxkKFwibWV0aG9kXCIsIEJvb2xlYW4pO1xuICBkZWYoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwicGFyYW1zXCIpLmZpZWxkKFwicGFyYW1zXCIsIFtkZWYoXCJUeXBlUGFyYW1ldGVyXCIpXSk7XG4gIGRlZihcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZChcInBhcmFtc1wiKS5maWVsZChcInBhcmFtc1wiLCBbZGVmKFwiRmxvd1R5cGVcIildKTtcbiAgZGVmKFwiVHlwZVBhcmFtZXRlclwiKS5iYXNlcyhcIkZsb3dUeXBlXCIpLmJ1aWxkKFwibmFtZVwiLCBcInZhcmlhbmNlXCIsIFwiYm91bmRcIiwgXCJkZWZhdWx0XCIpLmZpZWxkKFwibmFtZVwiLCBTdHJpbmcpLmZpZWxkKFwidmFyaWFuY2VcIiwgTGVnYWN5VmFyaWFuY2UsIGRlZmF1bHRzW1wibnVsbFwiXSkuZmllbGQoXCJib3VuZFwiLCBvcihkZWYoXCJUeXBlQW5ub3RhdGlvblwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSkuZmllbGQoXCJkZWZhdWx0XCIsIG9yKGRlZihcIkZsb3dUeXBlXCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKTtcbiAgZGVmKFwiQ2xhc3NQcm9wZXJ0eVwiKS5maWVsZChcInZhcmlhbmNlXCIsIExlZ2FjeVZhcmlhbmNlLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuICBkZWYoXCJDbGFzc0ltcGxlbWVudHNcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwiaWRcIikuZmllbGQoXCJpZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKS5maWVsZChcInN1cGVyQ2xhc3NcIiwgb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSkuZmllbGQoXG4gICAgXCJ0eXBlUGFyYW1ldGVyc1wiLFxuICAgIG9yKGRlZihcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLCBudWxsKSxcbiAgICBkZWZhdWx0c1tcIm51bGxcIl1cbiAgKTtcbiAgZGVmKFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZChcImJvZHlcIiwgXCJleHRlbmRzXCIpLmZpZWxkKFwiYm9keVwiLCBkZWYoXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiKSkuZmllbGQoXCJleHRlbmRzXCIsIG9yKFtkZWYoXCJJbnRlcmZhY2VFeHRlbmRzXCIpXSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpLmJhc2VzKFwiRGVjbGFyYXRpb25cIikuYnVpbGQoXCJpZFwiLCBcImJvZHlcIiwgXCJleHRlbmRzXCIpLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSkuZmllbGQoXG4gICAgXCJ0eXBlUGFyYW1ldGVyc1wiLFxuICAgIG9yKGRlZihcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKSwgbnVsbCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICkuZmllbGQoXCJib2R5XCIsIGRlZihcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIpKS5maWVsZChcImV4dGVuZHNcIiwgW2RlZihcIkludGVyZmFjZUV4dGVuZHNcIildKTtcbiAgZGVmKFwiRGVjbGFyZUludGVyZmFjZVwiKS5iYXNlcyhcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpLmJ1aWxkKFwiaWRcIiwgXCJib2R5XCIsIFwiZXh0ZW5kc1wiKTtcbiAgZGVmKFwiSW50ZXJmYWNlRXh0ZW5kc1wiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJpZFwiKS5maWVsZChcImlkXCIsIGRlZihcIklkZW50aWZpZXJcIikpLmZpZWxkKFxuICAgIFwidHlwZVBhcmFtZXRlcnNcIixcbiAgICBvcihkZWYoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSwgbnVsbCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICk7XG4gIGRlZihcIlR5cGVBbGlhc1wiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcInJpZ2h0XCIpLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSkuZmllbGQoXCJ0eXBlUGFyYW1ldGVyc1wiLCBvcihkZWYoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksIG51bGwpKS5maWVsZChcInJpZ2h0XCIsIGRlZihcIkZsb3dUeXBlXCIpKTtcbiAgZGVmKFwiRGVjbGFyZVR5cGVBbGlhc1wiKS5iYXNlcyhcIlR5cGVBbGlhc1wiKS5idWlsZChcImlkXCIsIFwidHlwZVBhcmFtZXRlcnNcIiwgXCJyaWdodFwiKTtcbiAgZGVmKFwiT3BhcXVlVHlwZVwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwiaWRcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiLCBcImltcGx0eXBlXCIsIFwic3VwZXJ0eXBlXCIpLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSkuZmllbGQoXCJ0eXBlUGFyYW1ldGVyc1wiLCBvcihkZWYoXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksIG51bGwpKS5maWVsZChcImltcGx0eXBlXCIsIGRlZihcIkZsb3dUeXBlXCIpKS5maWVsZChcInN1cGVydHlwZVwiLCBvcihkZWYoXCJGbG93VHlwZVwiKSwgbnVsbCkpO1xuICBkZWYoXCJEZWNsYXJlT3BhcXVlVHlwZVwiKS5iYXNlcyhcIk9wYXF1ZVR5cGVcIikuYnVpbGQoXCJpZFwiLCBcInR5cGVQYXJhbWV0ZXJzXCIsIFwic3VwZXJ0eXBlXCIpLmZpZWxkKFwiaW1wbHR5cGVcIiwgb3IoZGVmKFwiRmxvd1R5cGVcIiksIG51bGwpKTtcbiAgZGVmKFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcImV4cHJlc3Npb25cIiwgXCJ0eXBlQW5ub3RhdGlvblwiKS5maWVsZChcImV4cHJlc3Npb25cIiwgZGVmKFwiRXhwcmVzc2lvblwiKSkuZmllbGQoXCJ0eXBlQW5ub3RhdGlvblwiLCBkZWYoXCJUeXBlQW5ub3RhdGlvblwiKSk7XG4gIGRlZihcIlR1cGxlVHlwZUFubm90YXRpb25cIikuYmFzZXMoXCJGbG93VHlwZVwiKS5idWlsZChcInR5cGVzXCIpLmZpZWxkKFwidHlwZXNcIiwgW2RlZihcIkZsb3dUeXBlXCIpXSk7XG4gIGRlZihcIkRlY2xhcmVWYXJpYWJsZVwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZChcImlkXCIpLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSk7XG4gIGRlZihcIkRlY2xhcmVGdW5jdGlvblwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZChcImlkXCIpLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSkuZmllbGQoXCJwcmVkaWNhdGVcIiwgb3IoZGVmKFwiRmxvd1ByZWRpY2F0ZVwiKSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIkRlY2xhcmVDbGFzc1wiKS5iYXNlcyhcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpLmJ1aWxkKFwiaWRcIik7XG4gIGRlZihcIkRlY2xhcmVNb2R1bGVcIikuYmFzZXMoXCJTdGF0ZW1lbnRcIikuYnVpbGQoXCJpZFwiLCBcImJvZHlcIikuZmllbGQoXCJpZFwiLCBvcihkZWYoXCJJZGVudGlmaWVyXCIpLCBkZWYoXCJMaXRlcmFsXCIpKSkuZmllbGQoXCJib2R5XCIsIGRlZihcIkJsb2NrU3RhdGVtZW50XCIpKTtcbiAgZGVmKFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIikuYmFzZXMoXCJTdGF0ZW1lbnRcIikuYnVpbGQoXCJ0eXBlQW5ub3RhdGlvblwiKS5maWVsZChcInR5cGVBbm5vdGF0aW9uXCIsIGRlZihcIlR5cGVBbm5vdGF0aW9uXCIpKTtcbiAgZGVmKFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpLmJhc2VzKFwiRGVjbGFyYXRpb25cIikuYnVpbGQoXCJkZWZhdWx0XCIsIFwiZGVjbGFyYXRpb25cIiwgXCJzcGVjaWZpZXJzXCIsIFwic291cmNlXCIpLmZpZWxkKFwiZGVmYXVsdFwiLCBCb29sZWFuKS5maWVsZChcImRlY2xhcmF0aW9uXCIsIG9yKFxuICAgIGRlZihcIkRlY2xhcmVWYXJpYWJsZVwiKSxcbiAgICBkZWYoXCJEZWNsYXJlRnVuY3Rpb25cIiksXG4gICAgZGVmKFwiRGVjbGFyZUNsYXNzXCIpLFxuICAgIGRlZihcIkZsb3dUeXBlXCIpLFxuICAgIC8vIEltcGxpZXMgZGVmYXVsdC5cbiAgICBkZWYoXCJUeXBlQWxpYXNcIiksXG4gICAgLy8gSW1wbGllcyBuYW1lZCB0eXBlXG4gICAgZGVmKFwiRGVjbGFyZU9wYXF1ZVR5cGVcIiksXG4gICAgLy8gSW1wbGllcyBuYW1lZCBvcGFxdWUgdHlwZVxuICAgIGRlZihcIkludGVyZmFjZURlY2xhcmF0aW9uXCIpLFxuICAgIG51bGxcbiAgKSkuZmllbGQoXCJzcGVjaWZpZXJzXCIsIFtvcihcbiAgICBkZWYoXCJFeHBvcnRTcGVjaWZpZXJcIiksXG4gICAgZGVmKFwiRXhwb3J0QmF0Y2hTcGVjaWZpZXJcIilcbiAgKV0sIGRlZmF1bHRzLmVtcHR5QXJyYXkpLmZpZWxkKFwic291cmNlXCIsIG9yKFxuICAgIGRlZihcIkxpdGVyYWxcIiksXG4gICAgbnVsbFxuICApLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuICBkZWYoXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIikuYmFzZXMoXCJEZWNsYXJhdGlvblwiKS5idWlsZChcInNvdXJjZVwiKS5maWVsZChcInNvdXJjZVwiLCBvcihcbiAgICBkZWYoXCJMaXRlcmFsXCIpLFxuICAgIG51bGxcbiAgKSwgZGVmYXVsdHNbXCJudWxsXCJdKTtcbiAgZGVmKFwiSW1wb3J0RGVjbGFyYXRpb25cIikuZmllbGQoXCJpbXBvcnRLaW5kXCIsIG9yKFwidmFsdWVcIiwgXCJ0eXBlXCIsIFwidHlwZW9mXCIpLCAoKSA9PiBcInZhbHVlXCIpO1xuICBkZWYoXCJGbG93UHJlZGljYXRlXCIpLmJhc2VzKFwiRmxvd1wiKTtcbiAgZGVmKFwiSW5mZXJyZWRQcmVkaWNhdGVcIikuYmFzZXMoXCJGbG93UHJlZGljYXRlXCIpLmJ1aWxkKCk7XG4gIGRlZihcIkRlY2xhcmVkUHJlZGljYXRlXCIpLmJhc2VzKFwiRmxvd1ByZWRpY2F0ZVwiKS5idWlsZChcInZhbHVlXCIpLmZpZWxkKFwidmFsdWVcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG4gIGRlZihcIkZ1bmN0aW9uXCIpLmZpZWxkKFwicHJlZGljYXRlXCIsIG9yKGRlZihcIkZsb3dQcmVkaWNhdGVcIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuICBkZWYoXCJDYWxsRXhwcmVzc2lvblwiKS5maWVsZChcInR5cGVBcmd1bWVudHNcIiwgb3IoXG4gICAgbnVsbCxcbiAgICBkZWYoXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKVxuICApLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuICBkZWYoXCJOZXdFeHByZXNzaW9uXCIpLmZpZWxkKFwidHlwZUFyZ3VtZW50c1wiLCBvcihcbiAgICBudWxsLFxuICAgIGRlZihcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpXG4gICksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIkVudW1EZWNsYXJhdGlvblwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwiaWRcIiwgXCJib2R5XCIpLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSkuZmllbGQoXCJib2R5XCIsIG9yKFxuICAgIGRlZihcIkVudW1Cb29sZWFuQm9keVwiKSxcbiAgICBkZWYoXCJFbnVtTnVtYmVyQm9keVwiKSxcbiAgICBkZWYoXCJFbnVtU3RyaW5nQm9keVwiKSxcbiAgICBkZWYoXCJFbnVtU3ltYm9sQm9keVwiKVxuICApKTtcbiAgZGVmKFwiRW51bUJvb2xlYW5Cb2R5XCIpLmJ1aWxkKFwibWVtYmVyc1wiLCBcImV4cGxpY2l0VHlwZVwiKS5maWVsZChcIm1lbWJlcnNcIiwgW2RlZihcIkVudW1Cb29sZWFuTWVtYmVyXCIpXSkuZmllbGQoXCJleHBsaWNpdFR5cGVcIiwgQm9vbGVhbik7XG4gIGRlZihcIkVudW1OdW1iZXJCb2R5XCIpLmJ1aWxkKFwibWVtYmVyc1wiLCBcImV4cGxpY2l0VHlwZVwiKS5maWVsZChcIm1lbWJlcnNcIiwgW2RlZihcIkVudW1OdW1iZXJNZW1iZXJcIildKS5maWVsZChcImV4cGxpY2l0VHlwZVwiLCBCb29sZWFuKTtcbiAgZGVmKFwiRW51bVN0cmluZ0JvZHlcIikuYnVpbGQoXCJtZW1iZXJzXCIsIFwiZXhwbGljaXRUeXBlXCIpLmZpZWxkKFwibWVtYmVyc1wiLCBvcihbZGVmKFwiRW51bVN0cmluZ01lbWJlclwiKV0sIFtkZWYoXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIpXSkpLmZpZWxkKFwiZXhwbGljaXRUeXBlXCIsIEJvb2xlYW4pO1xuICBkZWYoXCJFbnVtU3ltYm9sQm9keVwiKS5idWlsZChcIm1lbWJlcnNcIikuZmllbGQoXCJtZW1iZXJzXCIsIFtkZWYoXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIpXSk7XG4gIGRlZihcIkVudW1Cb29sZWFuTWVtYmVyXCIpLmJ1aWxkKFwiaWRcIiwgXCJpbml0XCIpLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSkuZmllbGQoXCJpbml0XCIsIG9yKGRlZihcIkxpdGVyYWxcIiksIEJvb2xlYW4pKTtcbiAgZGVmKFwiRW51bU51bWJlck1lbWJlclwiKS5idWlsZChcImlkXCIsIFwiaW5pdFwiKS5maWVsZChcImlkXCIsIGRlZihcIklkZW50aWZpZXJcIikpLmZpZWxkKFwiaW5pdFwiLCBkZWYoXCJMaXRlcmFsXCIpKTtcbiAgZGVmKFwiRW51bVN0cmluZ01lbWJlclwiKS5idWlsZChcImlkXCIsIFwiaW5pdFwiKS5maWVsZChcImlkXCIsIGRlZihcIklkZW50aWZpZXJcIikpLmZpZWxkKFwiaW5pdFwiLCBkZWYoXCJMaXRlcmFsXCIpKTtcbiAgZGVmKFwiRW51bURlZmF1bHRlZE1lbWJlclwiKS5idWlsZChcImlkXCIpLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSk7XG59XG5tYXliZVNldE1vZHVsZUV4cG9ydHMoKCkgPT4gbW9kdWxlKTtcblxuZnVuY3Rpb24gZXNwcmltYURlZihmb3JrKSB7XG4gIGZvcmsudXNlKGVzUHJvcG9zYWxzRGVmKTtcbiAgdmFyIHR5cGVzID0gZm9yay51c2UodHlwZXNQbHVnaW4pO1xuICB2YXIgZGVmYXVsdHMgPSBmb3JrLnVzZShzaGFyZWRQbHVnaW4pLmRlZmF1bHRzO1xuICB2YXIgZGVmID0gdHlwZXMuVHlwZS5kZWY7XG4gIHZhciBvciA9IHR5cGVzLlR5cGUub3I7XG4gIGRlZihcIlZhcmlhYmxlRGVjbGFyYXRpb25cIikuZmllbGQoXCJkZWNsYXJhdGlvbnNcIiwgW29yKFxuICAgIGRlZihcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSxcbiAgICBkZWYoXCJJZGVudGlmaWVyXCIpXG4gICAgLy8gRXNwcmltYSBkZXZpYXRpb24uXG4gICldKTtcbiAgZGVmKFwiUHJvcGVydHlcIikuZmllbGQoXCJ2YWx1ZVwiLCBvcihcbiAgICBkZWYoXCJFeHByZXNzaW9uXCIpLFxuICAgIGRlZihcIlBhdHRlcm5cIilcbiAgICAvLyBFc3ByaW1hIGRldmlhdGlvbi5cbiAgKSk7XG4gIGRlZihcIkFycmF5UGF0dGVyblwiKS5maWVsZChcImVsZW1lbnRzXCIsIFtvcihcbiAgICBkZWYoXCJQYXR0ZXJuXCIpLFxuICAgIGRlZihcIlNwcmVhZEVsZW1lbnRcIiksXG4gICAgbnVsbFxuICApXSk7XG4gIGRlZihcIk9iamVjdFBhdHRlcm5cIikuZmllbGQoXCJwcm9wZXJ0aWVzXCIsIFtvcihcbiAgICBkZWYoXCJQcm9wZXJ0eVwiKSxcbiAgICBkZWYoXCJQcm9wZXJ0eVBhdHRlcm5cIiksXG4gICAgZGVmKFwiU3ByZWFkUHJvcGVydHlQYXR0ZXJuXCIpLFxuICAgIGRlZihcIlNwcmVhZFByb3BlcnR5XCIpXG4gICAgLy8gVXNlZCBieSBFc3ByaW1hLlxuICApXSk7XG4gIGRlZihcIkV4cG9ydFNwZWNpZmllclwiKS5iYXNlcyhcIk1vZHVsZVNwZWNpZmllclwiKS5idWlsZChcImlkXCIsIFwibmFtZVwiKTtcbiAgZGVmKFwiRXhwb3J0QmF0Y2hTcGVjaWZpZXJcIikuYmFzZXMoXCJTcGVjaWZpZXJcIikuYnVpbGQoKTtcbiAgZGVmKFwiRXhwb3J0RGVjbGFyYXRpb25cIikuYmFzZXMoXCJEZWNsYXJhdGlvblwiKS5idWlsZChcImRlZmF1bHRcIiwgXCJkZWNsYXJhdGlvblwiLCBcInNwZWNpZmllcnNcIiwgXCJzb3VyY2VcIikuZmllbGQoXCJkZWZhdWx0XCIsIEJvb2xlYW4pLmZpZWxkKFwiZGVjbGFyYXRpb25cIiwgb3IoXG4gICAgZGVmKFwiRGVjbGFyYXRpb25cIiksXG4gICAgZGVmKFwiRXhwcmVzc2lvblwiKSxcbiAgICAvLyBJbXBsaWVzIGRlZmF1bHQuXG4gICAgbnVsbFxuICApKS5maWVsZChcInNwZWNpZmllcnNcIiwgW29yKFxuICAgIGRlZihcIkV4cG9ydFNwZWNpZmllclwiKSxcbiAgICBkZWYoXCJFeHBvcnRCYXRjaFNwZWNpZmllclwiKVxuICApXSwgZGVmYXVsdHMuZW1wdHlBcnJheSkuZmllbGQoXCJzb3VyY2VcIiwgb3IoXG4gICAgZGVmKFwiTGl0ZXJhbFwiKSxcbiAgICBudWxsXG4gICksIGRlZmF1bHRzW1wibnVsbFwiXSk7XG4gIGRlZihcIkJsb2NrXCIpLmJhc2VzKFwiQ29tbWVudFwiKS5idWlsZChcbiAgICBcInZhbHVlXCIsXG4gICAgLypvcHRpb25hbDoqL1xuICAgIFwibGVhZGluZ1wiLFxuICAgIFwidHJhaWxpbmdcIlxuICApO1xuICBkZWYoXCJMaW5lXCIpLmJhc2VzKFwiQ29tbWVudFwiKS5idWlsZChcbiAgICBcInZhbHVlXCIsXG4gICAgLypvcHRpb25hbDoqL1xuICAgIFwibGVhZGluZ1wiLFxuICAgIFwidHJhaWxpbmdcIlxuICApO1xufVxubWF5YmVTZXRNb2R1bGVFeHBvcnRzKCgpID0+IG1vZHVsZSk7XG5cbmZ1bmN0aW9uIGJhYmVsQ29yZURlZihmb3JrKSB7XG4gIGZvcmsudXNlKGVzUHJvcG9zYWxzRGVmKTtcbiAgY29uc3QgdHlwZXMgPSBmb3JrLnVzZSh0eXBlc1BsdWdpbik7XG4gIGNvbnN0IGRlZmF1bHRzID0gZm9yay51c2Uoc2hhcmVkUGx1Z2luKS5kZWZhdWx0cztcbiAgY29uc3QgZGVmID0gdHlwZXMuVHlwZS5kZWY7XG4gIGNvbnN0IG9yID0gdHlwZXMuVHlwZS5vcjtcbiAgY29uc3Qge1xuICAgIHVuZGVmaW5lZDogaXNVbmRlZmluZWRcbiAgfSA9IHR5cGVzLmJ1aWx0SW5UeXBlcztcbiAgZGVmKFwiTm9vcFwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZCgpO1xuICBkZWYoXCJEb0V4cHJlc3Npb25cIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpLmJ1aWxkKFwiYm9keVwiKS5maWVsZChcImJvZHlcIiwgW2RlZihcIlN0YXRlbWVudFwiKV0pO1xuICBkZWYoXCJCaW5kRXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJvYmplY3RcIiwgXCJjYWxsZWVcIikuZmllbGQoXCJvYmplY3RcIiwgb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgbnVsbCkpLmZpZWxkKFwiY2FsbGVlXCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuICBkZWYoXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJleHByZXNzaW9uXCIpLmZpZWxkKFwiZXhwcmVzc2lvblwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKTtcbiAgZGVmKFwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpLmJhc2VzKFwiU3BlY2lmaWVyXCIpLmJ1aWxkKFwiZXhwb3J0ZWRcIikuZmllbGQoXCJleHBvcnRlZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKTtcbiAgZGVmKFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiKS5iYXNlcyhcIlNwZWNpZmllclwiKS5idWlsZChcImV4cG9ydGVkXCIpLmZpZWxkKFwiZXhwb3J0ZWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSk7XG4gIGRlZihcIkNvbW1lbnRCbG9ja1wiKS5iYXNlcyhcIkNvbW1lbnRcIikuYnVpbGQoXG4gICAgXCJ2YWx1ZVwiLFxuICAgIC8qb3B0aW9uYWw6Ki9cbiAgICBcImxlYWRpbmdcIixcbiAgICBcInRyYWlsaW5nXCJcbiAgKTtcbiAgZGVmKFwiQ29tbWVudExpbmVcIikuYmFzZXMoXCJDb21tZW50XCIpLmJ1aWxkKFxuICAgIFwidmFsdWVcIixcbiAgICAvKm9wdGlvbmFsOiovXG4gICAgXCJsZWFkaW5nXCIsXG4gICAgXCJ0cmFpbGluZ1wiXG4gICk7XG4gIGRlZihcIkRpcmVjdGl2ZVwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJ2YWx1ZVwiKS5maWVsZChcInZhbHVlXCIsIGRlZihcIkRpcmVjdGl2ZUxpdGVyYWxcIikpO1xuICBkZWYoXCJEaXJlY3RpdmVMaXRlcmFsXCIpLmJhc2VzKFwiTm9kZVwiLCBcIkV4cHJlc3Npb25cIikuYnVpbGQoXCJ2YWx1ZVwiKS5maWVsZChcInZhbHVlXCIsIFN0cmluZywgZGVmYXVsdHNbXCJ1c2Ugc3RyaWN0XCJdKTtcbiAgZGVmKFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwidmFsdWVcIikuZmllbGQoXCJ2YWx1ZVwiLCBTdHJpbmcpO1xuICBkZWYoXCJCbG9ja1N0YXRlbWVudFwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZChcImJvZHlcIikuZmllbGQoXCJib2R5XCIsIFtkZWYoXCJTdGF0ZW1lbnRcIildKS5maWVsZChcImRpcmVjdGl2ZXNcIiwgW2RlZihcIkRpcmVjdGl2ZVwiKV0sIGRlZmF1bHRzLmVtcHR5QXJyYXkpO1xuICBkZWYoXCJQcm9ncmFtXCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZChcImJvZHlcIikuZmllbGQoXCJib2R5XCIsIFtkZWYoXCJTdGF0ZW1lbnRcIildKS5maWVsZChcImRpcmVjdGl2ZXNcIiwgW2RlZihcIkRpcmVjdGl2ZVwiKV0sIGRlZmF1bHRzLmVtcHR5QXJyYXkpLmZpZWxkKFwiaW50ZXJwcmV0ZXJcIiwgb3IoZGVmKFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuICBmdW5jdGlvbiBtYWtlTGl0ZXJhbEV4dHJhKHJhd1ZhbHVlVHlwZSA9IFN0cmluZywgdG9SYXcpIHtcbiAgICByZXR1cm4gW1xuICAgICAgXCJleHRyYVwiLFxuICAgICAge1xuICAgICAgICByYXdWYWx1ZTogcmF3VmFsdWVUeXBlLFxuICAgICAgICByYXc6IFN0cmluZ1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdHlwZXMuZ2V0RmllbGRWYWx1ZSh0aGlzLCBcInZhbHVlXCIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJhd1ZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICByYXc6IHRvUmF3ID8gdG9SYXcodmFsdWUpIDogU3RyaW5nKHZhbHVlKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIF07XG4gIH1cbiAgZGVmKFwiU3RyaW5nTGl0ZXJhbFwiKS5iYXNlcyhcIkxpdGVyYWxcIikuYnVpbGQoXCJ2YWx1ZVwiKS5maWVsZChcInZhbHVlXCIsIFN0cmluZykuZmllbGQoLi4ubWFrZUxpdGVyYWxFeHRyYShTdHJpbmcsICh2YWwpID0+IEpTT04uc3RyaW5naWZ5KHZhbCkpKTtcbiAgZGVmKFwiTnVtZXJpY0xpdGVyYWxcIikuYmFzZXMoXCJMaXRlcmFsXCIpLmJ1aWxkKFwidmFsdWVcIikuZmllbGQoXCJ2YWx1ZVwiLCBOdW1iZXIpLmZpZWxkKFwicmF3XCIsIG9yKFN0cmluZywgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSkuZmllbGQoLi4ubWFrZUxpdGVyYWxFeHRyYShOdW1iZXIpKTtcbiAgZGVmKFwiQmlnSW50TGl0ZXJhbFwiKS5iYXNlcyhcIkxpdGVyYWxcIikuYnVpbGQoXCJ2YWx1ZVwiKS5maWVsZChcInZhbHVlXCIsIG9yKFN0cmluZywgTnVtYmVyKSkuZmllbGQoLi4ubWFrZUxpdGVyYWxFeHRyYShTdHJpbmcsICh2YWwpID0+IHZhbCArIFwiblwiKSk7XG4gIGRlZihcIkRlY2ltYWxMaXRlcmFsXCIpLmJhc2VzKFwiTGl0ZXJhbFwiKS5idWlsZChcInZhbHVlXCIpLmZpZWxkKFwidmFsdWVcIiwgU3RyaW5nKS5maWVsZCguLi5tYWtlTGl0ZXJhbEV4dHJhKFN0cmluZywgKHZhbCkgPT4gdmFsICsgXCJtXCIpKTtcbiAgZGVmKFwiTnVsbExpdGVyYWxcIikuYmFzZXMoXCJMaXRlcmFsXCIpLmJ1aWxkKCkuZmllbGQoXCJ2YWx1ZVwiLCBudWxsLCBkZWZhdWx0c1tcIm51bGxcIl0pO1xuICBkZWYoXCJCb29sZWFuTGl0ZXJhbFwiKS5iYXNlcyhcIkxpdGVyYWxcIikuYnVpbGQoXCJ2YWx1ZVwiKS5maWVsZChcInZhbHVlXCIsIEJvb2xlYW4pO1xuICBkZWYoXCJSZWdFeHBMaXRlcmFsXCIpLmJhc2VzKFwiTGl0ZXJhbFwiKS5idWlsZChcInBhdHRlcm5cIiwgXCJmbGFnc1wiKS5maWVsZChcInBhdHRlcm5cIiwgU3RyaW5nKS5maWVsZChcImZsYWdzXCIsIFN0cmluZykuZmllbGQoXCJ2YWx1ZVwiLCBSZWdFeHAsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHRoaXMucGF0dGVybiwgdGhpcy5mbGFncyk7XG4gIH0pLmZpZWxkKC4uLm1ha2VMaXRlcmFsRXh0cmEoXG4gICAgb3IoUmVnRXhwLCBpc1VuZGVmaW5lZCksXG4gICAgKGV4cCkgPT4gYC8ke2V4cC5wYXR0ZXJufS8ke2V4cC5mbGFncyB8fCBcIlwifWBcbiAgKSkuZmllbGQoXCJyZWdleFwiLCB7XG4gICAgcGF0dGVybjogU3RyaW5nLFxuICAgIGZsYWdzOiBTdHJpbmdcbiAgfSwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdHRlcm46IHRoaXMucGF0dGVybixcbiAgICAgIGZsYWdzOiB0aGlzLmZsYWdzXG4gICAgfTtcbiAgfSk7XG4gIHZhciBPYmplY3RFeHByZXNzaW9uUHJvcGVydHkgPSBvcihcbiAgICBkZWYoXCJQcm9wZXJ0eVwiKSxcbiAgICBkZWYoXCJPYmplY3RNZXRob2RcIiksXG4gICAgZGVmKFwiT2JqZWN0UHJvcGVydHlcIiksXG4gICAgZGVmKFwiU3ByZWFkUHJvcGVydHlcIiksXG4gICAgZGVmKFwiU3ByZWFkRWxlbWVudFwiKVxuICApO1xuICBkZWYoXCJPYmplY3RFeHByZXNzaW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiKS5idWlsZChcInByb3BlcnRpZXNcIikuZmllbGQoXCJwcm9wZXJ0aWVzXCIsIFtPYmplY3RFeHByZXNzaW9uUHJvcGVydHldKTtcbiAgZGVmKFwiT2JqZWN0TWV0aG9kXCIpLmJhc2VzKFwiTm9kZVwiLCBcIkZ1bmN0aW9uXCIpLmJ1aWxkKFwia2luZFwiLCBcImtleVwiLCBcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJjb21wdXRlZFwiKS5maWVsZChcImtpbmRcIiwgb3IoXCJtZXRob2RcIiwgXCJnZXRcIiwgXCJzZXRcIikpLmZpZWxkKFwia2V5XCIsIG9yKGRlZihcIkxpdGVyYWxcIiksIGRlZihcIklkZW50aWZpZXJcIiksIGRlZihcIkV4cHJlc3Npb25cIikpKS5maWVsZChcInBhcmFtc1wiLCBbZGVmKFwiUGF0dGVyblwiKV0pLmZpZWxkKFwiYm9keVwiLCBkZWYoXCJCbG9ja1N0YXRlbWVudFwiKSkuZmllbGQoXCJjb21wdXRlZFwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcImdlbmVyYXRvclwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcImFzeW5jXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pLmZpZWxkKFxuICAgIFwiYWNjZXNzaWJpbGl0eVwiLFxuICAgIC8vIFR5cGVTY3JpcHRcbiAgICBvcihkZWYoXCJMaXRlcmFsXCIpLCBudWxsKSxcbiAgICBkZWZhdWx0c1tcIm51bGxcIl1cbiAgKS5maWVsZChcbiAgICBcImRlY29yYXRvcnNcIixcbiAgICBvcihbZGVmKFwiRGVjb3JhdG9yXCIpXSwgbnVsbCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICk7XG4gIGRlZihcIk9iamVjdFByb3BlcnR5XCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZChcImtleVwiLCBcInZhbHVlXCIpLmZpZWxkKFwia2V5XCIsIG9yKGRlZihcIkxpdGVyYWxcIiksIGRlZihcIklkZW50aWZpZXJcIiksIGRlZihcIkV4cHJlc3Npb25cIikpKS5maWVsZChcInZhbHVlXCIsIG9yKGRlZihcIkV4cHJlc3Npb25cIiksIGRlZihcIlBhdHRlcm5cIikpKS5maWVsZChcbiAgICBcImFjY2Vzc2liaWxpdHlcIixcbiAgICAvLyBUeXBlU2NyaXB0XG4gICAgb3IoZGVmKFwiTGl0ZXJhbFwiKSwgbnVsbCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICkuZmllbGQoXCJjb21wdXRlZFwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKTtcbiAgdmFyIENsYXNzQm9keUVsZW1lbnQgPSBvcihcbiAgICBkZWYoXCJNZXRob2REZWZpbml0aW9uXCIpLFxuICAgIGRlZihcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSxcbiAgICBkZWYoXCJDbGFzc1Byb3BlcnR5RGVmaW5pdGlvblwiKSxcbiAgICBkZWYoXCJDbGFzc1Byb3BlcnR5XCIpLFxuICAgIGRlZihcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIpLFxuICAgIGRlZihcIkNsYXNzTWV0aG9kXCIpLFxuICAgIGRlZihcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiKSxcbiAgICBkZWYoXCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcIiksXG4gICAgZGVmKFwiU3RhdGljQmxvY2tcIilcbiAgKTtcbiAgZGVmKFwiQ2xhc3NCb2R5XCIpLmJhc2VzKFwiRGVjbGFyYXRpb25cIikuYnVpbGQoXCJib2R5XCIpLmZpZWxkKFwiYm9keVwiLCBbQ2xhc3NCb2R5RWxlbWVudF0pO1xuICBkZWYoXCJDbGFzc01ldGhvZFwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIsIFwiRnVuY3Rpb25cIikuYnVpbGQoXCJraW5kXCIsIFwia2V5XCIsIFwicGFyYW1zXCIsIFwiYm9keVwiLCBcImNvbXB1dGVkXCIsIFwic3RhdGljXCIpLmZpZWxkKFwia2V5XCIsIG9yKGRlZihcIkxpdGVyYWxcIiksIGRlZihcIklkZW50aWZpZXJcIiksIGRlZihcIkV4cHJlc3Npb25cIikpKTtcbiAgZGVmKFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIpLmJhc2VzKFwiRGVjbGFyYXRpb25cIiwgXCJGdW5jdGlvblwiKS5idWlsZChcImtleVwiLCBcInBhcmFtc1wiLCBcImJvZHlcIiwgXCJraW5kXCIsIFwiY29tcHV0ZWRcIiwgXCJzdGF0aWNcIikuZmllbGQoXCJrZXlcIiwgZGVmKFwiUHJpdmF0ZU5hbWVcIikpO1xuICBkZWYoXCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcIikuYmFzZXMoXCJEZWNsYXJhdGlvblwiKS5idWlsZChcImtleVwiLCBcInZhbHVlXCIsIFwiZGVjb3JhdG9yc1wiLCBcImNvbXB1dGVkXCIsIFwic3RhdGljXCIpLmZpZWxkKFwia2V5XCIsIG9yKFxuICAgIGRlZihcIkxpdGVyYWxcIiksXG4gICAgZGVmKFwiSWRlbnRpZmllclwiKSxcbiAgICBkZWYoXCJQcml2YXRlTmFtZVwiKSxcbiAgICAvLyBPbmx5IHdoZW4gLmNvbXB1dGVkIGlzIHRydWUgKFRPRE8gZW5mb3JjZSB0aGlzKVxuICAgIGRlZihcIkV4cHJlc3Npb25cIilcbiAgKSkuZmllbGQoXCJ2YWx1ZVwiLCBvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKTtcbiAgW1xuICAgIFwiQ2xhc3NNZXRob2RcIixcbiAgICBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiXG4gIF0uZm9yRWFjaCgodHlwZU5hbWUpID0+IHtcbiAgICBkZWYodHlwZU5hbWUpLmZpZWxkKFwia2luZFwiLCBvcihcImdldFwiLCBcInNldFwiLCBcIm1ldGhvZFwiLCBcImNvbnN0cnVjdG9yXCIpLCAoKSA9PiBcIm1ldGhvZFwiKS5maWVsZChcImJvZHlcIiwgZGVmKFwiQmxvY2tTdGF0ZW1lbnRcIikpLmZpZWxkKFwiYWNjZXNzXCIsIG9yKFwicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBudWxsKSwgZGVmYXVsdHNbXCJudWxsXCJdKTtcbiAgfSk7XG4gIFtcbiAgICBcIkNsYXNzTWV0aG9kXCIsXG4gICAgXCJDbGFzc1ByaXZhdGVNZXRob2RcIixcbiAgICBcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiXG4gIF0uZm9yRWFjaCgodHlwZU5hbWUpID0+IHtcbiAgICBkZWYodHlwZU5hbWUpLmZpZWxkKFwiY29tcHV0ZWRcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJzdGF0aWNcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJhYnN0cmFjdFwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcImFjY2Vzc2liaWxpdHlcIiwgb3IoXCJwdWJsaWNcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pLmZpZWxkKFwiZGVjb3JhdG9yc1wiLCBvcihbZGVmKFwiRGVjb3JhdG9yXCIpXSwgbnVsbCksIGRlZmF1bHRzW1wibnVsbFwiXSkuZmllbGQoXCJkZWZpbml0ZVwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcIm9wdGlvbmFsXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pLmZpZWxkKFwib3ZlcnJpZGVcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJyZWFkb25seVwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKTtcbiAgfSk7XG4gIHZhciBPYmplY3RQYXR0ZXJuUHJvcGVydHkgPSBvcihcbiAgICBkZWYoXCJQcm9wZXJ0eVwiKSxcbiAgICBkZWYoXCJQcm9wZXJ0eVBhdHRlcm5cIiksXG4gICAgZGVmKFwiU3ByZWFkUHJvcGVydHlQYXR0ZXJuXCIpLFxuICAgIGRlZihcIlNwcmVhZFByb3BlcnR5XCIpLFxuICAgIC8vIFVzZWQgYnkgRXNwcmltYVxuICAgIGRlZihcIk9iamVjdFByb3BlcnR5XCIpLFxuICAgIC8vIEJhYmVsIDZcbiAgICBkZWYoXCJSZXN0UHJvcGVydHlcIiksXG4gICAgLy8gQmFiZWwgNlxuICAgIGRlZihcIlJlc3RFbGVtZW50XCIpXG4gICAgLy8gQmFiZWwgNlxuICApO1xuICBkZWYoXCJPYmplY3RQYXR0ZXJuXCIpLmJhc2VzKFwiUGF0dGVyblwiKS5idWlsZChcInByb3BlcnRpZXNcIikuZmllbGQoXCJwcm9wZXJ0aWVzXCIsIFtPYmplY3RQYXR0ZXJuUHJvcGVydHldKS5maWVsZChcbiAgICBcImRlY29yYXRvcnNcIixcbiAgICBvcihbZGVmKFwiRGVjb3JhdG9yXCIpXSwgbnVsbCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICk7XG4gIGRlZihcIlNwcmVhZFByb3BlcnR5XCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZChcImFyZ3VtZW50XCIpLmZpZWxkKFwiYXJndW1lbnRcIiwgZGVmKFwiRXhwcmVzc2lvblwiKSk7XG4gIGRlZihcIlJlc3RQcm9wZXJ0eVwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJhcmd1bWVudFwiKS5maWVsZChcImFyZ3VtZW50XCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuICBkZWYoXCJGb3JBd2FpdFN0YXRlbWVudFwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZChcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvZHlcIikuZmllbGQoXCJsZWZ0XCIsIG9yKFxuICAgIGRlZihcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiksXG4gICAgZGVmKFwiRXhwcmVzc2lvblwiKVxuICApKS5maWVsZChcInJpZ2h0XCIsIGRlZihcIkV4cHJlc3Npb25cIikpLmZpZWxkKFwiYm9keVwiLCBkZWYoXCJTdGF0ZW1lbnRcIikpO1xuICBkZWYoXCJJbXBvcnRcIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpLmJ1aWxkKCk7XG59XG5tYXliZVNldE1vZHVsZUV4cG9ydHMoKCkgPT4gbW9kdWxlKTtcblxuZnVuY3Rpb24gYmFiZWxEZWYoZm9yaykge1xuICBjb25zdCB0eXBlcyA9IGZvcmsudXNlKHR5cGVzUGx1Z2luKTtcbiAgY29uc3QgZGVmID0gdHlwZXMuVHlwZS5kZWY7XG4gIGZvcmsudXNlKGJhYmVsQ29yZURlZik7XG4gIGZvcmsudXNlKGZsb3dEZWYpO1xuICBkZWYoXCJWOEludHJpbnNpY0lkZW50aWZpZXJcIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpLmJ1aWxkKFwibmFtZVwiKS5maWVsZChcIm5hbWVcIiwgU3RyaW5nKTtcbiAgZGVmKFwiVG9waWNSZWZlcmVuY2VcIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpLmJ1aWxkKCk7XG59XG5tYXliZVNldE1vZHVsZUV4cG9ydHMoKCkgPT4gbW9kdWxlKTtcblxuZnVuY3Rpb24gdHlwZXNjcmlwdERlZihmb3JrKSB7XG4gIGZvcmsudXNlKGJhYmVsQ29yZURlZik7XG4gIGZvcmsudXNlKHR5cGVBbm5vdGF0aW9uc0RlZik7XG4gIHZhciB0eXBlcyA9IGZvcmsudXNlKHR5cGVzUGx1Z2luKTtcbiAgdmFyIG4gPSB0eXBlcy5uYW1lZFR5cGVzO1xuICB2YXIgZGVmID0gdHlwZXMuVHlwZS5kZWY7XG4gIHZhciBvciA9IHR5cGVzLlR5cGUub3I7XG4gIHZhciBkZWZhdWx0cyA9IGZvcmsudXNlKHNoYXJlZFBsdWdpbikuZGVmYXVsdHM7XG4gIHZhciBTdHJpbmdMaXRlcmFsID0gdHlwZXMuVHlwZS5mcm9tKGZ1bmN0aW9uKHZhbHVlLCBkZWVwKSB7XG4gICAgaWYgKG4uU3RyaW5nTGl0ZXJhbCAmJiBuLlN0cmluZ0xpdGVyYWwuY2hlY2sodmFsdWUsIGRlZXApKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG4uTGl0ZXJhbCAmJiBuLkxpdGVyYWwuY2hlY2sodmFsdWUsIGRlZXApICYmIHR5cGVvZiB2YWx1ZS52YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgXCJTdHJpbmdMaXRlcmFsXCIpO1xuICBkZWYoXCJUU1R5cGVcIikuYmFzZXMoXCJOb2RlXCIpO1xuICB2YXIgVFNFbnRpdHlOYW1lID0gb3IoXG4gICAgZGVmKFwiSWRlbnRpZmllclwiKSxcbiAgICBkZWYoXCJUU1F1YWxpZmllZE5hbWVcIilcbiAgKTtcbiAgZGVmKFwiVFNUeXBlUmVmZXJlbmNlXCIpLmJhc2VzKFwiVFNUeXBlXCIsIFwiVFNIYXNPcHRpb25hbFR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLmJ1aWxkKFwidHlwZU5hbWVcIiwgXCJ0eXBlUGFyYW1ldGVyc1wiKS5maWVsZChcInR5cGVOYW1lXCIsIFRTRW50aXR5TmFtZSk7XG4gIGRlZihcIlRTSGFzT3B0aW9uYWxUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKS5maWVsZChcbiAgICBcInR5cGVQYXJhbWV0ZXJzXCIsXG4gICAgb3IoZGVmKFwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKSwgbnVsbCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICk7XG4gIGRlZihcIlRTSGFzT3B0aW9uYWxUeXBlUGFyYW1ldGVyc1wiKS5maWVsZChcbiAgICBcInR5cGVQYXJhbWV0ZXJzXCIsXG4gICAgb3IoZGVmKFwiVFNUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiksIG51bGwsIHZvaWQgMCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICk7XG4gIGRlZihcIlRTSGFzT3B0aW9uYWxUeXBlQW5ub3RhdGlvblwiKS5maWVsZChcbiAgICBcInR5cGVBbm5vdGF0aW9uXCIsXG4gICAgb3IoZGVmKFwiVFNUeXBlQW5ub3RhdGlvblwiKSwgbnVsbCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICk7XG4gIGRlZihcIlRTUXVhbGlmaWVkTmFtZVwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJsZWZ0XCIsIFwicmlnaHRcIikuZmllbGQoXCJsZWZ0XCIsIFRTRW50aXR5TmFtZSkuZmllbGQoXCJyaWdodFwiLCBUU0VudGl0eU5hbWUpO1xuICBkZWYoXCJUU0FzRXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIiwgXCJQYXR0ZXJuXCIpLmJ1aWxkKFwiZXhwcmVzc2lvblwiLCBcInR5cGVBbm5vdGF0aW9uXCIpLmZpZWxkKFwiZXhwcmVzc2lvblwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcInR5cGVBbm5vdGF0aW9uXCIsIGRlZihcIlRTVHlwZVwiKSkuZmllbGQoXG4gICAgXCJleHRyYVwiLFxuICAgIG9yKHsgcGFyZW50aGVzaXplZDogQm9vbGVhbiB9LCBudWxsKSxcbiAgICBkZWZhdWx0c1tcIm51bGxcIl1cbiAgKTtcbiAgZGVmKFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIikuYmFzZXMoXCJFeHByZXNzaW9uXCIpLmJ1aWxkKFwiZXhwcmVzc2lvblwiLCBcInR5cGVBbm5vdGF0aW9uXCIpLmZpZWxkKFwiZXhwcmVzc2lvblwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcInR5cGVBbm5vdGF0aW9uXCIsIGRlZihcIlRTVHlwZVwiKSk7XG4gIGRlZihcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIiwgXCJQYXR0ZXJuXCIpLmJ1aWxkKFwiZXhwcmVzc2lvblwiLCBcInR5cGVBbm5vdGF0aW9uXCIpLmZpZWxkKFwiZXhwcmVzc2lvblwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcInR5cGVBbm5vdGF0aW9uXCIsIGRlZihcIlRTVHlwZVwiKSk7XG4gIGRlZihcIlRTTm9uTnVsbEV4cHJlc3Npb25cIikuYmFzZXMoXCJFeHByZXNzaW9uXCIsIFwiUGF0dGVyblwiKS5idWlsZChcImV4cHJlc3Npb25cIikuZmllbGQoXCJleHByZXNzaW9uXCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuICBbXG4gICAgLy8gRGVmaW5lIGFsbCB0aGUgc2ltcGxlIGtleXdvcmQgdHlwZXMuXG4gICAgXCJUU0FueUtleXdvcmRcIixcbiAgICBcIlRTQmlnSW50S2V5d29yZFwiLFxuICAgIFwiVFNCb29sZWFuS2V5d29yZFwiLFxuICAgIFwiVFNOZXZlcktleXdvcmRcIixcbiAgICBcIlRTTnVsbEtleXdvcmRcIixcbiAgICBcIlRTTnVtYmVyS2V5d29yZFwiLFxuICAgIFwiVFNPYmplY3RLZXl3b3JkXCIsXG4gICAgXCJUU1N0cmluZ0tleXdvcmRcIixcbiAgICBcIlRTU3ltYm9sS2V5d29yZFwiLFxuICAgIFwiVFNVbmRlZmluZWRLZXl3b3JkXCIsXG4gICAgXCJUU1Vua25vd25LZXl3b3JkXCIsXG4gICAgXCJUU1ZvaWRLZXl3b3JkXCIsXG4gICAgXCJUU0ludHJpbnNpY0tleXdvcmRcIixcbiAgICBcIlRTVGhpc1R5cGVcIlxuICBdLmZvckVhY2goKGtleXdvcmRUeXBlKSA9PiB7XG4gICAgZGVmKGtleXdvcmRUeXBlKS5iYXNlcyhcIlRTVHlwZVwiKS5idWlsZCgpO1xuICB9KTtcbiAgZGVmKFwiVFNBcnJheVR5cGVcIikuYmFzZXMoXCJUU1R5cGVcIikuYnVpbGQoXCJlbGVtZW50VHlwZVwiKS5maWVsZChcImVsZW1lbnRUeXBlXCIsIGRlZihcIlRTVHlwZVwiKSk7XG4gIGRlZihcIlRTTGl0ZXJhbFR5cGVcIikuYmFzZXMoXCJUU1R5cGVcIikuYnVpbGQoXCJsaXRlcmFsXCIpLmZpZWxkKFwibGl0ZXJhbFwiLCBvcihcbiAgICBkZWYoXCJOdW1lcmljTGl0ZXJhbFwiKSxcbiAgICBkZWYoXCJTdHJpbmdMaXRlcmFsXCIpLFxuICAgIGRlZihcIkJvb2xlYW5MaXRlcmFsXCIpLFxuICAgIGRlZihcIlRlbXBsYXRlTGl0ZXJhbFwiKSxcbiAgICBkZWYoXCJVbmFyeUV4cHJlc3Npb25cIiksXG4gICAgZGVmKFwiQmlnSW50TGl0ZXJhbFwiKVxuICApKTtcbiAgZGVmKFwiVGVtcGxhdGVMaXRlcmFsXCIpLmZpZWxkKFwiZXhwcmVzc2lvbnNcIiwgb3IoXG4gICAgW2RlZihcIkV4cHJlc3Npb25cIildLFxuICAgIFtkZWYoXCJUU1R5cGVcIildXG4gICkpO1xuICBbXG4gICAgXCJUU1VuaW9uVHlwZVwiLFxuICAgIFwiVFNJbnRlcnNlY3Rpb25UeXBlXCJcbiAgXS5mb3JFYWNoKCh0eXBlTmFtZSkgPT4ge1xuICAgIGRlZih0eXBlTmFtZSkuYmFzZXMoXCJUU1R5cGVcIikuYnVpbGQoXCJ0eXBlc1wiKS5maWVsZChcInR5cGVzXCIsIFtkZWYoXCJUU1R5cGVcIildKTtcbiAgfSk7XG4gIGRlZihcIlRTQ29uZGl0aW9uYWxUeXBlXCIpLmJhc2VzKFwiVFNUeXBlXCIpLmJ1aWxkKFwiY2hlY2tUeXBlXCIsIFwiZXh0ZW5kc1R5cGVcIiwgXCJ0cnVlVHlwZVwiLCBcImZhbHNlVHlwZVwiKS5maWVsZChcImNoZWNrVHlwZVwiLCBkZWYoXCJUU1R5cGVcIikpLmZpZWxkKFwiZXh0ZW5kc1R5cGVcIiwgZGVmKFwiVFNUeXBlXCIpKS5maWVsZChcInRydWVUeXBlXCIsIGRlZihcIlRTVHlwZVwiKSkuZmllbGQoXCJmYWxzZVR5cGVcIiwgZGVmKFwiVFNUeXBlXCIpKTtcbiAgZGVmKFwiVFNJbmZlclR5cGVcIikuYmFzZXMoXCJUU1R5cGVcIikuYnVpbGQoXCJ0eXBlUGFyYW1ldGVyXCIpLmZpZWxkKFwidHlwZVBhcmFtZXRlclwiLCBkZWYoXCJUU1R5cGVQYXJhbWV0ZXJcIikpO1xuICBkZWYoXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCIpLmJhc2VzKFwiVFNUeXBlXCIpLmJ1aWxkKFwidHlwZUFubm90YXRpb25cIikuZmllbGQoXCJ0eXBlQW5ub3RhdGlvblwiLCBkZWYoXCJUU1R5cGVcIikpO1xuICB2YXIgUGFyYW1ldGVyc1R5cGUgPSBbb3IoXG4gICAgZGVmKFwiSWRlbnRpZmllclwiKSxcbiAgICBkZWYoXCJSZXN0RWxlbWVudFwiKSxcbiAgICBkZWYoXCJBcnJheVBhdHRlcm5cIiksXG4gICAgZGVmKFwiT2JqZWN0UGF0dGVyblwiKVxuICApXTtcbiAgW1xuICAgIFwiVFNGdW5jdGlvblR5cGVcIixcbiAgICBcIlRTQ29uc3RydWN0b3JUeXBlXCJcbiAgXS5mb3JFYWNoKCh0eXBlTmFtZSkgPT4ge1xuICAgIGRlZih0eXBlTmFtZSkuYmFzZXMoXG4gICAgICBcIlRTVHlwZVwiLFxuICAgICAgXCJUU0hhc09wdGlvbmFsVHlwZVBhcmFtZXRlcnNcIixcbiAgICAgIFwiVFNIYXNPcHRpb25hbFR5cGVBbm5vdGF0aW9uXCJcbiAgICApLmJ1aWxkKFwicGFyYW1ldGVyc1wiKS5maWVsZChcInBhcmFtZXRlcnNcIiwgUGFyYW1ldGVyc1R5cGUpO1xuICB9KTtcbiAgZGVmKFwiVFNEZWNsYXJlRnVuY3Rpb25cIikuYmFzZXMoXCJEZWNsYXJhdGlvblwiLCBcIlRTSGFzT3B0aW9uYWxUeXBlUGFyYW1ldGVyc1wiKS5idWlsZChcImlkXCIsIFwicGFyYW1zXCIsIFwicmV0dXJuVHlwZVwiKS5maWVsZChcImRlY2xhcmVcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJhc3luY1wiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcImdlbmVyYXRvclwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcImlkXCIsIG9yKGRlZihcIklkZW50aWZpZXJcIiksIG51bGwpLCBkZWZhdWx0c1tcIm51bGxcIl0pLmZpZWxkKFwicGFyYW1zXCIsIFtkZWYoXCJQYXR0ZXJuXCIpXSkuZmllbGQoXG4gICAgXCJyZXR1cm5UeXBlXCIsXG4gICAgb3IoXG4gICAgICBkZWYoXCJUU1R5cGVBbm5vdGF0aW9uXCIpLFxuICAgICAgZGVmKFwiTm9vcFwiKSxcbiAgICAgIC8vIFN0aWxsIHVzZWQ/XG4gICAgICBudWxsXG4gICAgKSxcbiAgICBkZWZhdWx0c1tcIm51bGxcIl1cbiAgKTtcbiAgZGVmKFwiVFNEZWNsYXJlTWV0aG9kXCIpLmJhc2VzKFwiRGVjbGFyYXRpb25cIiwgXCJUU0hhc09wdGlvbmFsVHlwZVBhcmFtZXRlcnNcIikuYnVpbGQoXCJrZXlcIiwgXCJwYXJhbXNcIiwgXCJyZXR1cm5UeXBlXCIpLmZpZWxkKFwiYXN5bmNcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJnZW5lcmF0b3JcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJwYXJhbXNcIiwgW2RlZihcIlBhdHRlcm5cIildKS5maWVsZChcImFic3RyYWN0XCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pLmZpZWxkKFxuICAgIFwiYWNjZXNzaWJpbGl0eVwiLFxuICAgIG9yKFwicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCB2b2lkIDApLFxuICAgIGRlZmF1bHRzW1widW5kZWZpbmVkXCJdXG4gICkuZmllbGQoXCJzdGF0aWNcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJjb21wdXRlZFwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcIm9wdGlvbmFsXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pLmZpZWxkKFwia2V5XCIsIG9yKFxuICAgIGRlZihcIklkZW50aWZpZXJcIiksXG4gICAgZGVmKFwiU3RyaW5nTGl0ZXJhbFwiKSxcbiAgICBkZWYoXCJOdW1lcmljTGl0ZXJhbFwiKSxcbiAgICAvLyBPbmx5IGFsbG93ZWQgaWYgLmNvbXB1dGVkIGlzIHRydWUuXG4gICAgZGVmKFwiRXhwcmVzc2lvblwiKVxuICApKS5maWVsZChcbiAgICBcImtpbmRcIixcbiAgICBvcihcImdldFwiLCBcInNldFwiLCBcIm1ldGhvZFwiLCBcImNvbnN0cnVjdG9yXCIpLFxuICAgIGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gXCJtZXRob2RcIjtcbiAgICB9XG4gICkuZmllbGQoXG4gICAgXCJhY2Nlc3NcIixcbiAgICAvLyBOb3QgXCJhY2Nlc3NpYmlsaXR5XCI/XG4gICAgb3IoXCJwdWJsaWNcIiwgXCJwcml2YXRlXCIsIFwicHJvdGVjdGVkXCIsIHZvaWQgMCksXG4gICAgZGVmYXVsdHNbXCJ1bmRlZmluZWRcIl1cbiAgKS5maWVsZChcbiAgICBcImRlY29yYXRvcnNcIixcbiAgICBvcihbZGVmKFwiRGVjb3JhdG9yXCIpXSwgbnVsbCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICkuZmllbGQoXG4gICAgXCJyZXR1cm5UeXBlXCIsXG4gICAgb3IoXG4gICAgICBkZWYoXCJUU1R5cGVBbm5vdGF0aW9uXCIpLFxuICAgICAgZGVmKFwiTm9vcFwiKSxcbiAgICAgIC8vIFN0aWxsIHVzZWQ/XG4gICAgICBudWxsXG4gICAgKSxcbiAgICBkZWZhdWx0c1tcIm51bGxcIl1cbiAgKTtcbiAgZGVmKFwiVFNNYXBwZWRUeXBlXCIpLmJhc2VzKFwiVFNUeXBlXCIpLmJ1aWxkKFwidHlwZVBhcmFtZXRlclwiLCBcInR5cGVBbm5vdGF0aW9uXCIpLmZpZWxkKFwicmVhZG9ubHlcIiwgb3IoQm9vbGVhbiwgXCIrXCIsIFwiLVwiKSwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJ0eXBlUGFyYW1ldGVyXCIsIGRlZihcIlRTVHlwZVBhcmFtZXRlclwiKSkuZmllbGQoXCJvcHRpb25hbFwiLCBvcihCb29sZWFuLCBcIitcIiwgXCItXCIpLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcbiAgICBcInR5cGVBbm5vdGF0aW9uXCIsXG4gICAgb3IoZGVmKFwiVFNUeXBlXCIpLCBudWxsKSxcbiAgICBkZWZhdWx0c1tcIm51bGxcIl1cbiAgKTtcbiAgZGVmKFwiVFNUdXBsZVR5cGVcIikuYmFzZXMoXCJUU1R5cGVcIikuYnVpbGQoXCJlbGVtZW50VHlwZXNcIikuZmllbGQoXCJlbGVtZW50VHlwZXNcIiwgW29yKFxuICAgIGRlZihcIlRTVHlwZVwiKSxcbiAgICBkZWYoXCJUU05hbWVkVHVwbGVNZW1iZXJcIilcbiAgKV0pO1xuICBkZWYoXCJUU05hbWVkVHVwbGVNZW1iZXJcIikuYmFzZXMoXCJUU1R5cGVcIikuYnVpbGQoXCJsYWJlbFwiLCBcImVsZW1lbnRUeXBlXCIsIFwib3B0aW9uYWxcIikuZmllbGQoXCJsYWJlbFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKS5maWVsZChcIm9wdGlvbmFsXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pLmZpZWxkKFwiZWxlbWVudFR5cGVcIiwgZGVmKFwiVFNUeXBlXCIpKTtcbiAgZGVmKFwiVFNSZXN0VHlwZVwiKS5iYXNlcyhcIlRTVHlwZVwiKS5idWlsZChcInR5cGVBbm5vdGF0aW9uXCIpLmZpZWxkKFwidHlwZUFubm90YXRpb25cIiwgZGVmKFwiVFNUeXBlXCIpKTtcbiAgZGVmKFwiVFNPcHRpb25hbFR5cGVcIikuYmFzZXMoXCJUU1R5cGVcIikuYnVpbGQoXCJ0eXBlQW5ub3RhdGlvblwiKS5maWVsZChcInR5cGVBbm5vdGF0aW9uXCIsIGRlZihcIlRTVHlwZVwiKSk7XG4gIGRlZihcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIikuYmFzZXMoXCJUU1R5cGVcIikuYnVpbGQoXCJvYmplY3RUeXBlXCIsIFwiaW5kZXhUeXBlXCIpLmZpZWxkKFwib2JqZWN0VHlwZVwiLCBkZWYoXCJUU1R5cGVcIikpLmZpZWxkKFwiaW5kZXhUeXBlXCIsIGRlZihcIlRTVHlwZVwiKSk7XG4gIGRlZihcIlRTVHlwZU9wZXJhdG9yXCIpLmJhc2VzKFwiVFNUeXBlXCIpLmJ1aWxkKFwib3BlcmF0b3JcIikuZmllbGQoXCJvcGVyYXRvclwiLCBTdHJpbmcpLmZpZWxkKFwidHlwZUFubm90YXRpb25cIiwgZGVmKFwiVFNUeXBlXCIpKTtcbiAgZGVmKFwiVFNUeXBlQW5ub3RhdGlvblwiKS5iYXNlcyhcIk5vZGVcIikuYnVpbGQoXCJ0eXBlQW5ub3RhdGlvblwiKS5maWVsZChcbiAgICBcInR5cGVBbm5vdGF0aW9uXCIsXG4gICAgb3IoXG4gICAgICBkZWYoXCJUU1R5cGVcIiksXG4gICAgICBkZWYoXCJUU1R5cGVBbm5vdGF0aW9uXCIpXG4gICAgKVxuICApO1xuICBkZWYoXCJUU0luZGV4U2lnbmF0dXJlXCIpLmJhc2VzKFwiRGVjbGFyYXRpb25cIiwgXCJUU0hhc09wdGlvbmFsVHlwZUFubm90YXRpb25cIikuYnVpbGQoXCJwYXJhbWV0ZXJzXCIsIFwidHlwZUFubm90YXRpb25cIikuZmllbGQoXCJwYXJhbWV0ZXJzXCIsIFtkZWYoXCJJZGVudGlmaWVyXCIpXSkuZmllbGQoXCJyZWFkb25seVwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKTtcbiAgZGVmKFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIsIFwiVFNIYXNPcHRpb25hbFR5cGVBbm5vdGF0aW9uXCIpLmJ1aWxkKFwia2V5XCIsIFwidHlwZUFubm90YXRpb25cIiwgXCJvcHRpb25hbFwiKS5maWVsZChcImtleVwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcImNvbXB1dGVkXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pLmZpZWxkKFwicmVhZG9ubHlcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJvcHRpb25hbFwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcbiAgICBcImluaXRpYWxpemVyXCIsXG4gICAgb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgbnVsbCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICk7XG4gIGRlZihcIlRTTWV0aG9kU2lnbmF0dXJlXCIpLmJhc2VzKFxuICAgIFwiRGVjbGFyYXRpb25cIixcbiAgICBcIlRTSGFzT3B0aW9uYWxUeXBlUGFyYW1ldGVyc1wiLFxuICAgIFwiVFNIYXNPcHRpb25hbFR5cGVBbm5vdGF0aW9uXCJcbiAgKS5idWlsZChcImtleVwiLCBcInBhcmFtZXRlcnNcIiwgXCJ0eXBlQW5ub3RhdGlvblwiKS5maWVsZChcImtleVwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcImNvbXB1dGVkXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pLmZpZWxkKFwib3B0aW9uYWxcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJwYXJhbWV0ZXJzXCIsIFBhcmFtZXRlcnNUeXBlKTtcbiAgZGVmKFwiVFNUeXBlUHJlZGljYXRlXCIpLmJhc2VzKFwiVFNUeXBlQW5ub3RhdGlvblwiLCBcIlRTVHlwZVwiKS5idWlsZChcInBhcmFtZXRlck5hbWVcIiwgXCJ0eXBlQW5ub3RhdGlvblwiLCBcImFzc2VydHNcIikuZmllbGQoXG4gICAgXCJwYXJhbWV0ZXJOYW1lXCIsXG4gICAgb3IoXG4gICAgICBkZWYoXCJJZGVudGlmaWVyXCIpLFxuICAgICAgZGVmKFwiVFNUaGlzVHlwZVwiKVxuICAgIClcbiAgKS5maWVsZChcbiAgICBcInR5cGVBbm5vdGF0aW9uXCIsXG4gICAgb3IoZGVmKFwiVFNUeXBlQW5ub3RhdGlvblwiKSwgbnVsbCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICkuZmllbGQoXCJhc3NlcnRzXCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pO1xuICBbXG4gICAgXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiLFxuICAgIFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiXG4gIF0uZm9yRWFjaCgodHlwZU5hbWUpID0+IHtcbiAgICBkZWYodHlwZU5hbWUpLmJhc2VzKFxuICAgICAgXCJEZWNsYXJhdGlvblwiLFxuICAgICAgXCJUU0hhc09wdGlvbmFsVHlwZVBhcmFtZXRlcnNcIixcbiAgICAgIFwiVFNIYXNPcHRpb25hbFR5cGVBbm5vdGF0aW9uXCJcbiAgICApLmJ1aWxkKFwicGFyYW1ldGVyc1wiLCBcInR5cGVBbm5vdGF0aW9uXCIpLmZpZWxkKFwicGFyYW1ldGVyc1wiLCBQYXJhbWV0ZXJzVHlwZSk7XG4gIH0pO1xuICBkZWYoXCJUU0VudW1NZW1iZXJcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwiaWRcIiwgXCJpbml0aWFsaXplclwiKS5maWVsZChcImlkXCIsIG9yKGRlZihcIklkZW50aWZpZXJcIiksIFN0cmluZ0xpdGVyYWwpKS5maWVsZChcbiAgICBcImluaXRpYWxpemVyXCIsXG4gICAgb3IoZGVmKFwiRXhwcmVzc2lvblwiKSwgbnVsbCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICk7XG4gIGRlZihcIlRTVHlwZVF1ZXJ5XCIpLmJhc2VzKFwiVFNUeXBlXCIpLmJ1aWxkKFwiZXhwck5hbWVcIikuZmllbGQoXCJleHByTmFtZVwiLCBvcihUU0VudGl0eU5hbWUsIGRlZihcIlRTSW1wb3J0VHlwZVwiKSkpO1xuICB2YXIgVFNUeXBlTWVtYmVyID0gb3IoXG4gICAgZGVmKFwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIiksXG4gICAgZGVmKFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiKSxcbiAgICBkZWYoXCJUU0luZGV4U2lnbmF0dXJlXCIpLFxuICAgIGRlZihcIlRTTWV0aG9kU2lnbmF0dXJlXCIpLFxuICAgIGRlZihcIlRTUHJvcGVydHlTaWduYXR1cmVcIilcbiAgKTtcbiAgZGVmKFwiVFNUeXBlTGl0ZXJhbFwiKS5iYXNlcyhcIlRTVHlwZVwiKS5idWlsZChcIm1lbWJlcnNcIikuZmllbGQoXCJtZW1iZXJzXCIsIFtUU1R5cGVNZW1iZXJdKTtcbiAgZGVmKFwiVFNUeXBlUGFyYW1ldGVyXCIpLmJhc2VzKFwiSWRlbnRpZmllclwiKS5idWlsZChcIm5hbWVcIiwgXCJjb25zdHJhaW50XCIsIFwiZGVmYXVsdFwiKS5maWVsZChcIm5hbWVcIiwgb3IoZGVmKFwiSWRlbnRpZmllclwiKSwgU3RyaW5nKSkuZmllbGQoXCJjb25zdHJhaW50XCIsIG9yKGRlZihcIlRTVHlwZVwiKSwgdm9pZCAwKSwgZGVmYXVsdHNbXCJ1bmRlZmluZWRcIl0pLmZpZWxkKFwiZGVmYXVsdFwiLCBvcihkZWYoXCJUU1R5cGVcIiksIHZvaWQgMCksIGRlZmF1bHRzW1widW5kZWZpbmVkXCJdKTtcbiAgZGVmKFwiVFNUeXBlQXNzZXJ0aW9uXCIpLmJhc2VzKFwiRXhwcmVzc2lvblwiLCBcIlBhdHRlcm5cIikuYnVpbGQoXCJ0eXBlQW5ub3RhdGlvblwiLCBcImV4cHJlc3Npb25cIikuZmllbGQoXCJ0eXBlQW5ub3RhdGlvblwiLCBkZWYoXCJUU1R5cGVcIikpLmZpZWxkKFwiZXhwcmVzc2lvblwiLCBkZWYoXCJFeHByZXNzaW9uXCIpKS5maWVsZChcbiAgICBcImV4dHJhXCIsXG4gICAgb3IoeyBwYXJlbnRoZXNpemVkOiBCb29sZWFuIH0sIG51bGwpLFxuICAgIGRlZmF1bHRzW1wibnVsbFwiXVxuICApO1xuICBkZWYoXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwicGFyYW1zXCIpLmZpZWxkKFwicGFyYW1zXCIsIFtkZWYoXCJUU1R5cGVQYXJhbWV0ZXJcIildKTtcbiAgZGVmKFwiVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvblwiKS5iYXNlcyhcIkV4cHJlc3Npb25cIiwgXCJUU0hhc09wdGlvbmFsVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIikuYnVpbGQoXCJleHByZXNzaW9uXCIsIFwidHlwZVBhcmFtZXRlcnNcIikuZmllbGQoXCJleHByZXNzaW9uXCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuICBkZWYoXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpLmJhc2VzKFwiTm9kZVwiKS5idWlsZChcInBhcmFtc1wiKS5maWVsZChcInBhcmFtc1wiLCBbZGVmKFwiVFNUeXBlXCIpXSk7XG4gIGRlZihcIlRTRW51bURlY2xhcmF0aW9uXCIpLmJhc2VzKFwiRGVjbGFyYXRpb25cIikuYnVpbGQoXCJpZFwiLCBcIm1lbWJlcnNcIikuZmllbGQoXCJpZFwiLCBkZWYoXCJJZGVudGlmaWVyXCIpKS5maWVsZChcImNvbnN0XCIsIEJvb2xlYW4sIGRlZmF1bHRzW1wiZmFsc2VcIl0pLmZpZWxkKFwiZGVjbGFyZVwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcIm1lbWJlcnNcIiwgW2RlZihcIlRTRW51bU1lbWJlclwiKV0pLmZpZWxkKFxuICAgIFwiaW5pdGlhbGl6ZXJcIixcbiAgICBvcihkZWYoXCJFeHByZXNzaW9uXCIpLCBudWxsKSxcbiAgICBkZWZhdWx0c1tcIm51bGxcIl1cbiAgKTtcbiAgZGVmKFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIsIFwiVFNIYXNPcHRpb25hbFR5cGVQYXJhbWV0ZXJzXCIpLmJ1aWxkKFwiaWRcIiwgXCJ0eXBlQW5ub3RhdGlvblwiKS5maWVsZChcImlkXCIsIGRlZihcIklkZW50aWZpZXJcIikpLmZpZWxkKFwiZGVjbGFyZVwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcInR5cGVBbm5vdGF0aW9uXCIsIGRlZihcIlRTVHlwZVwiKSk7XG4gIGRlZihcIlRTTW9kdWxlQmxvY2tcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwiYm9keVwiKS5maWVsZChcImJvZHlcIiwgW2RlZihcIlN0YXRlbWVudFwiKV0pO1xuICBkZWYoXCJUU01vZHVsZURlY2xhcmF0aW9uXCIpLmJhc2VzKFwiRGVjbGFyYXRpb25cIikuYnVpbGQoXCJpZFwiLCBcImJvZHlcIikuZmllbGQoXCJpZFwiLCBvcihTdHJpbmdMaXRlcmFsLCBUU0VudGl0eU5hbWUpKS5maWVsZChcImRlY2xhcmVcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXCJnbG9iYWxcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXG4gICAgXCJib2R5XCIsXG4gICAgb3IoXG4gICAgICBkZWYoXCJUU01vZHVsZUJsb2NrXCIpLFxuICAgICAgZGVmKFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKSxcbiAgICAgIG51bGxcbiAgICApLFxuICAgIGRlZmF1bHRzW1wibnVsbFwiXVxuICApO1xuICBkZWYoXCJUU0ltcG9ydFR5cGVcIikuYmFzZXMoXCJUU1R5cGVcIiwgXCJUU0hhc09wdGlvbmFsVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIikuYnVpbGQoXCJhcmd1bWVudFwiLCBcInF1YWxpZmllclwiLCBcInR5cGVQYXJhbWV0ZXJzXCIpLmZpZWxkKFwiYXJndW1lbnRcIiwgU3RyaW5nTGl0ZXJhbCkuZmllbGQoXCJxdWFsaWZpZXJcIiwgb3IoVFNFbnRpdHlOYW1lLCB2b2lkIDApLCBkZWZhdWx0c1tcInVuZGVmaW5lZFwiXSk7XG4gIGRlZihcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIikuYmFzZXMoXCJEZWNsYXJhdGlvblwiKS5idWlsZChcImlkXCIsIFwibW9kdWxlUmVmZXJlbmNlXCIpLmZpZWxkKFwiaWRcIiwgZGVmKFwiSWRlbnRpZmllclwiKSkuZmllbGQoXCJpc0V4cG9ydFwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcbiAgICBcIm1vZHVsZVJlZmVyZW5jZVwiLFxuICAgIG9yKFxuICAgICAgVFNFbnRpdHlOYW1lLFxuICAgICAgZGVmKFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiKVxuICAgIClcbiAgKTtcbiAgZGVmKFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIpLmJ1aWxkKFwiZXhwcmVzc2lvblwiKS5maWVsZChcImV4cHJlc3Npb25cIiwgU3RyaW5nTGl0ZXJhbCk7XG4gIGRlZihcIlRTRXhwb3J0QXNzaWdubWVudFwiKS5iYXNlcyhcIlN0YXRlbWVudFwiKS5idWlsZChcImV4cHJlc3Npb25cIikuZmllbGQoXCJleHByZXNzaW9uXCIsIGRlZihcIkV4cHJlc3Npb25cIikpO1xuICBkZWYoXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIpLmJhc2VzKFwiRGVjbGFyYXRpb25cIikuYnVpbGQoXCJpZFwiKS5maWVsZChcImlkXCIsIGRlZihcIklkZW50aWZpZXJcIikpO1xuICBkZWYoXCJUU0ludGVyZmFjZUJvZHlcIikuYmFzZXMoXCJOb2RlXCIpLmJ1aWxkKFwiYm9keVwiKS5maWVsZChcImJvZHlcIiwgW1RTVHlwZU1lbWJlcl0pO1xuICBkZWYoXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiKS5iYXNlcyhcIlRTVHlwZVwiLCBcIlRTSGFzT3B0aW9uYWxUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiKS5idWlsZChcImV4cHJlc3Npb25cIiwgXCJ0eXBlUGFyYW1ldGVyc1wiKS5maWVsZChcImV4cHJlc3Npb25cIiwgVFNFbnRpdHlOYW1lKTtcbiAgZGVmKFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIsIFwiVFNIYXNPcHRpb25hbFR5cGVQYXJhbWV0ZXJzXCIpLmJ1aWxkKFwiaWRcIiwgXCJib2R5XCIpLmZpZWxkKFwiaWRcIiwgVFNFbnRpdHlOYW1lKS5maWVsZChcImRlY2xhcmVcIiwgQm9vbGVhbiwgZGVmYXVsdHNbXCJmYWxzZVwiXSkuZmllbGQoXG4gICAgXCJleHRlbmRzXCIsXG4gICAgb3IoW2RlZihcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIpXSwgbnVsbCksXG4gICAgZGVmYXVsdHNbXCJudWxsXCJdXG4gICkuZmllbGQoXCJib2R5XCIsIGRlZihcIlRTSW50ZXJmYWNlQm9keVwiKSk7XG4gIGRlZihcIlRTUGFyYW1ldGVyUHJvcGVydHlcIikuYmFzZXMoXCJQYXR0ZXJuXCIpLmJ1aWxkKFwicGFyYW1ldGVyXCIpLmZpZWxkKFxuICAgIFwiYWNjZXNzaWJpbGl0eVwiLFxuICAgIG9yKFwicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCB2b2lkIDApLFxuICAgIGRlZmF1bHRzW1widW5kZWZpbmVkXCJdXG4gICkuZmllbGQoXCJyZWFkb25seVwiLCBCb29sZWFuLCBkZWZhdWx0c1tcImZhbHNlXCJdKS5maWVsZChcInBhcmFtZXRlclwiLCBvcihcbiAgICBkZWYoXCJJZGVudGlmaWVyXCIpLFxuICAgIGRlZihcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpXG4gICkpO1xuICBkZWYoXCJDbGFzc1Byb3BlcnR5XCIpLmZpZWxkKFxuICAgIFwiYWNjZXNzXCIsXG4gICAgLy8gTm90IFwiYWNjZXNzaWJpbGl0eVwiP1xuICAgIG9yKFwicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCB2b2lkIDApLFxuICAgIGRlZmF1bHRzW1widW5kZWZpbmVkXCJdXG4gICk7XG4gIGRlZihcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiKS5iYXNlcyhcIkRlY2xhcmF0aW9uXCIsIFwiVFNIYXNPcHRpb25hbFR5cGVBbm5vdGF0aW9uXCIpO1xuICBkZWYoXCJDbGFzc0JvZHlcIikuZmllbGQoXCJib2R5XCIsIFtvcihcbiAgICBkZWYoXCJNZXRob2REZWZpbml0aW9uXCIpLFxuICAgIGRlZihcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSxcbiAgICBkZWYoXCJDbGFzc1Byb3BlcnR5RGVmaW5pdGlvblwiKSxcbiAgICBkZWYoXCJDbGFzc1Byb3BlcnR5XCIpLFxuICAgIGRlZihcIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCIpLFxuICAgIGRlZihcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiKSxcbiAgICBkZWYoXCJDbGFzc01ldGhvZFwiKSxcbiAgICBkZWYoXCJDbGFzc1ByaXZhdGVNZXRob2RcIiksXG4gICAgZGVmKFwiU3RhdGljQmxvY2tcIiksXG4gICAgLy8gSnVzdCBuZWVkIHRvIGFkZCB0aGVzZSB0eXBlczpcbiAgICBkZWYoXCJUU0RlY2xhcmVNZXRob2RcIiksXG4gICAgVFNUeXBlTWVtYmVyXG4gICldKTtcbn1cbm1heWJlU2V0TW9kdWxlRXhwb3J0cygoKSA9PiBtb2R1bGUpO1xuXG52YXIgbmFtZWRUeXBlcyQxO1xuKChuYW1lZFR5cGVzMikgPT4ge1xufSkobmFtZWRUeXBlcyQxIHx8IChuYW1lZFR5cGVzJDEgPSB7fSkpO1xuXG5jb25zdCB7XG4gIGFzdE5vZGVzQXJlRXF1aXZhbGVudCxcbiAgYnVpbGRlcnM6IGJ1aWxkZXJzJDEsXG4gIGJ1aWx0SW5UeXBlcyxcbiAgZGVmaW5lTWV0aG9kLFxuICBlYWNoRmllbGQsXG4gIGZpbmFsaXplLFxuICBnZXRCdWlsZGVyTmFtZSxcbiAgZ2V0RmllbGROYW1lcyxcbiAgZ2V0RmllbGRWYWx1ZSxcbiAgZ2V0U3VwZXJ0eXBlTmFtZXMsXG4gIG5hbWVkVHlwZXM6IG4kMyxcbiAgTm9kZVBhdGgsXG4gIFBhdGgsXG4gIFBhdGhWaXNpdG9yLFxuICBzb21lRmllbGQsXG4gIFR5cGUsXG4gIHVzZSxcbiAgdmlzaXRcbn0gPSBmb3JrKFtcbiAgLy8gRmVlbCBmcmVlIHRvIGFkZCB0byBvciByZW1vdmUgZnJvbSB0aGlzIGxpc3Qgb2YgZXh0ZW5zaW9uIG1vZHVsZXMgdG9cbiAgLy8gY29uZmlndXJlIHRoZSBwcmVjaXNlIHR5cGUgaGllcmFyY2h5IHRoYXQgeW91IG5lZWQuXG4gIGVzUHJvcG9zYWxzRGVmLFxuICBqc3hEZWYsXG4gIGZsb3dEZWYsXG4gIGVzcHJpbWFEZWYsXG4gIGJhYmVsRGVmLFxuICB0eXBlc2NyaXB0RGVmXG5dKTtcbk9iamVjdC5hc3NpZ24obmFtZWRUeXBlcyQxLCBuJDMpO1xuXG5jb25zdCBuJDIgPSBuYW1lZFR5cGVzJDE7XG5jb25zdCBTb3VyY2VNYXBDb25zdW1lciA9IHNvdXJjZU1hcC5Tb3VyY2VNYXBDb25zdW1lcjtcbmNvbnN0IFNvdXJjZU1hcEdlbmVyYXRvciA9IHNvdXJjZU1hcC5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5jb25zdCBoYXNPd24kMiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBnZXRMaW5lVGVybWluYXRvcigpIHtcbiAgcmV0dXJuIFwiXFxuXCI7XG59XG5mdW5jdGlvbiBnZXRPcHRpb24ob3B0aW9ucywga2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgaWYgKG9wdGlvbnMgJiYgaGFzT3duJDIuY2FsbChvcHRpb25zLCBrZXkpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnNba2V5XTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0VW5pb25PZktleXMoLi4uYXJncykge1xuICBjb25zdCByZXN1bHQgPSB7fTtcbiAgY29uc3QgYXJnYyA9IGFyZ3MubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ2M7ICsraSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhcmdzW2ldKTtcbiAgICBjb25zdCBrZXlDb3VudCA9IGtleXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5Q291bnQ7ICsraikge1xuICAgICAgcmVzdWx0W2tleXNbal1dID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVQb3MocG9zMSwgcG9zMikge1xuICByZXR1cm4gcG9zMS5saW5lIC0gcG9zMi5saW5lIHx8IHBvczEuY29sdW1uIC0gcG9zMi5jb2x1bW47XG59XG5mdW5jdGlvbiBjb3B5UG9zKHBvcykge1xuICByZXR1cm4ge1xuICAgIGxpbmU6IHBvcy5saW5lLFxuICAgIGNvbHVtbjogcG9zLmNvbHVtblxuICB9O1xufVxuZnVuY3Rpb24gY29tcG9zZVNvdXJjZU1hcHMoZm9ybWVyTWFwLCBsYXR0ZXJNYXApIHtcbiAgaWYgKGZvcm1lck1hcCkge1xuICAgIGlmICghbGF0dGVyTWFwKSB7XG4gICAgICByZXR1cm4gZm9ybWVyTWFwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0dGVyTWFwIHx8IG51bGw7XG4gIH1cbiAgY29uc3Qgc21jRm9ybWVyID0gbmV3IFNvdXJjZU1hcENvbnN1bWVyKGZvcm1lck1hcCk7XG4gIGNvbnN0IHNtY0xhdHRlciA9IG5ldyBTb3VyY2VNYXBDb25zdW1lcihsYXR0ZXJNYXApO1xuICBjb25zdCBzbWcgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKHtcbiAgICBmaWxlOiBsYXR0ZXJNYXAuZmlsZSxcbiAgICBzb3VyY2VSb290OiBsYXR0ZXJNYXAuc291cmNlUm9vdFxuICB9KTtcbiAgY29uc3Qgc291cmNlc1RvQ29udGVudHMgPSB7fTtcbiAgc21jTGF0dGVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uKG1hcHBpbmcpIHtcbiAgICBjb25zdCBvcmlnUG9zID0gc21jRm9ybWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICBjb2x1bW46IG1hcHBpbmcub3JpZ2luYWxDb2x1bW5cbiAgICB9KTtcbiAgICBjb25zdCBzb3VyY2VOYW1lID0gb3JpZ1Bvcy5zb3VyY2U7XG4gICAgaWYgKHNvdXJjZU5hbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc21nLmFkZE1hcHBpbmcoe1xuICAgICAgc291cmNlOiBzb3VyY2VOYW1lLFxuICAgICAgb3JpZ2luYWw6IGNvcHlQb3Mob3JpZ1BvcyksXG4gICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgbGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lLFxuICAgICAgICBjb2x1bW46IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uXG4gICAgICB9LFxuICAgICAgbmFtZTogbWFwcGluZy5uYW1lXG4gICAgfSk7XG4gICAgY29uc3Qgc291cmNlQ29udGVudCA9IHNtY0Zvcm1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZU5hbWUpO1xuICAgIGlmIChzb3VyY2VDb250ZW50ICYmICFoYXNPd24kMi5jYWxsKHNvdXJjZXNUb0NvbnRlbnRzLCBzb3VyY2VOYW1lKSkge1xuICAgICAgc291cmNlc1RvQ29udGVudHNbc291cmNlTmFtZV0gPSBzb3VyY2VDb250ZW50O1xuICAgICAgc21nLnNldFNvdXJjZUNvbnRlbnQoc291cmNlTmFtZSwgc291cmNlQ29udGVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNtZy50b0pTT04oKTtcbn1cbmZ1bmN0aW9uIGdldFRydWVMb2Mobm9kZSwgbGluZXMpIHtcbiAgaWYgKCFub2RlLmxvYykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBzdGFydDogbm9kZS5sb2Muc3RhcnQsXG4gICAgZW5kOiBub2RlLmxvYy5lbmRcbiAgfTtcbiAgZnVuY3Rpb24gaW5jbHVkZShub2RlMikge1xuICAgIGV4cGFuZExvYyhyZXN1bHQsIG5vZGUyLmxvYyk7XG4gIH1cbiAgaWYgKG5vZGUuZGVjbGFyYXRpb24gJiYgbm9kZS5kZWNsYXJhdGlvbi5kZWNvcmF0b3JzICYmIGlzRXhwb3J0RGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9uLmRlY29yYXRvcnMuZm9yRWFjaChpbmNsdWRlKTtcbiAgfVxuICBpZiAoY29tcGFyZVBvcyhyZXN1bHQuc3RhcnQsIHJlc3VsdC5lbmQpIDwgMCkge1xuICAgIHJlc3VsdC5zdGFydCA9IGNvcHlQb3MocmVzdWx0LnN0YXJ0KTtcbiAgICBsaW5lcy5za2lwU3BhY2VzKHJlc3VsdC5zdGFydCwgZmFsc2UsIHRydWUpO1xuICAgIGlmIChjb21wYXJlUG9zKHJlc3VsdC5zdGFydCwgcmVzdWx0LmVuZCkgPCAwKSB7XG4gICAgICByZXN1bHQuZW5kID0gY29weVBvcyhyZXN1bHQuZW5kKTtcbiAgICAgIGxpbmVzLnNraXBTcGFjZXMocmVzdWx0LmVuZCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIGlmIChub2RlLmNvbW1lbnRzKSB7XG4gICAgbm9kZS5jb21tZW50cy5mb3JFYWNoKGluY2x1ZGUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBleHBhbmRMb2MocGFyZW50TG9jLCBjaGlsZExvYykge1xuICBpZiAocGFyZW50TG9jICYmIGNoaWxkTG9jKSB7XG4gICAgaWYgKGNvbXBhcmVQb3MoY2hpbGRMb2Muc3RhcnQsIHBhcmVudExvYy5zdGFydCkgPCAwKSB7XG4gICAgICBwYXJlbnRMb2Muc3RhcnQgPSBjaGlsZExvYy5zdGFydDtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVQb3MocGFyZW50TG9jLmVuZCwgY2hpbGRMb2MuZW5kKSA8IDApIHtcbiAgICAgIHBhcmVudExvYy5lbmQgPSBjaGlsZExvYy5lbmQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaXhGYXVsdHlMb2NhdGlvbnMobm9kZSwgbGluZXMpIHtcbiAgY29uc3QgbG9jID0gbm9kZS5sb2M7XG4gIGlmIChsb2MpIHtcbiAgICBpZiAobG9jLnN0YXJ0LmxpbmUgPCAxKSB7XG4gICAgICBsb2Muc3RhcnQubGluZSA9IDE7XG4gICAgfVxuICAgIGlmIChsb2MuZW5kLmxpbmUgPCAxKSB7XG4gICAgICBsb2MuZW5kLmxpbmUgPSAxO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS50eXBlID09PSBcIkZpbGVcIikge1xuICAgIGxvYy5zdGFydCA9IGxpbmVzLmZpcnN0UG9zKCk7XG4gICAgbG9jLmVuZCA9IGxpbmVzLmxhc3RQb3MoKTtcbiAgfVxuICBmaXhGb3JMb29wSGVhZChub2RlLCBsaW5lcyk7XG4gIGZpeFRlbXBsYXRlTGl0ZXJhbChub2RlLCBsaW5lcyk7XG4gIGlmIChsb2MgJiYgbm9kZS5kZWNvcmF0b3JzKSB7XG4gICAgbm9kZS5kZWNvcmF0b3JzLmZvckVhY2goZnVuY3Rpb24oZGVjb3JhdG9yKSB7XG4gICAgICBleHBhbmRMb2MobG9jLCBkZWNvcmF0b3IubG9jKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChub2RlLmRlY2xhcmF0aW9uICYmIGlzRXhwb3J0RGVjbGFyYXRpb24obm9kZSkpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9uLmxvYyA9IG51bGw7XG4gICAgY29uc3QgZGVjb3JhdG9ycyA9IG5vZGUuZGVjbGFyYXRpb24uZGVjb3JhdG9ycztcbiAgICBpZiAoZGVjb3JhdG9ycykge1xuICAgICAgZGVjb3JhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uKGRlY29yYXRvcikge1xuICAgICAgICBleHBhbmRMb2MobG9jLCBkZWNvcmF0b3IubG9jKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChuJDIuTWV0aG9kRGVmaW5pdGlvbiAmJiBuJDIuTWV0aG9kRGVmaW5pdGlvbi5jaGVjayhub2RlKSB8fCBuJDIuUHJvcGVydHkuY2hlY2sobm9kZSkgJiYgKG5vZGUubWV0aG9kIHx8IG5vZGUuc2hvcnRoYW5kKSkge1xuICAgIG5vZGUudmFsdWUubG9jID0gbnVsbDtcbiAgICBpZiAobiQyLkZ1bmN0aW9uRXhwcmVzc2lvbi5jaGVjayhub2RlLnZhbHVlKSkge1xuICAgICAgbm9kZS52YWx1ZS5pZCA9IG51bGw7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJPYmplY3RUeXBlUHJvcGVydHlcIikge1xuICAgIGNvbnN0IGxvYzIgPSBub2RlLmxvYztcbiAgICBsZXQgZW5kID0gbG9jMiAmJiBsb2MyLmVuZDtcbiAgICBpZiAoZW5kKSB7XG4gICAgICBlbmQgPSBjb3B5UG9zKGVuZCk7XG4gICAgICBpZiAobGluZXMucHJldlBvcyhlbmQpICYmIGxpbmVzLmNoYXJBdChlbmQpID09PSBcIixcIikge1xuICAgICAgICBpZiAoZW5kID0gbGluZXMuc2tpcFNwYWNlcyhlbmQsIHRydWUsIHRydWUpKSB7XG4gICAgICAgICAgbG9jMi5lbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZpeEZvckxvb3BIZWFkKG5vZGUsIGxpbmVzKSB7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiRm9yU3RhdGVtZW50XCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZnVuY3Rpb24gZml4KGNoaWxkKSB7XG4gICAgY29uc3QgbG9jID0gY2hpbGQgJiYgY2hpbGQubG9jO1xuICAgIGNvbnN0IHN0YXJ0ID0gbG9jICYmIGxvYy5zdGFydDtcbiAgICBjb25zdCBlbmQgPSBsb2MgJiYgY29weVBvcyhsb2MuZW5kKTtcbiAgICB3aGlsZSAoc3RhcnQgJiYgZW5kICYmIGNvbXBhcmVQb3Moc3RhcnQsIGVuZCkgPCAwKSB7XG4gICAgICBsaW5lcy5wcmV2UG9zKGVuZCk7XG4gICAgICBpZiAobGluZXMuY2hhckF0KGVuZCkgPT09IFwiO1wiKSB7XG4gICAgICAgIGxvYy5lbmQubGluZSA9IGVuZC5saW5lO1xuICAgICAgICBsb2MuZW5kLmNvbHVtbiA9IGVuZC5jb2x1bW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZml4KG5vZGUuaW5pdCk7XG4gIGZpeChub2RlLnRlc3QpO1xuICBmaXgobm9kZS51cGRhdGUpO1xufVxuZnVuY3Rpb24gZml4VGVtcGxhdGVMaXRlcmFsKG5vZGUsIGxpbmVzKSB7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiVGVtcGxhdGVMaXRlcmFsXCIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG5vZGUucXVhc2lzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobm9kZS5sb2MpIHtcbiAgICBjb25zdCBhZnRlckxlZnRCYWNrVGlja1BvcyA9IGNvcHlQb3Mobm9kZS5sb2Muc3RhcnQpO1xuICAgIGNvbnN0IGZpcnN0UXVhc2kgPSBub2RlLnF1YXNpc1swXTtcbiAgICBpZiAoY29tcGFyZVBvcyhmaXJzdFF1YXNpLmxvYy5zdGFydCwgYWZ0ZXJMZWZ0QmFja1RpY2tQb3MpIDwgMCkge1xuICAgICAgZmlyc3RRdWFzaS5sb2Muc3RhcnQgPSBhZnRlckxlZnRCYWNrVGlja1BvcztcbiAgICB9XG4gICAgY29uc3QgcmlnaHRCYWNrVGlja1BvcyA9IGNvcHlQb3Mobm9kZS5sb2MuZW5kKTtcbiAgICBjb25zdCBsYXN0UXVhc2kgPSBub2RlLnF1YXNpc1tub2RlLnF1YXNpcy5sZW5ndGggLSAxXTtcbiAgICBpZiAoY29tcGFyZVBvcyhyaWdodEJhY2tUaWNrUG9zLCBsYXN0UXVhc2kubG9jLmVuZCkgPCAwKSB7XG4gICAgICBsYXN0UXVhc2kubG9jLmVuZCA9IHJpZ2h0QmFja1RpY2tQb3M7XG4gICAgfVxuICB9XG4gIG5vZGUuZXhwcmVzc2lvbnMuZm9yRWFjaChmdW5jdGlvbihleHByLCBpKSB7XG4gICAgY29uc3QgZG9sbGFyQ3VybHlQb3MgPSBsaW5lcy5za2lwU3BhY2VzKGV4cHIubG9jLnN0YXJ0LCB0cnVlLCBmYWxzZSk7XG4gICAgaWYgKGxpbmVzLnByZXZQb3MoZG9sbGFyQ3VybHlQb3MpICYmIGxpbmVzLmNoYXJBdChkb2xsYXJDdXJseVBvcykgPT09IFwie1wiICYmIGxpbmVzLnByZXZQb3MoZG9sbGFyQ3VybHlQb3MpICYmIGxpbmVzLmNoYXJBdChkb2xsYXJDdXJseVBvcykgPT09IFwiJFwiKSB7XG4gICAgICBjb25zdCBxdWFzaUJlZm9yZSA9IG5vZGUucXVhc2lzW2ldO1xuICAgICAgaWYgKGNvbXBhcmVQb3MoZG9sbGFyQ3VybHlQb3MsIHF1YXNpQmVmb3JlLmxvYy5lbmQpIDwgMCkge1xuICAgICAgICBxdWFzaUJlZm9yZS5sb2MuZW5kID0gZG9sbGFyQ3VybHlQb3M7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJpZ2h0Q3VybHlQb3MgPSBsaW5lcy5za2lwU3BhY2VzKGV4cHIubG9jLmVuZCwgZmFsc2UsIGZhbHNlKTtcbiAgICBpZiAobGluZXMuY2hhckF0KHJpZ2h0Q3VybHlQb3MpID09PSBcIn1cIikge1xuICAgICAgY29uc3QgcXVhc2lBZnRlciA9IG5vZGUucXVhc2lzW2kgKyAxXTtcbiAgICAgIGlmIChjb21wYXJlUG9zKHF1YXNpQWZ0ZXIubG9jLnN0YXJ0LCByaWdodEN1cmx5UG9zKSA8IDApIHtcbiAgICAgICAgcXVhc2lBZnRlci5sb2Muc3RhcnQgPSByaWdodEN1cmx5UG9zO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc0V4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgaWYgKG5vZGUpXG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJFeHBvcnREZWNsYXJhdGlvblwiOlxuICAgICAgY2FzZSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiOlxuICAgICAgY2FzZSBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIjpcbiAgICAgIGNhc2UgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6XG4gICAgICBjYXNlIFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRFeHBvcnREZWNsYXJhdGlvbihwYXRoKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcbiAgaWYgKHBhdGguZ2V0TmFtZSgpID09PSBcImRlY2xhcmF0aW9uXCIgJiYgaXNFeHBvcnREZWNsYXJhdGlvbihwYXJlbnROb2RlKSkge1xuICAgIHJldHVybiBwYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNUcmFpbGluZ0NvbW1hRW5hYmxlZChvcHRpb25zLCBjb250ZXh0KSB7XG4gIGNvbnN0IHRyYWlsaW5nQ29tbWEgPSBvcHRpb25zLnRyYWlsaW5nQ29tbWE7XG4gIGlmICh0eXBlb2YgdHJhaWxpbmdDb21tYSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiAhIXRyYWlsaW5nQ29tbWFbY29udGV4dF07XG4gIH1cbiAgcmV0dXJuICEhdHJhaWxpbmdDb21tYTtcbn1cblxuY29uc3QgZGVmYXVsdHMgPSB7XG4gIHRhYldpZHRoOiA0LFxuICB1c2VUYWJzOiBmYWxzZSxcbiAgcmV1c2VXaGl0ZXNwYWNlOiB0cnVlLFxuICBsaW5lVGVybWluYXRvcjogZ2V0TGluZVRlcm1pbmF0b3IoKSxcbiAgd3JhcENvbHVtbjogNzQsXG4gIC8vIEFzcGlyYXRpb25hbCBmb3Igbm93LlxuICBzb3VyY2VGaWxlTmFtZTogbnVsbCxcbiAgc291cmNlTWFwTmFtZTogbnVsbCxcbiAgc291cmNlUm9vdDogbnVsbCxcbiAgaW5wdXRTb3VyY2VNYXA6IG51bGwsXG4gIHJhbmdlOiBmYWxzZSxcbiAgdG9sZXJhbnQ6IHRydWUsXG4gIHF1b3RlOiBudWxsLFxuICB0cmFpbGluZ0NvbW1hOiBmYWxzZSxcbiAgYXJyYXlCcmFja2V0U3BhY2luZzogZmFsc2UsXG4gIG9iamVjdEN1cmx5U3BhY2luZzogdHJ1ZSxcbiAgYXJyb3dQYXJlbnNBbHdheXM6IGZhbHNlLFxuICBmbG93T2JqZWN0Q29tbWFzOiB0cnVlLFxuICB0b2tlbnM6IHRydWVcbn07XG5jb25zdCBoYXNPd24kMSA9IGRlZmF1bHRzLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gbm9ybWFsaXplKG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IG9wdHMgfHwgZGVmYXVsdHM7XG4gIGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICByZXR1cm4gaGFzT3duJDEuY2FsbChvcHRpb25zLCBrZXkpID8gb3B0aW9uc1trZXldIDogZGVmYXVsdHNba2V5XTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRhYldpZHRoOiArZ2V0KFwidGFiV2lkdGhcIiksXG4gICAgdXNlVGFiczogISFnZXQoXCJ1c2VUYWJzXCIpLFxuICAgIHJldXNlV2hpdGVzcGFjZTogISFnZXQoXCJyZXVzZVdoaXRlc3BhY2VcIiksXG4gICAgbGluZVRlcm1pbmF0b3I6IGdldChcImxpbmVUZXJtaW5hdG9yXCIpLFxuICAgIHdyYXBDb2x1bW46IE1hdGgubWF4KGdldChcIndyYXBDb2x1bW5cIiksIDApLFxuICAgIHNvdXJjZUZpbGVOYW1lOiBnZXQoXCJzb3VyY2VGaWxlTmFtZVwiKSxcbiAgICBzb3VyY2VNYXBOYW1lOiBnZXQoXCJzb3VyY2VNYXBOYW1lXCIpLFxuICAgIHNvdXJjZVJvb3Q6IGdldChcInNvdXJjZVJvb3RcIiksXG4gICAgaW5wdXRTb3VyY2VNYXA6IGdldChcImlucHV0U291cmNlTWFwXCIpLFxuICAgIHBhcnNlcjogZ2V0KFwiZXNwcmltYVwiKSB8fCBnZXQoXCJwYXJzZXJcIiksXG4gICAgcmFuZ2U6IGdldChcInJhbmdlXCIpLFxuICAgIHRvbGVyYW50OiBnZXQoXCJ0b2xlcmFudFwiKSxcbiAgICBxdW90ZTogZ2V0KFwicXVvdGVcIiksXG4gICAgdHJhaWxpbmdDb21tYTogZ2V0KFwidHJhaWxpbmdDb21tYVwiKSxcbiAgICBhcnJheUJyYWNrZXRTcGFjaW5nOiBnZXQoXCJhcnJheUJyYWNrZXRTcGFjaW5nXCIpLFxuICAgIG9iamVjdEN1cmx5U3BhY2luZzogZ2V0KFwib2JqZWN0Q3VybHlTcGFjaW5nXCIpLFxuICAgIGFycm93UGFyZW5zQWx3YXlzOiBnZXQoXCJhcnJvd1BhcmVuc0Fsd2F5c1wiKSxcbiAgICBmbG93T2JqZWN0Q29tbWFzOiBnZXQoXCJmbG93T2JqZWN0Q29tbWFzXCIpLFxuICAgIHRva2VuczogISFnZXQoXCJ0b2tlbnNcIilcbiAgfTtcbn1cblxuY2xhc3MgTWFwcGluZyB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZUxpbmVzLCBzb3VyY2VMb2MsIHRhcmdldExvYyA9IHNvdXJjZUxvYykge1xuICAgIHRoaXMuc291cmNlTGluZXMgPSBzb3VyY2VMaW5lcztcbiAgICB0aGlzLnNvdXJjZUxvYyA9IHNvdXJjZUxvYztcbiAgICB0aGlzLnRhcmdldExvYyA9IHRhcmdldExvYztcbiAgfVxuICBzbGljZShsaW5lcywgc3RhcnQsIGVuZCA9IGxpbmVzLmxhc3RQb3MoKSkge1xuICAgIGNvbnN0IHNvdXJjZUxpbmVzID0gdGhpcy5zb3VyY2VMaW5lcztcbiAgICBsZXQgc291cmNlTG9jID0gdGhpcy5zb3VyY2VMb2M7XG4gICAgbGV0IHRhcmdldExvYyA9IHRoaXMudGFyZ2V0TG9jO1xuICAgIGZ1bmN0aW9uIHNraXAobmFtZSkge1xuICAgICAgY29uc3Qgc291cmNlRnJvbVBvcyA9IHNvdXJjZUxvY1tuYW1lXTtcbiAgICAgIGNvbnN0IHRhcmdldEZyb21Qb3MgPSB0YXJnZXRMb2NbbmFtZV07XG4gICAgICBsZXQgdGFyZ2V0VG9Qb3MgPSBzdGFydDtcbiAgICAgIGlmIChuYW1lID09PSBcImVuZFwiKSB7XG4gICAgICAgIHRhcmdldFRvUG9zID0gZW5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNraXBDaGFycyhcbiAgICAgICAgc291cmNlTGluZXMsXG4gICAgICAgIHNvdXJjZUZyb21Qb3MsXG4gICAgICAgIGxpbmVzLFxuICAgICAgICB0YXJnZXRGcm9tUG9zLFxuICAgICAgICB0YXJnZXRUb1Bvc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVQb3Moc3RhcnQsIHRhcmdldExvYy5zdGFydCkgPD0gMCkge1xuICAgICAgaWYgKGNvbXBhcmVQb3ModGFyZ2V0TG9jLmVuZCwgZW5kKSA8PSAwKSB7XG4gICAgICAgIHRhcmdldExvYyA9IHtcbiAgICAgICAgICBzdGFydDogc3VidHJhY3RQb3ModGFyZ2V0TG9jLnN0YXJ0LCBzdGFydC5saW5lLCBzdGFydC5jb2x1bW4pLFxuICAgICAgICAgIGVuZDogc3VidHJhY3RQb3ModGFyZ2V0TG9jLmVuZCwgc3RhcnQubGluZSwgc3RhcnQuY29sdW1uKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChjb21wYXJlUG9zKGVuZCwgdGFyZ2V0TG9jLnN0YXJ0KSA8PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc291cmNlTG9jID0ge1xuICAgICAgICAgIHN0YXJ0OiBzb3VyY2VMb2Muc3RhcnQsXG4gICAgICAgICAgZW5kOiBza2lwKFwiZW5kXCIpXG4gICAgICAgIH07XG4gICAgICAgIHRhcmdldExvYyA9IHtcbiAgICAgICAgICBzdGFydDogc3VidHJhY3RQb3ModGFyZ2V0TG9jLnN0YXJ0LCBzdGFydC5saW5lLCBzdGFydC5jb2x1bW4pLFxuICAgICAgICAgIGVuZDogc3VidHJhY3RQb3MoZW5kLCBzdGFydC5saW5lLCBzdGFydC5jb2x1bW4pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb21wYXJlUG9zKHRhcmdldExvYy5lbmQsIHN0YXJ0KSA8PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNvbXBhcmVQb3ModGFyZ2V0TG9jLmVuZCwgZW5kKSA8PSAwKSB7XG4gICAgICAgIHNvdXJjZUxvYyA9IHtcbiAgICAgICAgICBzdGFydDogc2tpcChcInN0YXJ0XCIpLFxuICAgICAgICAgIGVuZDogc291cmNlTG9jLmVuZFxuICAgICAgICB9O1xuICAgICAgICB0YXJnZXRMb2MgPSB7XG4gICAgICAgICAgLy8gU2FtZSBhcyBzdWJ0cmFjdFBvcyhzdGFydCwgc3RhcnQubGluZSwgc3RhcnQuY29sdW1uKTpcbiAgICAgICAgICBzdGFydDogeyBsaW5lOiAxLCBjb2x1bW46IDAgfSxcbiAgICAgICAgICBlbmQ6IHN1YnRyYWN0UG9zKHRhcmdldExvYy5lbmQsIHN0YXJ0LmxpbmUsIHN0YXJ0LmNvbHVtbilcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNvdXJjZUxvYyA9IHtcbiAgICAgICAgICBzdGFydDogc2tpcChcInN0YXJ0XCIpLFxuICAgICAgICAgIGVuZDogc2tpcChcImVuZFwiKVxuICAgICAgICB9O1xuICAgICAgICB0YXJnZXRMb2MgPSB7XG4gICAgICAgICAgLy8gU2FtZSBhcyBzdWJ0cmFjdFBvcyhzdGFydCwgc3RhcnQubGluZSwgc3RhcnQuY29sdW1uKTpcbiAgICAgICAgICBzdGFydDogeyBsaW5lOiAxLCBjb2x1bW46IDAgfSxcbiAgICAgICAgICBlbmQ6IHN1YnRyYWN0UG9zKGVuZCwgc3RhcnQubGluZSwgc3RhcnQuY29sdW1uKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5zb3VyY2VMaW5lcywgc291cmNlTG9jLCB0YXJnZXRMb2MpO1xuICB9XG4gIGFkZChsaW5lLCBjb2x1bW4pIHtcbiAgICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5zb3VyY2VMaW5lcywgdGhpcy5zb3VyY2VMb2MsIHtcbiAgICAgIHN0YXJ0OiBhZGRQb3ModGhpcy50YXJnZXRMb2Muc3RhcnQsIGxpbmUsIGNvbHVtbiksXG4gICAgICBlbmQ6IGFkZFBvcyh0aGlzLnRhcmdldExvYy5lbmQsIGxpbmUsIGNvbHVtbilcbiAgICB9KTtcbiAgfVxuICBzdWJ0cmFjdChsaW5lLCBjb2x1bW4pIHtcbiAgICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5zb3VyY2VMaW5lcywgdGhpcy5zb3VyY2VMb2MsIHtcbiAgICAgIHN0YXJ0OiBzdWJ0cmFjdFBvcyh0aGlzLnRhcmdldExvYy5zdGFydCwgbGluZSwgY29sdW1uKSxcbiAgICAgIGVuZDogc3VidHJhY3RQb3ModGhpcy50YXJnZXRMb2MuZW5kLCBsaW5lLCBjb2x1bW4pXG4gICAgfSk7XG4gIH1cbiAgaW5kZW50KGJ5LCBza2lwRmlyc3RMaW5lID0gZmFsc2UsIG5vTmVnYXRpdmVDb2x1bW5zID0gZmFsc2UpIHtcbiAgICBpZiAoYnkgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsZXQgdGFyZ2V0TG9jID0gdGhpcy50YXJnZXRMb2M7XG4gICAgY29uc3Qgc3RhcnRMaW5lID0gdGFyZ2V0TG9jLnN0YXJ0LmxpbmU7XG4gICAgY29uc3QgZW5kTGluZSA9IHRhcmdldExvYy5lbmQubGluZTtcbiAgICBpZiAoc2tpcEZpcnN0TGluZSAmJiBzdGFydExpbmUgPT09IDEgJiYgZW5kTGluZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRhcmdldExvYyA9IHtcbiAgICAgIHN0YXJ0OiB0YXJnZXRMb2Muc3RhcnQsXG4gICAgICBlbmQ6IHRhcmdldExvYy5lbmRcbiAgICB9O1xuICAgIGlmICghc2tpcEZpcnN0TGluZSB8fCBzdGFydExpbmUgPiAxKSB7XG4gICAgICBjb25zdCBzdGFydENvbHVtbiA9IHRhcmdldExvYy5zdGFydC5jb2x1bW4gKyBieTtcbiAgICAgIHRhcmdldExvYy5zdGFydCA9IHtcbiAgICAgICAgbGluZTogc3RhcnRMaW5lLFxuICAgICAgICBjb2x1bW46IG5vTmVnYXRpdmVDb2x1bW5zID8gTWF0aC5tYXgoMCwgc3RhcnRDb2x1bW4pIDogc3RhcnRDb2x1bW5cbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghc2tpcEZpcnN0TGluZSB8fCBlbmRMaW5lID4gMSkge1xuICAgICAgY29uc3QgZW5kQ29sdW1uID0gdGFyZ2V0TG9jLmVuZC5jb2x1bW4gKyBieTtcbiAgICAgIHRhcmdldExvYy5lbmQgPSB7XG4gICAgICAgIGxpbmU6IGVuZExpbmUsXG4gICAgICAgIGNvbHVtbjogbm9OZWdhdGl2ZUNvbHVtbnMgPyBNYXRoLm1heCgwLCBlbmRDb2x1bW4pIDogZW5kQ29sdW1uXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5zb3VyY2VMaW5lcywgdGhpcy5zb3VyY2VMb2MsIHRhcmdldExvYyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFBvcyh0b1BvcywgbGluZSwgY29sdW1uKSB7XG4gIHJldHVybiB7XG4gICAgbGluZTogdG9Qb3MubGluZSArIGxpbmUgLSAxLFxuICAgIGNvbHVtbjogdG9Qb3MubGluZSA9PT0gMSA/IHRvUG9zLmNvbHVtbiArIGNvbHVtbiA6IHRvUG9zLmNvbHVtblxuICB9O1xufVxuZnVuY3Rpb24gc3VidHJhY3RQb3MoZnJvbVBvcywgbGluZSwgY29sdW1uKSB7XG4gIHJldHVybiB7XG4gICAgbGluZTogZnJvbVBvcy5saW5lIC0gbGluZSArIDEsXG4gICAgY29sdW1uOiBmcm9tUG9zLmxpbmUgPT09IGxpbmUgPyBmcm9tUG9zLmNvbHVtbiAtIGNvbHVtbiA6IGZyb21Qb3MuY29sdW1uXG4gIH07XG59XG5mdW5jdGlvbiBza2lwQ2hhcnMoc291cmNlTGluZXMsIHNvdXJjZUZyb21Qb3MsIHRhcmdldExpbmVzLCB0YXJnZXRGcm9tUG9zLCB0YXJnZXRUb1Bvcykge1xuICBjb25zdCB0YXJnZXRDb21wYXJpc29uID0gY29tcGFyZVBvcyh0YXJnZXRGcm9tUG9zLCB0YXJnZXRUb1Bvcyk7XG4gIGlmICh0YXJnZXRDb21wYXJpc29uID09PSAwKSB7XG4gICAgcmV0dXJuIHNvdXJjZUZyb21Qb3M7XG4gIH1cbiAgbGV0IHNvdXJjZUN1cnNvciwgdGFyZ2V0Q3Vyc29yO1xuICBpZiAodGFyZ2V0Q29tcGFyaXNvbiA8IDApIHtcbiAgICBzb3VyY2VDdXJzb3IgPSBzb3VyY2VMaW5lcy5za2lwU3BhY2VzKHNvdXJjZUZyb21Qb3MpIHx8IHNvdXJjZUxpbmVzLmxhc3RQb3MoKTtcbiAgICB0YXJnZXRDdXJzb3IgPSB0YXJnZXRMaW5lcy5za2lwU3BhY2VzKHRhcmdldEZyb21Qb3MpIHx8IHRhcmdldExpbmVzLmxhc3RQb3MoKTtcbiAgICBjb25zdCBsaW5lRGlmZiA9IHRhcmdldFRvUG9zLmxpbmUgLSB0YXJnZXRDdXJzb3IubGluZTtcbiAgICBzb3VyY2VDdXJzb3IubGluZSArPSBsaW5lRGlmZjtcbiAgICB0YXJnZXRDdXJzb3IubGluZSArPSBsaW5lRGlmZjtcbiAgICBpZiAobGluZURpZmYgPiAwKSB7XG4gICAgICBzb3VyY2VDdXJzb3IuY29sdW1uID0gMDtcbiAgICAgIHRhcmdldEN1cnNvci5jb2x1bW4gPSAwO1xuICAgIH1cbiAgICB3aGlsZSAoY29tcGFyZVBvcyh0YXJnZXRDdXJzb3IsIHRhcmdldFRvUG9zKSA8IDAgJiYgdGFyZ2V0TGluZXMubmV4dFBvcyh0YXJnZXRDdXJzb3IsIHRydWUpKSB7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNvdXJjZUN1cnNvciA9IHNvdXJjZUxpbmVzLnNraXBTcGFjZXMoc291cmNlRnJvbVBvcywgdHJ1ZSkgfHwgc291cmNlTGluZXMuZmlyc3RQb3MoKTtcbiAgICB0YXJnZXRDdXJzb3IgPSB0YXJnZXRMaW5lcy5za2lwU3BhY2VzKHRhcmdldEZyb21Qb3MsIHRydWUpIHx8IHRhcmdldExpbmVzLmZpcnN0UG9zKCk7XG4gICAgY29uc3QgbGluZURpZmYgPSB0YXJnZXRUb1Bvcy5saW5lIC0gdGFyZ2V0Q3Vyc29yLmxpbmU7XG4gICAgc291cmNlQ3Vyc29yLmxpbmUgKz0gbGluZURpZmY7XG4gICAgdGFyZ2V0Q3Vyc29yLmxpbmUgKz0gbGluZURpZmY7XG4gICAgaWYgKGxpbmVEaWZmIDwgMCkge1xuICAgICAgc291cmNlQ3Vyc29yLmNvbHVtbiA9IHNvdXJjZUxpbmVzLmdldExpbmVMZW5ndGgoc291cmNlQ3Vyc29yLmxpbmUpO1xuICAgICAgdGFyZ2V0Q3Vyc29yLmNvbHVtbiA9IHRhcmdldExpbmVzLmdldExpbmVMZW5ndGgodGFyZ2V0Q3Vyc29yLmxpbmUpO1xuICAgIH1cbiAgICB3aGlsZSAoY29tcGFyZVBvcyh0YXJnZXRUb1BvcywgdGFyZ2V0Q3Vyc29yKSA8IDAgJiYgdGFyZ2V0TGluZXMucHJldlBvcyh0YXJnZXRDdXJzb3IsIHRydWUpKSB7XG4gICAgfVxuICB9XG4gIHJldHVybiBzb3VyY2VDdXJzb3I7XG59XG5cbnZhciBfX2RlZlByb3AkMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZk5vcm1hbFByb3AkMSA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3AkMShvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19wdWJsaWNGaWVsZCQxID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ge1xuICBfX2RlZk5vcm1hbFByb3AkMShvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBMaW5lcyB7XG4gIGNvbnN0cnVjdG9yKGluZm9zLCBzb3VyY2VGaWxlTmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLmluZm9zID0gaW5mb3M7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibGVuZ3RoXCIpO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcIm5hbWVcIik7XG4gICAgX19wdWJsaWNGaWVsZCQxKHRoaXMsIFwibWFwcGluZ3NcIiwgW10pO1xuICAgIF9fcHVibGljRmllbGQkMSh0aGlzLCBcImNhY2hlZFNvdXJjZU1hcFwiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkJDEodGhpcywgXCJjYWNoZWRUYWJXaWR0aFwiKTtcbiAgICB0aGlzLmxlbmd0aCA9IGluZm9zLmxlbmd0aDtcbiAgICB0aGlzLm5hbWUgPSBzb3VyY2VGaWxlTmFtZSB8fCBudWxsO1xuICAgIGlmICh0aGlzLm5hbWUpIHtcbiAgICAgIHRoaXMubWFwcGluZ3MucHVzaChcbiAgICAgICAgbmV3IE1hcHBpbmcodGhpcywge1xuICAgICAgICAgIHN0YXJ0OiB0aGlzLmZpcnN0UG9zKCksXG4gICAgICAgICAgZW5kOiB0aGlzLmxhc3RQb3MoKVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNsaWNlU3RyaW5nKHRoaXMuZmlyc3RQb3MoKSwgdGhpcy5sYXN0UG9zKCksIG9wdGlvbnMpO1xuICB9XG4gIGdldFNvdXJjZU1hcChzb3VyY2VNYXBOYW1lLCBzb3VyY2VSb290KSB7XG4gICAgaWYgKCFzb3VyY2VNYXBOYW1lKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0TGluZXMgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZUpTT04oanNvbikge1xuICAgICAganNvbiA9IGpzb24gfHwge307XG4gICAgICBqc29uLmZpbGUgPSBzb3VyY2VNYXBOYW1lO1xuICAgICAgaWYgKHNvdXJjZVJvb3QpIHtcbiAgICAgICAganNvbi5zb3VyY2VSb290ID0gc291cmNlUm9vdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBqc29uO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0TGluZXMuY2FjaGVkU291cmNlTWFwKSB7XG4gICAgICByZXR1cm4gdXBkYXRlSlNPTih0YXJnZXRMaW5lcy5jYWNoZWRTb3VyY2VNYXAudG9KU09OKCkpO1xuICAgIH1cbiAgICBjb25zdCBzbWcgPSBuZXcgc291cmNlTWFwLlNvdXJjZU1hcEdlbmVyYXRvcih1cGRhdGVKU09OKCkpO1xuICAgIGNvbnN0IHNvdXJjZXNUb0NvbnRlbnRzID0ge307XG4gICAgdGFyZ2V0TGluZXMubWFwcGluZ3MuZm9yRWFjaChmdW5jdGlvbihtYXBwaW5nKSB7XG4gICAgICBjb25zdCBzb3VyY2VDdXJzb3IgPSBtYXBwaW5nLnNvdXJjZUxpbmVzLnNraXBTcGFjZXMobWFwcGluZy5zb3VyY2VMb2Muc3RhcnQpIHx8IG1hcHBpbmcuc291cmNlTGluZXMubGFzdFBvcygpO1xuICAgICAgY29uc3QgdGFyZ2V0Q3Vyc29yID0gdGFyZ2V0TGluZXMuc2tpcFNwYWNlcyhtYXBwaW5nLnRhcmdldExvYy5zdGFydCkgfHwgdGFyZ2V0TGluZXMubGFzdFBvcygpO1xuICAgICAgd2hpbGUgKGNvbXBhcmVQb3Moc291cmNlQ3Vyc29yLCBtYXBwaW5nLnNvdXJjZUxvYy5lbmQpIDwgMCAmJiBjb21wYXJlUG9zKHRhcmdldEN1cnNvciwgbWFwcGluZy50YXJnZXRMb2MuZW5kKSA8IDApIHtcbiAgICAgICAgbWFwcGluZy5zb3VyY2VMaW5lcy5jaGFyQXQoc291cmNlQ3Vyc29yKTtcbiAgICAgICAgdGFyZ2V0TGluZXMuY2hhckF0KHRhcmdldEN1cnNvcik7XG4gICAgICAgIGNvbnN0IHNvdXJjZU5hbWUgPSBtYXBwaW5nLnNvdXJjZUxpbmVzLm5hbWU7XG4gICAgICAgIHNtZy5hZGRNYXBwaW5nKHtcbiAgICAgICAgICBzb3VyY2U6IHNvdXJjZU5hbWUsXG4gICAgICAgICAgb3JpZ2luYWw6IHsgbGluZTogc291cmNlQ3Vyc29yLmxpbmUsIGNvbHVtbjogc291cmNlQ3Vyc29yLmNvbHVtbiB9LFxuICAgICAgICAgIGdlbmVyYXRlZDogeyBsaW5lOiB0YXJnZXRDdXJzb3IubGluZSwgY29sdW1uOiB0YXJnZXRDdXJzb3IuY29sdW1uIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaGFzT3duLmNhbGwoc291cmNlc1RvQ29udGVudHMsIHNvdXJjZU5hbWUpKSB7XG4gICAgICAgICAgY29uc3Qgc291cmNlQ29udGVudCA9IG1hcHBpbmcuc291cmNlTGluZXMudG9TdHJpbmcoKTtcbiAgICAgICAgICBzbWcuc2V0U291cmNlQ29udGVudChzb3VyY2VOYW1lLCBzb3VyY2VDb250ZW50KTtcbiAgICAgICAgICBzb3VyY2VzVG9Db250ZW50c1tzb3VyY2VOYW1lXSA9IHNvdXJjZUNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0TGluZXMubmV4dFBvcyh0YXJnZXRDdXJzb3IsIHRydWUpO1xuICAgICAgICBtYXBwaW5nLnNvdXJjZUxpbmVzLm5leHRQb3Moc291cmNlQ3Vyc29yLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0YXJnZXRMaW5lcy5jYWNoZWRTb3VyY2VNYXAgPSBzbWc7XG4gICAgcmV0dXJuIHNtZy50b0pTT04oKTtcbiAgfVxuICBib290c3RyYXBDaGFyQXQocG9zKSB7XG4gICAgY29uc3QgbGluZSA9IHBvcy5saW5lLCBjb2x1bW4gPSBwb3MuY29sdW1uLCBzdHJpbmdzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KGxpbmVUZXJtaW5hdG9yU2VxRXhwKSwgc3RyaW5nID0gc3RyaW5nc1tsaW5lIC0gMV07XG4gICAgaWYgKHR5cGVvZiBzdHJpbmcgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBpZiAoY29sdW1uID09PSBzdHJpbmcubGVuZ3RoICYmIGxpbmUgPCBzdHJpbmdzLmxlbmd0aClcbiAgICAgIHJldHVybiBcIlxcblwiO1xuICAgIGlmIChjb2x1bW4gPj0gc3RyaW5nLmxlbmd0aClcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KGNvbHVtbik7XG4gIH1cbiAgY2hhckF0KHBvcykge1xuICAgIGxldCBsaW5lID0gcG9zLmxpbmUsIGNvbHVtbiA9IHBvcy5jb2x1bW4sIHNlY3JldCA9IHRoaXMsIGluZm9zID0gc2VjcmV0LmluZm9zLCBpbmZvID0gaW5mb3NbbGluZSAtIDFdLCBjID0gY29sdW1uO1xuICAgIGlmICh0eXBlb2YgaW5mbyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBjIDwgMClcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIGNvbnN0IGluZGVudCA9IHRoaXMuZ2V0SW5kZW50QXQobGluZSk7XG4gICAgaWYgKGMgPCBpbmRlbnQpXG4gICAgICByZXR1cm4gXCIgXCI7XG4gICAgYyArPSBpbmZvLnNsaWNlU3RhcnQgLSBpbmRlbnQ7XG4gICAgaWYgKGMgPT09IGluZm8uc2xpY2VFbmQgJiYgbGluZSA8IHRoaXMubGVuZ3RoKVxuICAgICAgcmV0dXJuIFwiXFxuXCI7XG4gICAgaWYgKGMgPj0gaW5mby5zbGljZUVuZClcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIHJldHVybiBpbmZvLmxpbmUuY2hhckF0KGMpO1xuICB9XG4gIHN0cmlwTWFyZ2luKHdpZHRoLCBza2lwRmlyc3RMaW5lKSB7XG4gICAgaWYgKHdpZHRoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHNraXBGaXJzdExpbmUgJiYgdGhpcy5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCBsaW5lcyA9IG5ldyBMaW5lcyhcbiAgICAgIHRoaXMuaW5mb3MubWFwKGZ1bmN0aW9uKGluZm8sIGkpIHtcbiAgICAgICAgaWYgKGluZm8ubGluZSAmJiAoaSA+IDAgfHwgIXNraXBGaXJzdExpbmUpKSB7XG4gICAgICAgICAgaW5mbyA9IHtcbiAgICAgICAgICAgIC4uLmluZm8sXG4gICAgICAgICAgICBpbmRlbnQ6IE1hdGgubWF4KDAsIGluZm8uaW5kZW50IC0gd2lkdGgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5mbztcbiAgICAgIH0pXG4gICAgKTtcbiAgICBpZiAodGhpcy5tYXBwaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBuZXdNYXBwaW5ncyA9IGxpbmVzLm1hcHBpbmdzO1xuICAgICAgdGhpcy5tYXBwaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKG1hcHBpbmcpIHtcbiAgICAgICAgbmV3TWFwcGluZ3MucHVzaChtYXBwaW5nLmluZGVudCh3aWR0aCwgc2tpcEZpcnN0TGluZSwgdHJ1ZSkpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBpbmRlbnQoYnkpIHtcbiAgICBpZiAoYnkgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBsaW5lcyA9IG5ldyBMaW5lcyhcbiAgICAgIHRoaXMuaW5mb3MubWFwKGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgICAgaWYgKGluZm8ubGluZSAmJiAhaW5mby5sb2NrZWQpIHtcbiAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgLi4uaW5mbyxcbiAgICAgICAgICAgIGluZGVudDogaW5mby5pbmRlbnQgKyBieVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKHRoaXMubWFwcGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbmV3TWFwcGluZ3MgPSBsaW5lcy5tYXBwaW5ncztcbiAgICAgIHRoaXMubWFwcGluZ3MuZm9yRWFjaChmdW5jdGlvbihtYXBwaW5nKSB7XG4gICAgICAgIG5ld01hcHBpbmdzLnB1c2gobWFwcGluZy5pbmRlbnQoYnkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgaW5kZW50VGFpbChieSkge1xuICAgIGlmIChieSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25zdCBsaW5lcyA9IG5ldyBMaW5lcyhcbiAgICAgIHRoaXMuaW5mb3MubWFwKGZ1bmN0aW9uKGluZm8sIGkpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIGluZm8ubGluZSAmJiAhaW5mby5sb2NrZWQpIHtcbiAgICAgICAgICBpbmZvID0ge1xuICAgICAgICAgICAgLi4uaW5mbyxcbiAgICAgICAgICAgIGluZGVudDogaW5mby5pbmRlbnQgKyBieVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZm87XG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKHRoaXMubWFwcGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbmV3TWFwcGluZ3MgPSBsaW5lcy5tYXBwaW5ncztcbiAgICAgIHRoaXMubWFwcGluZ3MuZm9yRWFjaChmdW5jdGlvbihtYXBwaW5nKSB7XG4gICAgICAgIG5ld01hcHBpbmdzLnB1c2gobWFwcGluZy5pbmRlbnQoYnksIHRydWUpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgbG9ja0luZGVudFRhaWwoKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTGluZXMoXG4gICAgICB0aGlzLmluZm9zLm1hcCgoaW5mbywgaSkgPT4gKHtcbiAgICAgICAgLi4uaW5mbyxcbiAgICAgICAgbG9ja2VkOiBpID4gMFxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICBnZXRJbmRlbnRBdChsaW5lKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KHRoaXMuaW5mb3NbbGluZSAtIDFdLmluZGVudCwgMCk7XG4gIH1cbiAgZ3Vlc3NUYWJXaWR0aCgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuY2FjaGVkVGFiV2lkdGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhY2hlZFRhYldpZHRoO1xuICAgIH1cbiAgICBjb25zdCBjb3VudHMgPSBbXTtcbiAgICBsZXQgbGFzdEluZGVudCA9IDA7XG4gICAgZm9yIChsZXQgbGluZSA9IDEsIGxhc3QgPSB0aGlzLmxlbmd0aDsgbGluZSA8PSBsYXN0OyArK2xpbmUpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB0aGlzLmluZm9zW2xpbmUgLSAxXTtcbiAgICAgIGNvbnN0IHNsaWNlZCA9IGluZm8ubGluZS5zbGljZShpbmZvLnNsaWNlU3RhcnQsIGluZm8uc2xpY2VFbmQpO1xuICAgICAgaWYgKGlzT25seVdoaXRlc3BhY2Uoc2xpY2VkKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhpbmZvLmluZGVudCAtIGxhc3RJbmRlbnQpO1xuICAgICAgY291bnRzW2RpZmZdID0gfn5jb3VudHNbZGlmZl0gKyAxO1xuICAgICAgbGFzdEluZGVudCA9IGluZm8uaW5kZW50O1xuICAgIH1cbiAgICBsZXQgbWF4Q291bnQgPSAtMTtcbiAgICBsZXQgcmVzdWx0ID0gMjtcbiAgICBmb3IgKGxldCB0YWJXaWR0aCA9IDE7IHRhYldpZHRoIDwgY291bnRzLmxlbmd0aDsgdGFiV2lkdGggKz0gMSkge1xuICAgICAgaWYgKGhhc093bi5jYWxsKGNvdW50cywgdGFiV2lkdGgpICYmIGNvdW50c1t0YWJXaWR0aF0gPiBtYXhDb3VudCkge1xuICAgICAgICBtYXhDb3VudCA9IGNvdW50c1t0YWJXaWR0aF07XG4gICAgICAgIHJlc3VsdCA9IHRhYldpZHRoO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWNoZWRUYWJXaWR0aCA9IHJlc3VsdDtcbiAgfVxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGxpc3Qgb2YgbGluZXMgaGFzIGEgZmlyc3QgbGluZSB0aGF0IHN0YXJ0cyB3aXRoIGEgLy9cbiAgLy8gb3IgLyogY29tbWVudC4gSWYgdGhpcyBpcyB0aGUgY2FzZSwgdGhlIGNvZGUgbWF5IG5lZWQgdG8gYmUgd3JhcHBlZCBpblxuICAvLyBwYXJlbnMgdG8gYXZvaWQgQVNJIGlzc3Vlcy5cbiAgc3RhcnRzV2l0aENvbW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuaW5mb3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0TGluZUluZm8gPSB0aGlzLmluZm9zWzBdLCBzbGljZVN0YXJ0ID0gZmlyc3RMaW5lSW5mby5zbGljZVN0YXJ0LCBzbGljZUVuZCA9IGZpcnN0TGluZUluZm8uc2xpY2VFbmQsIGZpcnN0TGluZSA9IGZpcnN0TGluZUluZm8ubGluZS5zbGljZShzbGljZVN0YXJ0LCBzbGljZUVuZCkudHJpbSgpO1xuICAgIHJldHVybiBmaXJzdExpbmUubGVuZ3RoID09PSAwIHx8IGZpcnN0TGluZS5zbGljZSgwLCAyKSA9PT0gXCIvL1wiIHx8IGZpcnN0TGluZS5zbGljZSgwLCAyKSA9PT0gXCIvKlwiO1xuICB9XG4gIGlzT25seVdoaXRlc3BhY2UoKSB7XG4gICAgcmV0dXJuIGlzT25seVdoaXRlc3BhY2UodGhpcy50b1N0cmluZygpKTtcbiAgfVxuICBpc1ByZWNlZGVkT25seUJ5V2hpdGVzcGFjZShwb3MpIHtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5pbmZvc1twb3MubGluZSAtIDFdO1xuICAgIGNvbnN0IGluZGVudCA9IE1hdGgubWF4KGluZm8uaW5kZW50LCAwKTtcbiAgICBjb25zdCBkaWZmID0gcG9zLmNvbHVtbiAtIGluZGVudDtcbiAgICBpZiAoZGlmZiA8PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSBpbmZvLnNsaWNlU3RhcnQ7XG4gICAgY29uc3QgZW5kID0gTWF0aC5taW4oc3RhcnQgKyBkaWZmLCBpbmZvLnNsaWNlRW5kKTtcbiAgICBjb25zdCBwcmVmaXggPSBpbmZvLmxpbmUuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgcmV0dXJuIGlzT25seVdoaXRlc3BhY2UocHJlZml4KTtcbiAgfVxuICBnZXRMaW5lTGVuZ3RoKGxpbmUpIHtcbiAgICBjb25zdCBpbmZvID0gdGhpcy5pbmZvc1tsaW5lIC0gMV07XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5kZW50QXQobGluZSkgKyBpbmZvLnNsaWNlRW5kIC0gaW5mby5zbGljZVN0YXJ0O1xuICB9XG4gIG5leHRQb3MocG9zLCBza2lwU3BhY2VzID0gZmFsc2UpIHtcbiAgICBjb25zdCBsID0gTWF0aC5tYXgocG9zLmxpbmUsIDApLCBjID0gTWF0aC5tYXgocG9zLmNvbHVtbiwgMCk7XG4gICAgaWYgKGMgPCB0aGlzLmdldExpbmVMZW5ndGgobCkpIHtcbiAgICAgIHBvcy5jb2x1bW4gKz0gMTtcbiAgICAgIHJldHVybiBza2lwU3BhY2VzID8gISF0aGlzLnNraXBTcGFjZXMocG9zLCBmYWxzZSwgdHJ1ZSkgOiB0cnVlO1xuICAgIH1cbiAgICBpZiAobCA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBwb3MubGluZSArPSAxO1xuICAgICAgcG9zLmNvbHVtbiA9IDA7XG4gICAgICByZXR1cm4gc2tpcFNwYWNlcyA/ICEhdGhpcy5za2lwU3BhY2VzKHBvcywgZmFsc2UsIHRydWUpIDogdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHByZXZQb3MocG9zLCBza2lwU3BhY2VzID0gZmFsc2UpIHtcbiAgICBsZXQgbCA9IHBvcy5saW5lLCBjID0gcG9zLmNvbHVtbjtcbiAgICBpZiAoYyA8IDEpIHtcbiAgICAgIGwgLT0gMTtcbiAgICAgIGlmIChsIDwgMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgYyA9IHRoaXMuZ2V0TGluZUxlbmd0aChsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYyA9IE1hdGgubWluKGMgLSAxLCB0aGlzLmdldExpbmVMZW5ndGgobCkpO1xuICAgIH1cbiAgICBwb3MubGluZSA9IGw7XG4gICAgcG9zLmNvbHVtbiA9IGM7XG4gICAgcmV0dXJuIHNraXBTcGFjZXMgPyAhIXRoaXMuc2tpcFNwYWNlcyhwb3MsIHRydWUsIHRydWUpIDogdHJ1ZTtcbiAgfVxuICBmaXJzdFBvcygpIHtcbiAgICByZXR1cm4geyBsaW5lOiAxLCBjb2x1bW46IDAgfTtcbiAgfVxuICBsYXN0UG9zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiB0aGlzLmxlbmd0aCxcbiAgICAgIGNvbHVtbjogdGhpcy5nZXRMaW5lTGVuZ3RoKHRoaXMubGVuZ3RoKVxuICAgIH07XG4gIH1cbiAgc2tpcFNwYWNlcyhwb3MsIGJhY2t3YXJkID0gZmFsc2UsIG1vZGlmeUluUGxhY2UgPSBmYWxzZSkge1xuICAgIGlmIChwb3MpIHtcbiAgICAgIHBvcyA9IG1vZGlmeUluUGxhY2UgPyBwb3MgOiB7XG4gICAgICAgIGxpbmU6IHBvcy5saW5lLFxuICAgICAgICBjb2x1bW46IHBvcy5jb2x1bW5cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChiYWNrd2FyZCkge1xuICAgICAgcG9zID0gdGhpcy5sYXN0UG9zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IHRoaXMuZmlyc3RQb3MoKTtcbiAgICB9XG4gICAgaWYgKGJhY2t3YXJkKSB7XG4gICAgICB3aGlsZSAodGhpcy5wcmV2UG9zKHBvcykpIHtcbiAgICAgICAgaWYgKCFpc09ubHlXaGl0ZXNwYWNlKHRoaXMuY2hhckF0KHBvcykpICYmIHRoaXMubmV4dFBvcyhwb3MpKSB7XG4gICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChpc09ubHlXaGl0ZXNwYWNlKHRoaXMuY2hhckF0KHBvcykpKSB7XG4gICAgICAgIGlmICghdGhpcy5uZXh0UG9zKHBvcykpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gIH1cbiAgdHJpbUxlZnQoKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5za2lwU3BhY2VzKHRoaXMuZmlyc3RQb3MoKSwgZmFsc2UsIHRydWUpO1xuICAgIHJldHVybiBwb3MgPyB0aGlzLnNsaWNlKHBvcykgOiBlbXB0eUxpbmVzO1xuICB9XG4gIHRyaW1SaWdodCgpIHtcbiAgICBjb25zdCBwb3MgPSB0aGlzLnNraXBTcGFjZXModGhpcy5sYXN0UG9zKCksIHRydWUsIHRydWUpO1xuICAgIHJldHVybiBwb3MgPyB0aGlzLnNsaWNlKHRoaXMuZmlyc3RQb3MoKSwgcG9zKSA6IGVtcHR5TGluZXM7XG4gIH1cbiAgdHJpbSgpIHtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc2tpcFNwYWNlcyh0aGlzLmZpcnN0UG9zKCksIGZhbHNlLCB0cnVlKTtcbiAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbXB0eUxpbmVzO1xuICAgIH1cbiAgICBjb25zdCBlbmQgPSB0aGlzLnNraXBTcGFjZXModGhpcy5sYXN0UG9zKCksIHRydWUsIHRydWUpO1xuICAgIGlmIChlbmQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbXB0eUxpbmVzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKTtcbiAgfVxuICBlYWNoUG9zKGNhbGxiYWNrLCBzdGFydFBvcyA9IHRoaXMuZmlyc3RQb3MoKSwgc2tpcFNwYWNlcyA9IGZhbHNlKSB7XG4gICAgY29uc3QgcG9zID0gdGhpcy5maXJzdFBvcygpO1xuICAgIGlmIChzdGFydFBvcykge1xuICAgICAgcG9zLmxpbmUgPSBzdGFydFBvcy5saW5lLCBwb3MuY29sdW1uID0gc3RhcnRQb3MuY29sdW1uO1xuICAgIH1cbiAgICBpZiAoc2tpcFNwYWNlcyAmJiAhdGhpcy5za2lwU3BhY2VzKHBvcywgZmFsc2UsIHRydWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvXG4gICAgICBjYWxsYmFjay5jYWxsKHRoaXMsIHBvcyk7XG4gICAgd2hpbGUgKHRoaXMubmV4dFBvcyhwb3MsIHNraXBTcGFjZXMpKTtcbiAgfVxuICBib290c3RyYXBTbGljZShzdGFydCwgZW5kKSB7XG4gICAgY29uc3Qgc3RyaW5ncyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChsaW5lVGVybWluYXRvclNlcUV4cCkuc2xpY2Uoc3RhcnQubGluZSAtIDEsIGVuZC5saW5lKTtcbiAgICBpZiAoc3RyaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBzdHJpbmdzLnB1c2goc3RyaW5ncy5wb3AoKS5zbGljZSgwLCBlbmQuY29sdW1uKSk7XG4gICAgICBzdHJpbmdzWzBdID0gc3RyaW5nc1swXS5zbGljZShzdGFydC5jb2x1bW4pO1xuICAgIH1cbiAgICByZXR1cm4gZnJvbVN0cmluZyhzdHJpbmdzLmpvaW4oXCJcXG5cIikpO1xuICB9XG4gIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoIWVuZCkge1xuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGVuZCA9IHRoaXMubGFzdFBvcygpO1xuICAgIH1cbiAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3Qgc2xpY2Ugd2l0aCBlbmQgYnV0IG5vdCBzdGFydFwiKTtcbiAgICB9XG4gICAgY29uc3Qgc2xpY2VkID0gdGhpcy5pbmZvcy5zbGljZShzdGFydC5saW5lIC0gMSwgZW5kLmxpbmUpO1xuICAgIGlmIChzdGFydC5saW5lID09PSBlbmQubGluZSkge1xuICAgICAgc2xpY2VkWzBdID0gc2xpY2VJbmZvKHNsaWNlZFswXSwgc3RhcnQuY29sdW1uLCBlbmQuY29sdW1uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2xpY2VkWzBdID0gc2xpY2VJbmZvKHNsaWNlZFswXSwgc3RhcnQuY29sdW1uKTtcbiAgICAgIHNsaWNlZC5wdXNoKHNsaWNlSW5mbyhzbGljZWQucG9wKCksIDAsIGVuZC5jb2x1bW4pKTtcbiAgICB9XG4gICAgY29uc3QgbGluZXMgPSBuZXcgTGluZXMoc2xpY2VkKTtcbiAgICBpZiAodGhpcy5tYXBwaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBuZXdNYXBwaW5ncyA9IGxpbmVzLm1hcHBpbmdzO1xuICAgICAgdGhpcy5tYXBwaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKG1hcHBpbmcpIHtcbiAgICAgICAgY29uc3Qgc2xpY2VkMiA9IG1hcHBpbmcuc2xpY2UodGhpcywgc3RhcnQsIGVuZCk7XG4gICAgICAgIGlmIChzbGljZWQyKSB7XG4gICAgICAgICAgbmV3TWFwcGluZ3MucHVzaChzbGljZWQyKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBib290c3RyYXBTbGljZVN0cmluZyhzdGFydCwgZW5kLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpY2Uoc3RhcnQsIGVuZCkudG9TdHJpbmcob3B0aW9ucyk7XG4gIH1cbiAgc2xpY2VTdHJpbmcoc3RhcnQgPSB0aGlzLmZpcnN0UG9zKCksIGVuZCA9IHRoaXMubGFzdFBvcygpLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0YWJXaWR0aCwgdXNlVGFicywgcmV1c2VXaGl0ZXNwYWNlLCBsaW5lVGVybWluYXRvciB9ID0gbm9ybWFsaXplKG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgZm9yIChsZXQgbGluZSA9IHN0YXJ0LmxpbmU7IGxpbmUgPD0gZW5kLmxpbmU7ICsrbGluZSkge1xuICAgICAgbGV0IGluZm8gPSB0aGlzLmluZm9zW2xpbmUgLSAxXTtcbiAgICAgIGlmIChsaW5lID09PSBzdGFydC5saW5lKSB7XG4gICAgICAgIGlmIChsaW5lID09PSBlbmQubGluZSkge1xuICAgICAgICAgIGluZm8gPSBzbGljZUluZm8oaW5mbywgc3RhcnQuY29sdW1uLCBlbmQuY29sdW1uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbmZvID0gc2xpY2VJbmZvKGluZm8sIHN0YXJ0LmNvbHVtbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobGluZSA9PT0gZW5kLmxpbmUpIHtcbiAgICAgICAgaW5mbyA9IHNsaWNlSW5mbyhpbmZvLCAwLCBlbmQuY29sdW1uKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGVudCA9IE1hdGgubWF4KGluZm8uaW5kZW50LCAwKTtcbiAgICAgIGNvbnN0IGJlZm9yZSA9IGluZm8ubGluZS5zbGljZSgwLCBpbmZvLnNsaWNlU3RhcnQpO1xuICAgICAgaWYgKHJldXNlV2hpdGVzcGFjZSAmJiBpc09ubHlXaGl0ZXNwYWNlKGJlZm9yZSkgJiYgY291bnRTcGFjZXMoYmVmb3JlLCB0YWJXaWR0aCkgPT09IGluZGVudCkge1xuICAgICAgICBwYXJ0cy5wdXNoKGluZm8ubGluZS5zbGljZSgwLCBpbmZvLnNsaWNlRW5kKSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IHRhYnMgPSAwO1xuICAgICAgbGV0IHNwYWNlcyA9IGluZGVudDtcbiAgICAgIGlmICh1c2VUYWJzKSB7XG4gICAgICAgIHRhYnMgPSBNYXRoLmZsb29yKGluZGVudCAvIHRhYldpZHRoKTtcbiAgICAgICAgc3BhY2VzIC09IHRhYnMgKiB0YWJXaWR0aDtcbiAgICAgIH1cbiAgICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgICAgaWYgKHRhYnMgPiAwKSB7XG4gICAgICAgIHJlc3VsdCArPSBuZXcgQXJyYXkodGFicyArIDEpLmpvaW4oXCJcdFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChzcGFjZXMgPiAwKSB7XG4gICAgICAgIHJlc3VsdCArPSBuZXcgQXJyYXkoc3BhY2VzICsgMSkuam9pbihcIiBcIik7XG4gICAgICB9XG4gICAgICByZXN1bHQgKz0gaW5mby5saW5lLnNsaWNlKGluZm8uc2xpY2VTdGFydCwgaW5mby5zbGljZUVuZCk7XG4gICAgICBwYXJ0cy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKGxpbmVUZXJtaW5hdG9yKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLmxlbmd0aCA8IDIgJiYgdGhpcy5nZXRMaW5lTGVuZ3RoKDEpIDwgMTtcbiAgfVxuICBqb2luKGVsZW1lbnRzKSB7XG4gICAgY29uc3Qgc2VwYXJhdG9yID0gdGhpcztcbiAgICBjb25zdCBpbmZvcyA9IFtdO1xuICAgIGNvbnN0IG1hcHBpbmdzID0gW107XG4gICAgbGV0IHByZXZJbmZvO1xuICAgIGZ1bmN0aW9uIGFwcGVuZExpbmVzKGxpbmVzT3JOdWxsKSB7XG4gICAgICBpZiAobGluZXNPck51bGwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZJbmZvKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSBsaW5lc09yTnVsbC5pbmZvc1swXTtcbiAgICAgICAgY29uc3QgaW5kZW50ID0gbmV3IEFycmF5KGluZm8uaW5kZW50ICsgMSkuam9pbihcIiBcIik7XG4gICAgICAgIGNvbnN0IHByZXZMaW5lID0gaW5mb3MubGVuZ3RoO1xuICAgICAgICBjb25zdCBwcmV2Q29sdW1uID0gTWF0aC5tYXgocHJldkluZm8uaW5kZW50LCAwKSArIHByZXZJbmZvLnNsaWNlRW5kIC0gcHJldkluZm8uc2xpY2VTdGFydDtcbiAgICAgICAgcHJldkluZm8ubGluZSA9IHByZXZJbmZvLmxpbmUuc2xpY2UoMCwgcHJldkluZm8uc2xpY2VFbmQpICsgaW5kZW50ICsgaW5mby5saW5lLnNsaWNlKGluZm8uc2xpY2VTdGFydCwgaW5mby5zbGljZUVuZCk7XG4gICAgICAgIHByZXZJbmZvLmxvY2tlZCA9IHByZXZJbmZvLmxvY2tlZCB8fCBpbmZvLmxvY2tlZDtcbiAgICAgICAgcHJldkluZm8uc2xpY2VFbmQgPSBwcmV2SW5mby5saW5lLmxlbmd0aDtcbiAgICAgICAgaWYgKGxpbmVzT3JOdWxsLm1hcHBpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsaW5lc09yTnVsbC5tYXBwaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKG1hcHBpbmcpIHtcbiAgICAgICAgICAgIG1hcHBpbmdzLnB1c2gobWFwcGluZy5hZGQocHJldkxpbmUsIHByZXZDb2x1bW4pKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChsaW5lc09yTnVsbC5tYXBwaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIG1hcHBpbmdzLnB1c2guYXBwbHkobWFwcGluZ3MsIGxpbmVzT3JOdWxsLm1hcHBpbmdzKTtcbiAgICAgIH1cbiAgICAgIGxpbmVzT3JOdWxsLmluZm9zLmZvckVhY2goZnVuY3Rpb24oaW5mbywgaSkge1xuICAgICAgICBpZiAoIXByZXZJbmZvIHx8IGkgPiAwKSB7XG4gICAgICAgICAgcHJldkluZm8gPSB7IC4uLmluZm8gfTtcbiAgICAgICAgICBpbmZvcy5wdXNoKHByZXZJbmZvKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGVuZFdpdGhTZXBhcmF0b3IobGluZXNPck51bGwsIGkpIHtcbiAgICAgIGlmIChpID4gMClcbiAgICAgICAgYXBwZW5kTGluZXMoc2VwYXJhdG9yKTtcbiAgICAgIGFwcGVuZExpbmVzKGxpbmVzT3JOdWxsKTtcbiAgICB9XG4gICAgZWxlbWVudHMubWFwKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIGNvbnN0IGxpbmVzMiA9IGZyb21TdHJpbmcoZWxlbSk7XG4gICAgICBpZiAobGluZXMyLmlzRW1wdHkoKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gbGluZXMyO1xuICAgIH0pLmZvckVhY2goKGxpbmVzT3JOdWxsLCBpKSA9PiB7XG4gICAgICBpZiAoc2VwYXJhdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICBhcHBlbmRMaW5lcyhsaW5lc09yTnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmRXaXRoU2VwYXJhdG9yKGxpbmVzT3JOdWxsLCBpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoaW5mb3MubGVuZ3RoIDwgMSlcbiAgICAgIHJldHVybiBlbXB0eUxpbmVzO1xuICAgIGNvbnN0IGxpbmVzID0gbmV3IExpbmVzKGluZm9zKTtcbiAgICBsaW5lcy5tYXBwaW5ncyA9IG1hcHBpbmdzO1xuICAgIHJldHVybiBsaW5lcztcbiAgfVxuICBjb25jYXQoLi4uYXJncykge1xuICAgIGNvbnN0IGxpc3QgPSBbdGhpc107XG4gICAgbGlzdC5wdXNoLmFwcGx5KGxpc3QsIGFyZ3MpO1xuICAgIHJldHVybiBlbXB0eUxpbmVzLmpvaW4obGlzdCk7XG4gIH1cbn1cbmNvbnN0IGZyb21TdHJpbmdDYWNoZSA9IHt9O1xuY29uc3QgaGFzT3duID0gZnJvbVN0cmluZ0NhY2hlLmhhc093blByb3BlcnR5O1xuY29uc3QgbWF4Q2FjaGVLZXlMZW4gPSAxMDtcbmZ1bmN0aW9uIGNvdW50U3BhY2VzKHNwYWNlcywgdGFiV2lkdGgpIHtcbiAgbGV0IGNvdW50ID0gMDtcbiAgY29uc3QgbGVuID0gc3BhY2VzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHN3aXRjaCAoc3BhY2VzLmNoYXJDb2RlQXQoaSkpIHtcbiAgICAgIGNhc2UgOToge1xuICAgICAgICBjb25zdCBuZXh0ID0gTWF0aC5jZWlsKGNvdW50IC8gdGFiV2lkdGgpICogdGFiV2lkdGg7XG4gICAgICAgIGlmIChuZXh0ID09PSBjb3VudCkge1xuICAgICAgICAgIGNvdW50ICs9IHRhYldpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvdW50ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgMTE6XG4gICAgICBjYXNlIDEyOlxuICAgICAgY2FzZSAxMzpcbiAgICAgIGNhc2UgNjUyNzk6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzMjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5jb25zdCBsZWFkaW5nU3BhY2VFeHAgPSAvXlxccyovO1xuY29uc3QgbGluZVRlcm1pbmF0b3JTZXFFeHAgPSAvXFx1MDAwRFxcdTAwMEF8XFx1MDAwRCg/IVxcdTAwMEEpfFxcdTAwMEF8XFx1MjAyOHxcXHUyMDI5LztcbmZ1bmN0aW9uIGZyb21TdHJpbmcoc3RyaW5nLCBvcHRpb25zKSB7XG4gIGlmIChzdHJpbmcgaW5zdGFuY2VvZiBMaW5lcylcbiAgICByZXR1cm4gc3RyaW5nO1xuICBzdHJpbmcgKz0gXCJcIjtcbiAgY29uc3QgdGFiV2lkdGggPSBvcHRpb25zICYmIG9wdGlvbnMudGFiV2lkdGg7XG4gIGNvbnN0IHRhYmxlc3MgPSBzdHJpbmcuaW5kZXhPZihcIlx0XCIpIDwgMDtcbiAgY29uc3QgY2FjaGVhYmxlID0gIW9wdGlvbnMgJiYgdGFibGVzcyAmJiBzdHJpbmcubGVuZ3RoIDw9IG1heENhY2hlS2V5TGVuO1xuICBpZiAoY2FjaGVhYmxlICYmIGhhc093bi5jYWxsKGZyb21TdHJpbmdDYWNoZSwgc3RyaW5nKSlcbiAgICByZXR1cm4gZnJvbVN0cmluZ0NhY2hlW3N0cmluZ107XG4gIGNvbnN0IGxpbmVzID0gbmV3IExpbmVzKFxuICAgIHN0cmluZy5zcGxpdChsaW5lVGVybWluYXRvclNlcUV4cCkubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGNvbnN0IHNwYWNlcyA9IGxlYWRpbmdTcGFjZUV4cC5leGVjKGxpbmUpWzBdO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgaW5kZW50OiBjb3VudFNwYWNlcyhzcGFjZXMsIHRhYldpZHRoKSxcbiAgICAgICAgLy8gQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBsaW5lIGNhbiBiZSByZWluZGVudGVkLlxuICAgICAgICBsb2NrZWQ6IGZhbHNlLFxuICAgICAgICBzbGljZVN0YXJ0OiBzcGFjZXMubGVuZ3RoLFxuICAgICAgICBzbGljZUVuZDogbGluZS5sZW5ndGhcbiAgICAgIH07XG4gICAgfSksXG4gICAgbm9ybWFsaXplKG9wdGlvbnMpLnNvdXJjZUZpbGVOYW1lXG4gICk7XG4gIGlmIChjYWNoZWFibGUpXG4gICAgZnJvbVN0cmluZ0NhY2hlW3N0cmluZ10gPSBsaW5lcztcbiAgcmV0dXJuIGxpbmVzO1xufVxuZnVuY3Rpb24gaXNPbmx5V2hpdGVzcGFjZShzdHJpbmcpIHtcbiAgcmV0dXJuICEvXFxTLy50ZXN0KHN0cmluZyk7XG59XG5mdW5jdGlvbiBzbGljZUluZm8oaW5mbywgc3RhcnRDb2wsIGVuZENvbCkge1xuICBsZXQgc2xpY2VTdGFydCA9IGluZm8uc2xpY2VTdGFydDtcbiAgbGV0IHNsaWNlRW5kID0gaW5mby5zbGljZUVuZDtcbiAgbGV0IGluZGVudCA9IE1hdGgubWF4KGluZm8uaW5kZW50LCAwKTtcbiAgbGV0IGxpbmVMZW5ndGggPSBpbmRlbnQgKyBzbGljZUVuZCAtIHNsaWNlU3RhcnQ7XG4gIGlmICh0eXBlb2YgZW5kQ29sID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZW5kQ29sID0gbGluZUxlbmd0aDtcbiAgfVxuICBzdGFydENvbCA9IE1hdGgubWF4KHN0YXJ0Q29sLCAwKTtcbiAgZW5kQ29sID0gTWF0aC5taW4oZW5kQ29sLCBsaW5lTGVuZ3RoKTtcbiAgZW5kQ29sID0gTWF0aC5tYXgoZW5kQ29sLCBzdGFydENvbCk7XG4gIGlmIChlbmRDb2wgPCBpbmRlbnQpIHtcbiAgICBpbmRlbnQgPSBlbmRDb2w7XG4gICAgc2xpY2VFbmQgPSBzbGljZVN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIHNsaWNlRW5kIC09IGxpbmVMZW5ndGggLSBlbmRDb2w7XG4gIH1cbiAgbGluZUxlbmd0aCA9IGVuZENvbDtcbiAgbGluZUxlbmd0aCAtPSBzdGFydENvbDtcbiAgaWYgKHN0YXJ0Q29sIDwgaW5kZW50KSB7XG4gICAgaW5kZW50IC09IHN0YXJ0Q29sO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0Q29sIC09IGluZGVudDtcbiAgICBpbmRlbnQgPSAwO1xuICAgIHNsaWNlU3RhcnQgKz0gc3RhcnRDb2w7XG4gIH1cbiAgaWYgKGluZm8uaW5kZW50ID09PSBpbmRlbnQgJiYgaW5mby5zbGljZVN0YXJ0ID09PSBzbGljZVN0YXJ0ICYmIGluZm8uc2xpY2VFbmQgPT09IHNsaWNlRW5kKSB7XG4gICAgcmV0dXJuIGluZm87XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsaW5lOiBpbmZvLmxpbmUsXG4gICAgaW5kZW50LFxuICAgIC8vIEEgZGVzdHJ1Y3RpdmUgc2xpY2UgYWx3YXlzIHVubG9ja3MgaW5kZW50YXRpb24uXG4gICAgbG9ja2VkOiBmYWxzZSxcbiAgICBzbGljZVN0YXJ0LFxuICAgIHNsaWNlRW5kXG4gIH07XG59XG5mdW5jdGlvbiBjb25jYXQoZWxlbWVudHMpIHtcbiAgcmV0dXJuIGVtcHR5TGluZXMuam9pbihlbGVtZW50cyk7XG59XG5jb25zdCBlbXB0eUxpbmVzID0gZnJvbVN0cmluZyhcIlwiKTtcblxuY29uc3QgbiQxID0gbmFtZWRUeXBlcyQxO1xuY29uc3QgaXNBcnJheSQzID0gYnVpbHRJblR5cGVzLmFycmF5O1xuY29uc3QgaXNPYmplY3QkMyA9IGJ1aWx0SW5UeXBlcy5vYmplY3Q7XG5jb25zdCBjaGlsZE5vZGVzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGdldFNvcnRlZENoaWxkTm9kZXMobm9kZSwgbGluZXMsIHJlc3VsdEFycmF5KSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiByZXN1bHRBcnJheTtcbiAgfVxuICBmaXhGYXVsdHlMb2NhdGlvbnMobm9kZSwgbGluZXMpO1xuICBpZiAocmVzdWx0QXJyYXkpIHtcbiAgICBpZiAobiQxLk5vZGUuY2hlY2sobm9kZSkgJiYgbiQxLlNvdXJjZUxvY2F0aW9uLmNoZWNrKG5vZGUubG9jKSkge1xuICAgICAgbGV0IGkgPSByZXN1bHRBcnJheS5sZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gcmVzdWx0QXJyYXlbaV07XG4gICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZC5sb2MgJiYgY29tcGFyZVBvcyhjaGlsZC5sb2MuZW5kLCBub2RlLmxvYy5zdGFydCkgPD0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHRBcnJheS5zcGxpY2UoaSArIDEsIDAsIG5vZGUpO1xuICAgICAgcmV0dXJuIHJlc3VsdEFycmF5O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjaGlsZE5vZGVzID0gY2hpbGROb2Rlc0NhY2hlLmdldChub2RlKTtcbiAgICBpZiAoY2hpbGROb2Rlcykge1xuICAgICAgcmV0dXJuIGNoaWxkTm9kZXM7XG4gICAgfVxuICB9XG4gIGxldCBuYW1lcztcbiAgaWYgKGlzQXJyYXkkMy5jaGVjayhub2RlKSkge1xuICAgIG5hbWVzID0gT2JqZWN0LmtleXMobm9kZSk7XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QkMy5jaGVjayhub2RlKSkge1xuICAgIG5hbWVzID0gZ2V0RmllbGROYW1lcyhub2RlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzdWx0QXJyYXk7XG4gIH1cbiAgaWYgKCFyZXN1bHRBcnJheSkge1xuICAgIGNoaWxkTm9kZXNDYWNoZS5zZXQobm9kZSwgcmVzdWx0QXJyYXkgPSBbXSk7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDAsIG5hbWVDb3VudCA9IG5hbWVzLmxlbmd0aDsgaSA8IG5hbWVDb3VudDsgKytpKSB7XG4gICAgZ2V0U29ydGVkQ2hpbGROb2Rlcyhub2RlW25hbWVzW2ldXSwgbGluZXMsIHJlc3VsdEFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0QXJyYXk7XG59XG5mdW5jdGlvbiBkZWNvcmF0ZUNvbW1lbnQobm9kZSwgY29tbWVudCwgbGluZXMpIHtcbiAgY29uc3QgY2hpbGROb2RlcyA9IGdldFNvcnRlZENoaWxkTm9kZXMobm9kZSwgbGluZXMpO1xuICBsZXQgbGVmdCA9IDA7XG4gIGxldCByaWdodCA9IGNoaWxkTm9kZXMgJiYgY2hpbGROb2Rlcy5sZW5ndGg7XG4gIGxldCBwcmVjZWRpbmdOb2RlO1xuICBsZXQgZm9sbG93aW5nTm9kZTtcbiAgd2hpbGUgKHR5cGVvZiByaWdodCA9PT0gXCJudW1iZXJcIiAmJiBsZWZ0IDwgcmlnaHQpIHtcbiAgICBjb25zdCBtaWRkbGUgPSBsZWZ0ICsgcmlnaHQgPj4gMTtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkTm9kZXNbbWlkZGxlXTtcbiAgICBpZiAoY29tcGFyZVBvcyhjaGlsZC5sb2Muc3RhcnQsIGNvbW1lbnQubG9jLnN0YXJ0KSA8PSAwICYmIGNvbXBhcmVQb3MoY29tbWVudC5sb2MuZW5kLCBjaGlsZC5sb2MuZW5kKSA8PSAwKSB7XG4gICAgICBkZWNvcmF0ZUNvbW1lbnQoY29tbWVudC5lbmNsb3NpbmdOb2RlID0gY2hpbGQsIGNvbW1lbnQsIGxpbmVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVQb3MoY2hpbGQubG9jLmVuZCwgY29tbWVudC5sb2Muc3RhcnQpIDw9IDApIHtcbiAgICAgIHByZWNlZGluZ05vZGUgPSBjaGlsZDtcbiAgICAgIGxlZnQgPSBtaWRkbGUgKyAxO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChjb21wYXJlUG9zKGNvbW1lbnQubG9jLmVuZCwgY2hpbGQubG9jLnN0YXJ0KSA8PSAwKSB7XG4gICAgICBmb2xsb3dpbmdOb2RlID0gY2hpbGQ7XG4gICAgICByaWdodCA9IG1pZGRsZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb21tZW50IGxvY2F0aW9uIG92ZXJsYXBzIHdpdGggbm9kZSBsb2NhdGlvblwiKTtcbiAgfVxuICBpZiAocHJlY2VkaW5nTm9kZSkge1xuICAgIGNvbW1lbnQucHJlY2VkaW5nTm9kZSA9IHByZWNlZGluZ05vZGU7XG4gIH1cbiAgaWYgKGZvbGxvd2luZ05vZGUpIHtcbiAgICBjb21tZW50LmZvbGxvd2luZ05vZGUgPSBmb2xsb3dpbmdOb2RlO1xuICB9XG59XG5mdW5jdGlvbiBhdHRhY2goY29tbWVudHMsIGFzdCwgbGluZXMpIHtcbiAgaWYgKCFpc0FycmF5JDMuY2hlY2soY29tbWVudHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRpZXNUb0JyZWFrID0gW107XG4gIGNvbW1lbnRzLmZvckVhY2goZnVuY3Rpb24oY29tbWVudCkge1xuICAgIGNvbW1lbnQubG9jLmxpbmVzID0gbGluZXM7XG4gICAgZGVjb3JhdGVDb21tZW50KGFzdCwgY29tbWVudCwgbGluZXMpO1xuICAgIGNvbnN0IHBuID0gY29tbWVudC5wcmVjZWRpbmdOb2RlO1xuICAgIGNvbnN0IGVuID0gY29tbWVudC5lbmNsb3NpbmdOb2RlO1xuICAgIGNvbnN0IGZuID0gY29tbWVudC5mb2xsb3dpbmdOb2RlO1xuICAgIGlmIChwbiAmJiBmbikge1xuICAgICAgY29uc3QgdGllQ291bnQgPSB0aWVzVG9CcmVhay5sZW5ndGg7XG4gICAgICBpZiAodGllQ291bnQgPiAwKSB7XG4gICAgICAgIGNvbnN0IGxhc3RUaWUgPSB0aWVzVG9CcmVha1t0aWVDb3VudCAtIDFdO1xuICAgICAgICBpZiAobGFzdFRpZS5mb2xsb3dpbmdOb2RlICE9PSBjb21tZW50LmZvbGxvd2luZ05vZGUpIHtcbiAgICAgICAgICBicmVha1RpZXModGllc1RvQnJlYWssIGxpbmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGllc1RvQnJlYWsucHVzaChjb21tZW50KTtcbiAgICB9IGVsc2UgaWYgKHBuKSB7XG4gICAgICBicmVha1RpZXModGllc1RvQnJlYWssIGxpbmVzKTtcbiAgICAgIGFkZFRyYWlsaW5nQ29tbWVudChwbiwgY29tbWVudCk7XG4gICAgfSBlbHNlIGlmIChmbikge1xuICAgICAgYnJlYWtUaWVzKHRpZXNUb0JyZWFrLCBsaW5lcyk7XG4gICAgICBhZGRMZWFkaW5nQ29tbWVudChmbiwgY29tbWVudCk7XG4gICAgfSBlbHNlIGlmIChlbikge1xuICAgICAgYnJlYWtUaWVzKHRpZXNUb0JyZWFrLCBsaW5lcyk7XG4gICAgICBhZGREYW5nbGluZ0NvbW1lbnQoZW4sIGNvbW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBU1QgY29udGFpbnMgbm8gbm9kZXMgYXQgYWxsP1wiKTtcbiAgICB9XG4gIH0pO1xuICBicmVha1RpZXModGllc1RvQnJlYWssIGxpbmVzKTtcbiAgY29tbWVudHMuZm9yRWFjaChmdW5jdGlvbihjb21tZW50KSB7XG4gICAgZGVsZXRlIGNvbW1lbnQucHJlY2VkaW5nTm9kZTtcbiAgICBkZWxldGUgY29tbWVudC5lbmNsb3NpbmdOb2RlO1xuICAgIGRlbGV0ZSBjb21tZW50LmZvbGxvd2luZ05vZGU7XG4gIH0pO1xufVxuZnVuY3Rpb24gYnJlYWtUaWVzKHRpZXNUb0JyZWFrLCBsaW5lcykge1xuICBjb25zdCB0aWVDb3VudCA9IHRpZXNUb0JyZWFrLmxlbmd0aDtcbiAgaWYgKHRpZUNvdW50ID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBuID0gdGllc1RvQnJlYWtbMF0ucHJlY2VkaW5nTm9kZTtcbiAgY29uc3QgZm4gPSB0aWVzVG9CcmVha1swXS5mb2xsb3dpbmdOb2RlO1xuICBsZXQgZ2FwRW5kUG9zID0gZm4ubG9jLnN0YXJ0O1xuICBsZXQgaW5kZXhPZkZpcnN0TGVhZGluZ0NvbW1lbnQgPSB0aWVDb3VudDtcbiAgbGV0IGNvbW1lbnQ7XG4gIGZvciAoOyBpbmRleE9mRmlyc3RMZWFkaW5nQ29tbWVudCA+IDA7IC0taW5kZXhPZkZpcnN0TGVhZGluZ0NvbW1lbnQpIHtcbiAgICBjb21tZW50ID0gdGllc1RvQnJlYWtbaW5kZXhPZkZpcnN0TGVhZGluZ0NvbW1lbnQgLSAxXTtcbiAgICBjb25zdCBnYXAgPSBsaW5lcy5zbGljZVN0cmluZyhjb21tZW50LmxvYy5lbmQsIGdhcEVuZFBvcyk7XG4gICAgaWYgKC9cXFMvLnRlc3QoZ2FwKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGdhcEVuZFBvcyA9IGNvbW1lbnQubG9jLnN0YXJ0O1xuICB9XG4gIHdoaWxlIChpbmRleE9mRmlyc3RMZWFkaW5nQ29tbWVudCA8PSB0aWVDb3VudCAmJiAoY29tbWVudCA9IHRpZXNUb0JyZWFrW2luZGV4T2ZGaXJzdExlYWRpbmdDb21tZW50XSkgJiYgLy8gSWYgdGhlIGNvbW1lbnQgaXMgYSAvLy1zdHlsZSBjb21tZW50IGFuZCBpbmRlbnRlZCBtb3JlXG4gIC8vIGRlZXBseSB0aGFuIHRoZSBub2RlIGl0c2VsZiwgcmVjb25zaWRlciBpdCBhcyB0cmFpbGluZy5cbiAgKGNvbW1lbnQudHlwZSA9PT0gXCJMaW5lXCIgfHwgY29tbWVudC50eXBlID09PSBcIkNvbW1lbnRMaW5lXCIpICYmIGNvbW1lbnQubG9jLnN0YXJ0LmNvbHVtbiA+IGZuLmxvYy5zdGFydC5jb2x1bW4pIHtcbiAgICArK2luZGV4T2ZGaXJzdExlYWRpbmdDb21tZW50O1xuICB9XG4gIGlmIChpbmRleE9mRmlyc3RMZWFkaW5nQ29tbWVudCkge1xuICAgIGNvbnN0IHsgZW5jbG9zaW5nTm9kZSB9ID0gdGllc1RvQnJlYWtbaW5kZXhPZkZpcnN0TGVhZGluZ0NvbW1lbnQgLSAxXTtcbiAgICBpZiAoZW5jbG9zaW5nTm9kZT8udHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICAtLWluZGV4T2ZGaXJzdExlYWRpbmdDb21tZW50O1xuICAgIH1cbiAgfVxuICB0aWVzVG9CcmVhay5mb3JFYWNoKGZ1bmN0aW9uKGNvbW1lbnQyLCBpKSB7XG4gICAgaWYgKGkgPCBpbmRleE9mRmlyc3RMZWFkaW5nQ29tbWVudCkge1xuICAgICAgYWRkVHJhaWxpbmdDb21tZW50KHBuLCBjb21tZW50Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZExlYWRpbmdDb21tZW50KGZuLCBjb21tZW50Mik7XG4gICAgfVxuICB9KTtcbiAgdGllc1RvQnJlYWsubGVuZ3RoID0gMDtcbn1cbmZ1bmN0aW9uIGFkZENvbW1lbnRIZWxwZXIobm9kZSwgY29tbWVudCkge1xuICBjb25zdCBjb21tZW50cyA9IG5vZGUuY29tbWVudHMgfHwgKG5vZGUuY29tbWVudHMgPSBbXSk7XG4gIGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG59XG5mdW5jdGlvbiBhZGRMZWFkaW5nQ29tbWVudChub2RlLCBjb21tZW50KSB7XG4gIGNvbW1lbnQubGVhZGluZyA9IHRydWU7XG4gIGNvbW1lbnQudHJhaWxpbmcgPSBmYWxzZTtcbiAgYWRkQ29tbWVudEhlbHBlcihub2RlLCBjb21tZW50KTtcbn1cbmZ1bmN0aW9uIGFkZERhbmdsaW5nQ29tbWVudChub2RlLCBjb21tZW50KSB7XG4gIGNvbW1lbnQubGVhZGluZyA9IGZhbHNlO1xuICBjb21tZW50LnRyYWlsaW5nID0gZmFsc2U7XG4gIGFkZENvbW1lbnRIZWxwZXIobm9kZSwgY29tbWVudCk7XG59XG5mdW5jdGlvbiBhZGRUcmFpbGluZ0NvbW1lbnQobm9kZSwgY29tbWVudCkge1xuICBjb21tZW50LmxlYWRpbmcgPSBmYWxzZTtcbiAgY29tbWVudC50cmFpbGluZyA9IHRydWU7XG4gIGFkZENvbW1lbnRIZWxwZXIobm9kZSwgY29tbWVudCk7XG59XG5mdW5jdGlvbiBwcmludExlYWRpbmdDb21tZW50KGNvbW1lbnRQYXRoLCBwcmludCkge1xuICBjb25zdCBjb21tZW50ID0gY29tbWVudFBhdGguZ2V0VmFsdWUoKTtcbiAgbiQxLkNvbW1lbnQuYXNzZXJ0KGNvbW1lbnQpO1xuICBjb25zdCBsb2MgPSBjb21tZW50LmxvYztcbiAgY29uc3QgbGluZXMgPSBsb2MgJiYgbG9jLmxpbmVzO1xuICBjb25zdCBwYXJ0cyA9IFtwcmludChjb21tZW50UGF0aCldO1xuICBpZiAoY29tbWVudC50cmFpbGluZykge1xuICAgIHBhcnRzLnB1c2goXCJcXG5cIik7XG4gIH0gZWxzZSBpZiAobGluZXMgaW5zdGFuY2VvZiBMaW5lcykge1xuICAgIGNvbnN0IHRyYWlsaW5nU3BhY2UgPSBsaW5lcy5zbGljZShcbiAgICAgIGxvYy5lbmQsXG4gICAgICBsaW5lcy5za2lwU3BhY2VzKGxvYy5lbmQpIHx8IGxpbmVzLmxhc3RQb3MoKVxuICAgICk7XG4gICAgaWYgKHRyYWlsaW5nU3BhY2UubGVuZ3RoID09PSAxKSB7XG4gICAgICBwYXJ0cy5wdXNoKHRyYWlsaW5nU3BhY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cy5wdXNoKG5ldyBBcnJheSh0cmFpbGluZ1NwYWNlLmxlbmd0aCkuam9pbihcIlxcblwiKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcnRzLnB1c2goXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG59XG5mdW5jdGlvbiBwcmludFRyYWlsaW5nQ29tbWVudChjb21tZW50UGF0aCwgcHJpbnQpIHtcbiAgY29uc3QgY29tbWVudCA9IGNvbW1lbnRQYXRoLmdldFZhbHVlKGNvbW1lbnRQYXRoKTtcbiAgbiQxLkNvbW1lbnQuYXNzZXJ0KGNvbW1lbnQpO1xuICBjb25zdCBsb2MgPSBjb21tZW50LmxvYztcbiAgY29uc3QgbGluZXMgPSBsb2MgJiYgbG9jLmxpbmVzO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBpZiAobGluZXMgaW5zdGFuY2VvZiBMaW5lcykge1xuICAgIGNvbnN0IGZyb21Qb3MgPSBsaW5lcy5za2lwU3BhY2VzKGxvYy5zdGFydCwgdHJ1ZSkgfHwgbGluZXMuZmlyc3RQb3MoKTtcbiAgICBjb25zdCBsZWFkaW5nU3BhY2UgPSBsaW5lcy5zbGljZShmcm9tUG9zLCBsb2Muc3RhcnQpO1xuICAgIGlmIChsZWFkaW5nU3BhY2UubGVuZ3RoID09PSAxKSB7XG4gICAgICBwYXJ0cy5wdXNoKGxlYWRpbmdTcGFjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzLnB1c2gobmV3IEFycmF5KGxlYWRpbmdTcGFjZS5sZW5ndGgpLmpvaW4oXCJcXG5cIikpO1xuICAgIH1cbiAgfVxuICBwYXJ0cy5wdXNoKHByaW50KGNvbW1lbnRQYXRoKSk7XG4gIHJldHVybiBjb25jYXQocGFydHMpO1xufVxuZnVuY3Rpb24gcHJpbnRDb21tZW50cyhwYXRoLCBwcmludCkge1xuICBjb25zdCB2YWx1ZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgY29uc3QgaW5uZXJMaW5lcyA9IHByaW50KHBhdGgpO1xuICBjb25zdCBjb21tZW50cyA9IG4kMS5Ob2RlLmNoZWNrKHZhbHVlKSAmJiBnZXRGaWVsZFZhbHVlKHZhbHVlLCBcImNvbW1lbnRzXCIpO1xuICBpZiAoIWNvbW1lbnRzIHx8IGNvbW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBpbm5lckxpbmVzO1xuICB9XG4gIGNvbnN0IGxlYWRpbmdQYXJ0cyA9IFtdO1xuICBjb25zdCB0cmFpbGluZ1BhcnRzID0gW2lubmVyTGluZXNdO1xuICBwYXRoLmVhY2goZnVuY3Rpb24oY29tbWVudFBhdGgpIHtcbiAgICBjb25zdCBjb21tZW50ID0gY29tbWVudFBhdGguZ2V0VmFsdWUoKTtcbiAgICBjb25zdCBsZWFkaW5nID0gZ2V0RmllbGRWYWx1ZShjb21tZW50LCBcImxlYWRpbmdcIik7XG4gICAgY29uc3QgdHJhaWxpbmcgPSBnZXRGaWVsZFZhbHVlKGNvbW1lbnQsIFwidHJhaWxpbmdcIik7XG4gICAgaWYgKGxlYWRpbmcgfHwgdHJhaWxpbmcgJiYgIShuJDEuU3RhdGVtZW50LmNoZWNrKHZhbHVlKSB8fCBjb21tZW50LnR5cGUgPT09IFwiQmxvY2tcIiB8fCBjb21tZW50LnR5cGUgPT09IFwiQ29tbWVudEJsb2NrXCIpKSB7XG4gICAgICBsZWFkaW5nUGFydHMucHVzaChwcmludExlYWRpbmdDb21tZW50KGNvbW1lbnRQYXRoLCBwcmludCkpO1xuICAgIH0gZWxzZSBpZiAodHJhaWxpbmcpIHtcbiAgICAgIHRyYWlsaW5nUGFydHMucHVzaChwcmludFRyYWlsaW5nQ29tbWVudChjb21tZW50UGF0aCwgcHJpbnQpKTtcbiAgICB9XG4gIH0sIFwiY29tbWVudHNcIik7XG4gIGxlYWRpbmdQYXJ0cy5wdXNoLmFwcGx5KGxlYWRpbmdQYXJ0cywgdHJhaWxpbmdQYXJ0cyk7XG4gIHJldHVybiBjb25jYXQobGVhZGluZ1BhcnRzKTtcbn1cblxuY29uc3QgYiQ1ID0gYnVpbGRlcnMkMTtcbmNvbnN0IGlzT2JqZWN0JDIgPSBidWlsdEluVHlwZXMub2JqZWN0O1xuY29uc3QgaXNBcnJheSQyID0gYnVpbHRJblR5cGVzLmFycmF5O1xuZnVuY3Rpb24gcGFyc2Uoc291cmNlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBub3JtYWxpemUob3B0aW9ucyk7XG4gIGNvbnN0IGxpbmVzID0gZnJvbVN0cmluZyhzb3VyY2UsIG9wdGlvbnMpO1xuICBjb25zdCBzb3VyY2VXaXRob3V0VGFicyA9IGxpbmVzLnRvU3RyaW5nKHtcbiAgICB0YWJXaWR0aDogb3B0aW9ucy50YWJXaWR0aCxcbiAgICByZXVzZVdoaXRlc3BhY2U6IGZhbHNlLFxuICAgIHVzZVRhYnM6IGZhbHNlXG4gIH0pO1xuICBsZXQgY29tbWVudHMgPSBbXTtcbiAgY29uc3QgYXN0ID0gb3B0aW9ucy5wYXJzZXIucGFyc2Uoc291cmNlV2l0aG91dFRhYnMsIHtcbiAgICBqc3g6IHRydWUsXG4gICAgbG9jOiB0cnVlLFxuICAgIGxvY2F0aW9uczogdHJ1ZSxcbiAgICByYW5nZTogb3B0aW9ucy5yYW5nZSxcbiAgICBjb21tZW50OiB0cnVlLFxuICAgIG9uQ29tbWVudDogY29tbWVudHMsXG4gICAgdG9sZXJhbnQ6IGdldE9wdGlvbihvcHRpb25zLCBcInRvbGVyYW50XCIsIHRydWUpLFxuICAgIGVjbWFWZXJzaW9uOiA2LFxuICAgIHNvdXJjZVR5cGU6IGdldE9wdGlvbihvcHRpb25zLCBcInNvdXJjZVR5cGVcIiwgXCJtb2R1bGVcIilcbiAgfSk7XG4gIGNvbnN0IHRva2VucyA9IEFycmF5LmlzQXJyYXkoYXN0LnRva2VucykgPyBhc3QudG9rZW5zIDogZmFsc2U7XG4gIGRlbGV0ZSBhc3QudG9rZW5zO1xuICB0b2tlbnMuZm9yRWFjaChmdW5jdGlvbih0b2tlbikge1xuICAgIGlmICh0eXBlb2YgdG9rZW4udmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRva2VuLnZhbHVlID0gbGluZXMuc2xpY2VTdHJpbmcodG9rZW4ubG9jLnN0YXJ0LCB0b2tlbi5sb2MuZW5kKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoQXJyYXkuaXNBcnJheShhc3QuY29tbWVudHMpKSB7XG4gICAgY29tbWVudHMgPSBhc3QuY29tbWVudHM7XG4gICAgZGVsZXRlIGFzdC5jb21tZW50cztcbiAgfVxuICBpZiAoYXN0LmxvYykge1xuICAgIGZpeEZhdWx0eUxvY2F0aW9ucyhhc3QsIGxpbmVzKTtcbiAgfSBlbHNlIHtcbiAgICBhc3QubG9jID0ge1xuICAgICAgc3RhcnQ6IGxpbmVzLmZpcnN0UG9zKCksXG4gICAgICBlbmQ6IGxpbmVzLmxhc3RQb3MoKVxuICAgIH07XG4gIH1cbiAgYXN0LmxvYy5saW5lcyA9IGxpbmVzO1xuICBhc3QubG9jLmluZGVudCA9IDA7XG4gIGxldCBmaWxlO1xuICBsZXQgcHJvZ3JhbTtcbiAgaWYgKGFzdC50eXBlID09PSBcIlByb2dyYW1cIikge1xuICAgIHByb2dyYW0gPSBhc3Q7XG4gICAgZmlsZSA9IGIkNS5maWxlKGFzdCwgb3B0aW9ucy5zb3VyY2VGaWxlTmFtZSB8fCBudWxsKTtcbiAgICBmaWxlLmxvYyA9IHtcbiAgICAgIHN0YXJ0OiBsaW5lcy5maXJzdFBvcygpLFxuICAgICAgZW5kOiBsaW5lcy5sYXN0UG9zKCksXG4gICAgICBsaW5lcyxcbiAgICAgIGluZGVudDogMFxuICAgIH07XG4gIH0gZWxzZSBpZiAoYXN0LnR5cGUgPT09IFwiRmlsZVwiKSB7XG4gICAgZmlsZSA9IGFzdDtcbiAgICBwcm9ncmFtID0gZmlsZS5wcm9ncmFtO1xuICB9XG4gIGlmIChvcHRpb25zLnRva2Vucykge1xuICAgIGZpbGUudG9rZW5zID0gdG9rZW5zO1xuICB9XG4gIGNvbnN0IHRydWVQcm9ncmFtTG9jID0gZ2V0VHJ1ZUxvYyhcbiAgICB7XG4gICAgICB0eXBlOiBwcm9ncmFtLnR5cGUsXG4gICAgICBsb2M6IHByb2dyYW0ubG9jLFxuICAgICAgYm9keTogW10sXG4gICAgICBjb21tZW50c1xuICAgIH0sXG4gICAgbGluZXNcbiAgKTtcbiAgcHJvZ3JhbS5sb2Muc3RhcnQgPSB0cnVlUHJvZ3JhbUxvYy5zdGFydDtcbiAgcHJvZ3JhbS5sb2MuZW5kID0gdHJ1ZVByb2dyYW1Mb2MuZW5kO1xuICBhdHRhY2goY29tbWVudHMsIHByb2dyYW0uYm9keS5sZW5ndGggPyBmaWxlLnByb2dyYW0gOiBmaWxlLCBsaW5lcyk7XG4gIHJldHVybiBuZXcgVHJlZUNvcGllcihsaW5lcywgdG9rZW5zKS5jb3B5KGZpbGUpO1xufVxuY29uc3QgVHJlZUNvcGllciA9IGZ1bmN0aW9uIFRyZWVDb3BpZXIyKGxpbmVzLCB0b2tlbnMpIHtcbiAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgdGhpcy5zdGFydFRva2VuSW5kZXggPSAwO1xuICB0aGlzLmVuZFRva2VuSW5kZXggPSB0b2tlbnMubGVuZ3RoO1xuICB0aGlzLmluZGVudCA9IDA7XG4gIHRoaXMuc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG59O1xuY29uc3QgVENwID0gVHJlZUNvcGllci5wcm90b3R5cGU7XG5UQ3AuY29weSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKHRoaXMuc2Vlbi5oYXMobm9kZSkpIHtcbiAgICByZXR1cm4gdGhpcy5zZWVuLmdldChub2RlKTtcbiAgfVxuICBpZiAoaXNBcnJheSQyLmNoZWNrKG5vZGUpKSB7XG4gICAgY29uc3QgY29weTIgPSBuZXcgQXJyYXkobm9kZS5sZW5ndGgpO1xuICAgIHRoaXMuc2Vlbi5zZXQobm9kZSwgY29weTIpO1xuICAgIG5vZGUuZm9yRWFjaChmdW5jdGlvbihpdGVtLCBpKSB7XG4gICAgICBjb3B5MltpXSA9IHRoaXMuY29weShpdGVtKTtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gY29weTI7XG4gIH1cbiAgaWYgKCFpc09iamVjdCQyLmNoZWNrKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZml4RmF1bHR5TG9jYXRpb25zKG5vZGUsIHRoaXMubGluZXMpO1xuICBjb25zdCBjb3B5ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yobm9kZSksIHtcbiAgICBvcmlnaW5hbDoge1xuICAgICAgLy8gUHJvdmlkZSBhIGxpbmsgZnJvbSB0aGUgY29weSB0byB0aGUgb3JpZ2luYWwuXG4gICAgICB2YWx1ZTogbm9kZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgdGhpcy5zZWVuLnNldChub2RlLCBjb3B5KTtcbiAgY29uc3QgbG9jID0gbm9kZS5sb2M7XG4gIGNvbnN0IG9sZEluZGVudCA9IHRoaXMuaW5kZW50O1xuICBsZXQgbmV3SW5kZW50ID0gb2xkSW5kZW50O1xuICBjb25zdCBvbGRTdGFydFRva2VuSW5kZXggPSB0aGlzLnN0YXJ0VG9rZW5JbmRleDtcbiAgY29uc3Qgb2xkRW5kVG9rZW5JbmRleCA9IHRoaXMuZW5kVG9rZW5JbmRleDtcbiAgaWYgKGxvYykge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQmxvY2tcIiB8fCBub2RlLnR5cGUgPT09IFwiTGluZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJDb21tZW50QmxvY2tcIiB8fCBub2RlLnR5cGUgPT09IFwiQ29tbWVudExpbmVcIiB8fCB0aGlzLmxpbmVzLmlzUHJlY2VkZWRPbmx5QnlXaGl0ZXNwYWNlKGxvYy5zdGFydCkpIHtcbiAgICAgIG5ld0luZGVudCA9IHRoaXMuaW5kZW50ID0gbG9jLnN0YXJ0LmNvbHVtbjtcbiAgICB9XG4gICAgbG9jLmxpbmVzID0gdGhpcy5saW5lcztcbiAgICBsb2MudG9rZW5zID0gdGhpcy50b2tlbnM7XG4gICAgbG9jLmluZGVudCA9IG5ld0luZGVudDtcbiAgICB0aGlzLmZpbmRUb2tlblJhbmdlKGxvYyk7XG4gIH1cbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUpO1xuICBjb25zdCBrZXlDb3VudCA9IGtleXMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGtleUNvdW50OyArK2kpIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChrZXkgPT09IFwibG9jXCIpIHtcbiAgICAgIGNvcHlba2V5XSA9IG5vZGVba2V5XTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJ0b2tlbnNcIiAmJiBub2RlLnR5cGUgPT09IFwiRmlsZVwiKSB7XG4gICAgICBjb3B5W2tleV0gPSBub2RlW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvcHlba2V5XSA9IHRoaXMuY29weShub2RlW2tleV0pO1xuICAgIH1cbiAgfVxuICB0aGlzLmluZGVudCA9IG9sZEluZGVudDtcbiAgdGhpcy5zdGFydFRva2VuSW5kZXggPSBvbGRTdGFydFRva2VuSW5kZXg7XG4gIHRoaXMuZW5kVG9rZW5JbmRleCA9IG9sZEVuZFRva2VuSW5kZXg7XG4gIHJldHVybiBjb3B5O1xufTtcblRDcC5maW5kVG9rZW5SYW5nZSA9IGZ1bmN0aW9uKGxvYykge1xuICB3aGlsZSAodGhpcy5zdGFydFRva2VuSW5kZXggPiAwKSB7XG4gICAgY29uc3QgdG9rZW4gPSBsb2MudG9rZW5zW3RoaXMuc3RhcnRUb2tlbkluZGV4XTtcbiAgICBpZiAoY29tcGFyZVBvcyhsb2Muc3RhcnQsIHRva2VuLmxvYy5zdGFydCkgPCAwKSB7XG4gICAgICAtLXRoaXMuc3RhcnRUb2tlbkluZGV4O1xuICAgIH0gZWxzZVxuICAgICAgYnJlYWs7XG4gIH1cbiAgd2hpbGUgKHRoaXMuZW5kVG9rZW5JbmRleCA8IGxvYy50b2tlbnMubGVuZ3RoKSB7XG4gICAgY29uc3QgdG9rZW4gPSBsb2MudG9rZW5zW3RoaXMuZW5kVG9rZW5JbmRleF07XG4gICAgaWYgKGNvbXBhcmVQb3ModG9rZW4ubG9jLmVuZCwgbG9jLmVuZCkgPCAwKSB7XG4gICAgICArK3RoaXMuZW5kVG9rZW5JbmRleDtcbiAgICB9IGVsc2VcbiAgICAgIGJyZWFrO1xuICB9XG4gIHdoaWxlICh0aGlzLnN0YXJ0VG9rZW5JbmRleCA8IHRoaXMuZW5kVG9rZW5JbmRleCkge1xuICAgIGNvbnN0IHRva2VuID0gbG9jLnRva2Vuc1t0aGlzLnN0YXJ0VG9rZW5JbmRleF07XG4gICAgaWYgKGNvbXBhcmVQb3ModG9rZW4ubG9jLnN0YXJ0LCBsb2Muc3RhcnQpIDwgMCkge1xuICAgICAgKyt0aGlzLnN0YXJ0VG9rZW5JbmRleDtcbiAgICB9IGVsc2VcbiAgICAgIGJyZWFrO1xuICB9XG4gIGxvYy5zdGFydC50b2tlbiA9IHRoaXMuc3RhcnRUb2tlbkluZGV4O1xuICB3aGlsZSAodGhpcy5lbmRUb2tlbkluZGV4ID4gdGhpcy5zdGFydFRva2VuSW5kZXgpIHtcbiAgICBjb25zdCB0b2tlbiA9IGxvYy50b2tlbnNbdGhpcy5lbmRUb2tlbkluZGV4IC0gMV07XG4gICAgaWYgKGNvbXBhcmVQb3MobG9jLmVuZCwgdG9rZW4ubG9jLmVuZCkgPCAwKSB7XG4gICAgICAtLXRoaXMuZW5kVG9rZW5JbmRleDtcbiAgICB9IGVsc2VcbiAgICAgIGJyZWFrO1xuICB9XG4gIGxvYy5lbmQudG9rZW4gPSB0aGlzLmVuZFRva2VuSW5kZXg7XG59O1xuXG5jb25zdCBuID0gbmFtZWRUeXBlcyQxO1xuY29uc3QgaXNBcnJheSQxID0gYnVpbHRJblR5cGVzLmFycmF5O1xuY29uc3QgaXNOdW1iZXIgPSBidWlsdEluVHlwZXMubnVtYmVyO1xuY29uc3QgUFJFQ0VERU5DRSA9IHt9O1xuW1xuICBbXCI/P1wiXSxcbiAgW1wifHxcIl0sXG4gIFtcIiYmXCJdLFxuICBbXCJ8XCJdLFxuICBbXCJeXCJdLFxuICBbXCImXCJdLFxuICBbXCI9PVwiLCBcIj09PVwiLCBcIiE9XCIsIFwiIT09XCJdLFxuICBbXCI8XCIsIFwiPlwiLCBcIjw9XCIsIFwiPj1cIiwgXCJpblwiLCBcImluc3RhbmNlb2ZcIl0sXG4gIFtcIj4+XCIsIFwiPDxcIiwgXCI+Pj5cIl0sXG4gIFtcIitcIiwgXCItXCJdLFxuICBbXCIqXCIsIFwiL1wiLCBcIiVcIl0sXG4gIFtcIioqXCJdXG5dLmZvckVhY2goZnVuY3Rpb24odGllciwgaSkge1xuICB0aWVyLmZvckVhY2goZnVuY3Rpb24ob3ApIHtcbiAgICBQUkVDRURFTkNFW29wXSA9IGk7XG4gIH0pO1xufSk7XG5jb25zdCBGYXN0UGF0aCA9IGZ1bmN0aW9uIEZhc3RQYXRoMih2YWx1ZSkge1xuICB0aGlzLnN0YWNrID0gW3ZhbHVlXTtcbn07XG5jb25zdCBGUHAgPSBGYXN0UGF0aC5wcm90b3R5cGU7XG5GYXN0UGF0aC5mcm9tID0gZnVuY3Rpb24ob2JqKSB7XG4gIGlmIChvYmogaW5zdGFuY2VvZiBGYXN0UGF0aCkge1xuICAgIHJldHVybiBvYmouY29weSgpO1xuICB9XG4gIGlmIChvYmogaW5zdGFuY2VvZiBOb2RlUGF0aCkge1xuICAgIGNvbnN0IGNvcHkyID0gT2JqZWN0LmNyZWF0ZShGYXN0UGF0aC5wcm90b3R5cGUpO1xuICAgIGNvbnN0IHN0YWNrID0gW29iai52YWx1ZV07XG4gICAgZm9yIChsZXQgcHA7IHBwID0gb2JqLnBhcmVudFBhdGg7IG9iaiA9IHBwKVxuICAgICAgc3RhY2sucHVzaChvYmoubmFtZSwgcHAudmFsdWUpO1xuICAgIGNvcHkyLnN0YWNrID0gc3RhY2sucmV2ZXJzZSgpO1xuICAgIHJldHVybiBjb3B5MjtcbiAgfVxuICByZXR1cm4gbmV3IEZhc3RQYXRoKG9iaik7XG59O1xuRlBwLmNvcHkgPSBmdW5jdGlvbiBjb3B5KCkge1xuICBjb25zdCBjb3B5MiA9IE9iamVjdC5jcmVhdGUoRmFzdFBhdGgucHJvdG90eXBlKTtcbiAgY29weTIuc3RhY2sgPSB0aGlzLnN0YWNrLnNsaWNlKDApO1xuICByZXR1cm4gY29weTI7XG59O1xuRlBwLmdldE5hbWUgPSBmdW5jdGlvbiBnZXROYW1lKCkge1xuICBjb25zdCBzID0gdGhpcy5zdGFjaztcbiAgY29uc3QgbGVuID0gcy5sZW5ndGg7XG4gIGlmIChsZW4gPiAxKSB7XG4gICAgcmV0dXJuIHNbbGVuIC0gMl07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuRlBwLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gIGNvbnN0IHMgPSB0aGlzLnN0YWNrO1xuICByZXR1cm4gc1tzLmxlbmd0aCAtIDFdO1xufTtcbkZQcC52YWx1ZUlzRHVwbGljYXRlID0gZnVuY3Rpb24oKSB7XG4gIGNvbnN0IHMgPSB0aGlzLnN0YWNrO1xuICBjb25zdCB2YWx1ZUluZGV4ID0gcy5sZW5ndGggLSAxO1xuICByZXR1cm4gcy5sYXN0SW5kZXhPZihzW3ZhbHVlSW5kZXhdLCB2YWx1ZUluZGV4IC0gMSkgPj0gMDtcbn07XG5mdW5jdGlvbiBnZXROb2RlSGVscGVyKHBhdGgsIGNvdW50KSB7XG4gIGNvbnN0IHMgPSBwYXRoLnN0YWNrO1xuICBmb3IgKGxldCBpID0gcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgIGNvbnN0IHZhbHVlID0gc1tpXTtcbiAgICBpZiAobi5Ob2RlLmNoZWNrKHZhbHVlKSAmJiAtLWNvdW50IDwgMCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbkZQcC5nZXROb2RlID0gZnVuY3Rpb24gZ2V0Tm9kZShjb3VudCA9IDApIHtcbiAgcmV0dXJuIGdldE5vZGVIZWxwZXIodGhpcywgfn5jb3VudCk7XG59O1xuRlBwLmdldFBhcmVudE5vZGUgPSBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGNvdW50ID0gMCkge1xuICByZXR1cm4gZ2V0Tm9kZUhlbHBlcih0aGlzLCB+fmNvdW50ICsgMSk7XG59O1xuRlBwLmdldFJvb3RWYWx1ZSA9IGZ1bmN0aW9uIGdldFJvb3RWYWx1ZSgpIHtcbiAgY29uc3QgcyA9IHRoaXMuc3RhY2s7XG4gIGlmIChzLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICByZXR1cm4gc1sxXTtcbiAgfVxuICByZXR1cm4gc1swXTtcbn07XG5GUHAuY2FsbCA9IGZ1bmN0aW9uIGNhbGwoY2FsbGJhY2spIHtcbiAgY29uc3QgcyA9IHRoaXMuc3RhY2s7XG4gIGNvbnN0IG9yaWdMZW4gPSBzLmxlbmd0aDtcbiAgbGV0IHZhbHVlID0gc1tvcmlnTGVuIC0gMV07XG4gIGNvbnN0IGFyZ2MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGFyZ2M7ICsraSkge1xuICAgIGNvbnN0IG5hbWUgPSBhcmd1bWVudHNbaV07XG4gICAgdmFsdWUgPSB2YWx1ZVtuYW1lXTtcbiAgICBzLnB1c2gobmFtZSwgdmFsdWUpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IGNhbGxiYWNrKHRoaXMpO1xuICBzLmxlbmd0aCA9IG9yaWdMZW47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuRlBwLmVhY2ggPSBmdW5jdGlvbiBlYWNoKGNhbGxiYWNrKSB7XG4gIGNvbnN0IHMgPSB0aGlzLnN0YWNrO1xuICBjb25zdCBvcmlnTGVuID0gcy5sZW5ndGg7XG4gIGxldCB2YWx1ZSA9IHNbb3JpZ0xlbiAtIDFdO1xuICBjb25zdCBhcmdjID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdjOyArK2kpIHtcbiAgICBjb25zdCBuYW1lID0gYXJndW1lbnRzW2ldO1xuICAgIHZhbHVlID0gdmFsdWVbbmFtZV07XG4gICAgcy5wdXNoKG5hbWUsIHZhbHVlKTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGkgaW4gdmFsdWUpIHtcbiAgICAgIHMucHVzaChpLCB2YWx1ZVtpXSk7XG4gICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICAgIHMubGVuZ3RoIC09IDI7XG4gICAgfVxuICB9XG4gIHMubGVuZ3RoID0gb3JpZ0xlbjtcbn07XG5GUHAubWFwID0gZnVuY3Rpb24gbWFwKGNhbGxiYWNrKSB7XG4gIGNvbnN0IHMgPSB0aGlzLnN0YWNrO1xuICBjb25zdCBvcmlnTGVuID0gcy5sZW5ndGg7XG4gIGxldCB2YWx1ZSA9IHNbb3JpZ0xlbiAtIDFdO1xuICBjb25zdCBhcmdjID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdjOyArK2kpIHtcbiAgICBjb25zdCBuYW1lID0gYXJndW1lbnRzW2ldO1xuICAgIHZhbHVlID0gdmFsdWVbbmFtZV07XG4gICAgcy5wdXNoKG5hbWUsIHZhbHVlKTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkodmFsdWUubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpIGluIHZhbHVlKSB7XG4gICAgICBzLnB1c2goaSwgdmFsdWVbaV0pO1xuICAgICAgcmVzdWx0W2ldID0gY2FsbGJhY2sodGhpcywgaSk7XG4gICAgICBzLmxlbmd0aCAtPSAyO1xuICAgIH1cbiAgfVxuICBzLmxlbmd0aCA9IG9yaWdMZW47XG4gIHJldHVybiByZXN1bHQ7XG59O1xuRlBwLmhhc1BhcmVucyA9IGZ1bmN0aW9uKCkge1xuICBjb25zdCBub2RlID0gdGhpcy5nZXROb2RlKCk7XG4gIGNvbnN0IHByZXZUb2tlbiA9IHRoaXMuZ2V0UHJldlRva2VuKG5vZGUpO1xuICBpZiAoIXByZXZUb2tlbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLmdldE5leHRUb2tlbihub2RlKTtcbiAgaWYgKCFuZXh0VG9rZW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHByZXZUb2tlbi52YWx1ZSA9PT0gXCIoXCIpIHtcbiAgICBpZiAobmV4dFRva2VuLnZhbHVlID09PSBcIilcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGp1c3ROZWVkc09wZW5pbmdQYXJlbiA9ICF0aGlzLmNhbkJlRmlyc3RJblN0YXRlbWVudCgpICYmIHRoaXMuZmlyc3RJblN0YXRlbWVudCgpICYmICF0aGlzLm5lZWRzUGFyZW5zKHRydWUpO1xuICAgIGlmIChqdXN0TmVlZHNPcGVuaW5nUGFyZW4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuRlBwLmdldFByZXZUb2tlbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgbm9kZSA9IG5vZGUgfHwgdGhpcy5nZXROb2RlKCk7XG4gIGNvbnN0IGxvYyA9IG5vZGUgJiYgbm9kZS5sb2M7XG4gIGNvbnN0IHRva2VucyA9IGxvYyAmJiBsb2MudG9rZW5zO1xuICBpZiAodG9rZW5zICYmIGxvYy5zdGFydC50b2tlbiA+IDApIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tsb2Muc3RhcnQudG9rZW4gLSAxXTtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGNvbnN0IHJvb3RMb2MgPSB0aGlzLmdldFJvb3RWYWx1ZSgpLmxvYztcbiAgICAgIGlmIChjb21wYXJlUG9zKHJvb3RMb2Muc3RhcnQsIHRva2VuLmxvYy5zdGFydCkgPD0gMCkge1xuICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufTtcbkZQcC5nZXROZXh0VG9rZW4gPSBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUgPSBub2RlIHx8IHRoaXMuZ2V0Tm9kZSgpO1xuICBjb25zdCBsb2MgPSBub2RlICYmIG5vZGUubG9jO1xuICBjb25zdCB0b2tlbnMgPSBsb2MgJiYgbG9jLnRva2VucztcbiAgaWYgKHRva2VucyAmJiBsb2MuZW5kLnRva2VuIDwgdG9rZW5zLmxlbmd0aCkge1xuICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2xvYy5lbmQudG9rZW5dO1xuICAgIGlmICh0b2tlbikge1xuICAgICAgY29uc3Qgcm9vdExvYyA9IHRoaXMuZ2V0Um9vdFZhbHVlKCkubG9jO1xuICAgICAgaWYgKGNvbXBhcmVQb3ModG9rZW4ubG9jLmVuZCwgcm9vdExvYy5lbmQpIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5GUHAubmVlZHNQYXJlbnMgPSBmdW5jdGlvbihhc3N1bWVFeHByZXNzaW9uQ29udGV4dCkge1xuICBjb25zdCBub2RlID0gdGhpcy5nZXROb2RlKCk7XG4gIGlmIChub2RlLnR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiAmJiBub2RlLmxlZnQudHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudE5vZGUoKTtcbiAgY29uc3QgbmFtZSA9IHRoaXMuZ2V0TmFtZSgpO1xuICBpZiAodGhpcy5nZXRWYWx1ZSgpICE9PSBub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChuLlN0YXRlbWVudC5jaGVjayhub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobm9kZS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5vZGUuZXh0cmEgJiYgbm9kZS5leHRyYS5wYXJlbnRoZXNpemVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFwYXJlbnQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAobm9kZS50eXBlID09PSBcIlVuYXJ5RXhwcmVzc2lvblwiICYmIHBhcmVudC50eXBlID09PSBcIkJpbmFyeUV4cHJlc3Npb25cIiAmJiBuYW1lID09PSBcImxlZnRcIiAmJiBwYXJlbnQubGVmdCA9PT0gbm9kZSAmJiBwYXJlbnQub3BlcmF0b3IgPT09IFwiKipcIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgY2FzZSBcIlNwcmVhZFByb3BlcnR5XCI6XG4gICAgICByZXR1cm4gcGFyZW50LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIG5hbWUgPT09IFwib2JqZWN0XCIgJiYgcGFyZW50Lm9iamVjdCA9PT0gbm9kZTtcbiAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOlxuICAgICAgc3dpdGNoIChwYXJlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFwiQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJjYWxsZWVcIiAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlO1xuICAgICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIGNhc2UgXCJTcHJlYWRQcm9wZXJ0eVwiOlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICAgIHJldHVybiBuYW1lID09PSBcIm9iamVjdFwiICYmIHBhcmVudC5vYmplY3QgPT09IG5vZGU7XG4gICAgICAgIGNhc2UgXCJCaW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJMb2dpY2FsRXhwcmVzc2lvblwiOiB7XG4gICAgICAgICAgY29uc3QgcG8gPSBwYXJlbnQub3BlcmF0b3I7XG4gICAgICAgICAgY29uc3QgcHAgPSBQUkVDRURFTkNFW3BvXTtcbiAgICAgICAgICBjb25zdCBubyA9IG5vZGUub3BlcmF0b3I7XG4gICAgICAgICAgY29uc3QgbnAgPSBQUkVDRURFTkNFW25vXTtcbiAgICAgICAgICBpZiAocHAgPiBucCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcCA9PT0gbnAgJiYgbmFtZSA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiU2VxdWVuY2VFeHByZXNzaW9uXCI6XG4gICAgICBzd2l0Y2ggKHBhcmVudC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJSZXR1cm5TdGF0ZW1lbnRcIjpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgXCJGb3JTdGF0ZW1lbnRcIjpcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6XG4gICAgICAgICAgcmV0dXJuIG5hbWUgIT09IFwiZXhwcmVzc2lvblwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIGNhc2UgXCJPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlXCI6XG4gICAgICByZXR1cm4gbm9kZS5vcHRpb25hbCAmJiBwYXJlbnQudHlwZSA9PT0gXCJJbmRleGVkQWNjZXNzVHlwZVwiO1xuICAgIGNhc2UgXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJVbmlvblR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICByZXR1cm4gcGFyZW50LnR5cGUgPT09IFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiO1xuICAgIGNhc2UgXCJMaXRlcmFsXCI6XG4gICAgICByZXR1cm4gcGFyZW50LnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiICYmIGlzTnVtYmVyLmNoZWNrKG5vZGUudmFsdWUpICYmIG5hbWUgPT09IFwib2JqZWN0XCIgJiYgcGFyZW50Lm9iamVjdCA9PT0gbm9kZTtcbiAgICBjYXNlIFwiTnVtZXJpY0xpdGVyYWxcIjpcbiAgICAgIHJldHVybiBwYXJlbnQudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgbmFtZSA9PT0gXCJvYmplY3RcIiAmJiBwYXJlbnQub2JqZWN0ID09PSBub2RlO1xuICAgIGNhc2UgXCJZaWVsZEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQXdhaXRFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgICAgc3dpdGNoIChwYXJlbnQudHlwZSkge1xuICAgICAgICBjYXNlIFwiVW5hcnlFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIGNhc2UgXCJTcHJlYWRQcm9wZXJ0eVwiOlxuICAgICAgICBjYXNlIFwiQmluYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6XG4gICAgICAgICAgcmV0dXJuIG5hbWUgPT09IFwiY2FsbGVlXCIgJiYgcGFyZW50LmNhbGxlZSA9PT0gbm9kZTtcbiAgICAgICAgY2FzZSBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIHJldHVybiBuYW1lID09PSBcInRlc3RcIiAmJiBwYXJlbnQudGVzdCA9PT0gbm9kZTtcbiAgICAgICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gXCJvYmplY3RcIiAmJiBwYXJlbnQub2JqZWN0ID09PSBub2RlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChuLkNhbGxFeHByZXNzaW9uLmNoZWNrKHBhcmVudCkgJiYgbmFtZSA9PT0gXCJjYWxsZWVcIiAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKG4uTWVtYmVyRXhwcmVzc2lvbi5jaGVjayhwYXJlbnQpICYmIG5hbWUgPT09IFwib2JqZWN0XCIgJiYgcGFyZW50Lm9iamVjdCA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChuLlRTQXNFeHByZXNzaW9uICYmIG4uVFNBc0V4cHJlc3Npb24uY2hlY2socGFyZW50KSAmJiBuYW1lID09PSBcImV4cHJlc3Npb25cIiAmJiBwYXJlbnQuZXhwcmVzc2lvbiA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0JpbmFyeShwYXJlbnQpO1xuICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICBpZiAocGFyZW50LnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiAmJiBuYW1lID09PSBcImJvZHlcIiAmJiBwYXJlbnQuYm9keSA9PT0gbm9kZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKHBhcmVudC50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgbmFtZSA9PT0gXCJib2R5XCIgJiYgcGFyZW50LmJvZHkgPT09IG5vZGUgJiYgbm9kZS5leHByZXNzaW9uLnR5cGUgPT09IFwiT2JqZWN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICBpZiAobmFtZSA9PT0gXCJkZWNsYXJhdGlvblwiICYmIG4uRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uLmNoZWNrKHBhcmVudCkgJiYgbi5GdW5jdGlvbkV4cHJlc3Npb24uY2hlY2sobm9kZS5jYWxsZWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICB9XG4gIGlmIChwYXJlbnQudHlwZSA9PT0gXCJOZXdFeHByZXNzaW9uXCIgJiYgbmFtZSA9PT0gXCJjYWxsZWVcIiAmJiBwYXJlbnQuY2FsbGVlID09PSBub2RlKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zQ2FsbEV4cHJlc3Npb24obm9kZSk7XG4gIH1cbiAgaWYgKGFzc3VtZUV4cHJlc3Npb25Db250ZXh0ICE9PSB0cnVlICYmICF0aGlzLmNhbkJlRmlyc3RJblN0YXRlbWVudCgpICYmIHRoaXMuZmlyc3RJblN0YXRlbWVudCgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbmZ1bmN0aW9uIGlzQmluYXJ5KG5vZGUpIHtcbiAgcmV0dXJuIG4uQmluYXJ5RXhwcmVzc2lvbi5jaGVjayhub2RlKSB8fCBuLkxvZ2ljYWxFeHByZXNzaW9uLmNoZWNrKG5vZGUpO1xufVxuZnVuY3Rpb24gY29udGFpbnNDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gIGlmIChuLkNhbGxFeHByZXNzaW9uLmNoZWNrKG5vZGUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkkMS5jaGVjayhub2RlKSkge1xuICAgIHJldHVybiBub2RlLnNvbWUoY29udGFpbnNDYWxsRXhwcmVzc2lvbik7XG4gIH1cbiAgaWYgKG4uTm9kZS5jaGVjayhub2RlKSkge1xuICAgIHJldHVybiBzb21lRmllbGQoXG4gICAgICBub2RlLFxuICAgICAgKF9uYW1lLCBjaGlsZCkgPT4gY29udGFpbnNDYWxsRXhwcmVzc2lvbihjaGlsZClcbiAgICApO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbkZQcC5jYW5CZUZpcnN0SW5TdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Tm9kZSgpO1xuICBpZiAobi5GdW5jdGlvbkV4cHJlc3Npb24uY2hlY2sobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG4uT2JqZWN0RXhwcmVzc2lvbi5jaGVjayhub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAobi5DbGFzc0V4cHJlc3Npb24uY2hlY2sobm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuRlBwLmZpcnN0SW5TdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgY29uc3QgcyA9IHRoaXMuc3RhY2s7XG4gIGxldCBwYXJlbnROYW1lLCBwYXJlbnQ7XG4gIGxldCBjaGlsZE5hbWUsIGNoaWxkO1xuICBmb3IgKGxldCBpID0gcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMikge1xuICAgIGlmIChuLk5vZGUuY2hlY2soc1tpXSkpIHtcbiAgICAgIGNoaWxkTmFtZSA9IHBhcmVudE5hbWU7XG4gICAgICBjaGlsZCA9IHBhcmVudDtcbiAgICAgIHBhcmVudE5hbWUgPSBzW2kgLSAxXTtcbiAgICAgIHBhcmVudCA9IHNbaV07XG4gICAgfVxuICAgIGlmICghcGFyZW50IHx8ICFjaGlsZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChuLkJsb2NrU3RhdGVtZW50LmNoZWNrKHBhcmVudCkgJiYgcGFyZW50TmFtZSA9PT0gXCJib2R5XCIgJiYgY2hpbGROYW1lID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG4uRXhwcmVzc2lvblN0YXRlbWVudC5jaGVjayhwYXJlbnQpICYmIGNoaWxkTmFtZSA9PT0gXCJleHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobi5Bc3NpZ25tZW50RXhwcmVzc2lvbi5jaGVjayhwYXJlbnQpICYmIGNoaWxkTmFtZSA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobi5BcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbi5jaGVjayhwYXJlbnQpICYmIGNoaWxkTmFtZSA9PT0gXCJib2R5XCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobi5TZXF1ZW5jZUV4cHJlc3Npb24uY2hlY2socGFyZW50KSAmJiBzW2kgKyAxXSA9PT0gXCJleHByZXNzaW9uc1wiICYmIGNoaWxkTmFtZSA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChuLkNhbGxFeHByZXNzaW9uLmNoZWNrKHBhcmVudCkgJiYgY2hpbGROYW1lID09PSBcImNhbGxlZVwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG4uTWVtYmVyRXhwcmVzc2lvbi5jaGVjayhwYXJlbnQpICYmIGNoaWxkTmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChuLkNvbmRpdGlvbmFsRXhwcmVzc2lvbi5jaGVjayhwYXJlbnQpICYmIGNoaWxkTmFtZSA9PT0gXCJ0ZXN0XCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaXNCaW5hcnkocGFyZW50KSAmJiBjaGlsZE5hbWUgPT09IFwibGVmdFwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG4uVW5hcnlFeHByZXNzaW9uLmNoZWNrKHBhcmVudCkgJiYgIXBhcmVudC5wcmVmaXggJiYgY2hpbGROYW1lID09PSBcImFyZ3VtZW50XCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBQcmludGFibGUgPSBuYW1lZFR5cGVzJDEuUHJpbnRhYmxlO1xuY29uc3QgRXhwcmVzc2lvbiA9IG5hbWVkVHlwZXMkMS5FeHByZXNzaW9uO1xuY29uc3QgUmV0dXJuU3RhdGVtZW50ID0gbmFtZWRUeXBlcyQxLlJldHVyblN0YXRlbWVudDtcbmNvbnN0IFNvdXJjZUxvY2F0aW9uID0gbmFtZWRUeXBlcyQxLlNvdXJjZUxvY2F0aW9uO1xuY29uc3QgaXNPYmplY3QkMSA9IGJ1aWx0SW5UeXBlcy5vYmplY3Q7XG5jb25zdCBpc0FycmF5ID0gYnVpbHRJblR5cGVzLmFycmF5O1xuY29uc3QgaXNTdHJpbmckMSA9IGJ1aWx0SW5UeXBlcy5zdHJpbmc7XG5jb25zdCByaXNreUFkam9pbmluZ0NoYXJFeHAgPSAvWzAtOWEtel8kXS9pO1xuY29uc3QgUGF0Y2hlciA9IGZ1bmN0aW9uIFBhdGNoZXIyKGxpbmVzKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzLCByZXBsYWNlbWVudHMgPSBbXTtcbiAgc2VsZi5yZXBsYWNlID0gZnVuY3Rpb24obG9jLCBsaW5lczIpIHtcbiAgICBpZiAoaXNTdHJpbmckMS5jaGVjayhsaW5lczIpKVxuICAgICAgbGluZXMyID0gZnJvbVN0cmluZyhsaW5lczIpO1xuICAgIHJlcGxhY2VtZW50cy5wdXNoKHtcbiAgICAgIGxpbmVzOiBsaW5lczIsXG4gICAgICBzdGFydDogbG9jLnN0YXJ0LFxuICAgICAgZW5kOiBsb2MuZW5kXG4gICAgfSk7XG4gIH07XG4gIHNlbGYuZ2V0ID0gZnVuY3Rpb24obG9jKSB7XG4gICAgbG9jID0gbG9jIHx8IHtcbiAgICAgIHN0YXJ0OiB7IGxpbmU6IDEsIGNvbHVtbjogMCB9LFxuICAgICAgZW5kOiB7IGxpbmU6IGxpbmVzLmxlbmd0aCwgY29sdW1uOiBsaW5lcy5nZXRMaW5lTGVuZ3RoKGxpbmVzLmxlbmd0aCkgfVxuICAgIH07XG4gICAgbGV0IHNsaWNlRnJvbSA9IGxvYy5zdGFydCwgdG9Db25jYXQgPSBbXTtcbiAgICBmdW5jdGlvbiBwdXNoU2xpY2UoZnJvbSwgdG8pIHtcbiAgICAgIHRvQ29uY2F0LnB1c2gobGluZXMuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgcmVwbGFjZW1lbnRzLnNvcnQoKGEsIGIpID0+IGNvbXBhcmVQb3MoYS5zdGFydCwgYi5zdGFydCkpLmZvckVhY2goZnVuY3Rpb24ocmVwKSB7XG4gICAgICBpZiAoY29tcGFyZVBvcyhzbGljZUZyb20sIHJlcC5zdGFydCkgPiAwKSA7IGVsc2Uge1xuICAgICAgICBwdXNoU2xpY2Uoc2xpY2VGcm9tLCByZXAuc3RhcnQpO1xuICAgICAgICB0b0NvbmNhdC5wdXNoKHJlcC5saW5lcyk7XG4gICAgICAgIHNsaWNlRnJvbSA9IHJlcC5lbmQ7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHVzaFNsaWNlKHNsaWNlRnJvbSwgbG9jLmVuZCk7XG4gICAgcmV0dXJuIGNvbmNhdCh0b0NvbmNhdCk7XG4gIH07XG59O1xuY29uc3QgUHAgPSBQYXRjaGVyLnByb3RvdHlwZTtcblBwLnRyeVRvUmVwcmludENvbW1lbnRzID0gZnVuY3Rpb24obmV3Tm9kZSwgb2xkTm9kZSwgcHJpbnQpIHtcbiAgY29uc3QgcGF0Y2hlciA9IHRoaXM7XG4gIGlmICghbmV3Tm9kZS5jb21tZW50cyAmJiAhb2xkTm9kZS5jb21tZW50cykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG5ld1BhdGggPSBGYXN0UGF0aC5mcm9tKG5ld05vZGUpO1xuICBjb25zdCBvbGRQYXRoID0gRmFzdFBhdGguZnJvbShvbGROb2RlKTtcbiAgbmV3UGF0aC5zdGFjay5wdXNoKFwiY29tbWVudHNcIiwgZ2V0U3Vycm91bmRpbmdDb21tZW50cyhuZXdOb2RlKSk7XG4gIG9sZFBhdGguc3RhY2sucHVzaChcImNvbW1lbnRzXCIsIGdldFN1cnJvdW5kaW5nQ29tbWVudHMob2xkTm9kZSkpO1xuICBjb25zdCByZXByaW50cyA9IFtdO1xuICBjb25zdCBhYmxlVG9SZXByaW50Q29tbWVudHMgPSBmaW5kQXJyYXlSZXByaW50cyhuZXdQYXRoLCBvbGRQYXRoLCByZXByaW50cyk7XG4gIGlmIChhYmxlVG9SZXByaW50Q29tbWVudHMgJiYgcmVwcmludHMubGVuZ3RoID4gMCkge1xuICAgIHJlcHJpbnRzLmZvckVhY2goZnVuY3Rpb24ocmVwcmludCkge1xuICAgICAgY29uc3Qgb2xkQ29tbWVudCA9IHJlcHJpbnQub2xkUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgcGF0Y2hlci5yZXBsYWNlKFxuICAgICAgICBvbGRDb21tZW50LmxvYyxcbiAgICAgICAgLy8gQ29tbWVudHMgY2FuJ3QgaGF2ZSAuY29tbWVudHMsIHNvIGl0IGRvZXNuJ3QgbWF0dGVyIHdoZXRoZXIgd2VcbiAgICAgICAgLy8gcHJpbnQgd2l0aCBjb21tZW50cyBvciB3aXRob3V0LlxuICAgICAgICBwcmludChyZXByaW50Lm5ld1BhdGgpLmluZGVudFRhaWwob2xkQ29tbWVudC5sb2MuaW5kZW50KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYWJsZVRvUmVwcmludENvbW1lbnRzO1xufTtcbmZ1bmN0aW9uIGdldFN1cnJvdW5kaW5nQ29tbWVudHMobm9kZSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgaWYgKG5vZGUuY29tbWVudHMgJiYgbm9kZS5jb21tZW50cy5sZW5ndGggPiAwKSB7XG4gICAgbm9kZS5jb21tZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICAgIGlmIChjb21tZW50LmxlYWRpbmcgfHwgY29tbWVudC50cmFpbGluZykge1xuICAgICAgICByZXN1bHQucHVzaChjb21tZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuUHAuZGVsZXRlQ29tbWVudHMgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmICghbm9kZS5jb21tZW50cykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwYXRjaGVyID0gdGhpcztcbiAgbm9kZS5jb21tZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNvbW1lbnQpIHtcbiAgICBpZiAoY29tbWVudC5sZWFkaW5nKSB7XG4gICAgICBwYXRjaGVyLnJlcGxhY2UoXG4gICAgICAgIHtcbiAgICAgICAgICBzdGFydDogY29tbWVudC5sb2Muc3RhcnQsXG4gICAgICAgICAgZW5kOiBub2RlLmxvYy5saW5lcy5za2lwU3BhY2VzKGNvbW1lbnQubG9jLmVuZCwgZmFsc2UsIGZhbHNlKVxuICAgICAgICB9LFxuICAgICAgICBcIlwiXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoY29tbWVudC50cmFpbGluZykge1xuICAgICAgcGF0Y2hlci5yZXBsYWNlKFxuICAgICAgICB7XG4gICAgICAgICAgc3RhcnQ6IG5vZGUubG9jLmxpbmVzLnNraXBTcGFjZXMoY29tbWVudC5sb2Muc3RhcnQsIHRydWUsIGZhbHNlKSxcbiAgICAgICAgICBlbmQ6IGNvbW1lbnQubG9jLmVuZFxuICAgICAgICB9LFxuICAgICAgICBcIlwiXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG59O1xuZnVuY3Rpb24gZ2V0UmVwcmludGVyKHBhdGgpIHtcbiAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgaWYgKCFQcmludGFibGUuY2hlY2sobm9kZSkpXG4gICAgcmV0dXJuO1xuICBjb25zdCBvcmlnID0gbm9kZS5vcmlnaW5hbDtcbiAgY29uc3Qgb3JpZ0xvYyA9IG9yaWcgJiYgb3JpZy5sb2M7XG4gIGNvbnN0IGxpbmVzID0gb3JpZ0xvYyAmJiBvcmlnTG9jLmxpbmVzO1xuICBjb25zdCByZXByaW50cyA9IFtdO1xuICBpZiAoIWxpbmVzIHx8ICFmaW5kUmVwcmludHMocGF0aCwgcmVwcmludHMpKVxuICAgIHJldHVybjtcbiAgcmV0dXJuIGZ1bmN0aW9uKHByaW50KSB7XG4gICAgY29uc3QgcGF0Y2hlciA9IG5ldyBQYXRjaGVyKGxpbmVzKTtcbiAgICByZXByaW50cy5mb3JFYWNoKGZ1bmN0aW9uKHJlcHJpbnQpIHtcbiAgICAgIGNvbnN0IG5ld05vZGUgPSByZXByaW50Lm5ld1BhdGguZ2V0VmFsdWUoKTtcbiAgICAgIGNvbnN0IG9sZE5vZGUgPSByZXByaW50Lm9sZFBhdGguZ2V0VmFsdWUoKTtcbiAgICAgIFNvdXJjZUxvY2F0aW9uLmFzc2VydChvbGROb2RlLmxvYywgdHJ1ZSk7XG4gICAgICBjb25zdCBuZWVkVG9QcmludE5ld1BhdGhXaXRoQ29tbWVudHMgPSAhcGF0Y2hlci50cnlUb1JlcHJpbnRDb21tZW50cyhcbiAgICAgICAgbmV3Tm9kZSxcbiAgICAgICAgb2xkTm9kZSxcbiAgICAgICAgcHJpbnRcbiAgICAgICk7XG4gICAgICBpZiAobmVlZFRvUHJpbnROZXdQYXRoV2l0aENvbW1lbnRzKSB7XG4gICAgICAgIHBhdGNoZXIuZGVsZXRlQ29tbWVudHMob2xkTm9kZSk7XG4gICAgICB9XG4gICAgICBsZXQgbmV3TGluZXMgPSBwcmludChyZXByaW50Lm5ld1BhdGgsIHtcbiAgICAgICAgaW5jbHVkZUNvbW1lbnRzOiBuZWVkVG9QcmludE5ld1BhdGhXaXRoQ29tbWVudHMsXG4gICAgICAgIC8vIElmIHRoZSBvbGROb2RlIHdlJ3JlIHJlcGxhY2luZyBhbHJlYWR5IGhhZCBwYXJlbnRoZXNlcywgd2UgbWF5XG4gICAgICAgIC8vIG5vdCBuZWVkIHRvIHByaW50IHRoZSBuZXcgbm9kZSB3aXRoIGFueSBleHRyYSBwYXJlbnRoZXNlcyxcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgZXhpc3RpbmcgcGFyZW50aGVzZXMgd2lsbCBzdWZmaWNlLiBIb3dldmVyLCBpZiB0aGVcbiAgICAgICAgLy8gbmV3Tm9kZSBoYXMgYSBkaWZmZXJlbnQgdHlwZSB0aGFuIHRoZSBvbGROb2RlLCBsZXQgdGhlIHByaW50ZXJcbiAgICAgICAgLy8gZGVjaWRlIGlmIHJlcHJpbnQubmV3UGF0aCBuZWVkcyBwYXJlbnRoZXNlcywgYXMgdXN1YWwuXG4gICAgICAgIGF2b2lkUm9vdFBhcmVuczogb2xkTm9kZS50eXBlID09PSBuZXdOb2RlLnR5cGUgJiYgcmVwcmludC5vbGRQYXRoLmhhc1BhcmVucygpXG4gICAgICB9KS5pbmRlbnRUYWlsKG9sZE5vZGUubG9jLmluZGVudCk7XG4gICAgICBjb25zdCBubHMgPSBuZWVkc0xlYWRpbmdTcGFjZShsaW5lcywgb2xkTm9kZS5sb2MsIG5ld0xpbmVzKTtcbiAgICAgIGNvbnN0IG50cyA9IG5lZWRzVHJhaWxpbmdTcGFjZShsaW5lcywgb2xkTm9kZS5sb2MsIG5ld0xpbmVzKTtcbiAgICAgIGlmIChubHMgfHwgbnRzKSB7XG4gICAgICAgIGNvbnN0IG5ld1BhcnRzID0gW107XG4gICAgICAgIG5scyAmJiBuZXdQYXJ0cy5wdXNoKFwiIFwiKTtcbiAgICAgICAgbmV3UGFydHMucHVzaChuZXdMaW5lcyk7XG4gICAgICAgIG50cyAmJiBuZXdQYXJ0cy5wdXNoKFwiIFwiKTtcbiAgICAgICAgbmV3TGluZXMgPSBjb25jYXQobmV3UGFydHMpO1xuICAgICAgfVxuICAgICAgcGF0Y2hlci5yZXBsYWNlKG9sZE5vZGUubG9jLCBuZXdMaW5lcyk7XG4gICAgfSk7XG4gICAgY29uc3QgcGF0Y2hlZExpbmVzID0gcGF0Y2hlci5nZXQob3JpZ0xvYykuaW5kZW50VGFpbCgtb3JpZy5sb2MuaW5kZW50KTtcbiAgICBpZiAocGF0aC5uZWVkc1BhcmVucygpKSB7XG4gICAgICByZXR1cm4gY29uY2F0KFtcIihcIiwgcGF0Y2hlZExpbmVzLCBcIilcIl0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0Y2hlZExpbmVzO1xuICB9O1xufVxuZnVuY3Rpb24gbmVlZHNMZWFkaW5nU3BhY2Uob2xkTGluZXMsIG9sZExvYywgbmV3TGluZXMpIHtcbiAgY29uc3QgcG9zQmVmb3JlT2xkTG9jID0gY29weVBvcyhvbGRMb2Muc3RhcnQpO1xuICBjb25zdCBjaGFyQmVmb3JlT2xkTG9jID0gb2xkTGluZXMucHJldlBvcyhwb3NCZWZvcmVPbGRMb2MpICYmIG9sZExpbmVzLmNoYXJBdChwb3NCZWZvcmVPbGRMb2MpO1xuICBjb25zdCBuZXdGaXJzdENoYXIgPSBuZXdMaW5lcy5jaGFyQXQobmV3TGluZXMuZmlyc3RQb3MoKSk7XG4gIHJldHVybiBjaGFyQmVmb3JlT2xkTG9jICYmIHJpc2t5QWRqb2luaW5nQ2hhckV4cC50ZXN0KGNoYXJCZWZvcmVPbGRMb2MpICYmIG5ld0ZpcnN0Q2hhciAmJiByaXNreUFkam9pbmluZ0NoYXJFeHAudGVzdChuZXdGaXJzdENoYXIpO1xufVxuZnVuY3Rpb24gbmVlZHNUcmFpbGluZ1NwYWNlKG9sZExpbmVzLCBvbGRMb2MsIG5ld0xpbmVzKSB7XG4gIGNvbnN0IGNoYXJBZnRlck9sZExvYyA9IG9sZExpbmVzLmNoYXJBdChvbGRMb2MuZW5kKTtcbiAgY29uc3QgbmV3TGFzdFBvcyA9IG5ld0xpbmVzLmxhc3RQb3MoKTtcbiAgY29uc3QgbmV3TGFzdENoYXIgPSBuZXdMaW5lcy5wcmV2UG9zKG5ld0xhc3RQb3MpICYmIG5ld0xpbmVzLmNoYXJBdChuZXdMYXN0UG9zKTtcbiAgcmV0dXJuIG5ld0xhc3RDaGFyICYmIHJpc2t5QWRqb2luaW5nQ2hhckV4cC50ZXN0KG5ld0xhc3RDaGFyKSAmJiBjaGFyQWZ0ZXJPbGRMb2MgJiYgcmlza3lBZGpvaW5pbmdDaGFyRXhwLnRlc3QoY2hhckFmdGVyT2xkTG9jKTtcbn1cbmZ1bmN0aW9uIGZpbmRSZXByaW50cyhuZXdQYXRoLCByZXByaW50cykge1xuICBjb25zdCBuZXdOb2RlID0gbmV3UGF0aC5nZXRWYWx1ZSgpO1xuICBQcmludGFibGUuYXNzZXJ0KG5ld05vZGUpO1xuICBjb25zdCBvbGROb2RlID0gbmV3Tm9kZS5vcmlnaW5hbDtcbiAgUHJpbnRhYmxlLmFzc2VydChvbGROb2RlKTtcbiAgaWYgKG5ld05vZGUudHlwZSAhPT0gb2xkTm9kZS50eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG9sZFBhdGggPSBuZXcgRmFzdFBhdGgob2xkTm9kZSk7XG4gIGNvbnN0IGNhblJlcHJpbnQgPSBmaW5kQ2hpbGRSZXByaW50cyhuZXdQYXRoLCBvbGRQYXRoLCByZXByaW50cyk7XG4gIGlmICghY2FuUmVwcmludCkge1xuICAgIHJlcHJpbnRzLmxlbmd0aCA9IDA7XG4gIH1cbiAgcmV0dXJuIGNhblJlcHJpbnQ7XG59XG5mdW5jdGlvbiBmaW5kQW55UmVwcmludHMobmV3UGF0aCwgb2xkUGF0aCwgcmVwcmludHMpIHtcbiAgY29uc3QgbmV3Tm9kZSA9IG5ld1BhdGguZ2V0VmFsdWUoKTtcbiAgY29uc3Qgb2xkTm9kZSA9IG9sZFBhdGguZ2V0VmFsdWUoKTtcbiAgaWYgKG5ld05vZGUgPT09IG9sZE5vZGUpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChpc0FycmF5LmNoZWNrKG5ld05vZGUpKVxuICAgIHJldHVybiBmaW5kQXJyYXlSZXByaW50cyhuZXdQYXRoLCBvbGRQYXRoLCByZXByaW50cyk7XG4gIGlmIChpc09iamVjdCQxLmNoZWNrKG5ld05vZGUpKVxuICAgIHJldHVybiBmaW5kT2JqZWN0UmVwcmludHMobmV3UGF0aCwgb2xkUGF0aCwgcmVwcmludHMpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBmaW5kQXJyYXlSZXByaW50cyhuZXdQYXRoLCBvbGRQYXRoLCByZXByaW50cykge1xuICBjb25zdCBuZXdOb2RlID0gbmV3UGF0aC5nZXRWYWx1ZSgpO1xuICBjb25zdCBvbGROb2RlID0gb2xkUGF0aC5nZXRWYWx1ZSgpO1xuICBpZiAobmV3Tm9kZSA9PT0gb2xkTm9kZSB8fCBuZXdQYXRoLnZhbHVlSXNEdXBsaWNhdGUoKSB8fCBvbGRQYXRoLnZhbHVlSXNEdXBsaWNhdGUoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlzQXJyYXkuYXNzZXJ0KG5ld05vZGUpO1xuICBjb25zdCBsZW4gPSBuZXdOb2RlLmxlbmd0aDtcbiAgaWYgKCEoaXNBcnJheS5jaGVjayhvbGROb2RlKSAmJiBvbGROb2RlLmxlbmd0aCA9PT0gbGVuKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBuZXdQYXRoLnN0YWNrLnB1c2goaSwgbmV3Tm9kZVtpXSk7XG4gICAgb2xkUGF0aC5zdGFjay5wdXNoKGksIG9sZE5vZGVbaV0pO1xuICAgIGNvbnN0IGNhblJlcHJpbnQgPSBmaW5kQW55UmVwcmludHMobmV3UGF0aCwgb2xkUGF0aCwgcmVwcmludHMpO1xuICAgIG5ld1BhdGguc3RhY2subGVuZ3RoIC09IDI7XG4gICAgb2xkUGF0aC5zdGFjay5sZW5ndGggLT0gMjtcbiAgICBpZiAoIWNhblJlcHJpbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBmaW5kT2JqZWN0UmVwcmludHMobmV3UGF0aCwgb2xkUGF0aCwgcmVwcmludHMpIHtcbiAgY29uc3QgbmV3Tm9kZSA9IG5ld1BhdGguZ2V0VmFsdWUoKTtcbiAgaXNPYmplY3QkMS5hc3NlcnQobmV3Tm9kZSk7XG4gIGlmIChuZXdOb2RlLm9yaWdpbmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG9sZE5vZGUgPSBvbGRQYXRoLmdldFZhbHVlKCk7XG4gIGlmICghaXNPYmplY3QkMS5jaGVjayhvbGROb2RlKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChuZXdOb2RlID09PSBvbGROb2RlIHx8IG5ld1BhdGgudmFsdWVJc0R1cGxpY2F0ZSgpIHx8IG9sZFBhdGgudmFsdWVJc0R1cGxpY2F0ZSgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKFByaW50YWJsZS5jaGVjayhuZXdOb2RlKSkge1xuICAgIGlmICghUHJpbnRhYmxlLmNoZWNrKG9sZE5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG5ld1BhcmVudE5vZGUgPSBuZXdQYXRoLmdldFBhcmVudE5vZGUoKTtcbiAgICBjb25zdCBvbGRQYXJlbnROb2RlID0gb2xkUGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgaWYgKG9sZFBhcmVudE5vZGUgIT09IG51bGwgJiYgb2xkUGFyZW50Tm9kZS50eXBlID09PSBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiAmJiBuZXdQYXJlbnROb2RlICE9PSBudWxsICYmIG5ld1BhcmVudE5vZGUudHlwZSA9PT0gXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpIHtcbiAgICAgIGNvbnN0IG9sZE5lZWRzUGFyZW5zID0gb2xkUGFyZW50Tm9kZS5wYXJhbXMubGVuZ3RoICE9PSAxIHx8ICEhb2xkUGFyZW50Tm9kZS5wYXJhbXNbMF0ubmFtZTtcbiAgICAgIGNvbnN0IG5ld05lZWRQYXJlbnMgPSBuZXdQYXJlbnROb2RlLnBhcmFtcy5sZW5ndGggIT09IDEgfHwgISFuZXdQYXJlbnROb2RlLnBhcmFtc1swXS5uYW1lO1xuICAgICAgaWYgKCFvbGROZWVkc1BhcmVucyAmJiBuZXdOZWVkUGFyZW5zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5ld05vZGUudHlwZSA9PT0gb2xkTm9kZS50eXBlKSB7XG4gICAgICBjb25zdCBjaGlsZFJlcHJpbnRzID0gW107XG4gICAgICBpZiAoZmluZENoaWxkUmVwcmludHMobmV3UGF0aCwgb2xkUGF0aCwgY2hpbGRSZXByaW50cykpIHtcbiAgICAgICAgcmVwcmludHMucHVzaC5hcHBseShyZXByaW50cywgY2hpbGRSZXByaW50cyk7XG4gICAgICB9IGVsc2UgaWYgKG9sZE5vZGUubG9jKSB7XG4gICAgICAgIHJlcHJpbnRzLnB1c2goe1xuICAgICAgICAgIG9sZFBhdGg6IG9sZFBhdGguY29weSgpLFxuICAgICAgICAgIG5ld1BhdGg6IG5ld1BhdGguY29weSgpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChFeHByZXNzaW9uLmNoZWNrKG5ld05vZGUpICYmIEV4cHJlc3Npb24uY2hlY2sob2xkTm9kZSkgJiYgLy8gSWYgd2UgaGF2ZSBubyAubG9jIGluZm9ybWF0aW9uIGZvciBvbGROb2RlLCB0aGVuIHdlIHdvbid0IGJlXG4gICAgLy8gYWJsZSB0byByZXByaW50IGl0LlxuICAgIG9sZE5vZGUubG9jKSB7XG4gICAgICByZXByaW50cy5wdXNoKHtcbiAgICAgICAgb2xkUGF0aDogb2xkUGF0aC5jb3B5KCksXG4gICAgICAgIG5ld1BhdGg6IG5ld1BhdGguY29weSgpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGZpbmRDaGlsZFJlcHJpbnRzKG5ld1BhdGgsIG9sZFBhdGgsIHJlcHJpbnRzKTtcbn1cbmZ1bmN0aW9uIGZpbmRDaGlsZFJlcHJpbnRzKG5ld1BhdGgsIG9sZFBhdGgsIHJlcHJpbnRzKSB7XG4gIGNvbnN0IG5ld05vZGUgPSBuZXdQYXRoLmdldFZhbHVlKCk7XG4gIGNvbnN0IG9sZE5vZGUgPSBvbGRQYXRoLmdldFZhbHVlKCk7XG4gIGlzT2JqZWN0JDEuYXNzZXJ0KG5ld05vZGUpO1xuICBpc09iamVjdCQxLmFzc2VydChvbGROb2RlKTtcbiAgaWYgKG5ld05vZGUub3JpZ2luYWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5ld1BhdGgubmVlZHNQYXJlbnMoKSAmJiAhb2xkUGF0aC5oYXNQYXJlbnMoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBrZXlzID0gZ2V0VW5pb25PZktleXMob2xkTm9kZSwgbmV3Tm9kZSk7XG4gIGlmIChvbGROb2RlLnR5cGUgPT09IFwiRmlsZVwiIHx8IG5ld05vZGUudHlwZSA9PT0gXCJGaWxlXCIpIHtcbiAgICBkZWxldGUga2V5cy50b2tlbnM7XG4gIH1cbiAgZGVsZXRlIGtleXMubG9jO1xuICBjb25zdCBvcmlnaW5hbFJlcHJpbnRDb3VudCA9IHJlcHJpbnRzLmxlbmd0aDtcbiAgZm9yIChsZXQgayBpbiBrZXlzKSB7XG4gICAgaWYgKGsuY2hhckF0KDApID09PSBcIl9cIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5ld1BhdGguc3RhY2sucHVzaChrLCBnZXRGaWVsZFZhbHVlKG5ld05vZGUsIGspKTtcbiAgICBvbGRQYXRoLnN0YWNrLnB1c2goaywgZ2V0RmllbGRWYWx1ZShvbGROb2RlLCBrKSk7XG4gICAgY29uc3QgY2FuUmVwcmludCA9IGZpbmRBbnlSZXByaW50cyhuZXdQYXRoLCBvbGRQYXRoLCByZXByaW50cyk7XG4gICAgbmV3UGF0aC5zdGFjay5sZW5ndGggLT0gMjtcbiAgICBvbGRQYXRoLnN0YWNrLmxlbmd0aCAtPSAyO1xuICAgIGlmICghY2FuUmVwcmludCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBpZiAoUmV0dXJuU3RhdGVtZW50LmNoZWNrKG5ld1BhdGguZ2V0Tm9kZSgpKSAmJiByZXByaW50cy5sZW5ndGggPiBvcmlnaW5hbFJlcHJpbnRDb3VudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuY29uc3QgbmFtZWRUeXBlcyA9IG5hbWVkVHlwZXMkMTtcbmNvbnN0IGlzU3RyaW5nID0gYnVpbHRJblR5cGVzLnN0cmluZztcbmNvbnN0IGlzT2JqZWN0ID0gYnVpbHRJblR5cGVzLm9iamVjdDtcbmNvbnN0IFByaW50UmVzdWx0ID0gZnVuY3Rpb24gUHJpbnRSZXN1bHQyKGNvZGUsIHNvdXJjZU1hcCkge1xuICBpc1N0cmluZy5hc3NlcnQoY29kZSk7XG4gIHRoaXMuY29kZSA9IGNvZGU7XG4gIGlmIChzb3VyY2VNYXApIHtcbiAgICBpc09iamVjdC5hc3NlcnQoc291cmNlTWFwKTtcbiAgICB0aGlzLm1hcCA9IHNvdXJjZU1hcDtcbiAgfVxufTtcbmNvbnN0IFBScCA9IFByaW50UmVzdWx0LnByb3RvdHlwZTtcbmxldCB3YXJuZWRBYm91dFRvU3RyaW5nID0gZmFsc2U7XG5QUnAudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF3YXJuZWRBYm91dFRvU3RyaW5nKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJEZXByZWNhdGlvbiB3YXJuaW5nOiByZWNhc3QucHJpbnQgbm93IHJldHVybnMgYW4gb2JqZWN0IHdpdGggYSAuY29kZSBwcm9wZXJ0eS4gWW91IGFwcGVhciB0byBiZSB0cmVhdGluZyB0aGUgb2JqZWN0IGFzIGEgc3RyaW5nLCB3aGljaCBtaWdodCBzdGlsbCB3b3JrIGJ1dCBpcyBzdHJvbmdseSBkaXNjb3VyYWdlZC5cIlxuICAgICk7XG4gICAgd2FybmVkQWJvdXRUb1N0cmluZyA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHRoaXMuY29kZTtcbn07XG5jb25zdCBlbXB0eVByaW50UmVzdWx0ID0gbmV3IFByaW50UmVzdWx0KFwiXCIpO1xuY29uc3QgUHJpbnRlciA9IGZ1bmN0aW9uIFByaW50ZXIyKGNvbmZpZykge1xuICBjb25zdCBleHBsaWNpdFRhYldpZHRoID0gY29uZmlnICYmIGNvbmZpZy50YWJXaWR0aDtcbiAgY29uZmlnID0gbm9ybWFsaXplKGNvbmZpZyk7XG4gIGNvbmZpZy5zb3VyY2VGaWxlTmFtZSA9IG51bGw7XG4gIGZ1bmN0aW9uIG1ha2VQcmludEZ1bmN0aW9uV2l0aChvcHRpb25zLCBvdmVycmlkZXMpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywgb3ZlcnJpZGVzKTtcbiAgICByZXR1cm4gKHBhdGgpID0+IHByaW50KHBhdGgsIG9wdGlvbnMpO1xuICB9XG4gIGZ1bmN0aW9uIHByaW50KHBhdGgsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlQ29tbWVudHMpIHtcbiAgICAgIHJldHVybiBwcmludENvbW1lbnRzKFxuICAgICAgICBwYXRoLFxuICAgICAgICBtYWtlUHJpbnRGdW5jdGlvbldpdGgob3B0aW9ucywge1xuICAgICAgICAgIGluY2x1ZGVDb21tZW50czogZmFsc2VcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IG9sZFRhYldpZHRoID0gY29uZmlnLnRhYldpZHRoO1xuICAgIGlmICghZXhwbGljaXRUYWJXaWR0aCkge1xuICAgICAgY29uc3QgbG9jID0gcGF0aC5nZXROb2RlKCkubG9jO1xuICAgICAgaWYgKGxvYyAmJiBsb2MubGluZXMgJiYgbG9jLmxpbmVzLmd1ZXNzVGFiV2lkdGgpIHtcbiAgICAgICAgY29uZmlnLnRhYldpZHRoID0gbG9jLmxpbmVzLmd1ZXNzVGFiV2lkdGgoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmVwcmludGVyID0gZ2V0UmVwcmludGVyKHBhdGgpO1xuICAgIGNvbnN0IGxpbmVzID0gcmVwcmludGVyID8gKFxuICAgICAgLy8gU2luY2UgdGhlIHByaW50IGZ1bmN0aW9uIHRoYXQgd2UgcGFzcyB0byB0aGUgcmVwcmludGVyIHdpbGxcbiAgICAgIC8vIGJlIHVzZWQgdG8gcHJpbnQgXCJuZXdcIiBub2RlcywgaXQncyB0ZW1wdGluZyB0byB0aGluayB3ZVxuICAgICAgLy8gc2hvdWxkIHBhc3MgcHJpbnRSb290R2VuZXJpY2FsbHkgaW5zdGVhZCBvZiBwcmludCwgdG8gYXZvaWRcbiAgICAgIC8vIGNhbGxpbmcgbWF5YmVSZXByaW50IGFnYWluLCBidXQgdGhhdCB3b3VsZCBiZSBhIG1pc3Rha2VcbiAgICAgIC8vIGJlY2F1c2UgdGhlIG5ldyBub2RlcyBtaWdodCBub3QgYmUgZW50aXJlbHkgbmV3LCBidXQgbWVyZWx5XG4gICAgICAvLyBtb3ZlZCBmcm9tIGVsc2V3aGVyZSBpbiB0aGUgQVNULiBUaGUgcHJpbnQgZnVuY3Rpb24gaXMgdGhlXG4gICAgICAvLyByaWdodCBjaG9pY2UgYmVjYXVzZSBpdCBnaXZlcyB1cyB0aGUgb3Bwb3J0dW5pdHkgdG8gcmVwcmludFxuICAgICAgLy8gc3VjaCBub2RlcyB1c2luZyB0aGVpciBvcmlnaW5hbCBzb3VyY2UuXG4gICAgICByZXByaW50ZXIocHJpbnQpXG4gICAgKSA6IGdlbmVyaWNQcmludChcbiAgICAgIHBhdGgsXG4gICAgICBjb25maWcsXG4gICAgICBvcHRpb25zLFxuICAgICAgbWFrZVByaW50RnVuY3Rpb25XaXRoKG9wdGlvbnMsIHtcbiAgICAgICAgaW5jbHVkZUNvbW1lbnRzOiB0cnVlLFxuICAgICAgICBhdm9pZFJvb3RQYXJlbnM6IGZhbHNlXG4gICAgICB9KVxuICAgICk7XG4gICAgY29uZmlnLnRhYldpZHRoID0gb2xkVGFiV2lkdGg7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG4gIHRoaXMucHJpbnQgPSBmdW5jdGlvbihhc3QpIHtcbiAgICBpZiAoIWFzdCkge1xuICAgICAgcmV0dXJuIGVtcHR5UHJpbnRSZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVzID0gcHJpbnQoRmFzdFBhdGguZnJvbShhc3QpLCB7XG4gICAgICBpbmNsdWRlQ29tbWVudHM6IHRydWUsXG4gICAgICBhdm9pZFJvb3RQYXJlbnM6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBQcmludFJlc3VsdChcbiAgICAgIGxpbmVzLnRvU3RyaW5nKGNvbmZpZyksXG4gICAgICBjb21wb3NlU291cmNlTWFwcyhcbiAgICAgICAgY29uZmlnLmlucHV0U291cmNlTWFwLFxuICAgICAgICBsaW5lcy5nZXRTb3VyY2VNYXAoY29uZmlnLnNvdXJjZU1hcE5hbWUsIGNvbmZpZy5zb3VyY2VSb290KVxuICAgICAgKVxuICAgICk7XG4gIH07XG4gIHRoaXMucHJpbnRHZW5lcmljYWxseSA9IGZ1bmN0aW9uKGFzdCkge1xuICAgIGlmICghYXN0KSB7XG4gICAgICByZXR1cm4gZW1wdHlQcmludFJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJpbnRHZW5lcmljYWxseShwYXRoMikge1xuICAgICAgcmV0dXJuIHByaW50Q29tbWVudHMoXG4gICAgICAgIHBhdGgyLFxuICAgICAgICAocGF0aDMpID0+IGdlbmVyaWNQcmludChcbiAgICAgICAgICBwYXRoMyxcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaW5jbHVkZUNvbW1lbnRzOiB0cnVlLFxuICAgICAgICAgICAgYXZvaWRSb290UGFyZW5zOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcHJpbnRHZW5lcmljYWxseVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gRmFzdFBhdGguZnJvbShhc3QpO1xuICAgIGNvbnN0IG9sZFJldXNlV2hpdGVzcGFjZSA9IGNvbmZpZy5yZXVzZVdoaXRlc3BhY2U7XG4gICAgY29uZmlnLnJldXNlV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgIGNvbnN0IHByID0gbmV3IFByaW50UmVzdWx0KHByaW50R2VuZXJpY2FsbHkocGF0aCkudG9TdHJpbmcoY29uZmlnKSk7XG4gICAgY29uZmlnLnJldXNlV2hpdGVzcGFjZSA9IG9sZFJldXNlV2hpdGVzcGFjZTtcbiAgICByZXR1cm4gcHI7XG4gIH07XG59O1xuZnVuY3Rpb24gZ2VuZXJpY1ByaW50KHBhdGgsIGNvbmZpZywgb3B0aW9ucywgcHJpbnRQYXRoKSB7XG4gIGNvbnN0IG5vZGUgPSBwYXRoLmdldFZhbHVlKCk7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGNvbnN0IGxpbmVzV2l0aG91dFBhcmVucyA9IGdlbmVyaWNQcmludE5vUGFyZW5zKHBhdGgsIGNvbmZpZywgcHJpbnRQYXRoKTtcbiAgaWYgKCFub2RlIHx8IGxpbmVzV2l0aG91dFBhcmVucy5pc0VtcHR5KCkpIHtcbiAgICByZXR1cm4gbGluZXNXaXRob3V0UGFyZW5zO1xuICB9XG4gIGxldCBzaG91bGRBZGRQYXJlbnMgPSBmYWxzZTtcbiAgY29uc3QgZGVjb3JhdG9yc0xpbmVzID0gcHJpbnREZWNvcmF0b3JzKHBhdGgsIHByaW50UGF0aCk7XG4gIGlmIChkZWNvcmF0b3JzTGluZXMuaXNFbXB0eSgpKSB7XG4gICAgaWYgKCFvcHRpb25zLmF2b2lkUm9vdFBhcmVucykge1xuICAgICAgc2hvdWxkQWRkUGFyZW5zID0gcGF0aC5uZWVkc1BhcmVucygpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5wdXNoKGRlY29yYXRvcnNMaW5lcyk7XG4gIH1cbiAgaWYgKHNob3VsZEFkZFBhcmVucykge1xuICAgIHBhcnRzLnVuc2hpZnQoXCIoXCIpO1xuICB9XG4gIHBhcnRzLnB1c2gobGluZXNXaXRob3V0UGFyZW5zKTtcbiAgaWYgKHNob3VsZEFkZFBhcmVucykge1xuICAgIHBhcnRzLnB1c2goXCIpXCIpO1xuICB9XG4gIHJldHVybiBjb25jYXQocGFydHMpO1xufVxuZnVuY3Rpb24gZ2VuZXJpY1ByaW50Tm9QYXJlbnMocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgY29uc3QgbiA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgaWYgKCFuKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJcIik7XG4gIH1cbiAgaWYgKHR5cGVvZiBuID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcobiwgb3B0aW9ucyk7XG4gIH1cbiAgbmFtZWRUeXBlcy5QcmludGFibGUuYXNzZXJ0KG4pO1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBzd2l0Y2ggKG4udHlwZSkge1xuICAgIGNhc2UgXCJGaWxlXCI6XG4gICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcInByb2dyYW1cIik7XG4gICAgY2FzZSBcIlByb2dyYW1cIjpcbiAgICAgIGlmIChuLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgcGF0aC5lYWNoKGZ1bmN0aW9uKGNoaWxkUGF0aCkge1xuICAgICAgICAgIHBhcnRzLnB1c2gocHJpbnQoY2hpbGRQYXRoKSwgXCI7XFxuXCIpO1xuICAgICAgICB9LCBcImRpcmVjdGl2ZXNcIik7XG4gICAgICB9XG4gICAgICBpZiAobi5pbnRlcnByZXRlcikge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJpbnRlcnByZXRlclwiKSk7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICBwYXRoLmNhbGwoXG4gICAgICAgICAgKGJvZHlQYXRoKSA9PiBwcmludFN0YXRlbWVudFNlcXVlbmNlKGJvZHlQYXRoLCBvcHRpb25zLCBwcmludCksXG4gICAgICAgICAgXCJib2R5XCJcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJOb29wXCI6XG4gICAgY2FzZSBcIkVtcHR5U3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcIlwiKTtcbiAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIiksIFwiO1wiXSk7XG4gICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcIihcIiwgcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIiksIFwiKVwiXSk7XG4gICAgY2FzZSBcIkJpbmFyeUV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiIFwiKS5qb2luKFtcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImxlZnRcIiksXG4gICAgICAgIG4ub3BlcmF0b3IsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJyaWdodFwiKVxuICAgICAgXSk7XG4gICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImxlZnRcIiksXG4gICAgICAgIFwiID0gXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJyaWdodFwiKVxuICAgICAgXSk7XG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6IHtcbiAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcIm9iamVjdFwiKSk7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IHBhdGguY2FsbChwcmludCwgXCJwcm9wZXJ0eVwiKTtcbiAgICAgIGNvbnN0IG9wdGlvbmFsID0gZ2V0RmllbGRWYWx1ZShuLCBcIm9wdGlvbmFsXCIpO1xuICAgICAgaWYgKG4uY29tcHV0ZWQpIHtcbiAgICAgICAgcGFydHMucHVzaChvcHRpb25hbCA/IFwiPy5bXCIgOiBcIltcIiwgcHJvcGVydHksIFwiXVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2gob3B0aW9uYWwgPyBcIj8uXCIgOiBcIi5cIiwgcHJvcGVydHkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgfVxuICAgIGNhc2UgXCJDaGFpbkV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKTtcbiAgICBjYXNlIFwiTWV0YVByb3BlcnR5XCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcIm1ldGFcIiksXG4gICAgICAgIFwiLlwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwicHJvcGVydHlcIilcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJCaW5kRXhwcmVzc2lvblwiOlxuICAgICAgaWYgKG4ub2JqZWN0KSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcIm9iamVjdFwiKSk7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKFwiOjpcIiwgcGF0aC5jYWxsKHByaW50LCBcImNhbGxlZVwiKSk7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICBjYXNlIFwiUGF0aFwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCIuXCIpLmpvaW4obi5ib2R5KTtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIGZyb21TdHJpbmcobi5uYW1lLCBvcHRpb25zKSxcbiAgICAgICAgbi5vcHRpb25hbCA/IFwiP1wiIDogXCJcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpXG4gICAgICBdKTtcbiAgICBjYXNlIFwiU3ByZWFkRWxlbWVudFwiOlxuICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50UGF0dGVyblwiOlxuICAgIGNhc2UgXCJSZXN0UHJvcGVydHlcIjpcbiAgICBjYXNlIFwiU3ByZWFkUHJvcGVydHlcIjpcbiAgICBjYXNlIFwiU3ByZWFkUHJvcGVydHlQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIk9iamVjdFR5cGVTcHJlYWRQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIFwiLi4uXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKSxcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpXG4gICAgICBdKTtcbiAgICBjYXNlIFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVFNEZWNsYXJlRnVuY3Rpb25cIjpcbiAgICAgIGlmIChuLmRlY2xhcmUpIHtcbiAgICAgICAgcGFydHMucHVzaChcImRlY2xhcmUgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG4uYXN5bmMpIHtcbiAgICAgICAgcGFydHMucHVzaChcImFzeW5jIFwiKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2goXCJmdW5jdGlvblwiKTtcbiAgICAgIGlmIChuLmdlbmVyYXRvcilcbiAgICAgICAgcGFydHMucHVzaChcIipcIik7XG4gICAgICBpZiAobi5pZCkge1xuICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgIFwiIFwiLFxuICAgICAgICAgIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSxcbiAgICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIilcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuLnR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICBcIihcIixcbiAgICAgICAgcHJpbnRGdW5jdGlvblBhcmFtcyhwYXRoLCBvcHRpb25zLCBwcmludCksXG4gICAgICAgIFwiKVwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwicmV0dXJuVHlwZVwiKVxuICAgICAgKTtcbiAgICAgIGlmIChuLmJvZHkpIHtcbiAgICAgICAgcGFydHMucHVzaChcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6XG4gICAgICBpZiAobi5hc3luYykge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiYXN5bmMgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG4udHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIikpO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zLmFycm93UGFyZW5zQWx3YXlzICYmIG4ucGFyYW1zLmxlbmd0aCA9PT0gMSAmJiAhbi5yZXN0ICYmIG4ucGFyYW1zWzBdLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICFuLnBhcmFtc1swXS50eXBlQW5ub3RhdGlvbiAmJiAhbi5yZXR1cm5UeXBlKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcInBhcmFtc1wiLCAwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgIFwiKFwiLFxuICAgICAgICAgIHByaW50RnVuY3Rpb25QYXJhbXMocGF0aCwgb3B0aW9ucywgcHJpbnQpLFxuICAgICAgICAgIFwiKVwiLFxuICAgICAgICAgIHBhdGguY2FsbChwcmludCwgXCJyZXR1cm5UeXBlXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKFwiID0+IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKSk7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICBjYXNlIFwiTWV0aG9kRGVmaW5pdGlvblwiOlxuICAgICAgcmV0dXJuIHByaW50TWV0aG9kKHBhdGgsIG9wdGlvbnMsIHByaW50KTtcbiAgICBjYXNlIFwiWWllbGRFeHByZXNzaW9uXCI6XG4gICAgICBwYXJ0cy5wdXNoKFwieWllbGRcIik7XG4gICAgICBpZiAobi5kZWxlZ2F0ZSlcbiAgICAgICAgcGFydHMucHVzaChcIipcIik7XG4gICAgICBpZiAobi5hcmd1bWVudClcbiAgICAgICAgcGFydHMucHVzaChcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImFyZ3VtZW50XCIpKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJBd2FpdEV4cHJlc3Npb25cIjpcbiAgICAgIHBhcnRzLnB1c2goXCJhd2FpdFwiKTtcbiAgICAgIGlmIChuLmFsbClcbiAgICAgICAgcGFydHMucHVzaChcIipcIik7XG4gICAgICBpZiAobi5hcmd1bWVudClcbiAgICAgICAgcGFydHMucHVzaChcIiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImFyZ3VtZW50XCIpKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJNb2R1bGVFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgXCJtb2R1bGUge1xcblwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKS5pbmRlbnQob3B0aW9ucy50YWJXaWR0aCksXG4gICAgICAgIFwiXFxufVwiXG4gICAgICBdKTtcbiAgICBjYXNlIFwiTW9kdWxlRGVjbGFyYXRpb25cIjpcbiAgICAgIHBhcnRzLnB1c2goXCJtb2R1bGVcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpKTtcbiAgICAgIGlmIChuLnNvdXJjZSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiZnJvbVwiLCBwYXRoLmNhbGwocHJpbnQsIFwic291cmNlXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCIgXCIpLmpvaW4ocGFydHMpO1xuICAgIGNhc2UgXCJJbXBvcnRTcGVjaWZpZXJcIjpcbiAgICAgIGlmIChuLmltcG9ydEtpbmQgJiYgbi5pbXBvcnRLaW5kICE9PSBcInZhbHVlXCIpIHtcbiAgICAgICAgcGFydHMucHVzaChuLmltcG9ydEtpbmQgKyBcIiBcIik7XG4gICAgICB9XG4gICAgICBpZiAobi5pbXBvcnRlZCkge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJpbXBvcnRlZFwiKSk7XG4gICAgICAgIGlmIChuLmxvY2FsICYmIG4ubG9jYWwubmFtZSAhPT0gbi5pbXBvcnRlZC5uYW1lKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIiBhcyBcIiwgcGF0aC5jYWxsKHByaW50LCBcImxvY2FsXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuLmlkKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImlkXCIpKTtcbiAgICAgICAgaWYgKG4ubmFtZSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIgYXMgXCIsIHBhdGguY2FsbChwcmludCwgXCJuYW1lXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIkV4cG9ydFNwZWNpZmllclwiOlxuICAgICAgaWYgKG4uZXhwb3J0S2luZCAmJiBuLmV4cG9ydEtpbmQgIT09IFwidmFsdWVcIikge1xuICAgICAgICBwYXJ0cy5wdXNoKG4uZXhwb3J0S2luZCArIFwiIFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLmxvY2FsKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImxvY2FsXCIpKTtcbiAgICAgICAgaWYgKG4uZXhwb3J0ZWQgJiYgbi5leHBvcnRlZC5uYW1lICE9PSBuLmxvY2FsLm5hbWUpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiIGFzIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwb3J0ZWRcIikpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG4uaWQpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwiaWRcIikpO1xuICAgICAgICBpZiAobi5uYW1lKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIiBhcyBcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICBjYXNlIFwiRXhwb3J0QmF0Y2hTcGVjaWZpZXJcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiKlwiKTtcbiAgICBjYXNlIFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCI6XG4gICAgICBwYXJ0cy5wdXNoKFwiKiBhcyBcIik7XG4gICAgICBpZiAobi5sb2NhbCkge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJsb2NhbFwiKSk7XG4gICAgICB9IGVsc2UgaWYgKG4uaWQpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwiaWRcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIjpcbiAgICAgIGlmIChuLmxvY2FsKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwibG9jYWxcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcImlkXCIpO1xuICAgIGNhc2UgXCJUU0V4cG9ydEFzc2lnbm1lbnRcIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1wiZXhwb3J0ID0gXCIsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpXSk7XG4gICAgY2FzZSBcIkV4cG9ydERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6XG4gICAgICByZXR1cm4gcHJpbnRFeHBvcnREZWNsYXJhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCk7XG4gICAgY2FzZSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCI6XG4gICAgICBwYXJ0cy5wdXNoKFwiZXhwb3J0ICpcIik7XG4gICAgICBpZiAobi5leHBvcnRlZCkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiIGFzIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwb3J0ZWRcIikpO1xuICAgICAgfVxuICAgICAgcGFydHMucHVzaChcIiBmcm9tIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwic291cmNlXCIpLCBcIjtcIik7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICBjYXNlIFwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwiOlxuICAgICAgcGFydHMucHVzaChcImV4cG9ydCBhcyBuYW1lc3BhY2UgXCIsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSk7XG4gICAgICByZXR1cm4gbWF5YmVBZGRTZW1pY29sb24oY29uY2F0KHBhcnRzKSk7XG4gICAgY2FzZSBcIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXCIqIGFzIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwb3J0ZWRcIildKTtcbiAgICBjYXNlIFwiRXhwb3J0RGVmYXVsdFNwZWNpZmllclwiOlxuICAgICAgcmV0dXJuIHBhdGguY2FsbChwcmludCwgXCJleHBvcnRlZFwiKTtcbiAgICBjYXNlIFwiSW1wb3J0XCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcImltcG9ydFwiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiSW1wb3J0RXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXCJpbXBvcnQoXCIsIHBhdGguY2FsbChwcmludCwgXCJzb3VyY2VcIiksIFwiKVwiXSk7XG4gICAgY2FzZSBcIkltcG9ydERlY2xhcmF0aW9uXCI6IHtcbiAgICAgIHBhcnRzLnB1c2goXCJpbXBvcnQgXCIpO1xuICAgICAgaWYgKG4uaW1wb3J0S2luZCAmJiBuLmltcG9ydEtpbmQgIT09IFwidmFsdWVcIikge1xuICAgICAgICBwYXJ0cy5wdXNoKG4uaW1wb3J0S2luZCArIFwiIFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLnNwZWNpZmllcnMgJiYgbi5zcGVjaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgdW5icmFjZWRTcGVjaWZpZXJzID0gW107XG4gICAgICAgIGNvbnN0IGJyYWNlZFNwZWNpZmllcnMgPSBbXTtcbiAgICAgICAgcGF0aC5lYWNoKGZ1bmN0aW9uKHNwZWNpZmllclBhdGgpIHtcbiAgICAgICAgICBjb25zdCBzcGVjID0gc3BlY2lmaWVyUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgICAgIGlmIChzcGVjLnR5cGUgPT09IFwiSW1wb3J0U3BlY2lmaWVyXCIpIHtcbiAgICAgICAgICAgIGJyYWNlZFNwZWNpZmllcnMucHVzaChwcmludChzcGVjaWZpZXJQYXRoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzcGVjLnR5cGUgPT09IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiIHx8IHNwZWMudHlwZSA9PT0gXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikge1xuICAgICAgICAgICAgdW5icmFjZWRTcGVjaWZpZXJzLnB1c2gocHJpbnQoc3BlY2lmaWVyUGF0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgXCJzcGVjaWZpZXJzXCIpO1xuICAgICAgICB1bmJyYWNlZFNwZWNpZmllcnMuZm9yRWFjaCgobGluZXMsIGkpID0+IHtcbiAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIsIFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydHMucHVzaChsaW5lcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoYnJhY2VkU3BlY2lmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gZnJvbVN0cmluZyhcIiwgXCIpLmpvaW4oYnJhY2VkU3BlY2lmaWVycyk7XG4gICAgICAgICAgaWYgKGxpbmVzLmdldExpbmVMZW5ndGgoMSkgPiBvcHRpb25zLndyYXBDb2x1bW4pIHtcbiAgICAgICAgICAgIGxpbmVzID0gY29uY2F0KFtcbiAgICAgICAgICAgICAgZnJvbVN0cmluZyhcIixcXG5cIikuam9pbihicmFjZWRTcGVjaWZpZXJzKS5pbmRlbnQob3B0aW9ucy50YWJXaWR0aCksXG4gICAgICAgICAgICAgIFwiLFwiXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVuYnJhY2VkU3BlY2lmaWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwiLCBcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsaW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwie1xcblwiLCBsaW5lcywgXCJcXG59XCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5vYmplY3RDdXJseVNwYWNpbmcpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJ7IFwiLCBsaW5lcywgXCIgfVwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIntcIiwgbGluZXMsIFwifVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChcIiBmcm9tIFwiKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJzb3VyY2VcIiksXG4gICAgICAgIG1heWJlUHJpbnRJbXBvcnRBc3NlcnRpb25zKHBhdGgsIG9wdGlvbnMsIHByaW50KSxcbiAgICAgICAgXCI7XCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIkltcG9ydEF0dHJpYnV0ZVwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbcGF0aC5jYWxsKHByaW50LCBcImtleVwiKSwgXCI6IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIildKTtcbiAgICBjYXNlIFwiU3RhdGljQmxvY2tcIjpcbiAgICAgIHBhcnRzLnB1c2goXCJzdGF0aWMgXCIpO1xuICAgIGNhc2UgXCJCbG9ja1N0YXRlbWVudFwiOiB7XG4gICAgICBjb25zdCBuYWtlZCA9IHBhdGguY2FsbChcbiAgICAgICAgKGJvZHlQYXRoKSA9PiBwcmludFN0YXRlbWVudFNlcXVlbmNlKGJvZHlQYXRoLCBvcHRpb25zLCBwcmludCksXG4gICAgICAgIFwiYm9keVwiXG4gICAgICApO1xuICAgICAgaWYgKG5ha2VkLmlzRW1wdHkoKSkge1xuICAgICAgICBpZiAoIW4uZGlyZWN0aXZlcyB8fCBuLmRpcmVjdGl2ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcInt9XCIpO1xuICAgICAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKFwie1xcblwiKTtcbiAgICAgIGlmIChuLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgcGF0aC5lYWNoKGZ1bmN0aW9uKGNoaWxkUGF0aCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgICAgICBtYXliZUFkZFNlbWljb2xvbihwcmludChjaGlsZFBhdGgpLmluZGVudChvcHRpb25zLnRhYldpZHRoKSksXG4gICAgICAgICAgICBuLmRpcmVjdGl2ZXMubGVuZ3RoID4gMSB8fCAhbmFrZWQuaXNFbXB0eSgpID8gXCJcXG5cIiA6IFwiXCJcbiAgICAgICAgICApO1xuICAgICAgICB9LCBcImRpcmVjdGl2ZXNcIik7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKG5ha2VkLmluZGVudChvcHRpb25zLnRhYldpZHRoKSk7XG4gICAgICBwYXJ0cy5wdXNoKFwiXFxufVwiKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIH1cbiAgICBjYXNlIFwiUmV0dXJuU3RhdGVtZW50XCI6IHtcbiAgICAgIHBhcnRzLnB1c2goXCJyZXR1cm5cIik7XG4gICAgICBpZiAobi5hcmd1bWVudCkge1xuICAgICAgICBjb25zdCBhcmdMaW5lcyA9IHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKTtcbiAgICAgICAgaWYgKGFyZ0xpbmVzLnN0YXJ0c1dpdGhDb21tZW50KCkgfHwgYXJnTGluZXMubGVuZ3RoID4gMSAmJiBuYW1lZFR5cGVzLkpTWEVsZW1lbnQgJiYgbmFtZWRUeXBlcy5KU1hFbGVtZW50LmNoZWNrKG4uYXJndW1lbnQpKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIiAoXFxuXCIsIGFyZ0xpbmVzLmluZGVudChvcHRpb25zLnRhYldpZHRoKSwgXCJcXG4pXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIGFyZ0xpbmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFydHMucHVzaChcIjtcIik7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpcbiAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImNhbGxlZVwiKSk7XG4gICAgICBpZiAobi50eXBlUGFyYW1ldGVycykge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKSk7XG4gICAgICB9XG4gICAgICBpZiAobi50eXBlQXJndW1lbnRzKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcInR5cGVBcmd1bWVudHNcIikpO1xuICAgICAgfVxuICAgICAgaWYgKGdldEZpZWxkVmFsdWUobiwgXCJvcHRpb25hbFwiKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiPy5cIik7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKHByaW50QXJndW1lbnRzTGlzdChwYXRoLCBvcHRpb25zLCBwcmludCkpO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIlJlY29yZEV4cHJlc3Npb25cIjpcbiAgICAgIHBhcnRzLnB1c2goXCIjXCIpO1xuICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICBjYXNlIFwiT2JqZWN0VHlwZUFubm90YXRpb25cIjoge1xuICAgICAgY29uc3QgaXNUeXBlQW5ub3RhdGlvbiA9IG4udHlwZSA9PT0gXCJPYmplY3RUeXBlQW5ub3RhdGlvblwiO1xuICAgICAgY29uc3Qgc2VwYXJhdG9yID0gb3B0aW9ucy5mbG93T2JqZWN0Q29tbWFzID8gXCIsXCIgOiBpc1R5cGVBbm5vdGF0aW9uID8gXCI7XCIgOiBcIixcIjtcbiAgICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgICAgbGV0IGFsbG93QnJlYWsgPSBmYWxzZTtcbiAgICAgIGlmIChpc1R5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKFwiaW5kZXhlcnNcIiwgXCJjYWxsUHJvcGVydGllc1wiKTtcbiAgICAgICAgaWYgKG4uaW50ZXJuYWxTbG90cyAhPSBudWxsKSB7XG4gICAgICAgICAgZmllbGRzLnB1c2goXCJpbnRlcm5hbFNsb3RzXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmaWVsZHMucHVzaChcInByb3BlcnRpZXNcIik7XG4gICAgICBsZXQgbGVuID0gMDtcbiAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkKSB7XG4gICAgICAgIGxlbiArPSBuW2ZpZWxkXS5sZW5ndGg7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG9uZUxpbmUgPSBpc1R5cGVBbm5vdGF0aW9uICYmIGxlbiA9PT0gMSB8fCBsZW4gPT09IDA7XG4gICAgICBjb25zdCBsZWZ0QnJhY2UgPSBuLmV4YWN0ID8gXCJ7fFwiIDogXCJ7XCI7XG4gICAgICBjb25zdCByaWdodEJyYWNlID0gbi5leGFjdCA/IFwifH1cIiA6IFwifVwiO1xuICAgICAgcGFydHMucHVzaChvbmVMaW5lID8gbGVmdEJyYWNlIDogbGVmdEJyYWNlICsgXCJcXG5cIik7XG4gICAgICBjb25zdCBsZWZ0QnJhY2VJbmRleCA9IHBhcnRzLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbihmaWVsZCkge1xuICAgICAgICBwYXRoLmVhY2goZnVuY3Rpb24oY2hpbGRQYXRoKSB7XG4gICAgICAgICAgbGV0IGxpbmVzID0gcHJpbnQoY2hpbGRQYXRoKTtcbiAgICAgICAgICBpZiAoIW9uZUxpbmUpIHtcbiAgICAgICAgICAgIGxpbmVzID0gbGluZXMuaW5kZW50KG9wdGlvbnMudGFiV2lkdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBtdWx0aUxpbmUgPSAhaXNUeXBlQW5ub3RhdGlvbiAmJiBsaW5lcy5sZW5ndGggPiAxO1xuICAgICAgICAgIGlmIChtdWx0aUxpbmUgJiYgYWxsb3dCcmVhaykge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIlxcblwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydHMucHVzaChsaW5lcyk7XG4gICAgICAgICAgaWYgKGkgPCBsZW4gLSAxKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHNlcGFyYXRvciArIChtdWx0aUxpbmUgPyBcIlxcblxcblwiIDogXCJcXG5cIikpO1xuICAgICAgICAgICAgYWxsb3dCcmVhayA9ICFtdWx0aUxpbmU7XG4gICAgICAgICAgfSBlbHNlIGlmIChsZW4gIT09IDEgJiYgaXNUeXBlQW5ub3RhdGlvbikge1xuICAgICAgICAgICAgcGFydHMucHVzaChzZXBhcmF0b3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIW9uZUxpbmUgJiYgaXNUcmFpbGluZ0NvbW1hRW5hYmxlZChvcHRpb25zLCBcIm9iamVjdHNcIikgJiYgY2hpbGRQYXRoLmdldFZhbHVlKCkudHlwZSAhPT0gXCJSZXN0RWxlbWVudFwiKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHNlcGFyYXRvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkrKztcbiAgICAgICAgfSwgZmllbGQpO1xuICAgICAgfSk7XG4gICAgICBpZiAobi5pbmV4YWN0KSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBmcm9tU3RyaW5nKFwiLi4uXCIsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob25lTGluZSkge1xuICAgICAgICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHNlcGFyYXRvciwgXCIgXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0cy5wdXNoKGxpbmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJcXG5cIiwgbGluZS5pbmRlbnQob3B0aW9ucy50YWJXaWR0aCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKG9uZUxpbmUgPyByaWdodEJyYWNlIDogXCJcXG5cIiArIHJpZ2h0QnJhY2UpO1xuICAgICAgaWYgKGkgIT09IDAgJiYgb25lTGluZSAmJiBvcHRpb25zLm9iamVjdEN1cmx5U3BhY2luZykge1xuICAgICAgICBwYXJ0c1tsZWZ0QnJhY2VJbmRleF0gPSBsZWZ0QnJhY2UgKyBcIiBcIjtcbiAgICAgICAgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPSBcIiBcIiArIHJpZ2h0QnJhY2U7XG4gICAgICB9XG4gICAgICBpZiAobi50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIlByb3BlcnR5UGF0dGVyblwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJrZXlcIiksXG4gICAgICAgIFwiOiBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInBhdHRlcm5cIilcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgIGNhc2UgXCJQcm9wZXJ0eVwiOiB7XG4gICAgICBpZiAobi5tZXRob2QgfHwgbi5raW5kID09PSBcImdldFwiIHx8IG4ua2luZCA9PT0gXCJzZXRcIikge1xuICAgICAgICByZXR1cm4gcHJpbnRNZXRob2QocGF0aCwgb3B0aW9ucywgcHJpbnQpO1xuICAgICAgfVxuICAgICAgaWYgKG4uc2hvcnRoYW5kICYmIG4udmFsdWUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSBwYXRoLmNhbGwocHJpbnQsIFwia2V5XCIpO1xuICAgICAgaWYgKG4uY29tcHV0ZWQpIHtcbiAgICAgICAgcGFydHMucHVzaChcIltcIiwga2V5LCBcIl1cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgICBpZiAoIW4uc2hvcnRoYW5kIHx8IG4ua2V5Lm5hbWUgIT09IG4udmFsdWUubmFtZSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIH1cbiAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICBjYXNlIFwiT2JqZWN0TWV0aG9kXCI6XG4gICAgY2FzZSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiOlxuICAgIGNhc2UgXCJUU0RlY2xhcmVNZXRob2RcIjpcbiAgICAgIHJldHVybiBwcmludE1ldGhvZChwYXRoLCBvcHRpb25zLCBwcmludCk7XG4gICAgY2FzZSBcIlByaXZhdGVOYW1lXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcIiNcIiwgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpXSk7XG4gICAgY2FzZSBcIkRlY29yYXRvclwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXCJAXCIsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpXSk7XG4gICAgY2FzZSBcIlR1cGxlRXhwcmVzc2lvblwiOlxuICAgICAgcGFydHMucHVzaChcIiNcIik7XG4gICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjoge1xuICAgICAgY29uc3QgZWxlbXMgPSBuLmVsZW1lbnRzO1xuICAgICAgY29uc3QgbGVuID0gZWxlbXMubGVuZ3RoO1xuICAgICAgY29uc3QgcHJpbnRlZCA9IHBhdGgubWFwKHByaW50LCBcImVsZW1lbnRzXCIpO1xuICAgICAgY29uc3Qgam9pbmVkID0gZnJvbVN0cmluZyhcIiwgXCIpLmpvaW4ocHJpbnRlZCk7XG4gICAgICBjb25zdCBvbmVMaW5lID0gam9pbmVkLmdldExpbmVMZW5ndGgoMSkgPD0gb3B0aW9ucy53cmFwQ29sdW1uO1xuICAgICAgaWYgKG9uZUxpbmUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXJyYXlCcmFja2V0U3BhY2luZykge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJbIFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiW1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaChcIltcXG5cIik7XG4gICAgICB9XG4gICAgICBwYXRoLmVhY2goZnVuY3Rpb24oZWxlbVBhdGgpIHtcbiAgICAgICAgY29uc3QgaSA9IGVsZW1QYXRoLmdldE5hbWUoKTtcbiAgICAgICAgY29uc3QgZWxlbSA9IGVsZW1QYXRoLmdldFZhbHVlKCk7XG4gICAgICAgIGlmICghZWxlbSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIsXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBsaW5lcyA9IHByaW50ZWRbaV07XG4gICAgICAgICAgaWYgKG9uZUxpbmUpIHtcbiAgICAgICAgICAgIGlmIChpID4gMClcbiAgICAgICAgICAgICAgcGFydHMucHVzaChcIiBcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVzID0gbGluZXMuaW5kZW50KG9wdGlvbnMudGFiV2lkdGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0cy5wdXNoKGxpbmVzKTtcbiAgICAgICAgICBpZiAoaSA8IGxlbiAtIDEgfHwgIW9uZUxpbmUgJiYgaXNUcmFpbGluZ0NvbW1hRW5hYmxlZChvcHRpb25zLCBcImFycmF5c1wiKSlcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIsXCIpO1xuICAgICAgICAgIGlmICghb25lTGluZSlcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgIH0sIFwiZWxlbWVudHNcIik7XG4gICAgICBpZiAob25lTGluZSAmJiBvcHRpb25zLmFycmF5QnJhY2tldFNwYWNpbmcpIHtcbiAgICAgICAgcGFydHMucHVzaChcIiBdXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaChcIl1cIik7XG4gICAgICB9XG4gICAgICBpZiAobi50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIlNlcXVlbmNlRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCIsIFwiKS5qb2luKHBhdGgubWFwKHByaW50LCBcImV4cHJlc3Npb25zXCIpKTtcbiAgICBjYXNlIFwiVGhpc0V4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwidGhpc1wiKTtcbiAgICBjYXNlIFwiU3VwZXJcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwic3VwZXJcIik7XG4gICAgY2FzZSBcIk51bGxMaXRlcmFsXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcIm51bGxcIik7XG4gICAgY2FzZSBcIlJlZ0V4cExpdGVyYWxcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFxuICAgICAgICBnZXRQb3NzaWJsZVJhdyhuKSB8fCBgLyR7bi5wYXR0ZXJufS8ke24uZmxhZ3MgfHwgXCJcIn1gLFxuICAgICAgICBvcHRpb25zXG4gICAgICApO1xuICAgIGNhc2UgXCJCaWdJbnRMaXRlcmFsXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhnZXRQb3NzaWJsZVJhdyhuKSB8fCBuLnZhbHVlICsgXCJuXCIsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJOdW1lcmljTGl0ZXJhbFwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoZ2V0UG9zc2libGVSYXcobikgfHwgbi52YWx1ZSwgb3B0aW9ucyk7XG4gICAgY2FzZSBcIkRlY2ltYWxMaXRlcmFsXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhnZXRQb3NzaWJsZVJhdyhuKSB8fCBuLnZhbHVlICsgXCJtXCIsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJTdHJpbmdMaXRlcmFsXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhub2RlU3RyKG4udmFsdWUsIG9wdGlvbnMpKTtcbiAgICBjYXNlIFwiQm9vbGVhbkxpdGVyYWxcIjpcbiAgICBjYXNlIFwiTGl0ZXJhbFwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXG4gICAgICAgIGdldFBvc3NpYmxlUmF3KG4pIHx8ICh0eXBlb2Ygbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IG5vZGVTdHIobi52YWx1ZSwgb3B0aW9ucykgOiBuLnZhbHVlKSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICBjYXNlIFwiRGlyZWN0aXZlXCI6XG4gICAgICByZXR1cm4gcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpO1xuICAgIGNhc2UgXCJEaXJlY3RpdmVMaXRlcmFsXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcbiAgICAgICAgZ2V0UG9zc2libGVSYXcobikgfHwgbm9kZVN0cihuLnZhbHVlLCBvcHRpb25zKSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICBjYXNlIFwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKGAjISR7bi52YWx1ZX1cbmAsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJNb2R1bGVTcGVjaWZpZXJcIjpcbiAgICAgIGlmIChuLmxvY2FsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBFU1RyZWUgTW9kdWxlU3BlY2lmaWVyIHR5cGUgc2hvdWxkIGJlIGFic3RyYWN0XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcobm9kZVN0cihuLnZhbHVlLCBvcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgY2FzZSBcIlVuYXJ5RXhwcmVzc2lvblwiOlxuICAgICAgcGFydHMucHVzaChuLm9wZXJhdG9yKTtcbiAgICAgIGlmICgvW2Etel0kLy50ZXN0KG4ub3BlcmF0b3IpKVxuICAgICAgICBwYXJ0cy5wdXNoKFwiIFwiKTtcbiAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImFyZ3VtZW50XCIpKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJVcGRhdGVFeHByZXNzaW9uXCI6XG4gICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKSwgbi5vcGVyYXRvcik7XG4gICAgICBpZiAobi5wcmVmaXgpXG4gICAgICAgIHBhcnRzLnJldmVyc2UoKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidGVzdFwiKSxcbiAgICAgICAgXCIgPyBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImNvbnNlcXVlbnRcIiksXG4gICAgICAgIFwiIDogXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJhbHRlcm5hdGVcIilcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJOZXdFeHByZXNzaW9uXCI6IHtcbiAgICAgIHBhcnRzLnB1c2goXCJuZXcgXCIsIHBhdGguY2FsbChwcmludCwgXCJjYWxsZWVcIikpO1xuICAgICAgaWYgKG4udHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIikpO1xuICAgICAgfVxuICAgICAgaWYgKG4udHlwZUFyZ3VtZW50cykge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJ0eXBlQXJndW1lbnRzXCIpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFyZ3MgPSBuLmFyZ3VtZW50cztcbiAgICAgIGlmIChhcmdzKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocHJpbnRBcmd1bWVudHNMaXN0KHBhdGgsIG9wdGlvbnMsIHByaW50KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjoge1xuICAgICAgaWYgKG4uZGVjbGFyZSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiZGVjbGFyZSBcIik7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKG4ua2luZCwgXCIgXCIpO1xuICAgICAgbGV0IG1heExlbiA9IDA7XG4gICAgICBjb25zdCBwcmludGVkID0gcGF0aC5tYXAoZnVuY3Rpb24oY2hpbGRQYXRoKSB7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gcHJpbnQoY2hpbGRQYXRoKTtcbiAgICAgICAgbWF4TGVuID0gTWF0aC5tYXgobGluZXMubGVuZ3RoLCBtYXhMZW4pO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgICB9LCBcImRlY2xhcmF0aW9uc1wiKTtcbiAgICAgIGlmIChtYXhMZW4gPT09IDEpIHtcbiAgICAgICAgcGFydHMucHVzaChmcm9tU3RyaW5nKFwiLCBcIikuam9pbihwcmludGVkKSk7XG4gICAgICB9IGVsc2UgaWYgKHByaW50ZWQubGVuZ3RoID4gMSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgIGZyb21TdHJpbmcoXCIsXFxuXCIpLmpvaW4ocHJpbnRlZCkuaW5kZW50VGFpbChuLmtpbmQubGVuZ3RoICsgMSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2gocHJpbnRlZFswXSk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnROb2RlID0gcGF0aC5nZXRQYXJlbnROb2RlKCk7XG4gICAgICBpZiAoIW5hbWVkVHlwZXMuRm9yU3RhdGVtZW50LmNoZWNrKHBhcmVudE5vZGUpICYmICFuYW1lZFR5cGVzLkZvckluU3RhdGVtZW50LmNoZWNrKHBhcmVudE5vZGUpICYmICEobmFtZWRUeXBlcy5Gb3JPZlN0YXRlbWVudCAmJiBuYW1lZFR5cGVzLkZvck9mU3RhdGVtZW50LmNoZWNrKHBhcmVudE5vZGUpKSAmJiAhKG5hbWVkVHlwZXMuRm9yQXdhaXRTdGF0ZW1lbnQgJiYgbmFtZWRUeXBlcy5Gb3JBd2FpdFN0YXRlbWVudC5jaGVjayhwYXJlbnROb2RlKSkpIHtcbiAgICAgICAgcGFydHMucHVzaChcIjtcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIlZhcmlhYmxlRGVjbGFyYXRvclwiOlxuICAgICAgcmV0dXJuIG4uaW5pdCA/IGZyb21TdHJpbmcoXCIgPSBcIikuam9pbihbXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSxcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImluaXRcIilcbiAgICAgIF0pIDogcGF0aC5jYWxsKHByaW50LCBcImlkXCIpO1xuICAgIGNhc2UgXCJXaXRoU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgXCJ3aXRoIChcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcIm9iamVjdFwiKSxcbiAgICAgICAgXCIpIFwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKVxuICAgICAgXSk7XG4gICAgY2FzZSBcIklmU3RhdGVtZW50XCI6IHtcbiAgICAgIGNvbnN0IGNvbiA9IGFkanVzdENsYXVzZShwYXRoLmNhbGwocHJpbnQsIFwiY29uc2VxdWVudFwiKSwgb3B0aW9ucyk7XG4gICAgICBwYXJ0cy5wdXNoKFwiaWYgKFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidGVzdFwiKSwgXCIpXCIsIGNvbik7XG4gICAgICBpZiAobi5hbHRlcm5hdGUpXG4gICAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgICAgZW5kc1dpdGhCcmFjZShjb24pID8gXCIgZWxzZVwiIDogXCJcXG5lbHNlXCIsXG4gICAgICAgICAgYWRqdXN0Q2xhdXNlKHBhdGguY2FsbChwcmludCwgXCJhbHRlcm5hdGVcIiksIG9wdGlvbnMpXG4gICAgICAgICk7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIkZvclN0YXRlbWVudFwiOiB7XG4gICAgICBjb25zdCBpbml0ID0gcGF0aC5jYWxsKHByaW50LCBcImluaXRcIik7XG4gICAgICBjb25zdCBzZXAgPSBpbml0Lmxlbmd0aCA+IDEgPyBcIjtcXG5cIiA6IFwiOyBcIjtcbiAgICAgIGNvbnN0IGZvclBhcmVuID0gXCJmb3IgKFwiO1xuICAgICAgY29uc3QgaW5kZW50ZWQgPSBmcm9tU3RyaW5nKHNlcCkuam9pbihbaW5pdCwgcGF0aC5jYWxsKHByaW50LCBcInRlc3RcIiksIHBhdGguY2FsbChwcmludCwgXCJ1cGRhdGVcIildKS5pbmRlbnRUYWlsKGZvclBhcmVuLmxlbmd0aCk7XG4gICAgICBjb25zdCBoZWFkID0gY29uY2F0KFtmb3JQYXJlbiwgaW5kZW50ZWQsIFwiKVwiXSk7XG4gICAgICBsZXQgY2xhdXNlID0gYWRqdXN0Q2xhdXNlKHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpLCBvcHRpb25zKTtcbiAgICAgIHBhcnRzLnB1c2goaGVhZCk7XG4gICAgICBpZiAoaGVhZC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJcXG5cIik7XG4gICAgICAgIGNsYXVzZSA9IGNsYXVzZS50cmltTGVmdCgpO1xuICAgICAgfVxuICAgICAgcGFydHMucHVzaChjbGF1c2UpO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgfVxuICAgIGNhc2UgXCJXaGlsZVN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIFwid2hpbGUgKFwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidGVzdFwiKSxcbiAgICAgICAgXCIpXCIsXG4gICAgICAgIGFkanVzdENsYXVzZShwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKSwgb3B0aW9ucylcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJGb3JJblN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIG4uZWFjaCA/IFwiZm9yIGVhY2ggKFwiIDogXCJmb3IgKFwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwibGVmdFwiKSxcbiAgICAgICAgXCIgaW4gXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJyaWdodFwiKSxcbiAgICAgICAgXCIpXCIsXG4gICAgICAgIGFkanVzdENsYXVzZShwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKSwgb3B0aW9ucylcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJGb3JPZlN0YXRlbWVudFwiOlxuICAgIGNhc2UgXCJGb3JBd2FpdFN0YXRlbWVudFwiOlxuICAgICAgcGFydHMucHVzaChcImZvciBcIik7XG4gICAgICBpZiAobi5hd2FpdCB8fCBuLnR5cGUgPT09IFwiRm9yQXdhaXRTdGF0ZW1lbnRcIikge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiYXdhaXQgXCIpO1xuICAgICAgfVxuICAgICAgcGFydHMucHVzaChcbiAgICAgICAgXCIoXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJsZWZ0XCIpLFxuICAgICAgICBcIiBvZiBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInJpZ2h0XCIpLFxuICAgICAgICBcIilcIixcbiAgICAgICAgYWRqdXN0Q2xhdXNlKHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpLCBvcHRpb25zKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJEb1doaWxlU3RhdGVtZW50XCI6IHtcbiAgICAgIGNvbnN0IGRvQm9keSA9IGNvbmNhdChbXG4gICAgICAgIFwiZG9cIixcbiAgICAgICAgYWRqdXN0Q2xhdXNlKHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpLCBvcHRpb25zKVxuICAgICAgXSk7XG4gICAgICBwYXJ0cy5wdXNoKGRvQm9keSk7XG4gICAgICBpZiAoZW5kc1dpdGhCcmFjZShkb0JvZHkpKVxuICAgICAgICBwYXJ0cy5wdXNoKFwiIHdoaWxlXCIpO1xuICAgICAgZWxzZVxuICAgICAgICBwYXJ0cy5wdXNoKFwiXFxud2hpbGVcIik7XG4gICAgICBwYXJ0cy5wdXNoKFwiIChcIiwgcGF0aC5jYWxsKHByaW50LCBcInRlc3RcIiksIFwiKTtcIik7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIkRvRXhwcmVzc2lvblwiOiB7XG4gICAgICBjb25zdCBzdGF0ZW1lbnRzID0gcGF0aC5jYWxsKFxuICAgICAgICAoYm9keVBhdGgpID0+IHByaW50U3RhdGVtZW50U2VxdWVuY2UoYm9keVBhdGgsIG9wdGlvbnMsIHByaW50KSxcbiAgICAgICAgXCJib2R5XCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gY29uY2F0KFtcImRvIHtcXG5cIiwgc3RhdGVtZW50cy5pbmRlbnQob3B0aW9ucy50YWJXaWR0aCksIFwiXFxufVwiXSk7XG4gICAgfVxuICAgIGNhc2UgXCJCcmVha1N0YXRlbWVudFwiOlxuICAgICAgcGFydHMucHVzaChcImJyZWFrXCIpO1xuICAgICAgaWYgKG4ubGFiZWwpXG4gICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJsYWJlbFwiKSk7XG4gICAgICBwYXJ0cy5wdXNoKFwiO1wiKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJDb250aW51ZVN0YXRlbWVudFwiOlxuICAgICAgcGFydHMucHVzaChcImNvbnRpbnVlXCIpO1xuICAgICAgaWYgKG4ubGFiZWwpXG4gICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJsYWJlbFwiKSk7XG4gICAgICBwYXJ0cy5wdXNoKFwiO1wiKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJMYWJlbGVkU3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImxhYmVsXCIpLFxuICAgICAgICBcIjpcXG5cIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIilcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJUcnlTdGF0ZW1lbnRcIjpcbiAgICAgIHBhcnRzLnB1c2goXCJ0cnkgXCIsIHBhdGguY2FsbChwcmludCwgXCJibG9ja1wiKSk7XG4gICAgICBpZiAobi5oYW5kbGVyKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJoYW5kbGVyXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAobi5oYW5kbGVycykge1xuICAgICAgICBwYXRoLmVhY2goZnVuY3Rpb24oaGFuZGxlclBhdGgpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiIFwiLCBwcmludChoYW5kbGVyUGF0aCkpO1xuICAgICAgICB9LCBcImhhbmRsZXJzXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG4uZmluYWxpemVyKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCIgZmluYWxseSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImZpbmFsaXplclwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICBjYXNlIFwiQ2F0Y2hDbGF1c2VcIjpcbiAgICAgIHBhcnRzLnB1c2goXCJjYXRjaCBcIik7XG4gICAgICBpZiAobi5wYXJhbSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiKFwiLCBwYXRoLmNhbGwocHJpbnQsIFwicGFyYW1cIikpO1xuICAgICAgfVxuICAgICAgaWYgKG4uZ3VhcmQpIHtcbiAgICAgICAgcGFydHMucHVzaChcIiBpZiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImd1YXJkXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLnBhcmFtKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCIpIFwiKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImJvZHlcIikpO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIlRocm93U3RhdGVtZW50XCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcInRocm93IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYXJndW1lbnRcIiksIFwiO1wiXSk7XG4gICAgY2FzZSBcIlN3aXRjaFN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIFwic3dpdGNoIChcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImRpc2NyaW1pbmFudFwiKSxcbiAgICAgICAgXCIpIHtcXG5cIixcbiAgICAgICAgZnJvbVN0cmluZyhcIlxcblwiKS5qb2luKHBhdGgubWFwKHByaW50LCBcImNhc2VzXCIpKSxcbiAgICAgICAgXCJcXG59XCJcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJTd2l0Y2hDYXNlXCI6XG4gICAgICBpZiAobi50ZXN0KVxuICAgICAgICBwYXJ0cy5wdXNoKFwiY2FzZSBcIiwgcGF0aC5jYWxsKHByaW50LCBcInRlc3RcIiksIFwiOlwiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcGFydHMucHVzaChcImRlZmF1bHQ6XCIpO1xuICAgICAgaWYgKG4uY29uc2VxdWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgICAgXCJcXG5cIixcbiAgICAgICAgICBwYXRoLmNhbGwoXG4gICAgICAgICAgICAoY29uc2VxdWVudFBhdGgpID0+IHByaW50U3RhdGVtZW50U2VxdWVuY2UoY29uc2VxdWVudFBhdGgsIG9wdGlvbnMsIHByaW50KSxcbiAgICAgICAgICAgIFwiY29uc2VxdWVudFwiXG4gICAgICAgICAgKS5pbmRlbnQob3B0aW9ucy50YWJXaWR0aClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJEZWJ1Z2dlclN0YXRlbWVudFwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJkZWJ1Z2dlcjtcIik7XG4gICAgY2FzZSBcIkpTWEF0dHJpYnV0ZVwiOlxuICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSk7XG4gICAgICBpZiAobi52YWx1ZSlcbiAgICAgICAgcGFydHMucHVzaChcIj1cIiwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJKU1hJZGVudGlmaWVyXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhuLm5hbWUsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJKU1hOYW1lc3BhY2VkTmFtZVwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCI6XCIpLmpvaW4oW1xuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwibmFtZXNwYWNlXCIpLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKVxuICAgICAgXSk7XG4gICAgY2FzZSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiLlwiKS5qb2luKFtcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcIm9iamVjdFwiKSxcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInByb3BlcnR5XCIpXG4gICAgICBdKTtcbiAgICBjYXNlIFwiSlNYU3ByZWFkQXR0cmlidXRlXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcInsuLi5cIiwgcGF0aC5jYWxsKHByaW50LCBcImFyZ3VtZW50XCIpLCBcIn1cIl0pO1xuICAgIGNhc2UgXCJKU1hTcHJlYWRDaGlsZFwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXCJ7Li4uXCIsIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLCBcIn1cIl0pO1xuICAgIGNhc2UgXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcIntcIiwgcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIiksIFwifVwiXSk7XG4gICAgY2FzZSBcIkpTWEVsZW1lbnRcIjpcbiAgICBjYXNlIFwiSlNYRnJhZ21lbnRcIjoge1xuICAgICAgY29uc3Qgb3BlbmluZ1Byb3BOYW1lID0gXCJvcGVuaW5nXCIgKyAobi50eXBlID09PSBcIkpTWEVsZW1lbnRcIiA/IFwiRWxlbWVudFwiIDogXCJGcmFnbWVudFwiKTtcbiAgICAgIGNvbnN0IGNsb3NpbmdQcm9wTmFtZSA9IFwiY2xvc2luZ1wiICsgKG4udHlwZSA9PT0gXCJKU1hFbGVtZW50XCIgPyBcIkVsZW1lbnRcIiA6IFwiRnJhZ21lbnRcIik7XG4gICAgICBjb25zdCBvcGVuaW5nTGluZXMgPSBwYXRoLmNhbGwocHJpbnQsIG9wZW5pbmdQcm9wTmFtZSk7XG4gICAgICBpZiAobltvcGVuaW5nUHJvcE5hbWVdLnNlbGZDbG9zaW5nKSB7XG4gICAgICAgIHJldHVybiBvcGVuaW5nTGluZXM7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZExpbmVzID0gY29uY2F0KFxuICAgICAgICBwYXRoLm1hcChmdW5jdGlvbihjaGlsZFBhdGgpIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgICAgIGlmIChuYW1lZFR5cGVzLkxpdGVyYWwuY2hlY2soY2hpbGQpICYmIHR5cGVvZiBjaGlsZC52YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKC9cXFMvLnRlc3QoY2hpbGQudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjaGlsZC52YWx1ZS5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL1xcbi8udGVzdChjaGlsZC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwcmludChjaGlsZFBhdGgpO1xuICAgICAgICB9LCBcImNoaWxkcmVuXCIpXG4gICAgICApLmluZGVudFRhaWwob3B0aW9ucy50YWJXaWR0aCk7XG4gICAgICBjb25zdCBjbG9zaW5nTGluZXMgPSBwYXRoLmNhbGwocHJpbnQsIGNsb3NpbmdQcm9wTmFtZSk7XG4gICAgICByZXR1cm4gY29uY2F0KFtvcGVuaW5nTGluZXMsIGNoaWxkTGluZXMsIGNsb3NpbmdMaW5lc10pO1xuICAgIH1cbiAgICBjYXNlIFwiSlNYT3BlbmluZ0VsZW1lbnRcIjoge1xuICAgICAgcGFydHMucHVzaChcIjxcIiwgcGF0aC5jYWxsKHByaW50LCBcIm5hbWVcIikpO1xuICAgICAgY29uc3QgYXR0clBhcnRzID0gW107XG4gICAgICBwYXRoLmVhY2goZnVuY3Rpb24oYXR0clBhdGgpIHtcbiAgICAgICAgYXR0clBhcnRzLnB1c2goXCIgXCIsIHByaW50KGF0dHJQYXRoKSk7XG4gICAgICB9LCBcImF0dHJpYnV0ZXNcIik7XG4gICAgICBsZXQgYXR0ckxpbmVzID0gY29uY2F0KGF0dHJQYXJ0cyk7XG4gICAgICBjb25zdCBuZWVkTGluZVdyYXAgPSBhdHRyTGluZXMubGVuZ3RoID4gMSB8fCBhdHRyTGluZXMuZ2V0TGluZUxlbmd0aCgxKSA+IG9wdGlvbnMud3JhcENvbHVtbjtcbiAgICAgIGlmIChuZWVkTGluZVdyYXApIHtcbiAgICAgICAgYXR0clBhcnRzLmZvckVhY2goZnVuY3Rpb24ocGFydCwgaSkge1xuICAgICAgICAgIGlmIChwYXJ0ID09PSBcIiBcIikge1xuICAgICAgICAgICAgYXR0clBhcnRzW2ldID0gXCJcXG5cIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBhdHRyTGluZXMgPSBjb25jYXQoYXR0clBhcnRzKS5pbmRlbnRUYWlsKG9wdGlvbnMudGFiV2lkdGgpO1xuICAgICAgfVxuICAgICAgcGFydHMucHVzaChhdHRyTGluZXMsIG4uc2VsZkNsb3NpbmcgPyBcIiAvPlwiIDogXCI+XCIpO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgfVxuICAgIGNhc2UgXCJKU1hDbG9zaW5nRWxlbWVudFwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXCI8L1wiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSwgXCI+XCJdKTtcbiAgICBjYXNlIFwiSlNYT3BlbmluZ0ZyYWdtZW50XCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcIjw+XCIpO1xuICAgIGNhc2UgXCJKU1hDbG9zaW5nRnJhZ21lbnRcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiPC8+XCIpO1xuICAgIGNhc2UgXCJKU1hUZXh0XCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhuLnZhbHVlLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiSlNYRW1wdHlFeHByZXNzaW9uXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcIlwiKTtcbiAgICBjYXNlIFwiVHlwZUFubm90YXRlZElkZW50aWZpZXJcIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwiYW5ub3RhdGlvblwiKSxcbiAgICAgICAgXCIgXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJpZGVudGlmaWVyXCIpXG4gICAgICBdKTtcbiAgICBjYXNlIFwiQ2xhc3NCb2R5XCI6XG4gICAgICBpZiAobi5ib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhcInt9XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIFwie1xcblwiLFxuICAgICAgICBwYXRoLmNhbGwoXG4gICAgICAgICAgKGJvZHlQYXRoKSA9PiBwcmludFN0YXRlbWVudFNlcXVlbmNlKGJvZHlQYXRoLCBvcHRpb25zLCBwcmludCksXG4gICAgICAgICAgXCJib2R5XCJcbiAgICAgICAgKS5pbmRlbnQob3B0aW9ucy50YWJXaWR0aCksXG4gICAgICAgIFwiXFxufVwiXG4gICAgICBdKTtcbiAgICBjYXNlIFwiQ2xhc3NQcm9wZXJ0eURlZmluaXRpb25cIjpcbiAgICAgIHBhcnRzLnB1c2goXCJzdGF0aWMgXCIsIHBhdGguY2FsbChwcmludCwgXCJkZWZpbml0aW9uXCIpKTtcbiAgICAgIGlmICghbmFtZWRUeXBlcy5NZXRob2REZWZpbml0aW9uLmNoZWNrKG4uZGVmaW5pdGlvbikpXG4gICAgICAgIHBhcnRzLnB1c2goXCI7XCIpO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIkNsYXNzUHJvcGVydHlcIjoge1xuICAgICAgaWYgKG4uZGVjbGFyZSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiZGVjbGFyZSBcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBhY2Nlc3MgPSBuLmFjY2Vzc2liaWxpdHkgfHwgbi5hY2Nlc3M7XG4gICAgICBpZiAodHlwZW9mIGFjY2VzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBwYXJ0cy5wdXNoKGFjY2VzcywgXCIgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG4uc3RhdGljKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJzdGF0aWMgXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG4uYWJzdHJhY3QpIHtcbiAgICAgICAgcGFydHMucHVzaChcImFic3RyYWN0IFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLnJlYWRvbmx5KSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJyZWFkb25seSBcIik7XG4gICAgICB9XG4gICAgICBsZXQga2V5ID0gcGF0aC5jYWxsKHByaW50LCBcImtleVwiKTtcbiAgICAgIGlmIChuLmNvbXB1dGVkKSB7XG4gICAgICAgIGtleSA9IGNvbmNhdChbXCJbXCIsIGtleSwgXCJdXCJdKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLnZhcmlhbmNlKSB7XG4gICAgICAgIGtleSA9IGNvbmNhdChbcHJpbnRWYXJpYW5jZShwYXRoLCBwcmludCksIGtleV0pO1xuICAgICAgfVxuICAgICAgcGFydHMucHVzaChrZXkpO1xuICAgICAgaWYgKG4ub3B0aW9uYWwpIHtcbiAgICAgICAgcGFydHMucHVzaChcIj9cIik7XG4gICAgICB9XG4gICAgICBpZiAobi5kZWZpbml0ZSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiIVwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLnZhbHVlKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCIgPSBcIiwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2goXCI7XCIpO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgfVxuICAgIGNhc2UgXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiOlxuICAgICAgaWYgKG4uc3RhdGljKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJzdGF0aWMgXCIpO1xuICAgICAgfVxuICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwia2V5XCIpKTtcbiAgICAgIGlmIChuLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLnZhbHVlKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCIgPSBcIiwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2goXCI7XCIpO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiOiB7XG4gICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAuLi5wcmludENsYXNzTWVtYmVyTW9kaWZpZXJzKG4pLFxuICAgICAgICBcImFjY2Vzc29yIFwiXG4gICAgICApO1xuICAgICAgaWYgKG4uY29tcHV0ZWQpIHtcbiAgICAgICAgcGFydHMucHVzaChcIltcIiwgcGF0aC5jYWxsKHByaW50LCBcImtleVwiKSwgXCJdXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwia2V5XCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLm9wdGlvbmFsKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCI/XCIpO1xuICAgICAgfVxuICAgICAgaWYgKG4uZGVmaW5pdGUpIHtcbiAgICAgICAgcGFydHMucHVzaChcIiFcIik7XG4gICAgICB9XG4gICAgICBpZiAobi50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKSk7XG4gICAgICB9XG4gICAgICBpZiAobi52YWx1ZSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiID0gXCIsIHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiKSk7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKFwiO1wiKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIH1cbiAgICBjYXNlIFwiQ2xhc3NEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJDbGFzc0V4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiRGVjbGFyZUNsYXNzXCI6XG4gICAgICBpZiAobi5kZWNsYXJlKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJkZWNsYXJlIFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLmFic3RyYWN0KSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJhYnN0cmFjdCBcIik7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKFwiY2xhc3NcIik7XG4gICAgICBpZiAobi5pZCkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIikpO1xuICAgICAgfVxuICAgICAgaWYgKG4udHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIikpO1xuICAgICAgfVxuICAgICAgaWYgKG4uc3VwZXJDbGFzcykge1xuICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgIFwiIGV4dGVuZHMgXCIsXG4gICAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInN1cGVyQ2xhc3NcIiksXG4gICAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInN1cGVyVHlwZVBhcmFtZXRlcnNcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLmV4dGVuZHMgJiYgbi5leHRlbmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFydHMucHVzaChcbiAgICAgICAgICBcIiBleHRlbmRzIFwiLFxuICAgICAgICAgIGZyb21TdHJpbmcoXCIsIFwiKS5qb2luKHBhdGgubWFwKHByaW50LCBcImV4dGVuZHNcIikpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAobltcImltcGxlbWVudHNcIl0gJiYgbltcImltcGxlbWVudHNcIl0ubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgIFwiIGltcGxlbWVudHMgXCIsXG4gICAgICAgICAgZnJvbVN0cmluZyhcIiwgXCIpLmpvaW4ocGF0aC5tYXAocHJpbnQsIFwiaW1wbGVtZW50c1wiKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKTtcbiAgICAgIGlmIChuLnR5cGUgPT09IFwiRGVjbGFyZUNsYXNzXCIpIHtcbiAgICAgICAgcmV0dXJuIHByaW50Rmxvd0RlY2xhcmF0aW9uKHBhdGgsIHBhcnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgICAgfVxuICAgIGNhc2UgXCJUZW1wbGF0ZUVsZW1lbnRcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKG4udmFsdWUucmF3LCBvcHRpb25zKS5sb2NrSW5kZW50VGFpbCgpO1xuICAgIGNhc2UgXCJUZW1wbGF0ZUxpdGVyYWxcIjoge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBwYXRoLm1hcChwcmludCwgXCJleHByZXNzaW9uc1wiKTtcbiAgICAgIHBhcnRzLnB1c2goXCJgXCIpO1xuICAgICAgcGF0aC5lYWNoKGZ1bmN0aW9uKGNoaWxkUGF0aCkge1xuICAgICAgICBjb25zdCBpID0gY2hpbGRQYXRoLmdldE5hbWUoKTtcbiAgICAgICAgcGFydHMucHVzaChwcmludChjaGlsZFBhdGgpKTtcbiAgICAgICAgaWYgKGkgPCBleHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiJHtcIiwgZXhwcmVzc2lvbnNbaV0sIFwifVwiKTtcbiAgICAgICAgfVxuICAgICAgfSwgXCJxdWFzaXNcIik7XG4gICAgICBwYXJ0cy5wdXNoKFwiYFwiKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpLmxvY2tJbmRlbnRUYWlsKCk7XG4gICAgfVxuICAgIGNhc2UgXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBjb25jYXQoW3BhdGguY2FsbChwcmludCwgXCJ0YWdcIiksIHBhdGguY2FsbChwcmludCwgXCJxdWFzaVwiKV0pO1xuICAgIGNhc2UgXCJOb2RlXCI6XG4gICAgY2FzZSBcIlByaW50YWJsZVwiOlxuICAgIGNhc2UgXCJTb3VyY2VMb2NhdGlvblwiOlxuICAgIGNhc2UgXCJQb3NpdGlvblwiOlxuICAgIGNhc2UgXCJTdGF0ZW1lbnRcIjpcbiAgICBjYXNlIFwiRnVuY3Rpb25cIjpcbiAgICBjYXNlIFwiUGF0dGVyblwiOlxuICAgIGNhc2UgXCJFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkRlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJOYW1lZFNwZWNpZmllclwiOlxuICAgIGNhc2UgXCJDb21tZW50XCI6XG4gICAgY2FzZSBcIkZsb3dcIjpcbiAgICBjYXNlIFwiRmxvd1R5cGVcIjpcbiAgICBjYXNlIFwiRmxvd1ByZWRpY2F0ZVwiOlxuICAgIGNhc2UgXCJNZW1iZXJUeXBlQW5ub3RhdGlvblwiOlxuICAgIGNhc2UgXCJUeXBlXCI6XG4gICAgY2FzZSBcIlRTSGFzT3B0aW9uYWxUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiOlxuICAgIGNhc2UgXCJUU0hhc09wdGlvbmFsVHlwZVBhcmFtZXRlcnNcIjpcbiAgICBjYXNlIFwiVFNIYXNPcHRpb25hbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIkNoYWluRWxlbWVudFwiOlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5wcmludGFibGUgdHlwZTogXCIgKyBKU09OLnN0cmluZ2lmeShuLnR5cGUpKTtcbiAgICBjYXNlIFwiQ29tbWVudEJsb2NrXCI6XG4gICAgY2FzZSBcIkJsb2NrXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcIi8qXCIsIGZyb21TdHJpbmcobi52YWx1ZSwgb3B0aW9ucyksIFwiKi9cIl0pO1xuICAgIGNhc2UgXCJDb21tZW50TGluZVwiOlxuICAgIGNhc2UgXCJMaW5lXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcIi8vXCIsIGZyb21TdHJpbmcobi52YWx1ZSwgb3B0aW9ucyldKTtcbiAgICBjYXNlIFwiVHlwZUFubm90YXRpb25cIjpcbiAgICAgIGlmIChuLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgIGlmIChuLnR5cGVBbm5vdGF0aW9uLnR5cGUgIT09IFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIjogXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcIlwiKTtcbiAgICBjYXNlIFwiRXhpc3RlbnRpYWxUeXBlUGFyYW1cIjpcbiAgICBjYXNlIFwiRXhpc3RzVHlwZUFubm90YXRpb25cIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiKlwiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiRW1wdHlUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJlbXB0eVwiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiQW55VHlwZUFubm90YXRpb25cIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiYW55XCIsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcIm1peGVkXCIsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJBcnJheVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtwYXRoLmNhbGwocHJpbnQsIFwiZWxlbWVudFR5cGVcIiksIFwiW11cIl0pO1xuICAgIGNhc2UgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCI6IHtcbiAgICAgIGNvbnN0IHByaW50ZWQgPSBwYXRoLm1hcChwcmludCwgXCJ0eXBlc1wiKTtcbiAgICAgIGNvbnN0IGpvaW5lZCA9IGZyb21TdHJpbmcoXCIsIFwiKS5qb2luKHByaW50ZWQpO1xuICAgICAgY29uc3Qgb25lTGluZSA9IGpvaW5lZC5nZXRMaW5lTGVuZ3RoKDEpIDw9IG9wdGlvbnMud3JhcENvbHVtbjtcbiAgICAgIGlmIChvbmVMaW5lKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFycmF5QnJhY2tldFNwYWNpbmcpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiWyBcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIltcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJbXFxuXCIpO1xuICAgICAgfVxuICAgICAgcGF0aC5lYWNoKGZ1bmN0aW9uKGVsZW1QYXRoKSB7XG4gICAgICAgIGNvbnN0IGkgPSBlbGVtUGF0aC5nZXROYW1lKCk7XG4gICAgICAgIGNvbnN0IGVsZW0gPSBlbGVtUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwiLFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgbGluZXMgPSBwcmludGVkW2ldO1xuICAgICAgICAgIGlmIChvbmVMaW5lKSB7XG4gICAgICAgICAgICBpZiAoaSA+IDApXG4gICAgICAgICAgICAgIHBhcnRzLnB1c2goXCIgXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaW5lcyA9IGxpbmVzLmluZGVudChvcHRpb25zLnRhYldpZHRoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydHMucHVzaChsaW5lcyk7XG4gICAgICAgICAgaWYgKGkgPCBuLnR5cGVzLmxlbmd0aCAtIDEgfHwgIW9uZUxpbmUgJiYgaXNUcmFpbGluZ0NvbW1hRW5hYmxlZChvcHRpb25zLCBcImFycmF5c1wiKSlcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCIsXCIpO1xuICAgICAgICAgIGlmICghb25lTGluZSlcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXCJcXG5cIik7XG4gICAgICAgIH1cbiAgICAgIH0sIFwidHlwZXNcIik7XG4gICAgICBpZiAob25lTGluZSAmJiBvcHRpb25zLmFycmF5QnJhY2tldFNwYWNpbmcpIHtcbiAgICAgICAgcGFydHMucHVzaChcIiBdXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaChcIl1cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJib29sZWFuXCIsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcIlwiICsgbi52YWx1ZSwgb3B0aW9ucyk7XG4gICAgY2FzZSBcIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICBwYXJ0cy5wdXNoKFwiaW50ZXJmYWNlXCIpO1xuICAgICAgaWYgKG4uZXh0ZW5kcyAmJiBuLmV4dGVuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgIFwiIGV4dGVuZHMgXCIsXG4gICAgICAgICAgZnJvbVN0cmluZyhcIiwgXCIpLmpvaW4ocGF0aC5tYXAocHJpbnQsIFwiZXh0ZW5kc1wiKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJEZWNsYXJlRnVuY3Rpb25cIjpcbiAgICAgIHJldHVybiBwcmludEZsb3dEZWNsYXJhdGlvbihwYXRoLCBbXG4gICAgICAgIFwiZnVuY3Rpb24gXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSxcbiAgICAgICAgXCI7XCJcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJEZWNsYXJlTW9kdWxlXCI6XG4gICAgICByZXR1cm4gcHJpbnRGbG93RGVjbGFyYXRpb24ocGF0aCwgW1xuICAgICAgICBcIm1vZHVsZSBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLFxuICAgICAgICBcIiBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIilcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiOlxuICAgICAgcmV0dXJuIHByaW50Rmxvd0RlY2xhcmF0aW9uKHBhdGgsIFtcbiAgICAgICAgXCJtb2R1bGUuZXhwb3J0c1wiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIilcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJEZWNsYXJlVmFyaWFibGVcIjpcbiAgICAgIHJldHVybiBwcmludEZsb3dEZWNsYXJhdGlvbihwYXRoLCBbXCJ2YXIgXCIsIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSwgXCI7XCJdKTtcbiAgICBjYXNlIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXCJkZWNsYXJlIFwiLCBwcmludEV4cG9ydERlY2xhcmF0aW9uKHBhdGgsIG9wdGlvbnMsIHByaW50KV0pO1xuICAgIGNhc2UgXCJFbnVtRGVjbGFyYXRpb25cIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICBcImVudW0gXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSxcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImJvZHlcIilcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJFbnVtQm9vbGVhbkJvZHlcIjpcbiAgICBjYXNlIFwiRW51bU51bWJlckJvZHlcIjpcbiAgICBjYXNlIFwiRW51bVN0cmluZ0JvZHlcIjpcbiAgICBjYXNlIFwiRW51bVN5bWJvbEJvZHlcIjoge1xuICAgICAgaWYgKG4udHlwZSA9PT0gXCJFbnVtU3ltYm9sQm9keVwiIHx8IG4uZXhwbGljaXRUeXBlKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgICAgXCIgb2YgXCIsXG4gICAgICAgICAgLy8gRW51bUJvb2xlYW5Cb2R5ID0+IGJvb2xlYW4sIGV0Yy5cbiAgICAgICAgICBuLnR5cGUuc2xpY2UoNCwgLTQpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgIFwiIHtcXG5cIixcbiAgICAgICAgZnJvbVN0cmluZyhcIlxcblwiKS5qb2luKHBhdGgubWFwKHByaW50LCBcIm1lbWJlcnNcIikpLmluZGVudChvcHRpb25zLnRhYldpZHRoKSxcbiAgICAgICAgXCJcXG59XCJcbiAgICAgICk7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIkVudW1EZWZhdWx0ZWRNZW1iZXJcIjpcbiAgICAgIHJldHVybiBjb25jYXQoW3BhdGguY2FsbChwcmludCwgXCJpZFwiKSwgXCIsXCJdKTtcbiAgICBjYXNlIFwiRW51bUJvb2xlYW5NZW1iZXJcIjpcbiAgICBjYXNlIFwiRW51bU51bWJlck1lbWJlclwiOlxuICAgIGNhc2UgXCJFbnVtU3RyaW5nTWVtYmVyXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLFxuICAgICAgICBcIiA9IFwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwiaW5pdFwiKSxcbiAgICAgICAgXCIsXCJcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJJbmZlcnJlZFByZWRpY2F0ZVwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCIlY2hlY2tzXCIsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJEZWNsYXJlZFByZWRpY2F0ZVwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXCIlY2hlY2tzKFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIiksIFwiKVwiXSk7XG4gICAgY2FzZSBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIjoge1xuICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5nZXRQYXJlbnROb2RlKDApO1xuICAgICAgY29uc3QgaXNBcnJvd0Z1bmN0aW9uVHlwZUFubm90YXRpb24gPSAhKG5hbWVkVHlwZXMuT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eS5jaGVjayhwYXJlbnQpIHx8IG5hbWVkVHlwZXMuT2JqZWN0VHlwZUludGVybmFsU2xvdC5jaGVjayhwYXJlbnQpICYmIHBhcmVudC5tZXRob2QgfHwgbmFtZWRUeXBlcy5EZWNsYXJlRnVuY3Rpb24uY2hlY2socGF0aC5nZXRQYXJlbnROb2RlKDIpKSk7XG4gICAgICBjb25zdCBuZWVkc0NvbG9uID0gaXNBcnJvd0Z1bmN0aW9uVHlwZUFubm90YXRpb24gJiYgIW5hbWVkVHlwZXMuRnVuY3Rpb25UeXBlUGFyYW0uY2hlY2socGFyZW50KSAmJiAhbmFtZWRUeXBlcy5UeXBlQWxpYXMuY2hlY2socGFyZW50KTtcbiAgICAgIGlmIChuZWVkc0NvbG9uKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCI6IFwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhhc1R5cGVQYXJhbWV0ZXJzID0gISFuLnR5cGVQYXJhbWV0ZXJzO1xuICAgICAgY29uc3QgbmVlZHNQYXJlbnMgPSBoYXNUeXBlUGFyYW1ldGVycyB8fCBuLnBhcmFtcy5sZW5ndGggIT09IDEgfHwgbi5wYXJhbXNbMF0ubmFtZTtcbiAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgIGhhc1R5cGVQYXJhbWV0ZXJzID8gcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpIDogXCJcIixcbiAgICAgICAgbmVlZHNQYXJlbnMgPyBcIihcIiA6IFwiXCIsXG4gICAgICAgIHByaW50RnVuY3Rpb25QYXJhbXMocGF0aCwgb3B0aW9ucywgcHJpbnQpLFxuICAgICAgICBuZWVkc1BhcmVucyA/IFwiKVwiIDogXCJcIlxuICAgICAgKTtcbiAgICAgIGlmIChuLnJldHVyblR5cGUpIHtcbiAgICAgICAgcGFydHMucHVzaChcbiAgICAgICAgICBpc0Fycm93RnVuY3Rpb25UeXBlQW5ub3RhdGlvbiA/IFwiID0+IFwiIDogXCI6IFwiLFxuICAgICAgICAgIHBhdGguY2FsbChwcmludCwgXCJyZXR1cm5UeXBlXCIpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIkZ1bmN0aW9uVHlwZVBhcmFtXCI6IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKTtcbiAgICAgIHBhcnRzLnB1c2gobmFtZSk7XG4gICAgICBpZiAobi5vcHRpb25hbCkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiP1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lLmluZm9zWzBdLmxpbmUpIHtcbiAgICAgICAgcGFydHMucHVzaChcIjogXCIpO1xuICAgICAgfVxuICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIikpO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgfVxuICAgIGNhc2UgXCJHZW5lcmljVHlwZUFubm90YXRpb25cIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKVxuICAgICAgXSk7XG4gICAgY2FzZSBcIkRlY2xhcmVJbnRlcmZhY2VcIjpcbiAgICAgIHBhcnRzLnB1c2goXCJkZWNsYXJlIFwiKTtcbiAgICBjYXNlIFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIjpcbiAgICBjYXNlIFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiOlxuICAgICAgaWYgKG4uZGVjbGFyZSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiZGVjbGFyZSBcIik7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICBcImludGVyZmFjZSBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIiksXG4gICAgICAgIFwiIFwiXG4gICAgICApO1xuICAgICAgaWYgKG5bXCJleHRlbmRzXCJdICYmIG5bXCJleHRlbmRzXCJdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFydHMucHVzaChcbiAgICAgICAgICBcImV4dGVuZHMgXCIsXG4gICAgICAgICAgZnJvbVN0cmluZyhcIiwgXCIpLmpvaW4ocGF0aC5tYXAocHJpbnQsIFwiZXh0ZW5kc1wiKSksXG4gICAgICAgICAgXCIgXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLmJvZHkpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICBjYXNlIFwiQ2xhc3NJbXBsZW1lbnRzXCI6XG4gICAgY2FzZSBcIkludGVyZmFjZUV4dGVuZHNcIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwiaWRcIiksXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKVxuICAgICAgXSk7XG4gICAgY2FzZSBcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcIiAmIFwiKS5qb2luKHBhdGgubWFwKHByaW50LCBcInR5cGVzXCIpKTtcbiAgICBjYXNlIFwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXCI/XCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKV0pO1xuICAgIGNhc2UgXCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcIm51bGxcIiwgb3B0aW9ucyk7XG4gICAgY2FzZSBcIlRoaXNUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJ0aGlzXCIsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJudW1iZXJcIiwgb3B0aW9ucyk7XG4gICAgY2FzZSBcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIjpcbiAgICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIik7XG4gICAgY2FzZSBcIk9iamVjdFR5cGVJbmRleGVyXCI6XG4gICAgICBpZiAobi5zdGF0aWMpIHtcbiAgICAgICAgcGFydHMucHVzaChcInN0YXRpYyBcIik7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKHByaW50VmFyaWFuY2UocGF0aCwgcHJpbnQpLCBcIltcIik7XG4gICAgICBpZiAobi5pZCkge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJpZFwiKSwgXCI6IFwiKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImtleVwiKSwgXCJdOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIpKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJPYmplY3RUeXBlUHJvcGVydHlcIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICBwcmludFZhcmlhbmNlKHBhdGgsIHByaW50KSxcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImtleVwiKSxcbiAgICAgICAgbi5vcHRpb25hbCA/IFwiP1wiIDogXCJcIixcbiAgICAgICAgXCI6IFwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIilcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJPYmplY3RUeXBlSW50ZXJuYWxTbG90XCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgbi5zdGF0aWMgPyBcInN0YXRpYyBcIiA6IFwiXCIsXG4gICAgICAgIFwiW1tcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLFxuICAgICAgICBcIl1dXCIsXG4gICAgICAgIG4ub3B0aW9uYWwgPyBcIj9cIiA6IFwiXCIsXG4gICAgICAgIG4udmFsdWUudHlwZSAhPT0gXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIgPyBcIjogXCIgOiBcIlwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIilcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJxdWFsaWZpY2F0aW9uXCIpLFxuICAgICAgICBcIi5cIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpXG4gICAgICBdKTtcbiAgICBjYXNlIFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhub2RlU3RyKG4udmFsdWUsIG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiTnVtYmVyTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgY2FzZSBcIk51bWVyaWNMaXRlcmFsVHlwZUFubm90YXRpb25cIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKEpTT04uc3RyaW5naWZ5KG4udmFsdWUpLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiQmlnSW50TGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhuLnJhdywgb3B0aW9ucyk7XG4gICAgY2FzZSBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcInN0cmluZ1wiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiRGVjbGFyZVR5cGVBbGlhc1wiOlxuICAgICAgcGFydHMucHVzaChcImRlY2xhcmUgXCIpO1xuICAgIGNhc2UgXCJUeXBlQWxpYXNcIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICBcInR5cGUgXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSxcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpLFxuICAgICAgICBcIiA9IFwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwicmlnaHRcIiksXG4gICAgICAgIFwiO1wiXG4gICAgICBdKTtcbiAgICBjYXNlIFwiRGVjbGFyZU9wYXF1ZVR5cGVcIjpcbiAgICAgIHBhcnRzLnB1c2goXCJkZWNsYXJlIFwiKTtcbiAgICBjYXNlIFwiT3BhcXVlVHlwZVwiOlxuICAgICAgcGFydHMucHVzaChcbiAgICAgICAgXCJvcGFxdWUgdHlwZSBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIilcbiAgICAgICk7XG4gICAgICBpZiAobltcInN1cGVydHlwZVwiXSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInN1cGVydHlwZVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAobltcImltcGx0eXBlXCJdKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCIgPSBcIiwgcGF0aC5jYWxsKHByaW50LCBcImltcGx0eXBlXCIpKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2goXCI7XCIpO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIFwiKFwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKSxcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpLFxuICAgICAgICBcIilcIlxuICAgICAgXSk7XG4gICAgY2FzZSBcIlR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIFwiPFwiLFxuICAgICAgICBmcm9tU3RyaW5nKFwiLCBcIikuam9pbihwYXRoLm1hcChwcmludCwgXCJwYXJhbXNcIikpLFxuICAgICAgICBcIj5cIlxuICAgICAgXSk7XG4gICAgY2FzZSBcIlZhcmlhbmNlXCI6XG4gICAgICBpZiAobi5raW5kID09PSBcInBsdXNcIikge1xuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhcIitcIik7XG4gICAgICB9XG4gICAgICBpZiAobi5raW5kID09PSBcIm1pbnVzXCIpIHtcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCItXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJcIik7XG4gICAgY2FzZSBcIlR5cGVQYXJhbWV0ZXJcIjpcbiAgICAgIGlmIChuLnZhcmlhbmNlKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocHJpbnRWYXJpYW5jZShwYXRoLCBwcmludCkpO1xuICAgICAgfVxuICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSk7XG4gICAgICBpZiAobi5ib3VuZCkge1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJib3VuZFwiKSk7XG4gICAgICB9XG4gICAgICBpZiAobltcImRlZmF1bHRcIl0pIHtcbiAgICAgICAgcGFydHMucHVzaChcIj1cIiwgcGF0aC5jYWxsKHByaW50LCBcImRlZmF1bHRcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgZnJvbVN0cmluZyhcInR5cGVvZiBcIiwgb3B0aW9ucyksXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKVxuICAgICAgXSk7XG4gICAgY2FzZSBcIkluZGV4ZWRBY2Nlc3NUeXBlXCI6XG4gICAgY2FzZSBcIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwib2JqZWN0VHlwZVwiKSxcbiAgICAgICAgbi5vcHRpb25hbCA/IFwiPy5cIiA6IFwiXCIsXG4gICAgICAgIFwiW1wiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwiaW5kZXhUeXBlXCIpLFxuICAgICAgICBcIl1cIlxuICAgICAgXSk7XG4gICAgY2FzZSBcIlVuaW9uVHlwZUFubm90YXRpb25cIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiIHwgXCIpLmpvaW4ocGF0aC5tYXAocHJpbnQsIFwidHlwZXNcIikpO1xuICAgIGNhc2UgXCJWb2lkVHlwZUFubm90YXRpb25cIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwidm9pZFwiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiTnVsbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcIm51bGxcIiwgb3B0aW9ucyk7XG4gICAgY2FzZSBcIlN5bWJvbFR5cGVBbm5vdGF0aW9uXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcInN5bWJvbFwiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiQmlnSW50VHlwZUFubm90YXRpb25cIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiYmlnaW50XCIsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJUU1R5cGVcIjpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVucHJpbnRhYmxlIHR5cGU6IFwiICsgSlNPTi5zdHJpbmdpZnkobi50eXBlKSk7XG4gICAgY2FzZSBcIlRTTnVtYmVyS2V5d29yZFwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJudW1iZXJcIiwgb3B0aW9ucyk7XG4gICAgY2FzZSBcIlRTQmlnSW50S2V5d29yZFwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJiaWdpbnRcIiwgb3B0aW9ucyk7XG4gICAgY2FzZSBcIlRTT2JqZWN0S2V5d29yZFwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJvYmplY3RcIiwgb3B0aW9ucyk7XG4gICAgY2FzZSBcIlRTQm9vbGVhbktleXdvcmRcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiYm9vbGVhblwiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiVFNTdHJpbmdLZXl3b3JkXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcInN0cmluZ1wiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiVFNTeW1ib2xLZXl3b3JkXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcInN5bWJvbFwiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiVFNBbnlLZXl3b3JkXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcImFueVwiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiVFNWb2lkS2V5d29yZFwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJ2b2lkXCIsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJUU0ludHJpbnNpY0tleXdvcmRcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiaW50cmluc2ljXCIsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJUU1RoaXNUeXBlXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcInRoaXNcIiwgb3B0aW9ucyk7XG4gICAgY2FzZSBcIlRTTnVsbEtleXdvcmRcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwibnVsbFwiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiVFNVbmRlZmluZWRLZXl3b3JkXCI6XG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhcInVuZGVmaW5lZFwiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiVFNVbmtub3duS2V5d29yZFwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJ1bmtub3duXCIsIG9wdGlvbnMpO1xuICAgIGNhc2UgXCJUU05ldmVyS2V5d29yZFwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJuZXZlclwiLCBvcHRpb25zKTtcbiAgICBjYXNlIFwiVFNBcnJheVR5cGVcIjpcbiAgICAgIHJldHVybiBjb25jYXQoW3BhdGguY2FsbChwcmludCwgXCJlbGVtZW50VHlwZVwiKSwgXCJbXVwiXSk7XG4gICAgY2FzZSBcIlRTTGl0ZXJhbFR5cGVcIjpcbiAgICAgIHJldHVybiBwYXRoLmNhbGwocHJpbnQsIFwibGl0ZXJhbFwiKTtcbiAgICBjYXNlIFwiVFNVbmlvblR5cGVcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiIHwgXCIpLmpvaW4ocGF0aC5tYXAocHJpbnQsIFwidHlwZXNcIikpO1xuICAgIGNhc2UgXCJUU0ludGVyc2VjdGlvblR5cGVcIjpcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKFwiICYgXCIpLmpvaW4ocGF0aC5tYXAocHJpbnQsIFwidHlwZXNcIikpO1xuICAgIGNhc2UgXCJUU0NvbmRpdGlvbmFsVHlwZVwiOlxuICAgICAgcGFydHMucHVzaChcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImNoZWNrVHlwZVwiKSxcbiAgICAgICAgXCIgZXh0ZW5kcyBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImV4dGVuZHNUeXBlXCIpLFxuICAgICAgICBcIiA/IFwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidHJ1ZVR5cGVcIiksXG4gICAgICAgIFwiIDogXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJmYWxzZVR5cGVcIilcbiAgICAgICk7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICBjYXNlIFwiVFNJbmZlclR5cGVcIjpcbiAgICAgIHBhcnRzLnB1c2goXCJpbmZlciBcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJcIikpO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIlRTUGFyZW50aGVzaXplZFR5cGVcIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1wiKFwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIiksIFwiKVwiXSk7XG4gICAgY2FzZSBcIlRTRnVuY3Rpb25UeXBlXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpLFxuICAgICAgICBcIihcIixcbiAgICAgICAgcHJpbnRGdW5jdGlvblBhcmFtcyhwYXRoLCBvcHRpb25zLCBwcmludCksXG4gICAgICAgIFwiKSA9PiBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIsIFwidHlwZUFubm90YXRpb25cIilcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJUU0NvbnN0cnVjdG9yVHlwZVwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIFwibmV3IFwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIiksXG4gICAgICAgIFwiKFwiLFxuICAgICAgICBwcmludEZ1bmN0aW9uUGFyYW1zKHBhdGgsIG9wdGlvbnMsIHByaW50KSxcbiAgICAgICAgXCIpID0+IFwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIiwgXCJ0eXBlQW5ub3RhdGlvblwiKVxuICAgICAgXSk7XG4gICAgY2FzZSBcIlRTTWFwcGVkVHlwZVwiOiB7XG4gICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICBuLnJlYWRvbmx5ID8gXCJyZWFkb25seSBcIiA6IFwiXCIsXG4gICAgICAgIFwiW1wiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlclwiKSxcbiAgICAgICAgXCJdXCIsXG4gICAgICAgIG4ub3B0aW9uYWwgPyBcIj9cIiA6IFwiXCJcbiAgICAgICk7XG4gICAgICBpZiAobi50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpLCBcIjtcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uY2F0KFtcIntcXG5cIiwgY29uY2F0KHBhcnRzKS5pbmRlbnQob3B0aW9ucy50YWJXaWR0aCksIFwiXFxufVwiXSk7XG4gICAgfVxuICAgIGNhc2UgXCJUU1R1cGxlVHlwZVwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIFwiW1wiLFxuICAgICAgICBmcm9tU3RyaW5nKFwiLCBcIikuam9pbihwYXRoLm1hcChwcmludCwgXCJlbGVtZW50VHlwZXNcIikpLFxuICAgICAgICBcIl1cIlxuICAgICAgXSk7XG4gICAgY2FzZSBcIlRTTmFtZWRUdXBsZU1lbWJlclwiOlxuICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwibGFiZWxcIikpO1xuICAgICAgaWYgKG4ub3B0aW9uYWwpIHtcbiAgICAgICAgcGFydHMucHVzaChcIj9cIik7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKFwiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImVsZW1lbnRUeXBlXCIpKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJUU1Jlc3RUeXBlXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcIi4uLlwiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIildKTtcbiAgICBjYXNlIFwiVFNPcHRpb25hbFR5cGVcIjpcbiAgICAgIHJldHVybiBjb25jYXQoW3BhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKSwgXCI/XCJdKTtcbiAgICBjYXNlIFwiVFNJbmRleGVkQWNjZXNzVHlwZVwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJvYmplY3RUeXBlXCIpLFxuICAgICAgICBcIltcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImluZGV4VHlwZVwiKSxcbiAgICAgICAgXCJdXCJcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJUU1R5cGVPcGVyYXRvclwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJvcGVyYXRvclwiKSxcbiAgICAgICAgXCIgXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKVxuICAgICAgXSk7XG4gICAgY2FzZSBcIlRTVHlwZUxpdGVyYWxcIjoge1xuICAgICAgY29uc3QgbWVtYmVycyA9IGZyb21TdHJpbmcoXCJcXG5cIikuam9pbihcbiAgICAgICAgcGF0aC5tYXAocHJpbnQsIFwibWVtYmVyc1wiKS5tYXAoKG1lbWJlcikgPT4ge1xuICAgICAgICAgIGlmIChsYXN0Tm9uU3BhY2VDaGFyYWN0ZXIobWVtYmVyKSAhPT0gXCI7XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBtZW1iZXIuY29uY2F0KFwiO1wiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1lbWJlcjtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBpZiAobWVtYmVycy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJ7fVwiLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2goXCJ7XFxuXCIsIG1lbWJlcnMuaW5kZW50KG9wdGlvbnMudGFiV2lkdGgpLCBcIlxcbn1cIik7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIlRTRW51bU1lbWJlclwiOlxuICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwiaWRcIikpO1xuICAgICAgaWYgKG4uaW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgcGFydHMucHVzaChcIiA9IFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiaW5pdGlhbGl6ZXJcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIlRTVHlwZVF1ZXJ5XCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtcInR5cGVvZiBcIiwgcGF0aC5jYWxsKHByaW50LCBcImV4cHJOYW1lXCIpXSk7XG4gICAgY2FzZSBcIlRTUGFyYW1ldGVyUHJvcGVydHlcIjpcbiAgICAgIGlmIChuLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgICAgcGFydHMucHVzaChuLmFjY2Vzc2liaWxpdHksIFwiIFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLmV4cG9ydCkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiZXhwb3J0IFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLnN0YXRpYykge1xuICAgICAgICBwYXJ0cy5wdXNoKFwic3RhdGljIFwiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuLnJlYWRvbmx5KSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJyZWFkb25seSBcIik7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJwYXJhbWV0ZXJcIikpO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIlRTVHlwZVJlZmVyZW5jZVwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJ0eXBlTmFtZVwiKSxcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpXG4gICAgICBdKTtcbiAgICBjYXNlIFwiVFNRdWFsaWZpZWROYW1lXCI6XG4gICAgICByZXR1cm4gY29uY2F0KFtwYXRoLmNhbGwocHJpbnQsIFwibGVmdFwiKSwgXCIuXCIsIHBhdGguY2FsbChwcmludCwgXCJyaWdodFwiKV0pO1xuICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIjoge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpO1xuICAgICAgcGFydHMucHVzaChcbiAgICAgICAgZXhwcmVzc2lvbixcbiAgICAgICAgbi50eXBlID09PSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiID8gXCIgc2F0aXNmaWVzIFwiIDogXCIgYXMgXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIH1cbiAgICBjYXNlIFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKSxcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpXG4gICAgICBdKTtcbiAgICBjYXNlIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIiksIFwiIVwiXSk7XG4gICAgY2FzZSBcIlRTVHlwZUFubm90YXRpb25cIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1wiOiBcIiwgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpXSk7XG4gICAgY2FzZSBcIlRTSW5kZXhTaWduYXR1cmVcIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICBuLnJlYWRvbmx5ID8gXCJyZWFkb25seSBcIiA6IFwiXCIsXG4gICAgICAgIFwiW1wiLFxuICAgICAgICBwYXRoLm1hcChwcmludCwgXCJwYXJhbWV0ZXJzXCIpLFxuICAgICAgICBcIl1cIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpXG4gICAgICBdKTtcbiAgICBjYXNlIFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiOlxuICAgICAgcGFydHMucHVzaChwcmludFZhcmlhbmNlKHBhdGgsIHByaW50KSwgbi5yZWFkb25seSA/IFwicmVhZG9ubHkgXCIgOiBcIlwiKTtcbiAgICAgIGlmIChuLmNvbXB1dGVkKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJbXCIsIHBhdGguY2FsbChwcmludCwgXCJrZXlcIiksIFwiXVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImtleVwiKSk7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKG4ub3B0aW9uYWwgPyBcIj9cIiA6IFwiXCIsIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKSk7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICBjYXNlIFwiVFNNZXRob2RTaWduYXR1cmVcIjpcbiAgICAgIGlmIChuLmNvbXB1dGVkKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJbXCIsIHBhdGguY2FsbChwcmludCwgXCJrZXlcIiksIFwiXVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImtleVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAobi5vcHRpb25hbCkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiP1wiKTtcbiAgICAgIH1cbiAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKSxcbiAgICAgICAgXCIoXCIsXG4gICAgICAgIHByaW50RnVuY3Rpb25QYXJhbXMocGF0aCwgb3B0aW9ucywgcHJpbnQpLFxuICAgICAgICBcIilcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIlRTVHlwZVByZWRpY2F0ZVwiOlxuICAgICAgaWYgKG4uYXNzZXJ0cykge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiYXNzZXJ0cyBcIik7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJwYXJhbWV0ZXJOYW1lXCIpKTtcbiAgICAgIGlmIChuLnR5cGVBbm5vdGF0aW9uKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgICAgXCIgaXMgXCIsXG4gICAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIsIFwidHlwZUFubm90YXRpb25cIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIGNhc2UgXCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKSxcbiAgICAgICAgXCIoXCIsXG4gICAgICAgIHByaW50RnVuY3Rpb25QYXJhbXMocGF0aCwgb3B0aW9ucywgcHJpbnQpLFxuICAgICAgICBcIilcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVBbm5vdGF0aW9uXCIpXG4gICAgICBdKTtcbiAgICBjYXNlIFwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiOlxuICAgICAgaWYgKG4udHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgcGFydHMucHVzaChcIm5ld1wiLCBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaChcIm5ldyBcIik7XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICBcIihcIixcbiAgICAgICAgcHJpbnRGdW5jdGlvblBhcmFtcyhwYXRoLCBvcHRpb25zLCBwcmludCksXG4gICAgICAgIFwiKVwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIilcbiAgICAgICk7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICBjYXNlIFwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIG4uZGVjbGFyZSA/IFwiZGVjbGFyZSBcIiA6IFwiXCIsXG4gICAgICAgIFwidHlwZSBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIiksXG4gICAgICAgIFwiID0gXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJ0eXBlQW5ub3RhdGlvblwiKSxcbiAgICAgICAgXCI7XCJcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJUU1R5cGVQYXJhbWV0ZXJcIjoge1xuICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKSk7XG4gICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoMCk7XG4gICAgICBjb25zdCBpc0luTWFwcGVkVHlwZSA9IG5hbWVkVHlwZXMuVFNNYXBwZWRUeXBlLmNoZWNrKHBhcmVudCk7XG4gICAgICBpZiAobi5jb25zdHJhaW50KSB7XG4gICAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgICAgaXNJbk1hcHBlZFR5cGUgPyBcIiBpbiBcIiA6IFwiIGV4dGVuZHMgXCIsXG4gICAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImNvbnN0cmFpbnRcIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChuW1wiZGVmYXVsdFwiXSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiID0gXCIsIHBhdGguY2FsbChwcmludCwgXCJkZWZhdWx0XCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIH1cbiAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6IHtcbiAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgIFwiPFwiLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidHlwZUFubm90YXRpb25cIiksXG4gICAgICAgIFwiPiBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImV4cHJlc3Npb25cIilcbiAgICAgICk7XG4gICAgICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbiAgICB9XG4gICAgY2FzZSBcIlRTVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCI6XG4gICAgY2FzZSBcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1xuICAgICAgICBcIjxcIixcbiAgICAgICAgZnJvbVN0cmluZyhcIiwgXCIpLmpvaW4ocGF0aC5tYXAocHJpbnQsIFwicGFyYW1zXCIpKSxcbiAgICAgICAgXCI+XCJcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJUU0VudW1EZWNsYXJhdGlvblwiOiB7XG4gICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICBuLmRlY2xhcmUgPyBcImRlY2xhcmUgXCIgOiBcIlwiLFxuICAgICAgICBuLmNvbnN0ID8gXCJjb25zdCBcIiA6IFwiXCIsXG4gICAgICAgIFwiZW51bSBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcImlkXCIpXG4gICAgICApO1xuICAgICAgY29uc3QgbWVtYmVyTGluZXMgPSBmcm9tU3RyaW5nKFwiLFxcblwiKS5qb2luKHBhdGgubWFwKHByaW50LCBcIm1lbWJlcnNcIikpO1xuICAgICAgaWYgKG1lbWJlckxpbmVzLmlzRW1wdHkoKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwiIHt9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMucHVzaChcIiB7XFxuXCIsIG1lbWJlckxpbmVzLmluZGVudChvcHRpb25zLnRhYldpZHRoKSwgXCJcXG59XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgfVxuICAgIGNhc2UgXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJleHByZXNzaW9uXCIpLFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIilcbiAgICAgIF0pO1xuICAgIGNhc2UgXCJUU0ludGVyZmFjZUJvZHlcIjoge1xuICAgICAgY29uc3QgbGluZXMgPSBmcm9tU3RyaW5nKFwiXFxuXCIpLmpvaW4oXG4gICAgICAgIHBhdGgubWFwKHByaW50LCBcImJvZHlcIikubWFwKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgaWYgKGxhc3ROb25TcGFjZUNoYXJhY3RlcihlbGVtZW50KSAhPT0gXCI7XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNvbmNhdChcIjtcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGlmIChsaW5lcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCJ7fVwiLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25jYXQoW1wie1xcblwiLCBsaW5lcy5pbmRlbnQob3B0aW9ucy50YWJXaWR0aCksIFwiXFxufVwiXSk7XG4gICAgfVxuICAgIGNhc2UgXCJUU0ltcG9ydFR5cGVcIjpcbiAgICAgIHBhcnRzLnB1c2goXCJpbXBvcnQoXCIsIHBhdGguY2FsbChwcmludCwgXCJhcmd1bWVudFwiKSwgXCIpXCIpO1xuICAgICAgaWYgKG4ucXVhbGlmaWVyKSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCIuXCIsIHBhdGguY2FsbChwcmludCwgXCJxdWFsaWZpZXJcIikpO1xuICAgICAgfVxuICAgICAgaWYgKG4udHlwZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgcGFydHMucHVzaChwYXRoLmNhbGwocHJpbnQsIFwidHlwZVBhcmFtZXRlcnNcIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgY2FzZSBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIjpcbiAgICAgIGlmIChuLmlzRXhwb3J0KSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCJleHBvcnQgXCIpO1xuICAgICAgfVxuICAgICAgcGFydHMucHVzaChcbiAgICAgICAgXCJpbXBvcnQgXCIsXG4gICAgICAgIHBhdGguY2FsbChwcmludCwgXCJpZFwiKSxcbiAgICAgICAgXCIgPSBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcIm1vZHVsZVJlZmVyZW5jZVwiKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBtYXliZUFkZFNlbWljb2xvbihjb25jYXQocGFydHMpKTtcbiAgICBjYXNlIFwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiOlxuICAgICAgcmV0dXJuIGNvbmNhdChbXCJyZXF1aXJlKFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKSwgXCIpXCJdKTtcbiAgICBjYXNlIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiOiB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBwYXRoLmdldFBhcmVudE5vZGUoKTtcbiAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gXCJUU01vZHVsZURlY2xhcmF0aW9uXCIpIHtcbiAgICAgICAgcGFydHMucHVzaChcIi5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAobi5kZWNsYXJlKSB7XG4gICAgICAgICAgcGFydHMucHVzaChcImRlY2xhcmUgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbi5nbG9iYWwpIHtcbiAgICAgICAgICBjb25zdCBpc0V4dGVybmFsID0gbi5pZC50eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIiB8fCBuLmlkLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIHR5cGVvZiBuLmlkLnZhbHVlID09PSBcInN0cmluZ1wiO1xuICAgICAgICAgIGlmIChpc0V4dGVybmFsKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFwibW9kdWxlIFwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4ubG9jICYmIG4ubG9jLmxpbmVzICYmIG4uaWQubG9jKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSBuLmxvYy5saW5lcy5zbGljZVN0cmluZyhuLmxvYy5zdGFydCwgbi5pZC5sb2Muc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHByZWZpeC5pbmRleE9mKFwibW9kdWxlXCIpID49IDApIHtcbiAgICAgICAgICAgICAgcGFydHMucHVzaChcIm1vZHVsZSBcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFwibmFtZXNwYWNlIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFydHMucHVzaChcIm5hbWVzcGFjZSBcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJpZFwiKSk7XG4gICAgICBpZiAobi5ib2R5KSB7XG4gICAgICAgIHBhcnRzLnB1c2goXCIgXCIpO1xuICAgICAgICBwYXJ0cy5wdXNoKHBhdGguY2FsbChwcmludCwgXCJib2R5XCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIH1cbiAgICBjYXNlIFwiVFNNb2R1bGVCbG9ja1wiOiB7XG4gICAgICBjb25zdCBuYWtlZCA9IHBhdGguY2FsbChcbiAgICAgICAgKGJvZHlQYXRoKSA9PiBwcmludFN0YXRlbWVudFNlcXVlbmNlKGJvZHlQYXRoLCBvcHRpb25zLCBwcmludCksXG4gICAgICAgIFwiYm9keVwiXG4gICAgICApO1xuICAgICAgaWYgKG5ha2VkLmlzRW1wdHkoKSkge1xuICAgICAgICBwYXJ0cy5wdXNoKFwie31cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5wdXNoKFwie1xcblwiLCBuYWtlZC5pbmRlbnQob3B0aW9ucy50YWJXaWR0aCksIFwiXFxufVwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICAgIH1cbiAgICBjYXNlIFwiVFNJbnN0YW50aWF0aW9uRXhwcmVzc2lvblwiOiB7XG4gICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICBwYXRoLmNhbGwocHJpbnQsIFwiZXhwcmVzc2lvblwiKSxcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInR5cGVQYXJhbWV0ZXJzXCIpXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG4gICAgfVxuICAgIGNhc2UgXCJWOEludHJpbnNpY0lkZW50aWZpZXJcIjpcbiAgICAgIHJldHVybiBjb25jYXQoW1wiJVwiLCBwYXRoLmNhbGwocHJpbnQsIFwibmFtZVwiKV0pO1xuICAgIGNhc2UgXCJUb3BpY1JlZmVyZW5jZVwiOlxuICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCIjXCIpO1xuICAgIGNhc2UgXCJDbGFzc0hlcml0YWdlXCI6XG4gICAgY2FzZSBcIkNvbXByZWhlbnNpb25CbG9ja1wiOlxuICAgIGNhc2UgXCJDb21wcmVoZW5zaW9uRXhwcmVzc2lvblwiOlxuICAgIGNhc2UgXCJHbG9iXCI6XG4gICAgY2FzZSBcIkdlbmVyYXRvckV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiTGV0U3RhdGVtZW50XCI6XG4gICAgY2FzZSBcIkxldEV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiR3JhcGhFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIkdyYXBoSW5kZXhFeHByZXNzaW9uXCI6XG4gICAgY2FzZSBcIlhNTERlZmF1bHREZWNsYXJhdGlvblwiOlxuICAgIGNhc2UgXCJYTUxBbnlOYW1lXCI6XG4gICAgY2FzZSBcIlhNTFF1YWxpZmllZElkZW50aWZpZXJcIjpcbiAgICBjYXNlIFwiWE1MRnVuY3Rpb25RdWFsaWZpZWRJZGVudGlmaWVyXCI6XG4gICAgY2FzZSBcIlhNTEF0dHJpYnV0ZVNlbGVjdG9yXCI6XG4gICAgY2FzZSBcIlhNTEZpbHRlckV4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiWE1MXCI6XG4gICAgY2FzZSBcIlhNTEVsZW1lbnRcIjpcbiAgICBjYXNlIFwiWE1MTGlzdFwiOlxuICAgIGNhc2UgXCJYTUxFc2NhcGVcIjpcbiAgICBjYXNlIFwiWE1MVGV4dFwiOlxuICAgIGNhc2UgXCJYTUxTdGFydFRhZ1wiOlxuICAgIGNhc2UgXCJYTUxFbmRUYWdcIjpcbiAgICBjYXNlIFwiWE1MUG9pbnRUYWdcIjpcbiAgICBjYXNlIFwiWE1MTmFtZVwiOlxuICAgIGNhc2UgXCJYTUxBdHRyaWJ1dGVcIjpcbiAgICBjYXNlIFwiWE1MQ2RhdGFcIjpcbiAgICBjYXNlIFwiWE1MQ29tbWVudFwiOlxuICAgIGNhc2UgXCJYTUxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb25cIjpcbiAgICBkZWZhdWx0OlxuICAgICAgZGVidWdnZXI7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgSlNPTi5zdHJpbmdpZnkobi50eXBlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHByaW50RGVjb3JhdG9ycyhwYXRoLCBwcmludFBhdGgpIHtcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgY29uc3Qgbm9kZSA9IHBhdGguZ2V0VmFsdWUoKTtcbiAgaWYgKG5vZGUuZGVjb3JhdG9ycyAmJiBub2RlLmRlY29yYXRvcnMubGVuZ3RoID4gMCAmJiAvLyBJZiB0aGUgcGFyZW50IG5vZGUgaXMgYW4gZXhwb3J0IGRlY2xhcmF0aW9uLCBpdCB3aWxsIGJlXG4gIC8vIHJlc3BvbnNpYmxlIGZvciBwcmludGluZyBub2RlLmRlY29yYXRvcnMuXG4gICFnZXRQYXJlbnRFeHBvcnREZWNsYXJhdGlvbihwYXRoKSkge1xuICAgIHBhdGguZWFjaChmdW5jdGlvbihkZWNvcmF0b3JQYXRoKSB7XG4gICAgICBwYXJ0cy5wdXNoKHByaW50UGF0aChkZWNvcmF0b3JQYXRoKSwgXCJcXG5cIik7XG4gICAgfSwgXCJkZWNvcmF0b3JzXCIpO1xuICB9IGVsc2UgaWYgKGlzRXhwb3J0RGVjbGFyYXRpb24obm9kZSkgJiYgbm9kZS5kZWNsYXJhdGlvbiAmJiBub2RlLmRlY2xhcmF0aW9uLmRlY29yYXRvcnMpIHtcbiAgICBwYXRoLmVhY2goXG4gICAgICBmdW5jdGlvbihkZWNvcmF0b3JQYXRoKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocHJpbnRQYXRoKGRlY29yYXRvclBhdGgpLCBcIlxcblwiKTtcbiAgICAgIH0sXG4gICAgICBcImRlY2xhcmF0aW9uXCIsXG4gICAgICBcImRlY29yYXRvcnNcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG59XG5mdW5jdGlvbiBwcmludFN0YXRlbWVudFNlcXVlbmNlKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gIGNvbnN0IGZpbHRlcmVkID0gW107XG4gIHBhdGguZWFjaChmdW5jdGlvbihzdG10UGF0aCkge1xuICAgIGNvbnN0IHN0bXQgPSBzdG10UGF0aC5nZXRWYWx1ZSgpO1xuICAgIGlmICghc3RtdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoc3RtdC50eXBlID09PSBcIkVtcHR5U3RhdGVtZW50XCIgJiYgIShzdG10LmNvbW1lbnRzICYmIHN0bXQuY29tbWVudHMubGVuZ3RoID4gMCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWVkVHlwZXMuQ29tbWVudC5jaGVjayhzdG10KSkgOyBlbHNlIGlmIChuYW1lZFR5cGVzLlN0YXRlbWVudC5jaGVjayhzdG10KSkgOyBlbHNlIHtcbiAgICAgIGlzU3RyaW5nLmFzc2VydChzdG10KTtcbiAgICB9XG4gICAgZmlsdGVyZWQucHVzaCh7XG4gICAgICBub2RlOiBzdG10LFxuICAgICAgcHJpbnRlZDogcHJpbnQoc3RtdFBhdGgpXG4gICAgfSk7XG4gIH0pO1xuICBsZXQgcHJldlRyYWlsaW5nU3BhY2UgPSBudWxsO1xuICBjb25zdCBsZW4gPSBmaWx0ZXJlZC5sZW5ndGg7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGZpbHRlcmVkLmZvckVhY2goZnVuY3Rpb24oaW5mbywgaSkge1xuICAgIGNvbnN0IHByaW50ZWQgPSBpbmZvLnByaW50ZWQ7XG4gICAgY29uc3Qgc3RtdCA9IGluZm8ubm9kZTtcbiAgICBjb25zdCBtdWx0aUxpbmUgPSBwcmludGVkLmxlbmd0aCA+IDE7XG4gICAgY29uc3Qgbm90Rmlyc3QgPSBpID4gMDtcbiAgICBjb25zdCBub3RMYXN0ID0gaSA8IGxlbiAtIDE7XG4gICAgbGV0IGxlYWRpbmdTcGFjZTtcbiAgICBsZXQgdHJhaWxpbmdTcGFjZTtcbiAgICBjb25zdCBsaW5lcyA9IHN0bXQgJiYgc3RtdC5sb2MgJiYgc3RtdC5sb2MubGluZXM7XG4gICAgY29uc3QgdHJ1ZUxvYyA9IGxpbmVzICYmIG9wdGlvbnMucmV1c2VXaGl0ZXNwYWNlICYmIGdldFRydWVMb2Moc3RtdCwgbGluZXMpO1xuICAgIGlmIChub3RGaXJzdCkge1xuICAgICAgaWYgKHRydWVMb2MpIHtcbiAgICAgICAgY29uc3QgYmVmb3JlU3RhcnQgPSBsaW5lcy5za2lwU3BhY2VzKHRydWVMb2Muc3RhcnQsIHRydWUpO1xuICAgICAgICBjb25zdCBiZWZvcmVTdGFydExpbmUgPSBiZWZvcmVTdGFydCA/IGJlZm9yZVN0YXJ0LmxpbmUgOiAxO1xuICAgICAgICBjb25zdCBsZWFkaW5nR2FwID0gdHJ1ZUxvYy5zdGFydC5saW5lIC0gYmVmb3JlU3RhcnRMaW5lO1xuICAgICAgICBsZWFkaW5nU3BhY2UgPSBBcnJheShsZWFkaW5nR2FwICsgMSkuam9pbihcIlxcblwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlYWRpbmdTcGFjZSA9IG11bHRpTGluZSA/IFwiXFxuXFxuXCIgOiBcIlxcblwiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZWFkaW5nU3BhY2UgPSBcIlwiO1xuICAgIH1cbiAgICBpZiAobm90TGFzdCkge1xuICAgICAgaWYgKHRydWVMb2MpIHtcbiAgICAgICAgY29uc3QgYWZ0ZXJFbmQgPSBsaW5lcy5za2lwU3BhY2VzKHRydWVMb2MuZW5kKTtcbiAgICAgICAgY29uc3QgYWZ0ZXJFbmRMaW5lID0gYWZ0ZXJFbmQgPyBhZnRlckVuZC5saW5lIDogbGluZXMubGVuZ3RoO1xuICAgICAgICBjb25zdCB0cmFpbGluZ0dhcCA9IGFmdGVyRW5kTGluZSAtIHRydWVMb2MuZW5kLmxpbmU7XG4gICAgICAgIHRyYWlsaW5nU3BhY2UgPSBBcnJheSh0cmFpbGluZ0dhcCArIDEpLmpvaW4oXCJcXG5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFpbGluZ1NwYWNlID0gbXVsdGlMaW5lID8gXCJcXG5cXG5cIiA6IFwiXFxuXCI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWlsaW5nU3BhY2UgPSBcIlwiO1xuICAgIH1cbiAgICBwYXJ0cy5wdXNoKG1heFNwYWNlKHByZXZUcmFpbGluZ1NwYWNlLCBsZWFkaW5nU3BhY2UpLCBwcmludGVkKTtcbiAgICBpZiAobm90TGFzdCkge1xuICAgICAgcHJldlRyYWlsaW5nU3BhY2UgPSB0cmFpbGluZ1NwYWNlO1xuICAgIH0gZWxzZSBpZiAodHJhaWxpbmdTcGFjZSkge1xuICAgICAgcGFydHMucHVzaCh0cmFpbGluZ1NwYWNlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY29uY2F0KHBhcnRzKTtcbn1cbmZ1bmN0aW9uIG1heFNwYWNlKHMxLCBzMikge1xuICBpZiAoIXMxICYmICFzMikge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKFwiXCIpO1xuICB9XG4gIGlmICghczEpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzMik7XG4gIH1cbiAgaWYgKCFzMikge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHMxKTtcbiAgfVxuICBjb25zdCBzcGFjZUxpbmVzMSA9IGZyb21TdHJpbmcoczEpO1xuICBjb25zdCBzcGFjZUxpbmVzMiA9IGZyb21TdHJpbmcoczIpO1xuICBpZiAoc3BhY2VMaW5lczIubGVuZ3RoID4gc3BhY2VMaW5lczEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHNwYWNlTGluZXMyO1xuICB9XG4gIHJldHVybiBzcGFjZUxpbmVzMTtcbn1cbmZ1bmN0aW9uIHByaW50Q2xhc3NNZW1iZXJNb2RpZmllcnMobm9kZSkge1xuICBjb25zdCBwYXJ0cyA9IFtdO1xuICBpZiAobm9kZS5kZWNsYXJlKSB7XG4gICAgcGFydHMucHVzaChcImRlY2xhcmUgXCIpO1xuICB9XG4gIGNvbnN0IGFjY2VzcyA9IG5vZGUuYWNjZXNzaWJpbGl0eSB8fCBub2RlLmFjY2VzcztcbiAgaWYgKHR5cGVvZiBhY2Nlc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICBwYXJ0cy5wdXNoKGFjY2VzcywgXCIgXCIpO1xuICB9XG4gIGlmIChub2RlLnN0YXRpYykge1xuICAgIHBhcnRzLnB1c2goXCJzdGF0aWMgXCIpO1xuICB9XG4gIGlmIChub2RlLm92ZXJyaWRlKSB7XG4gICAgcGFydHMucHVzaChcIm92ZXJyaWRlIFwiKTtcbiAgfVxuICBpZiAobm9kZS5hYnN0cmFjdCkge1xuICAgIHBhcnRzLnB1c2goXCJhYnN0cmFjdCBcIik7XG4gIH1cbiAgaWYgKG5vZGUucmVhZG9ubHkpIHtcbiAgICBwYXJ0cy5wdXNoKFwicmVhZG9ubHkgXCIpO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cbmZ1bmN0aW9uIHByaW50TWV0aG9kKHBhdGgsIG9wdGlvbnMsIHByaW50KSB7XG4gIGNvbnN0IG5vZGUgPSBwYXRoLmdldE5vZGUoKTtcbiAgY29uc3Qga2luZCA9IG5vZGUua2luZDtcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgbGV0IG5vZGVWYWx1ZSA9IG5vZGUudmFsdWU7XG4gIGlmICghbmFtZWRUeXBlcy5GdW5jdGlvbkV4cHJlc3Npb24uY2hlY2sobm9kZVZhbHVlKSkge1xuICAgIG5vZGVWYWx1ZSA9IG5vZGU7XG4gIH1cbiAgcGFydHMucHVzaCguLi5wcmludENsYXNzTWVtYmVyTW9kaWZpZXJzKG5vZGUpKTtcbiAgaWYgKG5vZGVWYWx1ZS5hc3luYykge1xuICAgIHBhcnRzLnB1c2goXCJhc3luYyBcIik7XG4gIH1cbiAgaWYgKG5vZGVWYWx1ZS5nZW5lcmF0b3IpIHtcbiAgICBwYXJ0cy5wdXNoKFwiKlwiKTtcbiAgfVxuICBpZiAoa2luZCA9PT0gXCJnZXRcIiB8fCBraW5kID09PSBcInNldFwiKSB7XG4gICAgcGFydHMucHVzaChraW5kLCBcIiBcIik7XG4gIH1cbiAgbGV0IGtleSA9IHBhdGguY2FsbChwcmludCwgXCJrZXlcIik7XG4gIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAga2V5ID0gY29uY2F0KFtcIltcIiwga2V5LCBcIl1cIl0pO1xuICB9XG4gIHBhcnRzLnB1c2goa2V5KTtcbiAgaWYgKG5vZGUub3B0aW9uYWwpIHtcbiAgICBwYXJ0cy5wdXNoKFwiP1wiKTtcbiAgfVxuICBpZiAobm9kZSA9PT0gbm9kZVZhbHVlKSB7XG4gICAgcGFydHMucHVzaChcbiAgICAgIHBhdGguY2FsbChwcmludCwgXCJ0eXBlUGFyYW1ldGVyc1wiKSxcbiAgICAgIFwiKFwiLFxuICAgICAgcHJpbnRGdW5jdGlvblBhcmFtcyhwYXRoLCBvcHRpb25zLCBwcmludCksXG4gICAgICBcIilcIixcbiAgICAgIHBhdGguY2FsbChwcmludCwgXCJyZXR1cm5UeXBlXCIpXG4gICAgKTtcbiAgICBpZiAobm9kZS5ib2R5KSB7XG4gICAgICBwYXJ0cy5wdXNoKFwiIFwiLCBwYXRoLmNhbGwocHJpbnQsIFwiYm9keVwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzLnB1c2goXCI7XCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgcGF0aC5jYWxsKHByaW50LCBcInZhbHVlXCIsIFwidHlwZVBhcmFtZXRlcnNcIiksXG4gICAgICBcIihcIixcbiAgICAgIHBhdGguY2FsbChcbiAgICAgICAgKHZhbHVlUGF0aCkgPT4gcHJpbnRGdW5jdGlvblBhcmFtcyh2YWx1ZVBhdGgsIG9wdGlvbnMsIHByaW50KSxcbiAgICAgICAgXCJ2YWx1ZVwiXG4gICAgICApLFxuICAgICAgXCIpXCIsXG4gICAgICBwYXRoLmNhbGwocHJpbnQsIFwidmFsdWVcIiwgXCJyZXR1cm5UeXBlXCIpXG4gICAgKTtcbiAgICBpZiAobm9kZVZhbHVlLmJvZHkpIHtcbiAgICAgIHBhcnRzLnB1c2goXCIgXCIsIHBhdGguY2FsbChwcmludCwgXCJ2YWx1ZVwiLCBcImJvZHlcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJ0cy5wdXNoKFwiO1wiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG59XG5mdW5jdGlvbiBwcmludEFyZ3VtZW50c0xpc3QocGF0aCwgb3B0aW9ucywgcHJpbnQpIHtcbiAgY29uc3QgcHJpbnRlZCA9IHBhdGgubWFwKHByaW50LCBcImFyZ3VtZW50c1wiKTtcbiAgY29uc3QgdHJhaWxpbmdDb21tYSA9IGlzVHJhaWxpbmdDb21tYUVuYWJsZWQob3B0aW9ucywgXCJwYXJhbWV0ZXJzXCIpO1xuICBsZXQgam9pbmVkID0gZnJvbVN0cmluZyhcIiwgXCIpLmpvaW4ocHJpbnRlZCk7XG4gIGlmIChqb2luZWQuZ2V0TGluZUxlbmd0aCgxKSA+IG9wdGlvbnMud3JhcENvbHVtbikge1xuICAgIGpvaW5lZCA9IGZyb21TdHJpbmcoXCIsXFxuXCIpLmpvaW4ocHJpbnRlZCk7XG4gICAgcmV0dXJuIGNvbmNhdChbXG4gICAgICBcIihcXG5cIixcbiAgICAgIGpvaW5lZC5pbmRlbnQob3B0aW9ucy50YWJXaWR0aCksXG4gICAgICB0cmFpbGluZ0NvbW1hID8gXCIsXFxuKVwiIDogXCJcXG4pXCJcbiAgICBdKTtcbiAgfVxuICByZXR1cm4gY29uY2F0KFtcIihcIiwgam9pbmVkLCBcIilcIl0pO1xufVxuZnVuY3Rpb24gcHJpbnRGdW5jdGlvblBhcmFtcyhwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICBjb25zdCBmdW4gPSBwYXRoLmdldFZhbHVlKCk7XG4gIGxldCBwYXJhbXM7XG4gIGxldCBwcmludGVkID0gW107XG4gIGlmIChmdW4ucGFyYW1zKSB7XG4gICAgcGFyYW1zID0gZnVuLnBhcmFtcztcbiAgICBwcmludGVkID0gcGF0aC5tYXAocHJpbnQsIFwicGFyYW1zXCIpO1xuICB9IGVsc2UgaWYgKGZ1bi5wYXJhbWV0ZXJzKSB7XG4gICAgcGFyYW1zID0gZnVuLnBhcmFtZXRlcnM7XG4gICAgcHJpbnRlZCA9IHBhdGgubWFwKHByaW50LCBcInBhcmFtZXRlcnNcIik7XG4gIH1cbiAgaWYgKGZ1bi5kZWZhdWx0cykge1xuICAgIHBhdGguZWFjaChmdW5jdGlvbihkZWZFeHByUGF0aCkge1xuICAgICAgY29uc3QgaSA9IGRlZkV4cHJQYXRoLmdldE5hbWUoKTtcbiAgICAgIGNvbnN0IHAgPSBwcmludGVkW2ldO1xuICAgICAgaWYgKHAgJiYgZGVmRXhwclBhdGguZ2V0VmFsdWUoKSkge1xuICAgICAgICBwcmludGVkW2ldID0gY29uY2F0KFtwLCBcIiA9IFwiLCBwcmludChkZWZFeHByUGF0aCldKTtcbiAgICAgIH1cbiAgICB9LCBcImRlZmF1bHRzXCIpO1xuICB9XG4gIGlmIChmdW4ucmVzdCkge1xuICAgIHByaW50ZWQucHVzaChjb25jYXQoW1wiLi4uXCIsIHBhdGguY2FsbChwcmludCwgXCJyZXN0XCIpXSkpO1xuICB9XG4gIGxldCBqb2luZWQgPSBmcm9tU3RyaW5nKFwiLCBcIikuam9pbihwcmludGVkKTtcbiAgaWYgKGpvaW5lZC5sZW5ndGggPiAxIHx8IGpvaW5lZC5nZXRMaW5lTGVuZ3RoKDEpID4gb3B0aW9ucy53cmFwQ29sdW1uKSB7XG4gICAgam9pbmVkID0gZnJvbVN0cmluZyhcIixcXG5cIikuam9pbihwcmludGVkKTtcbiAgICBpZiAoaXNUcmFpbGluZ0NvbW1hRW5hYmxlZChvcHRpb25zLCBcInBhcmFtZXRlcnNcIikgJiYgIWZ1bi5yZXN0ICYmIHBhcmFtc1twYXJhbXMubGVuZ3RoIC0gMV0udHlwZSAhPT0gXCJSZXN0RWxlbWVudFwiKSB7XG4gICAgICBqb2luZWQgPSBjb25jYXQoW2pvaW5lZCwgXCIsXFxuXCJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgam9pbmVkID0gY29uY2F0KFtqb2luZWQsIFwiXFxuXCJdKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmNhdChbXCJcXG5cIiwgam9pbmVkLmluZGVudChvcHRpb25zLnRhYldpZHRoKV0pO1xuICB9XG4gIHJldHVybiBqb2luZWQ7XG59XG5mdW5jdGlvbiBtYXliZVByaW50SW1wb3J0QXNzZXJ0aW9ucyhwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICBjb25zdCBuID0gcGF0aC5nZXRWYWx1ZSgpO1xuICBpZiAobi5hc3NlcnRpb25zICYmIG4uYXNzZXJ0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgcGFydHMgPSBbXCIgYXNzZXJ0IHtcIl07XG4gICAgY29uc3QgcHJpbnRlZCA9IHBhdGgubWFwKHByaW50LCBcImFzc2VydGlvbnNcIik7XG4gICAgY29uc3QgZmxhdCA9IGZyb21TdHJpbmcoXCIsIFwiKS5qb2luKHByaW50ZWQpO1xuICAgIGlmIChmbGF0Lmxlbmd0aCA+IDEgfHwgZmxhdC5nZXRMaW5lTGVuZ3RoKDEpID4gb3B0aW9ucy53cmFwQ29sdW1uKSB7XG4gICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICBcIlxcblwiLFxuICAgICAgICBmcm9tU3RyaW5nKFwiLFxcblwiKS5qb2luKHByaW50ZWQpLmluZGVudChvcHRpb25zLnRhYldpZHRoKSxcbiAgICAgICAgXCJcXG59XCJcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzLnB1c2goXCIgXCIsIGZsYXQsIFwiIH1cIik7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXQocGFydHMpO1xuICB9XG4gIHJldHVybiBmcm9tU3RyaW5nKFwiXCIpO1xufVxuZnVuY3Rpb24gcHJpbnRFeHBvcnREZWNsYXJhdGlvbihwYXRoLCBvcHRpb25zLCBwcmludCkge1xuICBjb25zdCBkZWNsID0gcGF0aC5nZXRWYWx1ZSgpO1xuICBjb25zdCBwYXJ0cyA9IFtcImV4cG9ydCBcIl07XG4gIGlmIChkZWNsLmV4cG9ydEtpbmQgJiYgZGVjbC5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgIGlmICghZGVjbC5kZWNsYXJhdGlvbikge1xuICAgICAgcGFydHMucHVzaChcInR5cGUgXCIpO1xuICAgIH1cbiAgfVxuICBjb25zdCBzaG91bGRQcmludFNwYWNlcyA9IG9wdGlvbnMub2JqZWN0Q3VybHlTcGFjaW5nO1xuICBuYW1lZFR5cGVzLkRlY2xhcmF0aW9uLmFzc2VydChkZWNsKTtcbiAgaWYgKGRlY2xbXCJkZWZhdWx0XCJdIHx8IGRlY2wudHlwZSA9PT0gXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIikge1xuICAgIHBhcnRzLnB1c2goXCJkZWZhdWx0IFwiKTtcbiAgfVxuICBpZiAoZGVjbC5kZWNsYXJhdGlvbikge1xuICAgIHBhcnRzLnB1c2gocGF0aC5jYWxsKHByaW50LCBcImRlY2xhcmF0aW9uXCIpKTtcbiAgfSBlbHNlIGlmIChkZWNsLnNwZWNpZmllcnMpIHtcbiAgICBpZiAoZGVjbC5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMSAmJiBkZWNsLnNwZWNpZmllcnNbMF0udHlwZSA9PT0gXCJFeHBvcnRCYXRjaFNwZWNpZmllclwiKSB7XG4gICAgICBwYXJ0cy5wdXNoKFwiKlwiKTtcbiAgICB9IGVsc2UgaWYgKGRlY2wuc3BlY2lmaWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHBhcnRzLnB1c2goXCJ7fVwiKTtcbiAgICB9IGVsc2UgaWYgKGRlY2wuc3BlY2lmaWVyc1swXS50eXBlID09PSBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgICAgY29uc3QgdW5icmFjZWRTcGVjaWZpZXJzID0gW107XG4gICAgICBjb25zdCBicmFjZWRTcGVjaWZpZXJzID0gW107XG4gICAgICBwYXRoLmVhY2goZnVuY3Rpb24oc3BlY2lmaWVyUGF0aCkge1xuICAgICAgICBjb25zdCBzcGVjID0gc3BlY2lmaWVyUGF0aC5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAoc3BlYy50eXBlID09PSBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgICAgICAgIHVuYnJhY2VkU3BlY2lmaWVycy5wdXNoKHByaW50KHNwZWNpZmllclBhdGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmFjZWRTcGVjaWZpZXJzLnB1c2gocHJpbnQoc3BlY2lmaWVyUGF0aCkpO1xuICAgICAgICB9XG4gICAgICB9LCBcInNwZWNpZmllcnNcIik7XG4gICAgICB1bmJyYWNlZFNwZWNpZmllcnMuZm9yRWFjaCgobGluZXMyLCBpKSA9PiB7XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIsIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGxpbmVzMik7XG4gICAgICB9KTtcbiAgICAgIGlmIChicmFjZWRTcGVjaWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbGV0IGxpbmVzMiA9IGZyb21TdHJpbmcoXCIsIFwiKS5qb2luKGJyYWNlZFNwZWNpZmllcnMpO1xuICAgICAgICBpZiAobGluZXMyLmdldExpbmVMZW5ndGgoMSkgPiBvcHRpb25zLndyYXBDb2x1bW4pIHtcbiAgICAgICAgICBsaW5lczIgPSBjb25jYXQoW1xuICAgICAgICAgICAgZnJvbVN0cmluZyhcIixcXG5cIikuam9pbihicmFjZWRTcGVjaWZpZXJzKS5pbmRlbnQob3B0aW9ucy50YWJXaWR0aCksXG4gICAgICAgICAgICBcIixcIlxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmJyYWNlZFNwZWNpZmllcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCIsIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZXMyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKFwie1xcblwiLCBsaW5lczIsIFwiXFxufVwiKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9iamVjdEN1cmx5U3BhY2luZykge1xuICAgICAgICAgIHBhcnRzLnB1c2goXCJ7IFwiLCBsaW5lczIsIFwiIH1cIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFydHMucHVzaChcIntcIiwgbGluZXMyLCBcIn1cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFydHMucHVzaChcbiAgICAgICAgc2hvdWxkUHJpbnRTcGFjZXMgPyBcInsgXCIgOiBcIntcIixcbiAgICAgICAgZnJvbVN0cmluZyhcIiwgXCIpLmpvaW4ocGF0aC5tYXAocHJpbnQsIFwic3BlY2lmaWVyc1wiKSksXG4gICAgICAgIHNob3VsZFByaW50U3BhY2VzID8gXCIgfVwiIDogXCJ9XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkZWNsLnNvdXJjZSkge1xuICAgICAgcGFydHMucHVzaChcbiAgICAgICAgXCIgZnJvbSBcIixcbiAgICAgICAgcGF0aC5jYWxsKHByaW50LCBcInNvdXJjZVwiKSxcbiAgICAgICAgbWF5YmVQcmludEltcG9ydEFzc2VydGlvbnMocGF0aCwgb3B0aW9ucywgcHJpbnQpXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBsZXQgbGluZXMgPSBjb25jYXQocGFydHMpO1xuICBpZiAobGFzdE5vblNwYWNlQ2hhcmFjdGVyKGxpbmVzKSAhPT0gXCI7XCIgJiYgIShkZWNsLmRlY2xhcmF0aW9uICYmIChkZWNsLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiRnVuY3Rpb25EZWNsYXJhdGlvblwiIHx8IGRlY2wuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJDbGFzc0RlY2xhcmF0aW9uXCIgfHwgZGVjbC5kZWNsYXJhdGlvbi50eXBlID09PSBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIiB8fCBkZWNsLmRlY2xhcmF0aW9uLnR5cGUgPT09IFwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiIHx8IGRlY2wuZGVjbGFyYXRpb24udHlwZSA9PT0gXCJUU0VudW1EZWNsYXJhdGlvblwiKSkpIHtcbiAgICBsaW5lcyA9IGNvbmNhdChbbGluZXMsIFwiO1wiXSk7XG4gIH1cbiAgcmV0dXJuIGxpbmVzO1xufVxuZnVuY3Rpb24gcHJpbnRGbG93RGVjbGFyYXRpb24ocGF0aCwgcGFydHMpIHtcbiAgY29uc3QgcGFyZW50RXhwb3J0RGVjbCA9IGdldFBhcmVudEV4cG9ydERlY2xhcmF0aW9uKHBhdGgpO1xuICBpZiAocGFyZW50RXhwb3J0RGVjbCkgOyBlbHNlIHtcbiAgICBwYXJ0cy51bnNoaWZ0KFwiZGVjbGFyZSBcIik7XG4gIH1cbiAgcmV0dXJuIGNvbmNhdChwYXJ0cyk7XG59XG5mdW5jdGlvbiBwcmludFZhcmlhbmNlKHBhdGgsIHByaW50KSB7XG4gIHJldHVybiBwYXRoLmNhbGwoZnVuY3Rpb24odmFyaWFuY2VQYXRoKSB7XG4gICAgY29uc3QgdmFsdWUgPSB2YXJpYW5jZVBhdGguZ2V0VmFsdWUoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gXCJwbHVzXCIpIHtcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCIrXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09PSBcIm1pbnVzXCIpIHtcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoXCItXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByaW50KHZhcmlhbmNlUGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tU3RyaW5nKFwiXCIpO1xuICB9LCBcInZhcmlhbmNlXCIpO1xufVxuZnVuY3Rpb24gYWRqdXN0Q2xhdXNlKGNsYXVzZSwgb3B0aW9ucykge1xuICBpZiAoY2xhdXNlLmxlbmd0aCA+IDEpXG4gICAgcmV0dXJuIGNvbmNhdChbXCIgXCIsIGNsYXVzZV0pO1xuICByZXR1cm4gY29uY2F0KFtcIlxcblwiLCBtYXliZUFkZFNlbWljb2xvbihjbGF1c2UpLmluZGVudChvcHRpb25zLnRhYldpZHRoKV0pO1xufVxuZnVuY3Rpb24gbGFzdE5vblNwYWNlQ2hhcmFjdGVyKGxpbmVzKSB7XG4gIGNvbnN0IHBvcyA9IGxpbmVzLmxhc3RQb3MoKTtcbiAgZG8ge1xuICAgIGNvbnN0IGNoID0gbGluZXMuY2hhckF0KHBvcyk7XG4gICAgaWYgKC9cXFMvLnRlc3QoY2gpKVxuICAgICAgcmV0dXJuIGNoO1xuICB9IHdoaWxlIChsaW5lcy5wcmV2UG9zKHBvcykpO1xufVxuZnVuY3Rpb24gZW5kc1dpdGhCcmFjZShsaW5lcykge1xuICByZXR1cm4gbGFzdE5vblNwYWNlQ2hhcmFjdGVyKGxpbmVzKSA9PT0gXCJ9XCI7XG59XG5mdW5jdGlvbiBzd2FwUXVvdGVzKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1snXCJdL2csIChtKSA9PiBtID09PSAnXCInID8gXCInXCIgOiAnXCInKTtcbn1cbmZ1bmN0aW9uIGdldFBvc3NpYmxlUmF3KG5vZGUpIHtcbiAgY29uc3QgdmFsdWUgPSBnZXRGaWVsZFZhbHVlKG5vZGUsIFwidmFsdWVcIik7XG4gIGNvbnN0IGV4dHJhID0gZ2V0RmllbGRWYWx1ZShub2RlLCBcImV4dHJhXCIpO1xuICBpZiAoZXh0cmEgJiYgdHlwZW9mIGV4dHJhLnJhdyA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSA9PSBleHRyYS5yYXdWYWx1ZSkge1xuICAgIHJldHVybiBleHRyYS5yYXc7XG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJMaXRlcmFsXCIpIHtcbiAgICBjb25zdCByYXcgPSBub2RlLnJhdztcbiAgICBpZiAodHlwZW9mIHJhdyA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZSA9PSByYXcpIHtcbiAgICAgIHJldHVybiByYXc7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBqc1NhZmVTdHJpbmdpZnkoc3RyKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpLnJlcGxhY2UoL1tcXHUyMDI4XFx1MjAyOV0vZywgZnVuY3Rpb24obSkge1xuICAgIHJldHVybiBcIlxcXFx1XCIgKyBtLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG5vZGVTdHIoc3RyLCBvcHRpb25zKSB7XG4gIGlzU3RyaW5nLmFzc2VydChzdHIpO1xuICBzd2l0Y2ggKG9wdGlvbnMucXVvdGUpIHtcbiAgICBjYXNlIFwiYXV0b1wiOiB7XG4gICAgICBjb25zdCBkb3VibGUgPSBqc1NhZmVTdHJpbmdpZnkoc3RyKTtcbiAgICAgIGNvbnN0IHNpbmdsZSA9IHN3YXBRdW90ZXMoanNTYWZlU3RyaW5naWZ5KHN3YXBRdW90ZXMoc3RyKSkpO1xuICAgICAgcmV0dXJuIGRvdWJsZS5sZW5ndGggPiBzaW5nbGUubGVuZ3RoID8gc2luZ2xlIDogZG91YmxlO1xuICAgIH1cbiAgICBjYXNlIFwic2luZ2xlXCI6XG4gICAgICByZXR1cm4gc3dhcFF1b3Rlcyhqc1NhZmVTdHJpbmdpZnkoc3dhcFF1b3RlcyhzdHIpKSk7XG4gICAgY2FzZSBcImRvdWJsZVwiOlxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4ganNTYWZlU3RyaW5naWZ5KHN0cik7XG4gIH1cbn1cbmZ1bmN0aW9uIG1heWJlQWRkU2VtaWNvbG9uKGxpbmVzKSB7XG4gIGNvbnN0IGVvYyA9IGxhc3ROb25TcGFjZUNoYXJhY3RlcihsaW5lcyk7XG4gIGlmICghZW9jIHx8IFwiXFxufTtcIi5pbmRleE9mKGVvYykgPCAwKVxuICAgIHJldHVybiBjb25jYXQoW2xpbmVzLCBcIjtcIl0pO1xuICByZXR1cm4gbGluZXM7XG59XG5cbmZ1bmN0aW9uIHByaW50KG5vZGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcmludGVyKG9wdGlvbnMpLnByaW50KG5vZGUpO1xufVxuXG5sZXQgX2JhYmVsUGFyc2VyO1xuZnVuY3Rpb24gZ2V0QmFiZWxQYXJzZXIoKSB7XG4gIGlmIChfYmFiZWxQYXJzZXIpIHtcbiAgICByZXR1cm4gX2JhYmVsUGFyc2VyO1xuICB9XG4gIGNvbnN0IGJhYmVsT3B0aW9ucyA9IF9nZXRCYWJlbE9wdGlvbnMoKTtcbiAgX2JhYmVsUGFyc2VyID0ge1xuICAgIHBhcnNlKHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGJhYmVsUGFyc2VyLnBhcnNlKHNvdXJjZSwge1xuICAgICAgICAuLi5iYWJlbE9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9iYWJlbFBhcnNlcjtcbn1cbmZ1bmN0aW9uIF9nZXRCYWJlbE9wdGlvbnMoKSB7XG4gIHJldHVybiB7XG4gICAgc291cmNlVHlwZTogXCJtb2R1bGVcIixcbiAgICBzdHJpY3RNb2RlOiBmYWxzZSxcbiAgICBhbGxvd0ltcG9ydEV4cG9ydEV2ZXJ5d2hlcmU6IHRydWUsXG4gICAgYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb246IHRydWUsXG4gICAgc3RhcnRMaW5lOiAxLFxuICAgIHRva2VuczogdHJ1ZSxcbiAgICBwbHVnaW5zOiBbXG4gICAgICBcImFzeW5jR2VuZXJhdG9yc1wiLFxuICAgICAgXCJiaWdJbnRcIixcbiAgICAgIFwiY2xhc3NQcml2YXRlTWV0aG9kc1wiLFxuICAgICAgXCJjbGFzc1ByaXZhdGVQcm9wZXJ0aWVzXCIsXG4gICAgICBcImNsYXNzUHJvcGVydGllc1wiLFxuICAgICAgXCJjbGFzc1N0YXRpY0Jsb2NrXCIsXG4gICAgICBcImRlY2ltYWxcIixcbiAgICAgIFwiZGVjb3JhdG9ycy1sZWdhY3lcIixcbiAgICAgIFwiZG9FeHByZXNzaW9uc1wiLFxuICAgICAgXCJkeW5hbWljSW1wb3J0XCIsXG4gICAgICBcImV4cG9ydERlZmF1bHRGcm9tXCIsXG4gICAgICBcImV4cG9ydEV4dGVuc2lvbnNcIixcbiAgICAgIFwiZXhwb3J0TmFtZXNwYWNlRnJvbVwiLFxuICAgICAgXCJmdW5jdGlvbkJpbmRcIixcbiAgICAgIFwiZnVuY3Rpb25TZW50XCIsXG4gICAgICBcImltcG9ydEFzc2VydGlvbnNcIixcbiAgICAgIFwiaW1wb3J0TWV0YVwiLFxuICAgICAgXCJudWxsaXNoQ29hbGVzY2luZ09wZXJhdG9yXCIsXG4gICAgICBcIm51bWVyaWNTZXBhcmF0b3JcIixcbiAgICAgIFwib2JqZWN0UmVzdFNwcmVhZFwiLFxuICAgICAgXCJvcHRpb25hbENhdGNoQmluZGluZ1wiLFxuICAgICAgXCJvcHRpb25hbENoYWluaW5nXCIsXG4gICAgICBbXG4gICAgICAgIFwicGlwZWxpbmVPcGVyYXRvclwiLFxuICAgICAgICB7XG4gICAgICAgICAgcHJvcG9zYWw6IFwibWluaW1hbFwiXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFwicmVjb3JkQW5kVHVwbGVcIixcbiAgICAgICAge1xuICAgICAgICAgIHN5bnRheFR5cGU6IFwiaGFzaFwiXG4gICAgICAgIH1cbiAgICAgIF0sXG4gICAgICBcInRocm93RXhwcmVzc2lvbnNcIixcbiAgICAgIFwidG9wTGV2ZWxBd2FpdFwiLFxuICAgICAgXCJ2OGludHJpbnNpY1wiLFxuICAgICAgXCJqc3hcIixcbiAgICAgIFwidHlwZXNjcmlwdFwiXG4gICAgXVxuICB9O1xufVxuXG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiB7XG4gIF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5jbGFzcyBNYWdpY2FzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoXCJcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInJhd01lc3NhZ2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIm9wdGlvbnNcIik7XG4gICAgdGhpcy5uYW1lID0gXCJNYWdpY2FzdEVycm9yXCI7XG4gICAgdGhpcy5yYXdNZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGlmIChvcHRpb25zPy5hc3QgJiYgb3B0aW9ucz8uY29kZSAmJiBvcHRpb25zLmFzdC5sb2MpIHtcbiAgICAgIGNvbnN0IHsgbGluZSwgY29sdW1uIH0gPSBvcHRpb25zLmFzdC5sb2Muc3RhcnQ7XG4gICAgICBjb25zdCBsaW5lcyA9IG9wdGlvbnMuY29kZS5zcGxpdChcIlxcblwiKTtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgbGluZSAtIDMpO1xuICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBsaW5lICsgMyk7XG4gICAgICBjb25zdCBjb2RlRnJhbWUgPSBsaW5lcy5zbGljZShzdGFydCwgZW5kKS5tYXAoKGxpbmVDb2RlLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IG51bWJlciA9IChzdGFydCArIGkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDMsIFwiIFwiKTtcbiAgICAgICAgbGluZUNvZGUgPSBgJHtudW1iZXJ9IHwgJHtsaW5lQ29kZX1gO1xuICAgICAgICBpZiAoc3RhcnQgKyBpID09PSBsaW5lIC0gMSkge1xuICAgICAgICAgIGxpbmVDb2RlICs9IGBcbiR7XCIgXCIucmVwZWF0KDYgKyBjb2x1bW4pfV5gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaW5lQ29kZTtcbiAgICAgIH0pO1xuICAgICAgbWVzc2FnZSArPSBgXG5cbiR7Y29kZUZyYW1lLmpvaW4oXCJcXG5cIil9XG5gO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG59XG5cbmNvbnN0IExJVEVSQUxTX0FTVCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJMaXRlcmFsXCIsXG4gIFwiU3RyaW5nTGl0ZXJhbFwiLFxuICBcIk51bWVyaWNMaXRlcmFsXCIsXG4gIFwiQm9vbGVhbkxpdGVyYWxcIixcbiAgXCJOdWxsTGl0ZXJhbFwiLFxuICBcIlJlZ0V4cExpdGVyYWxcIixcbiAgXCJCaWdJbnRMaXRlcmFsXCJcbl0pO1xuY29uc3QgTElURVJBTFNfVFlQRU9GID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcInN0cmluZ1wiLFxuICBcIm51bWJlclwiLFxuICBcImJvb2xlYW5cIixcbiAgXCJiaWdpbnRcIixcbiAgXCJzeW1ib2xcIixcbiAgXCJ1bmRlZmluZWRcIlxuXSk7XG5jb25zdCBiJDQgPSBidWlsZGVycyQxO1xuZnVuY3Rpb24gaXNWYWxpZFByb3BOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIC9eWyRBLVpfYS16XVtcXHckXSokLy50ZXN0KG5hbWUpO1xufVxuY29uc3QgUFJPWFlfS0VZID0gXCJfX21hZ2ljYXN0X3Byb3h5XCI7XG5mdW5jdGlvbiBsaXRlcmFsVG9Bc3QodmFsdWUsIHNlZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIGIkNC5pZGVudGlmaWVyKFwidW5kZWZpbmVkXCIpO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBiJDQubGl0ZXJhbChudWxsKTtcbiAgfVxuICBpZiAoTElURVJBTFNfVFlQRU9GLmhhcyh0eXBlb2YgdmFsdWUpKSB7XG4gICAgcmV0dXJuIGIkNC5saXRlcmFsKHZhbHVlKTtcbiAgfVxuICBpZiAoc2Vlbi5oYXModmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IE1hZ2ljYXN0RXJyb3IoXCJDYW4gbm90IHNlcmlhbGl6ZSBjaXJjdWxhciByZWZlcmVuY2VcIik7XG4gIH1cbiAgc2Vlbi5hZGQodmFsdWUpO1xuICBpZiAodmFsdWVbUFJPWFlfS0VZXSkge1xuICAgIHJldHVybiB2YWx1ZS4kYXN0O1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIGNvbnN0IHJlZ2V4ID0gYiQ0LnJlZ0V4cExpdGVyYWwodmFsdWUuc291cmNlLCB2YWx1ZS5mbGFncyk7XG4gICAgZGVsZXRlIHJlZ2V4LmV4dHJhLnJhdztcbiAgICByZXR1cm4gcmVnZXg7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgcmV0dXJuIGIkNC5uZXdFeHByZXNzaW9uKGIkNC5pZGVudGlmaWVyKFwiU2V0XCIpLCBbXG4gICAgICBiJDQuYXJyYXlFeHByZXNzaW9uKFsuLi52YWx1ZV0ubWFwKChuKSA9PiBsaXRlcmFsVG9Bc3Qobiwgc2VlbikpKVxuICAgIF0pO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gYiQ0Lm5ld0V4cHJlc3Npb24oYiQ0LmlkZW50aWZpZXIoXCJEYXRlXCIpLCBbXG4gICAgICBiJDQubGl0ZXJhbCh2YWx1ZS50b0lTT1N0cmluZygpKVxuICAgIF0pO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgIHJldHVybiBiJDQubmV3RXhwcmVzc2lvbihiJDQuaWRlbnRpZmllcihcIk1hcFwiKSwgW1xuICAgICAgYiQ0LmFycmF5RXhwcmVzc2lvbihcbiAgICAgICAgWy4uLnZhbHVlXS5tYXAoKFtrZXksIHZhbHVlMl0pID0+IHtcbiAgICAgICAgICByZXR1cm4gYiQ0LmFycmF5RXhwcmVzc2lvbihbXG4gICAgICAgICAgICBsaXRlcmFsVG9Bc3Qoa2V5LCBzZWVuKSxcbiAgICAgICAgICAgIGxpdGVyYWxUb0FzdCh2YWx1ZTIsIHNlZW4pXG4gICAgICAgICAgXSk7XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgXSk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGIkNC5hcnJheUV4cHJlc3Npb24oXG4gICAgICB2YWx1ZS5tYXAoKG4pID0+IGxpdGVyYWxUb0FzdChuLCBzZWVuKSlcbiAgICApO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gYiQ0Lm9iamVjdEV4cHJlc3Npb24oXG4gICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChba2V5LCB2YWx1ZTJdKSA9PiB7XG4gICAgICAgIHJldHVybiBiJDQucHJvcGVydHkoXG4gICAgICAgICAgXCJpbml0XCIsXG4gICAgICAgICAgL15bJEEtWl9hLXpdW1xcdyRdKiQvZy50ZXN0KGtleSkgPyBiJDQuaWRlbnRpZmllcihrZXkpIDogYiQ0LmxpdGVyYWwoa2V5KSxcbiAgICAgICAgICBsaXRlcmFsVG9Bc3QodmFsdWUyLCBzZWVuKVxuICAgICAgICApO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHJldHVybiBiJDQubGl0ZXJhbCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBtYWtlUHJveHlVdGlscyhub2RlLCBleHRlbmQgPSB7fSkge1xuICBjb25zdCBvYmogPSBleHRlbmQ7XG4gIG9ialtQUk9YWV9LRVldID0gdHJ1ZTtcbiAgb2JqLiRhc3QgPSBub2RlO1xuICBvYmouJHR5cGUgfHwgKG9iai4kdHlwZSA9IFwib2JqZWN0XCIpO1xuICByZXR1cm4gb2JqO1xufVxuY29uc3QgcHJvcGVydHlEZXNjcmlwdG9yID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn07XG5mdW5jdGlvbiBjcmVhdGVQcm94eShub2RlLCBleHRlbmQsIGhhbmRsZXIpIHtcbiAgY29uc3QgdXRpbHMgPSBtYWtlUHJveHlVdGlscyhub2RlLCBleHRlbmQpO1xuICByZXR1cm4gbmV3IFByb3h5KFxuICAgIHt9LFxuICAgIHtcbiAgICAgIG93bktleXMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh1dGlscykuZmlsdGVyKFxuICAgICAgICAgIChpKSA9PiBpICE9PSBQUk9YWV9LRVkgJiYgIWkuc3RhcnRzV2l0aChcIiRcIilcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgICB9LFxuICAgICAgaGFzKF90YXJnZXQsIGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIHV0aWxzKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIC4uLmhhbmRsZXIsXG4gICAgICBnZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdXRpbHMpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlci5nZXQpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlci5nZXQodGFyZ2V0LCBrZXksIHJlY2VpdmVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldCh0YXJnZXQsIGtleSwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdXRpbHMpIHtcbiAgICAgICAgICB1dGlsc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZXIuc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZXIuc2V0KHRhcmdldCwga2V5LCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cbmNvbnN0IGIkMyA9IGJ1aWxkZXJzJDE7XG5jb25zdCBfaW1wb3J0UHJveHlDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gY3JlYXRJbXBvcnRQcm94eShub2RlLCBzcGVjaWZpZXIsIHJvb3QpIHtcbiAgaWYgKF9pbXBvcnRQcm94eUNhY2hlLmhhcyhzcGVjaWZpZXIpKSB7XG4gICAgcmV0dXJuIF9pbXBvcnRQcm94eUNhY2hlLmdldChzcGVjaWZpZXIpO1xuICB9XG4gIGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkoXG4gICAgc3BlY2lmaWVyLFxuICAgIHtcbiAgICAgIGdldCAkZGVjbGFyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfSxcbiAgICAgIGdldCBpbXBvcnRlZCgpIHtcbiAgICAgICAgaWYgKHNwZWNpZmllci50eXBlID09PSBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikge1xuICAgICAgICAgIHJldHVybiBcImRlZmF1bHRcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlY2lmaWVyLnR5cGUgPT09IFwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCIpIHtcbiAgICAgICAgICByZXR1cm4gXCIqXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwZWNpZmllci5pbXBvcnRlZC50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICAgIHJldHVybiBzcGVjaWZpZXIuaW1wb3J0ZWQubmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BlY2lmaWVyLmltcG9ydGVkLnZhbHVlO1xuICAgICAgfSxcbiAgICAgIHNldCBpbXBvcnRlZCh2YWx1ZSkge1xuICAgICAgICBpZiAoc3BlY2lmaWVyLnR5cGUgIT09IFwiSW1wb3J0U3BlY2lmaWVyXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTWFnaWNhc3RFcnJvcihcbiAgICAgICAgICAgIFwiQ2hhbmdpbmcgaW1wb3J0IG5hbWUgaXMgbm90IHlldCBpbXBsZW1lbnRlZFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BlY2lmaWVyLmltcG9ydGVkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkLm5hbWUgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldCBsb2NhbCgpIHtcbiAgICAgICAgcmV0dXJuIHNwZWNpZmllci5sb2NhbC5uYW1lO1xuICAgICAgfSxcbiAgICAgIHNldCBsb2NhbCh2YWx1ZSkge1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwubmFtZSA9IHZhbHVlO1xuICAgICAgfSxcbiAgICAgIGdldCBmcm9tKCkge1xuICAgICAgICByZXR1cm4gbm9kZS5zb3VyY2UudmFsdWU7XG4gICAgICB9LFxuICAgICAgc2V0IGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSBub2RlLnNvdXJjZS52YWx1ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNwZWNpZmllcnMgPSBub2RlLnNwZWNpZmllcnMuZmlsdGVyKChzKSA9PiBzICE9PSBzcGVjaWZpZXIpO1xuICAgICAgICBpZiAobm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJvb3QuYm9keSA9IHJvb3QuYm9keS5maWx0ZXIoKHMpID0+IHMgIT09IG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gcm9vdC5ib2R5LmZpbmQoXG4gICAgICAgICAgKGkpID0+IGkudHlwZSA9PT0gXCJJbXBvcnREZWNsYXJhdGlvblwiICYmIGkuc291cmNlLnZhbHVlID09PSB2YWx1ZVxuICAgICAgICApO1xuICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICBkZWNsYXJhdGlvbi5zcGVjaWZpZXJzLnB1c2goc3BlY2lmaWVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb290LmJvZHkudW5zaGlmdChcbiAgICAgICAgICAgIGIkMy5pbXBvcnREZWNsYXJhdGlvbihcbiAgICAgICAgICAgICAgW3NwZWNpZmllcl0sXG4gICAgICAgICAgICAgIGIkMy5zdHJpbmdMaXRlcmFsKHZhbHVlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW1wb3J0ZWQ6IHRoaXMuaW1wb3J0ZWQsXG4gICAgICAgICAgbG9jYWw6IHRoaXMubG9jYWwsXG4gICAgICAgICAgZnJvbTogdGhpcy5mcm9tXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBvd25LZXlzKCkge1xuICAgICAgICByZXR1cm4gW1wiaW1wb3J0ZWRcIiwgXCJsb2NhbFwiLCBcImZyb21cIiwgXCJ0b0pTT05cIl07XG4gICAgICB9XG4gICAgfVxuICApO1xuICBfaW1wb3J0UHJveHlDYWNoZS5zZXQoc3BlY2lmaWVyLCBwcm94eSk7XG4gIHJldHVybiBwcm94eTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUltcG9ydHNQcm94eShyb290LCBtb2QpIHtcbiAgY29uc3QgZ2V0QWxsSW1wb3J0cyA9ICgpID0+IHtcbiAgICBjb25zdCBpbXBvcnRzID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIHJvb3QuYm9keSkge1xuICAgICAgaWYgKG4udHlwZSA9PT0gXCJJbXBvcnREZWNsYXJhdGlvblwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3BlY2lmaWVyIG9mIG4uc3BlY2lmaWVycykge1xuICAgICAgICAgIGltcG9ydHMucHVzaChjcmVhdEltcG9ydFByb3h5KG4sIHNwZWNpZmllciwgcm9vdCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbXBvcnRzO1xuICB9O1xuICBjb25zdCB1cGRhdGVJbXBvcnQgPSAoa2V5LCB2YWx1ZSwgb3JkZXIpID0+IHtcbiAgICBjb25zdCBpbXBvcnRzID0gZ2V0QWxsSW1wb3J0cygpO1xuICAgIGNvbnN0IGl0ZW0gPSBpbXBvcnRzLmZpbmQoKGkpID0+IGkubG9jYWwgPT09IGtleSk7XG4gICAgY29uc3QgbG9jYWwgPSB2YWx1ZS5sb2NhbCB8fCBrZXk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIGl0ZW0uaW1wb3J0ZWQgPSB2YWx1ZS5pbXBvcnRlZDtcbiAgICAgIGl0ZW0ubG9jYWwgPSBsb2NhbDtcbiAgICAgIGl0ZW0uZnJvbSA9IHZhbHVlLmZyb207XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgc3BlY2lmaWVyID0gdmFsdWUuaW1wb3J0ZWQgPT09IFwiZGVmYXVsdFwiID8gYiQzLmltcG9ydERlZmF1bHRTcGVjaWZpZXIoYiQzLmlkZW50aWZpZXIobG9jYWwpKSA6IHZhbHVlLmltcG9ydGVkID09PSBcIipcIiA/IGIkMy5pbXBvcnROYW1lc3BhY2VTcGVjaWZpZXIoYiQzLmlkZW50aWZpZXIobG9jYWwpKSA6IGIkMy5pbXBvcnRTcGVjaWZpZXIoXG4gICAgICBiJDMuaWRlbnRpZmllcih2YWx1ZS5pbXBvcnRlZCksXG4gICAgICBiJDMuaWRlbnRpZmllcihsb2NhbClcbiAgICApO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gaW1wb3J0cy5maW5kKFxuICAgICAgKGkpID0+IGkuZnJvbSA9PT0gdmFsdWUuZnJvbVxuICAgICk/LiRkZWNsYXJhdGlvbjtcbiAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgIGRlY2xhcmF0aW9uLnNwZWNpZmllcnMucHVzaChzcGVjaWZpZXIpO1xuICAgIH0gZWxzZSBpZiAob3JkZXIgPT09IFwicHJlcGVuZFwiIHx8IGltcG9ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByb290LmJvZHkudW5zaGlmdChcbiAgICAgICAgYiQzLmltcG9ydERlY2xhcmF0aW9uKFtzcGVjaWZpZXJdLCBiJDMuc3RyaW5nTGl0ZXJhbCh2YWx1ZS5mcm9tKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGxhc3RJbXBvcnQgPSBpbXBvcnRzLmF0KC0xKS4kZGVjbGFyYXRpb247XG4gICAgICBjb25zdCBsYXN0SW1wb3J0SW5kZXggPSByb290LmJvZHkuaW5kZXhPZihsYXN0SW1wb3J0KTtcbiAgICAgIHJvb3QuYm9keS5zcGxpY2UoXG4gICAgICAgIGxhc3RJbXBvcnRJbmRleCArIDEsXG4gICAgICAgIDAsXG4gICAgICAgIGIkMy5pbXBvcnREZWNsYXJhdGlvbihbc3BlY2lmaWVyXSwgYiQzLnN0cmluZ0xpdGVyYWwodmFsdWUuZnJvbSkpXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgY29uc3QgcmVtb3ZlSW1wb3J0ID0gKGtleSkgPT4ge1xuICAgIGNvbnN0IGl0ZW0gPSBnZXRBbGxJbXBvcnRzKCkuZmluZCgoaSkgPT4gaS5sb2NhbCA9PT0ga2V5KTtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IGl0ZW0uJGRlY2xhcmF0aW9uO1xuICAgIGNvbnN0IHNwZWNpZmllciA9IGl0ZW0uJGFzdDtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBub2RlLnNwZWNpZmllcnMuZmlsdGVyKChzKSA9PiBzICE9PSBzcGVjaWZpZXIpO1xuICAgIGlmIChub2RlLnNwZWNpZmllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByb290LmJvZHkgPSByb290LmJvZHkuZmlsdGVyKChuKSA9PiBuICE9PSBub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIGNvbnN0IHByb3h5ID0gY3JlYXRlUHJveHkoXG4gICAgcm9vdCxcbiAgICB7XG4gICAgICAkdHlwZTogXCJpbXBvcnRzXCIsXG4gICAgICAkYWRkKGl0ZW0pIHtcbiAgICAgICAgdXBkYXRlSW1wb3J0KGl0ZW0ubG9jYWwgfHwgaXRlbS5pbXBvcnRlZCwgaXRlbSwgXCJwcmVwZW5kXCIpO1xuICAgICAgfSxcbiAgICAgICRwcmVwZW5kKGl0ZW0pIHtcbiAgICAgICAgdXBkYXRlSW1wb3J0KGl0ZW0ubG9jYWwgfHwgaXRlbS5pbXBvcnRlZCwgaXRlbSwgXCJwcmVwZW5kXCIpO1xuICAgICAgfSxcbiAgICAgICRhcHBlbmQoaXRlbSkge1xuICAgICAgICB1cGRhdGVJbXBvcnQoaXRlbS5sb2NhbCB8fCBpdGVtLmltcG9ydGVkLCBpdGVtLCBcImFwcGVuZFwiKTtcbiAgICAgIH0sXG4gICAgICBnZXQgJGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gZ2V0QWxsSW1wb3J0cygpO1xuICAgICAgfSxcbiAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIGdldEFsbEltcG9ydHMoKS5yZWR1Y2UoKGFjYywgaSkgPT4ge1xuICAgICAgICAgIGFjY1tpLmxvY2FsXSA9IGk7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgZ2V0KF8sIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGdldEFsbEltcG9ydHMoKS5maW5kKChpKSA9PiBpLmxvY2FsID09PSBwcm9wKTtcbiAgICAgIH0sXG4gICAgICBzZXQoXywgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUltcG9ydChwcm9wLCB2YWx1ZSwgXCJwcmVwZW5kXCIpO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZVByb3BlcnR5KF8sIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIHJlbW92ZUltcG9ydChwcm9wKTtcbiAgICAgIH0sXG4gICAgICBvd25LZXlzKCkge1xuICAgICAgICByZXR1cm4gZ2V0QWxsSW1wb3J0cygpLm1hcCgoaSkgPT4gaS5sb2NhbCk7XG4gICAgICB9LFxuICAgICAgaGFzKF8sIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGdldEFsbEltcG9ydHMoKS5zb21lKChpKSA9PiBpLmxvY2FsID09PSBwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiBwcm94eTtcbn1cblxuZnVuY3Rpb24gcHJveGlmeUFycmF5RWxlbWVudHMobm9kZSwgZWxlbWVudHMsIG1vZCkge1xuICBjb25zdCBnZXRJdGVtID0gKGtleSkgPT4ge1xuICAgIHJldHVybiBlbGVtZW50c1trZXldO1xuICB9O1xuICBjb25zdCByZXBsYWNlSXRlbSA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgZWxlbWVudHNba2V5XSA9IHZhbHVlO1xuICB9O1xuICByZXR1cm4gY3JlYXRlUHJveHkoXG4gICAgbm9kZSxcbiAgICB7XG4gICAgICAkdHlwZTogXCJhcnJheVwiLFxuICAgICAgcHVzaCh2YWx1ZSkge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGxpdGVyYWxUb0FzdCh2YWx1ZSkpO1xuICAgICAgfSxcbiAgICAgIHBvcCgpIHtcbiAgICAgICAgcmV0dXJuIHByb3hpZnkoZWxlbWVudHMucG9wKCksIG1vZCk7XG4gICAgICB9LFxuICAgICAgdW5zaGlmdCh2YWx1ZSkge1xuICAgICAgICBlbGVtZW50cy51bnNoaWZ0KGxpdGVyYWxUb0FzdCh2YWx1ZSkpO1xuICAgICAgfSxcbiAgICAgIHNoaWZ0KCkge1xuICAgICAgICByZXR1cm4gcHJveGlmeShlbGVtZW50cy5zaGlmdCgpLCBtb2QpO1xuICAgICAgfSxcbiAgICAgIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQsIC4uLml0ZW1zKSB7XG4gICAgICAgIGNvbnN0IGRlbGV0ZWQgPSBlbGVtZW50cy5zcGxpY2UoXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgZGVsZXRlQ291bnQsXG4gICAgICAgICAgLi4uaXRlbXMubWFwKChuKSA9PiBsaXRlcmFsVG9Bc3QobikpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBkZWxldGVkLm1hcCgobikgPT4gcHJveGlmeShuLCBtb2QpKTtcbiAgICAgIH0sXG4gICAgICBmaW5kKHByZWRpY2F0ZSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudHMubWFwKChuKSA9PiBwcm94aWZ5KG4sIG1vZCkpLmZpbmQocHJlZGljYXRlKTtcbiAgICAgIH0sXG4gICAgICBmaW5kSW5kZXgocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50cy5tYXAoKG4pID0+IHByb3hpZnkobiwgbW9kKSkuZmluZEluZGV4KHByZWRpY2F0ZSk7XG4gICAgICB9LFxuICAgICAgaW5jbHVkZXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzLm1hcCgobikgPT4gcHJveGlmeShuLCBtb2QpKS5pbmNsdWRlcyh2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudHMubWFwKChuKSA9PiBwcm94aWZ5KG4sIG1vZCkpO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgZ2V0KF8sIGtleSkge1xuICAgICAgICBpZiAoa2V5ID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSBTeW1ib2wuaXRlcmF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICB5aWVsZCBwcm94aWZ5KGl0ZW0sIG1vZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9ICtrZXk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3AgPSBnZXRJdGVtKGluZGV4KTtcbiAgICAgICAgaWYgKHByb3ApIHtcbiAgICAgICAgICByZXR1cm4gcHJveGlmeShwcm9wLCBtb2QpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0KF8sIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSAra2V5O1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGluZGV4KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlSXRlbShpbmRleCwgbGl0ZXJhbFRvQXN0KHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGRlbGV0ZVByb3BlcnR5KF8sIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmRleCA9ICtrZXk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzW2luZGV4XSA9IGxpdGVyYWxUb0FzdCh2b2lkIDApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBvd25LZXlzKCkge1xuICAgICAgICByZXR1cm4gW1wibGVuZ3RoXCIsIC4uLmVsZW1lbnRzLm1hcCgoXywgaSkgPT4gaS50b1N0cmluZygpKV07XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gcHJveGlmeUFycmF5KG5vZGUsIG1vZCkge1xuICBpZiAoIShcImVsZW1lbnRzXCIgaW4gbm9kZSkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBwcm94aWZ5QXJyYXlFbGVtZW50cyhub2RlLCBub2RlLmVsZW1lbnRzLCBtb2QpO1xufVxuXG5mdW5jdGlvbiBwcm94aWZ5RnVuY3Rpb25DYWxsKG5vZGUsIG1vZCkge1xuICBpZiAobm9kZS50eXBlICE9PSBcIkNhbGxFeHByZXNzaW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgTWFnaWNhc3RFcnJvcihcIk5vdCBhIGZ1bmN0aW9uIGNhbGxcIik7XG4gIH1cbiAgZnVuY3Rpb24gc3RyaW5naWZ5RXhwcmVzc2lvbihub2RlMikge1xuICAgIGlmIChub2RlMi50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgcmV0dXJuIG5vZGUyLm5hbWU7XG4gICAgfVxuICAgIGlmIChub2RlMi50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIGAke3N0cmluZ2lmeUV4cHJlc3Npb24obm9kZTIub2JqZWN0KX0uJHtzdHJpbmdpZnlFeHByZXNzaW9uKFxuICAgICAgICBub2RlMi5wcm9wZXJ0eVxuICAgICAgKX1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgTWFnaWNhc3RFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBjb25zdCBhcmd1bWVudHNQcm94eSA9IHByb3hpZnlBcnJheUVsZW1lbnRzKG5vZGUsIG5vZGUuYXJndW1lbnRzLCBtb2QpO1xuICByZXR1cm4gY3JlYXRlUHJveHkoXG4gICAgbm9kZSxcbiAgICB7XG4gICAgICAkdHlwZTogXCJmdW5jdGlvbi1jYWxsXCIsXG4gICAgICAkY2FsbGVlOiBzdHJpbmdpZnlFeHByZXNzaW9uKG5vZGUuY2FsbGVlKSxcbiAgICAgICRhcmdzOiBhcmd1bWVudHNQcm94eVxuICAgIH0sXG4gICAge31cbiAgKTtcbn1cblxuZnVuY3Rpb24gcHJveGlmeUFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUsIG1vZCkge1xuICBpZiAobm9kZS50eXBlICE9PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgTWFnaWNhc3RFcnJvcihcIk5vdCBhbiBhcnJvdyBmdW5jdGlvbiBleHByZXNzaW9uXCIpO1xuICB9XG4gIGNvbnN0IHBhcmFtZXRlcnNQcm94eSA9IHByb3hpZnlBcnJheUVsZW1lbnRzKG5vZGUsIG5vZGUucGFyYW1zLCBtb2QpO1xuICByZXR1cm4gY3JlYXRlUHJveHkoXG4gICAgbm9kZSxcbiAgICB7XG4gICAgICAkdHlwZTogXCJhcnJvdy1mdW5jdGlvbi1leHByZXNzaW9uXCIsXG4gICAgICAkcGFyYW1zOiBwYXJhbWV0ZXJzUHJveHksXG4gICAgICAkYm9keTogcHJveGlmeShub2RlLmJvZHksIG1vZClcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5cbmNvbnN0IGIkMiA9IGJ1aWxkZXJzJDE7XG5mdW5jdGlvbiBwcm94aWZ5T2JqZWN0KG5vZGUsIG1vZCkge1xuICBpZiAoIShcInByb3BlcnRpZXNcIiBpbiBub2RlKSkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgZ2V0UHJvcCA9IChrZXkpID0+IHtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2Ygbm9kZS5wcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBwcm9wICYmIFwibmFtZVwiIGluIHByb3Aua2V5ICYmIHByb3Aua2V5Lm5hbWUgPT09IGtleSkge1xuICAgICAgICByZXR1cm4gcHJvcC52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wLnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIiAmJiAocHJvcC5rZXkudHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIgfHwgcHJvcC5rZXkudHlwZSA9PT0gXCJOdW1lcmljTGl0ZXJhbFwiIHx8IHByb3Aua2V5LnR5cGUgPT09IFwiQm9vbGVhbkxpdGVyYWxcIikgJiYgcHJvcC5rZXkudmFsdWUudG9TdHJpbmcoKSA9PT0ga2V5KSB7XG4gICAgICAgIHJldHVybiBwcm9wLnZhbHVlLnZhbHVlID8/IHByb3AudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBnZXRQcm9wTmFtZSA9IChwcm9wLCB0aHJvd0Vycm9yID0gZmFsc2UpID0+IHtcbiAgICBpZiAoXCJrZXlcIiBpbiBwcm9wICYmIFwibmFtZVwiIGluIHByb3Aua2V5KSB7XG4gICAgICByZXR1cm4gcHJvcC5rZXkubmFtZTtcbiAgICB9XG4gICAgaWYgKHByb3AudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiICYmIChwcm9wLmtleS50eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIiB8fCBwcm9wLmtleS50eXBlID09PSBcIk51bWVyaWNMaXRlcmFsXCIgfHwgcHJvcC5rZXkudHlwZSA9PT0gXCJCb29sZWFuTGl0ZXJhbFwiKSkge1xuICAgICAgcmV0dXJuIHByb3Aua2V5LnZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh0aHJvd0Vycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgTWFnaWNhc3RFcnJvcihgQ2FzdGluZyBcIiR7cHJvcC50eXBlfVwiIGlzIG5vdCBzdXBwb3J0ZWRgLCB7XG4gICAgICAgIGFzdDogcHJvcCxcbiAgICAgICAgY29kZTogbW9kPy4kY29kZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCByZXBsYWNlT3JBZGRQcm9wID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCBwcm9wID0gbm9kZS5wcm9wZXJ0aWVzLmZpbmQoXG4gICAgICAocHJvcDIpID0+IGdldFByb3BOYW1lKHByb3AyKSA9PT0ga2V5XG4gICAgKTtcbiAgICBpZiAocHJvcCkge1xuICAgICAgcHJvcC52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaXNWYWxpZFByb3BOYW1lKGtleSkpIHtcbiAgICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJQcm9wZXJ0eVwiLFxuICAgICAgICBrZXk6IHtcbiAgICAgICAgICB0eXBlOiBcIklkZW50aWZpZXJcIixcbiAgICAgICAgICBuYW1lOiBrZXlcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnByb3BlcnRpZXMucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiT2JqZWN0UHJvcGVydHlcIixcbiAgICAgICAga2V5OiBiJDIuc3RyaW5nTGl0ZXJhbChrZXkpLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gY3JlYXRlUHJveHkoXG4gICAgbm9kZSxcbiAgICB7XG4gICAgICAkdHlwZTogXCJvYmplY3RcIixcbiAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucHJvcGVydGllcy5yZWR1Y2UoKGFjYywgcHJvcCkgPT4ge1xuICAgICAgICAgIGlmIChcImtleVwiIGluIHByb3AgJiYgXCJuYW1lXCIgaW4gcHJvcC5rZXkpIHtcbiAgICAgICAgICAgIGFjY1twcm9wLmtleS5uYW1lXSA9IHByb3hpZnkocHJvcC52YWx1ZSwgbW9kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgZ2V0KF8sIGtleSkge1xuICAgICAgICBjb25zdCBwcm9wID0gZ2V0UHJvcChrZXkpO1xuICAgICAgICBpZiAocHJvcCkge1xuICAgICAgICAgIHJldHVybiBwcm94aWZ5KHByb3AsIG1vZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQoXywga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGtleSA9IFN0cmluZyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJlcGxhY2VPckFkZFByb3Aoa2V5LCBsaXRlcmFsVG9Bc3QodmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9LFxuICAgICAgZGVsZXRlUHJvcGVydHkoXywga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAga2V5ID0gU3RyaW5nKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSBub2RlLnByb3BlcnRpZXMuZmluZEluZGV4KFxuICAgICAgICAgIChwcm9wKSA9PiBcImtleVwiIGluIHByb3AgJiYgXCJuYW1lXCIgaW4gcHJvcC5rZXkgJiYgcHJvcC5rZXkubmFtZSA9PT0ga2V5XG4gICAgICAgICk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBub2RlLnByb3BlcnRpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBvd25LZXlzKCkge1xuICAgICAgICByZXR1cm4gbm9kZS5wcm9wZXJ0aWVzLm1hcCgocHJvcCkgPT4gZ2V0UHJvcE5hbWUocHJvcCwgdHJ1ZSkpLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIHByb3hpZnlOZXdFeHByZXNzaW9uKG5vZGUsIG1vZCkge1xuICBpZiAobm9kZS50eXBlICE9PSBcIk5ld0V4cHJlc3Npb25cIikge1xuICAgIHRocm93IG5ldyBNYWdpY2FzdEVycm9yKFwiTm90IGEgbmV3IGV4cHJlc3Npb25cIik7XG4gIH1cbiAgZnVuY3Rpb24gc3RyaW5naWZ5RXhwcmVzc2lvbihub2RlMikge1xuICAgIGlmIChub2RlMi50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgcmV0dXJuIG5vZGUyLm5hbWU7XG4gICAgfVxuICAgIGlmIChub2RlMi50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIGAke3N0cmluZ2lmeUV4cHJlc3Npb24obm9kZTIub2JqZWN0KX0uJHtzdHJpbmdpZnlFeHByZXNzaW9uKFxuICAgICAgICBub2RlMi5wcm9wZXJ0eVxuICAgICAgKX1gO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgTWFnaWNhc3RFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBjb25zdCBhcmd1bWVudHNQcm94eSA9IHByb3hpZnlBcnJheUVsZW1lbnRzKG5vZGUsIG5vZGUuYXJndW1lbnRzLCBtb2QpO1xuICByZXR1cm4gY3JlYXRlUHJveHkoXG4gICAgbm9kZSxcbiAgICB7XG4gICAgICAkdHlwZTogXCJuZXctZXhwcmVzc2lvblwiLFxuICAgICAgJGNhbGxlZTogc3RyaW5naWZ5RXhwcmVzc2lvbihub2RlLmNhbGxlZSksXG4gICAgICAkYXJnczogYXJndW1lbnRzUHJveHlcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5cbmZ1bmN0aW9uIHByb3hpZnlJZGVudGlmaWVyKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICB0aHJvdyBuZXcgTWFnaWNhc3RFcnJvcihcIk5vdCBhbiBpZGVudGlmaWVyXCIpO1xuICB9XG4gIHJldHVybiBjcmVhdGVQcm94eShcbiAgICBub2RlLFxuICAgIHtcbiAgICAgICR0eXBlOiBcImlkZW50aWZpZXJcIixcbiAgICAgICRuYW1lOiBub2RlLm5hbWVcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5cbmZ1bmN0aW9uIHByb3hpZnlMb2dpY2FsRXhwcmVzc2lvbihub2RlKSB7XG4gIGlmIChub2RlLnR5cGUgIT09IFwiTG9naWNhbEV4cHJlc3Npb25cIikge1xuICAgIHRocm93IG5ldyBNYWdpY2FzdEVycm9yKFwiTm90IGEgbG9naWNhbCBleHByZXNzaW9uXCIpO1xuICB9XG4gIHJldHVybiBjcmVhdGVQcm94eShcbiAgICBub2RlLFxuICAgIHtcbiAgICAgICR0eXBlOiBcImxvZ2ljYWxFeHByZXNzaW9uXCJcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5cbmZ1bmN0aW9uIHByb3hpZnlNZW1iZXJFeHByZXNzaW9uKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgTWFnaWNhc3RFcnJvcihcIk5vdCBhIG1lbWJlciBleHByZXNzaW9uXCIpO1xuICB9XG4gIHJldHVybiBjcmVhdGVQcm94eShcbiAgICBub2RlLFxuICAgIHtcbiAgICAgICR0eXBlOiBcIm1lbWJlckV4cHJlc3Npb25cIlxuICAgIH0sXG4gICAge31cbiAgKTtcbn1cblxuY29uc3QgX2NhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBwcm94aWZ5KG5vZGUsIG1vZCkge1xuICBpZiAoTElURVJBTFNfVFlQRU9GLmhhcyh0eXBlb2Ygbm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpZiAoTElURVJBTFNfQVNULmhhcyhub2RlLnR5cGUpKSB7XG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH1cbiAgaWYgKF9jYWNoZS5oYXMobm9kZSkpIHtcbiAgICByZXR1cm4gX2NhY2hlLmdldChub2RlKTtcbiAgfVxuICBsZXQgcHJveHk7XG4gIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjoge1xuICAgICAgcHJveHkgPSBwcm94aWZ5T2JqZWN0KG5vZGUsIG1vZCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOiB7XG4gICAgICBwcm94eSA9IHByb3hpZnlBcnJheShub2RlLCBtb2QpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOiB7XG4gICAgICBwcm94eSA9IHByb3hpZnlGdW5jdGlvbkNhbGwobm9kZSwgbW9kKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjoge1xuICAgICAgcHJveHkgPSBwcm94aWZ5QXJyb3dGdW5jdGlvbkV4cHJlc3Npb24obm9kZSwgbW9kKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiTmV3RXhwcmVzc2lvblwiOiB7XG4gICAgICBwcm94eSA9IHByb3hpZnlOZXdFeHByZXNzaW9uKG5vZGUsIG1vZCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIklkZW50aWZpZXJcIjoge1xuICAgICAgcHJveHkgPSBwcm94aWZ5SWRlbnRpZmllcihub2RlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiTG9naWNhbEV4cHJlc3Npb25cIjoge1xuICAgICAgcHJveHkgPSBwcm94aWZ5TG9naWNhbEV4cHJlc3Npb24obm9kZSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIk1lbWJlckV4cHJlc3Npb25cIjoge1xuICAgICAgcHJveHkgPSBwcm94aWZ5TWVtYmVyRXhwcmVzc2lvbihub2RlKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICBjYXNlIFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCI6IHtcbiAgICAgIHByb3h5ID0gcHJveGlmeShub2RlLmV4cHJlc3Npb24sIG1vZCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IE1hZ2ljYXN0RXJyb3IoYENhc3RpbmcgXCIke25vZGUudHlwZX1cIiBpcyBub3Qgc3VwcG9ydGVkYCwge1xuICAgICAgICBhc3Q6IG5vZGUsXG4gICAgICAgIGNvZGU6IG1vZD8uJGNvZGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfY2FjaGUuc2V0KG5vZGUsIHByb3h5KTtcbiAgcmV0dXJuIHByb3h5O1xufVxuXG5jb25zdCBiJDEgPSBidWlsZGVycyQxO1xuZnVuY3Rpb24gY3JlYXRlRXhwb3J0c1Byb3h5KHJvb3QsIG1vZCkge1xuICBjb25zdCBmaW5kRXhwb3J0ID0gKGtleSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBrZXkgPT09IFwiZGVmYXVsdFwiID8gXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiA6IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiO1xuICAgIGZvciAoY29uc3QgbiBvZiByb290LmJvZHkpIHtcbiAgICAgIGlmIChuLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICByZXR1cm4gbi5kZWNsYXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobi5kZWNsYXJhdGlvbiAmJiBcImRlY2xhcmF0aW9uc1wiIGluIG4uZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICBjb25zdCBkZWMgPSBuLmRlY2xhcmF0aW9uLmRlY2xhcmF0aW9uc1swXTtcbiAgICAgICAgICBpZiAoXCJuYW1lXCIgaW4gZGVjLmlkICYmIGRlYy5pZC5uYW1lID09PSBrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWMuaW5pdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHVwZGF0ZU9yQWRkRXhwb3J0ID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBjb25zdCB0eXBlID0ga2V5ID09PSBcImRlZmF1bHRcIiA/IFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIgOiBcIkV4cG9ydE5hbWVkRGVjbGFyYXRpb25cIjtcbiAgICBjb25zdCBub2RlID0gbGl0ZXJhbFRvQXN0KHZhbHVlKTtcbiAgICBmb3IgKGNvbnN0IG4gb2Ygcm9vdC5ib2R5KSB7XG4gICAgICBpZiAobi50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgbi5kZWNsYXJhdGlvbiA9IG5vZGU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuLmRlY2xhcmF0aW9uICYmIFwiZGVjbGFyYXRpb25zXCIgaW4gbi5kZWNsYXJhdGlvbikge1xuICAgICAgICAgIGNvbnN0IGRlYyA9IG4uZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zWzBdO1xuICAgICAgICAgIGlmIChcIm5hbWVcIiBpbiBkZWMuaWQgJiYgZGVjLmlkLm5hbWUgPT09IGtleSkge1xuICAgICAgICAgICAgZGVjLmluaXQgPSBub2RlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByb290LmJvZHkucHVzaChcbiAgICAgIGtleSA9PT0gXCJkZWZhdWx0XCIgPyBiJDEuZXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uKG5vZGUpIDogYiQxLmV4cG9ydE5hbWVkRGVjbGFyYXRpb24oXG4gICAgICAgIGIkMS52YXJpYWJsZURlY2xhcmF0aW9uKFwiY29uc3RcIiwgW1xuICAgICAgICAgIGIkMS52YXJpYWJsZURlY2xhcmF0b3IoYiQxLmlkZW50aWZpZXIoa2V5KSwgbm9kZSlcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICApO1xuICB9O1xuICByZXR1cm4gY3JlYXRlUHJveHkoXG4gICAgcm9vdCxcbiAgICB7XG4gICAgICAkdHlwZTogXCJleHBvcnRzXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGdldChfLCBwcm9wKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBmaW5kRXhwb3J0KHByb3ApO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBwcm94aWZ5KG5vZGUsIG1vZCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZXQoXywgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgdXBkYXRlT3JBZGRFeHBvcnQocHJvcCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICBvd25LZXlzKCkge1xuICAgICAgICByZXR1cm4gcm9vdC5ib2R5LmZsYXRNYXAoKGkpID0+IHtcbiAgICAgICAgICBpZiAoaS50eXBlID09PSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW1wiZGVmYXVsdFwiXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkudHlwZSA9PT0gXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIgJiYgaS5kZWNsYXJhdGlvbiAmJiBcImRlY2xhcmF0aW9uc1wiIGluIGkuZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBpLmRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucy5tYXAoXG4gICAgICAgICAgICAgIChkKSA9PiBcIm5hbWVcIiBpbiBkLmlkID8gZC5pZC5uYW1lIDogXCJcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICB9LFxuICAgICAgZGVsZXRlUHJvcGVydHkoXywgcHJvcCkge1xuICAgICAgICBjb25zdCB0eXBlID0gcHJvcCA9PT0gXCJkZWZhdWx0XCIgPyBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiIDogXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm9vdC5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbiA9IHJvb3QuYm9keVtpXTtcbiAgICAgICAgICBpZiAobi50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCA9PT0gXCJkZWZhdWx0XCIpIHtcbiAgICAgICAgICAgICAgcm9vdC5ib2R5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobi5kZWNsYXJhdGlvbiAmJiBcImRlY2xhcmF0aW9uc1wiIGluIG4uZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgY29uc3QgZGVjID0gbi5kZWNsYXJhdGlvbi5kZWNsYXJhdGlvbnNbMF07XG4gICAgICAgICAgICAgIGlmIChcIm5hbWVcIiBpbiBkZWMuaWQgJiYgZGVjLmlkLm5hbWUgPT09IHByb3ApIHtcbiAgICAgICAgICAgICAgICByb290LmJvZHkuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5cbmZ1bmN0aW9uIHByb3hpZnlNb2R1bGUoYXN0LCBjb2RlKSB7XG4gIGNvbnN0IHJvb3QgPSBhc3QucHJvZ3JhbTtcbiAgaWYgKHJvb3QudHlwZSAhPT0gXCJQcm9ncmFtXCIpIHtcbiAgICB0aHJvdyBuZXcgTWFnaWNhc3RFcnJvcihgQ2Fubm90IHByb3hpZnkgJHthc3QudHlwZX0gYXMgbW9kdWxlYCk7XG4gIH1cbiAgY29uc3QgdXRpbCA9IHtcbiAgICAkY29kZTogY29kZSxcbiAgICAkdHlwZTogXCJtb2R1bGVcIlxuICB9O1xuICBjb25zdCBtb2QgPSBjcmVhdGVQcm94eShyb290LCB1dGlsLCB7XG4gICAgb3duS2V5cygpIHtcbiAgICAgIHJldHVybiBbXCJpbXBvcnRzXCIsIFwiZXhwb3J0c1wiLCBcImdlbmVyYXRlXCJdO1xuICAgIH1cbiAgfSk7XG4gIHV0aWwuZXhwb3J0cyA9IGNyZWF0ZUV4cG9ydHNQcm94eShyb290LCBtb2QpO1xuICB1dGlsLmltcG9ydHMgPSBjcmVhdGVJbXBvcnRzUHJveHkocm9vdCk7XG4gIHV0aWwuZ2VuZXJhdGUgPSAob3B0aW9ucykgPT4gZ2VuZXJhdGVDb2RlKG1vZCwgb3B0aW9ucyk7XG4gIHJldHVybiBtb2Q7XG59XG5cbmZ1bmN0aW9uIGRldGVjdENvZGVGb3JtYXQoY29kZSwgdXNlclN0eWxlcyA9IHt9KSB7XG4gIGNvbnN0IGRldGVjdCA9IHtcbiAgICB3cmFwQ29sdW1uOiB1c2VyU3R5bGVzLndyYXBDb2x1bW4gPT09IHZvaWQgMCxcbiAgICBpbmRlbnQ6IHVzZXJTdHlsZXMudGFiV2lkdGggPT09IHZvaWQgMCB8fCB1c2VyU3R5bGVzLnVzZVRhYnMgPT09IHZvaWQgMCxcbiAgICBxdW90ZTogdXNlclN0eWxlcy5xdW90ZSA9PT0gdm9pZCAwLFxuICAgIGFycm93UGFyZW5zOiB1c2VyU3R5bGVzLmFycm93UGFyZW5zQWx3YXlzID09PSB2b2lkIDAsXG4gICAgdHJhaWxpbmdDb21tYTogdXNlclN0eWxlcy50cmFpbGluZ0NvbW1hID09PSB2b2lkIDBcbiAgfTtcbiAgbGV0IGNvZGVJbmRlbnQgPSAyO1xuICBsZXQgdGFiVXNhZ2VzID0gMDtcbiAgbGV0IHNlbWlVc2FnZXMgPSAwO1xuICBsZXQgbWF4TGluZUxlbmd0aCA9IDA7XG4gIGxldCBtdWx0aUxpbmVUcmFpbGluZ0NvbW1hVXNhZ2VzID0gMDtcbiAgY29uc3Qgc3ludGF4RGV0ZWN0UmVnZXggPSAvKD88ZG91YmxlUXVvdGU+XCJbXlwiXStcIil8KD88c2luZ2xlUXVvdGU+J1teJ10rJyl8KD88c2luZ2xlUGFyYW0+XFwoW14pLF0rXFwpXFxzKj0+KXwoPzx0cmFpbGluZ0NvbW1hPixcXHMqW1xcXX1dKS9nO1xuICBjb25zdCBzeW50YXhVc2FnZXMgPSB7XG4gICAgZG91YmxlUXVvdGU6IDAsXG4gICAgc2luZ2xlUXVvdGU6IDAsXG4gICAgc2luZ2xlUGFyYW06IDAsXG4gICAgdHJhaWxpbmdDb21tYTogMFxuICB9O1xuICBjb25zdCBsaW5lcyA9IChjb2RlIHx8IFwiXCIpLnNwbGl0KFwiXFxuXCIpO1xuICBsZXQgcHJldmlvdXNMaW5lVHJhaWxpbmcgPSBmYWxzZTtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgdHJpbW1pdGVkTGluZSA9IGxpbmUudHJpbSgpO1xuICAgIGlmICh0cmltbWl0ZWRMaW5lLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChkZXRlY3Qud3JhcENvbHVtbiAmJiBsaW5lLmxlbmd0aCA+IG1heExpbmVMZW5ndGgpIHtcbiAgICAgIG1heExpbmVMZW5ndGggPSBsaW5lLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGRldGVjdC5pbmRlbnQpIHtcbiAgICAgIGNvbnN0IGxpbmVJbmRlbnQgPSBsaW5lLm1hdGNoKC9eXFxzKy8pPy5bMF0gfHwgXCJcIjtcbiAgICAgIGlmIChsaW5lSW5kZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGxpbmVJbmRlbnQubGVuZ3RoID4gMCAmJiBsaW5lSW5kZW50Lmxlbmd0aCA8IGNvZGVJbmRlbnQpIHtcbiAgICAgICAgICBjb2RlSW5kZW50ID0gbGluZUluZGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmVJbmRlbnRbMF0gPT09IFwiXHRcIikge1xuICAgICAgICAgIHRhYlVzYWdlcysrO1xuICAgICAgICB9IGVsc2UgaWYgKGxpbmVJbmRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRhYlVzYWdlcy0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmltbWl0ZWRMaW5lLmF0KC0xKSA9PT0gXCI7XCIpIHtcbiAgICAgIHNlbWlVc2FnZXMrKztcbiAgICB9IGVsc2UgaWYgKHRyaW1taXRlZExpbmUubGVuZ3RoID4gMCkge1xuICAgICAgc2VtaVVzYWdlcy0tO1xuICAgIH1cbiAgICBpZiAoZGV0ZWN0LnF1b3RlIHx8IGRldGVjdC5hcnJvd1BhcmVucykge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IHRyaW1taXRlZExpbmUubWF0Y2hBbGwoc3ludGF4RGV0ZWN0UmVnZXgpO1xuICAgICAgZm9yIChjb25zdCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgICAgIGlmICghbWF0Y2guZ3JvdXBzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3ludGF4VXNhZ2VzKSB7XG4gICAgICAgICAgaWYgKG1hdGNoLmdyb3Vwc1trZXldKSB7XG4gICAgICAgICAgICBzeW50YXhVc2FnZXNba2V5XSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGV0ZWN0LnRyYWlsaW5nQ29tbWEpIHtcbiAgICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoXCJ9XCIpIHx8IGxpbmUuc3RhcnRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzTGluZVRyYWlsaW5nKSB7XG4gICAgICAgICAgbXVsdGlMaW5lVHJhaWxpbmdDb21tYVVzYWdlcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG11bHRpTGluZVRyYWlsaW5nQ29tbWFVc2FnZXMtLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJldmlvdXNMaW5lVHJhaWxpbmcgPSB0cmltbWl0ZWRMaW5lLmVuZHNXaXRoKFwiLFwiKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3cmFwQ29sdW1uOiBtYXhMaW5lTGVuZ3RoLFxuICAgIHVzZVRhYnM6IHRhYlVzYWdlcyA+IDAsXG4gICAgdGFiV2lkdGg6IGNvZGVJbmRlbnQsXG4gICAgcXVvdGU6IHN5bnRheFVzYWdlcy5zaW5nbGVRdW90ZSA+IHN5bnRheFVzYWdlcy5kb3VibGVRdW90ZSA/IFwic2luZ2xlXCIgOiBcImRvdWJsZVwiLFxuICAgIGFycm93UGFyZW5zQWx3YXlzOiBzeW50YXhVc2FnZXMuc2luZ2xlUGFyYW0gPiAwLFxuICAgIHRyYWlsaW5nQ29tbWE6IG11bHRpTGluZVRyYWlsaW5nQ29tbWFVc2FnZXMgPiAwIHx8IHN5bnRheFVzYWdlcy50cmFpbGluZ0NvbW1hID4gMCxcbiAgICB1c2VTZW1pOiBzZW1pVXNhZ2VzID4gMCxcbiAgICBhcnJheUJyYWNrZXRTcGFjaW5nOiB2b2lkIDAsXG4gICAgLy8gVE9ET1xuICAgIG9iamVjdEN1cmx5U3BhY2luZzogdm9pZCAwLFxuICAgIC8vIFRPRE9cbiAgICAuLi51c2VyU3R5bGVzXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9kdWxlKGNvZGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qgbm9kZSA9IHBhcnNlKGNvZGUsIHtcbiAgICBwYXJzZXI6IG9wdGlvbnM/LnBhcnNlciB8fCBnZXRCYWJlbFBhcnNlcigpLFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG4gIHJldHVybiBwcm94aWZ5TW9kdWxlKG5vZGUsIGNvZGUpO1xufVxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKGNvZGUsIG9wdGlvbnMpIHtcbiAgY29uc3Qgcm9vdCA9IHBhcnNlKFwiKFwiICsgY29kZSArIFwiKVwiLCB7XG4gICAgcGFyc2VyOiBvcHRpb25zPy5wYXJzZXIgfHwgZ2V0QmFiZWxQYXJzZXIoKSxcbiAgICAuLi5vcHRpb25zXG4gIH0pO1xuICBsZXQgYm9keSA9IHJvb3QucHJvZ3JhbS5ib2R5WzBdO1xuICBpZiAoYm9keS50eXBlID09PSBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIikge1xuICAgIGJvZHkgPSBib2R5LmV4cHJlc3Npb247XG4gIH1cbiAgaWYgKGJvZHkuZXh0cmE/LnBhcmVudGhlc2l6ZWQpIHtcbiAgICBib2R5LmV4dHJhLnBhcmVudGhlc2l6ZWQgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBtb2QgPSB7XG4gICAgJGFzdDogcm9vdCxcbiAgICAkY29kZTogXCIgXCIgKyBjb2RlICsgXCIgXCIsXG4gICAgJHR5cGU6IFwibW9kdWxlXCJcbiAgfTtcbiAgcmV0dXJuIHByb3hpZnkoYm9keSwgbW9kKTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29kZShub2RlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgYXN0ID0gbm9kZS4kYXN0IHx8IG5vZGU7XG4gIGNvbnN0IGZvcm1hdE9wdGlvbnMgPSBvcHRpb25zLmZvcm1hdCA9PT0gZmFsc2UgfHwgIShcIiRjb2RlXCIgaW4gbm9kZSkgPyB7fSA6IGRldGVjdENvZGVGb3JtYXQobm9kZS4kY29kZSwgb3B0aW9ucy5mb3JtYXQpO1xuICBjb25zdCB7IGNvZGUsIG1hcCB9ID0gcHJpbnQoYXN0LCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICAuLi5mb3JtYXRPcHRpb25zXG4gIH0pO1xuICByZXR1cm4geyBjb2RlLCBtYXAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGxvYWRGaWxlKGZpbGVuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgY29udGVudHMgPSBhd2FpdCBwcm9taXNlcy5yZWFkRmlsZShmaWxlbmFtZSwgXCJ1dGY4XCIpO1xuICBvcHRpb25zLnNvdXJjZUZpbGVOYW1lID0gb3B0aW9ucy5zb3VyY2VGaWxlTmFtZSA/PyBmaWxlbmFtZTtcbiAgcmV0dXJuIHBhcnNlTW9kdWxlKGNvbnRlbnRzLCBvcHRpb25zKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdyaXRlRmlsZShub2RlLCBmaWxlbmFtZSwgb3B0aW9ucykge1xuICBjb25zdCBhc3QgPSBcIiRhc3RcIiBpbiBub2RlID8gbm9kZS4kYXN0IDogbm9kZTtcbiAgY29uc3QgeyBjb2RlLCBtYXAgfSA9IGdlbmVyYXRlQ29kZShhc3QsIG9wdGlvbnMpO1xuICBhd2FpdCBwcm9taXNlcy53cml0ZUZpbGUoZmlsZW5hbWUsIGNvZGUpO1xuICBpZiAobWFwKSB7XG4gICAgYXdhaXQgcHJvbWlzZXMud3JpdGVGaWxlKGZpbGVuYW1lICsgXCIubWFwXCIsIG1hcCk7XG4gIH1cbn1cblxuY29uc3QgYiA9IGJ1aWxkZXJzJDE7XG5jb25zdCBidWlsZGVycyA9IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZ1bmN0aW9uIGNhbGwgbm9kZS5cbiAgICovXG4gIGZ1bmN0aW9uQ2FsbChjYWxsZWUsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBub2RlID0gYi5jYWxsRXhwcmVzc2lvbihcbiAgICAgIGIuaWRlbnRpZmllcihjYWxsZWUpLFxuICAgICAgYXJncy5tYXAoKGkpID0+IGxpdGVyYWxUb0FzdChpKSlcbiAgICApO1xuICAgIHJldHVybiBwcm94aWZ5RnVuY3Rpb25DYWxsKG5vZGUpO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGV4cHJlc3Npb24gbm9kZS5cbiAgICovXG4gIG5ld0V4cHJlc3Npb24oY2FsbGVlLCAuLi5hcmdzKSB7XG4gICAgY29uc3Qgbm9kZSA9IGIubmV3RXhwcmVzc2lvbihcbiAgICAgIGIuaWRlbnRpZmllcihjYWxsZWUpLFxuICAgICAgYXJncy5tYXAoKGkpID0+IGxpdGVyYWxUb0FzdChpKSlcbiAgICApO1xuICAgIHJldHVybiBwcm94aWZ5TmV3RXhwcmVzc2lvbihub2RlKTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZSBhIHByb3hpZmllZCB2ZXJzaW9uIG9mIGEgbGl0ZXJhbCB2YWx1ZS5cbiAgICovXG4gIGxpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gbGl0ZXJhbFRvQXN0KHZhbHVlKTtcbiAgfSxcbiAgLyoqXG4gICAqIFBhcnNlIGEgcmF3IGV4cHJlc3Npb24gYW5kIHJldHVybiBhIHByb3hpZmllZCB2ZXJzaW9uIG9mIGl0LlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBjb25zdCBvYmogPSBidWlsZGVycy5yYXcoXCJ7IGZvbzogMSB9XCIpO1xuICAgKiBjb25zb2xlLmxvZyhvYmouZm9vKTsgLy8gMVxuICAgKiBgYGBcbiAgICovXG4gIHJhdyhjb2RlKSB7XG4gICAgcmV0dXJuIHBhcnNlRXhwcmVzc2lvbihjb2RlKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgTWFnaWNhc3RFcnJvciwgYnVpbGRlcnMsIGRldGVjdENvZGVGb3JtYXQsIGdlbmVyYXRlQ29kZSwgbG9hZEZpbGUsIHBhcnNlRXhwcmVzc2lvbiwgcGFyc2VNb2R1bGUsIHdyaXRlRmlsZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/magicast@0.3.5/node_modules/magicast/dist/index.mjs\n");

/***/ })

};
;