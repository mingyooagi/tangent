"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@babel+parser@7.28.6";
exports.ids = ["vendor-chunks/@babel+parser@7.28.6"];
exports.modules = {

/***/ "(rsc)/../node_modules/.pnpm/@babel+parser@7.28.6/node_modules/@babel/parser/lib/index.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/.pnpm/@babel+parser@7.28.6/node_modules/@babel/parser/lib/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (-1 !== e.indexOf(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nclass Position {\n  constructor(line, col, index) {\n    this.line = void 0;\n    this.column = void 0;\n    this.index = void 0;\n    this.line = line;\n    this.column = col;\n    this.index = index;\n  }\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = void 0;\n    this.end = void 0;\n    this.filename = void 0;\n    this.identifierName = void 0;\n    this.start = start;\n    this.end = end;\n  }\n}\nfunction createPositionWithColumnOffset(position, columnOffset) {\n  const {\n    line,\n    column,\n    index\n  } = position;\n  return new Position(line, column + columnOffset, index + columnOffset);\n}\nconst code = \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\";\nvar ModuleErrors = {\n  ImportMetaOutsideModule: {\n    message: `import.meta may appear only with 'sourceType: \"module\"'`,\n    code\n  },\n  ImportOutsideModule: {\n    message: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n    code\n  }\n};\nconst NodeDescriptions = {\n  ArrayPattern: \"array destructuring pattern\",\n  AssignmentExpression: \"assignment expression\",\n  AssignmentPattern: \"assignment expression\",\n  ArrowFunctionExpression: \"arrow function expression\",\n  ConditionalExpression: \"conditional expression\",\n  CatchClause: \"catch clause\",\n  ForOfStatement: \"for-of statement\",\n  ForInStatement: \"for-in statement\",\n  ForStatement: \"for-loop\",\n  FormalParameters: \"function parameter list\",\n  Identifier: \"identifier\",\n  ImportSpecifier: \"import specifier\",\n  ImportDefaultSpecifier: \"import default specifier\",\n  ImportNamespaceSpecifier: \"import namespace specifier\",\n  ObjectPattern: \"object destructuring pattern\",\n  ParenthesizedExpression: \"parenthesized expression\",\n  RestElement: \"rest element\",\n  UpdateExpression: {\n    true: \"prefix operation\",\n    false: \"postfix operation\"\n  },\n  VariableDeclarator: \"variable declaration\",\n  YieldExpression: \"yield expression\"\n};\nconst toNodeDescription = node => node.type === \"UpdateExpression\" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];\nvar StandardErrors = {\n  AccessorIsGenerator: ({\n    kind\n  }) => `A ${kind}ter cannot be a generator.`,\n  ArgumentsInClass: \"'arguments' is only allowed in functions and class methods.\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block.\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function.\",\n  AwaitBindingIdentifierInStaticBlock: \"Can not use 'await' as identifier inside a static block.\",\n  AwaitExpressionFormalParameter: \"'await' is not allowed in async function parameters.\",\n  AwaitUsingNotInAsyncContext: \"'await using' is only allowed within async functions and at the top levels of modules.\",\n  AwaitNotInAsyncContext: \"'await' is only allowed within async functions and at the top levels of modules.\",\n  BadGetterArity: \"A 'get' accessor must not have any formal parameters.\",\n  BadSetterArity: \"A 'set' accessor must have exactly one formal parameter.\",\n  BadSetterRestParameter: \"A 'set' accessor function argument must not be a rest parameter.\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'.\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'.\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor.\",\n  ConstructorIsAsync: \"Constructor can't be an async function.\",\n  ConstructorIsGenerator: \"Constructor can't be a generator.\",\n  DeclarationMissingInitializer: ({\n    kind\n  }) => `Missing initializer in ${kind} declaration.`,\n  DecoratorArgumentsOutsideParentheses: \"Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.\",\n  DecoratorsBeforeAfterExport: \"Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon.\",\n  DecoratorStaticBlock: \"Decorators can't be used with a static block.\",\n  DeferImportRequiresNamespace: 'Only `import defer * as x from \"./module\"` is valid.',\n  DeletePrivateField: \"Deleting a private field is not allowed.\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class.\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: ({\n    exportName\n  }) => `\\`${exportName}\\` has already been exported. Exported identifiers must be unique.`,\n  DuplicateProto: \"Redefinition of __proto__ property.\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag.\",\n  ElementAfterRest: \"Rest element must be last element.\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape.\",\n  ExportBindingIsString: ({\n    localName,\n    exportName\n  }) => `A string literal cannot be used as an exported binding without \\`from\\`.\\n- Did you mean \\`export { '${localName}' as '${exportName}' } from 'some-module'\\`?`,\n  ExportDefaultFromAsIdentifier: \"'from' is not allowed as an identifier after 'export default'.\",\n  ForInOfLoopInitializer: ({\n    type\n  }) => `'${type === \"ForInStatement\" ? \"for-in\" : \"for-of\"}' loop variable declaration may not have an initializer.`,\n  ForInUsing: \"For-in loop may not start with 'using' declaration.\",\n  ForOfAsync: \"The left-hand side of a for-of loop may not be 'async'.\",\n  ForOfLet: \"The left-hand side of a for-of loop may not start with 'let'.\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block.\",\n  IllegalBreakContinue: ({\n    type\n  }) => `Unsyntactic ${type === \"BreakStatement\" ? \"break\" : \"continue\"}.`,\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list.\",\n  IllegalReturn: \"'return' outside of function.\",\n  ImportAttributesUseAssert: \"The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.\",\n  ImportBindingIsString: ({\n    importName\n  }) => `A string literal cannot be used as an imported binding.\\n- Did you mean \\`import { \"${importName}\" as foo }\\`?`,\n  ImportCallArity: `\\`import()\\` requires exactly one or two arguments.`,\n  ImportCallNotNewExpression: \"Cannot use new with import(...).\",\n  ImportCallSpreadArgument: \"`...` is not allowed in `import()`.\",\n  ImportJSONBindingNotDefault: \"A JSON module can only be imported with `default`.\",\n  ImportReflectionHasAssertion: \"`import module x` cannot have assertions.\",\n  ImportReflectionNotBinding: 'Only `import module x from \"./module\"` is valid.',\n  IncompatibleRegExpUVFlags: \"The 'u' and 'v' regular expression flags cannot be enabled at the same time.\",\n  InvalidBigIntLiteral: \"Invalid BigIntLiteral.\",\n  InvalidCodePoint: \"Code point out of bounds.\",\n  InvalidCoverDiscardElement: \"'void' must be followed by an expression when not used in a binding position.\",\n  InvalidCoverInitializedName: \"Invalid shorthand property initializer.\",\n  InvalidDecimal: \"Invalid decimal.\",\n  InvalidDigit: ({\n    radix\n  }) => `Expected number in radix ${radix}.`,\n  InvalidEscapeSequence: \"Bad character escape sequence.\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template.\",\n  InvalidEscapedReservedWord: ({\n    reservedWord\n  }) => `Escape sequence in keyword ${reservedWord}.`,\n  InvalidIdentifier: ({\n    identifierName\n  }) => `Invalid identifier ${identifierName}.`,\n  InvalidLhs: ({\n    ancestor\n  }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsBinding: ({\n    ancestor\n  }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,\n  InvalidLhsOptionalChaining: ({\n    ancestor\n  }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,\n  InvalidNumber: \"Invalid number.\",\n  InvalidOrMissingExponent: \"Floating-point numbers require a valid exponent after the 'e'.\",\n  InvalidOrUnexpectedToken: ({\n    unexpected\n  }) => `Unexpected character '${unexpected}'.`,\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern.\",\n  InvalidPrivateFieldResolution: ({\n    identifierName\n  }) => `Private name #${identifierName} is not defined.`,\n  InvalidPropertyBindingPattern: \"Binding member expression.\",\n  InvalidRecordProperty: \"Only properties and spread elements are allowed in record definitions.\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument.\",\n  LabelRedeclaration: ({\n    labelName\n  }) => `Label '${labelName}' is already declared.`,\n  LetInLexicalBinding: \"'let' is disallowed as a lexically bound name.\",\n  LineTerminatorBeforeArrow: \"No line break is allowed before '=>'.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag.\",\n  MissingClassName: \"A class name is required.\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingSemicolon: \"Missing semicolon.\",\n  MissingPlugin: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingOneOfPlugins: ({\n    missingPlugin\n  }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map(name => JSON.stringify(name)).join(\", \")}.`,\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX.\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators.\",\n  ModuleAttributeDifferentFromType: \"The only accepted module attribute is `type`.\",\n  ModuleAttributeInvalidValue: \"Only string literals are allowed as module attribute values.\",\n  ModuleAttributesWithDuplicateKeys: ({\n    key\n  }) => `Duplicate key \"${key}\" is not allowed in module attributes.`,\n  ModuleExportNameHasLoneSurrogate: ({\n    surrogateCharCode\n  }) => `An export name cannot include a lone surrogate, found '\\\\u${surrogateCharCode.toString(16)}'.`,\n  ModuleExportUndefined: ({\n    localName\n  }) => `Export '${localName}' is not defined.`,\n  MultipleDefaultsInSwitch: \"Multiple default clauses.\",\n  NewlineAfterThrow: \"Illegal newline after throw.\",\n  NoCatchOrFinally: \"Missing catch or finally clause.\",\n  NumberIdentifier: \"Identifier directly after number.\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.\",\n  ObsoleteAwaitStar: \"'await*' has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"Constructors in/after an Optional Chain are not allowed.\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain.\",\n  OverrideOnConstructor: \"'override' modifier cannot appear on a constructor declaration.\",\n  ParamDupe: \"Argument name clash.\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter.\",\n  PatternHasMethod: \"Object pattern can't contain methods.\",\n  PrivateInExpectedIn: ({\n    identifierName\n  }) => `Private names are only allowed in property accesses (\\`obj.#${identifierName}\\`) or in \\`in\\` expressions (\\`#${identifierName} in obj\\`).`,\n  PrivateNameRedeclaration: ({\n    identifierName\n  }) => `Duplicate private name #${identifierName}.`,\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  RecordNoProto: \"'__proto__' is not allowed in Record expressions.\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element.\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level or inside a block.\",\n  SloppyFunctionAnnexB: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.\",\n  SourcePhaseImportRequiresDefault: 'Only `import source x from \"./module\"` is valid.',\n  StaticPrototype: \"Classes may not have static property named prototype.\",\n  SuperNotAllowed: \"`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super.\",\n  TrailingDecorator: \"Decorators must be attached to a class element.\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder.\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal.',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token.\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level.\",\n  UnexpectedKeyword: ({\n    keyword\n  }) => `Unexpected keyword '${keyword}'.`,\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration.\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context.\",\n  UnexpectedNewTarget: \"`new.target` can only be used in functions or class properties.\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits.\",\n  UnexpectedPrivateField: \"Unexpected private name.\",\n  UnexpectedReservedWord: ({\n    reservedWord\n  }) => `Unexpected reserved word '${reservedWord}'.`,\n  UnexpectedSuper: \"'super' is only allowed in object methods and classes.\",\n  UnexpectedToken: ({\n    expected,\n    unexpected\n  }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : \"\"}${expected ? `, expected \"${expected}\"` : \"\"}`,\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnexpectedUsingDeclaration: \"Using declaration cannot appear in the top level when source type is `script` or in the bare case statement.\",\n  UnexpectedVoidPattern: \"Unexpected void binding.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration.\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"`import` can only be used in `import()` or `import.meta`.\",\n  UnsupportedMetaProperty: ({\n    target,\n    onlyValidPropertyName\n  }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters.\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties.\",\n  UnsupportedSuper: \"'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).\",\n  UnterminatedComment: \"Unterminated comment.\",\n  UnterminatedRegExp: \"Unterminated regular expression.\",\n  UnterminatedString: \"Unterminated string constant.\",\n  UnterminatedTemplate: \"Unterminated template.\",\n  UsingDeclarationExport: \"Using declaration cannot be exported.\",\n  UsingDeclarationHasBindingPattern: \"Using declaration cannot have destructuring patterns.\",\n  VarRedeclaration: ({\n    identifierName\n  }) => `Identifier '${identifierName}' has already been declared.`,\n  VoidPatternCatchClauseParam: \"A void binding can not be the catch clause parameter. Use `try { ... } catch { ... }` if you want to discard the caught error.\",\n  VoidPatternInitializer: \"A void binding may not have an initializer.\",\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator.\",\n  YieldInParameter: \"Yield expression is not allowed in formal parameters.\",\n  YieldNotInGeneratorFunction: \"'yield' is only allowed within generator functions.\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0.\"\n};\nvar StrictModeErrors = {\n  StrictDelete: \"Deleting local variable in strict mode.\",\n  StrictEvalArguments: ({\n    referenceName\n  }) => `Assigning to '${referenceName}' in strict mode.`,\n  StrictEvalArgumentsBinding: ({\n    bindingName\n  }) => `Binding '${bindingName}' in strict mode.`,\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block.\",\n  StrictNumericEscape: \"The only valid numeric escape in strict mode is '\\\\0'.\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode.\",\n  StrictWith: \"'with' in strict mode.\"\n};\nvar ParseExpressionErrors = {\n  ParseExpressionEmptyInput: \"Unexpected parseExpression() input: The input is empty or contains only comments.\",\n  ParseExpressionExpectsEOF: ({\n    unexpected\n  }) => `Unexpected parseExpression() input: The input should contain exactly one expression, but the first expression is followed by the unexpected character \\`${String.fromCodePoint(unexpected)}\\`.`\n};\nconst UnparenthesizedPipeBodyDescriptions = new Set([\"ArrowFunctionExpression\", \"AssignmentExpression\", \"ConditionalExpression\", \"YieldExpression\"]);\nvar PipelineOperatorErrors = Object.assign({\n  PipeBodyIsTighter: \"Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.\",\n  PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.',\n  PipeTopicUnbound: \"Topic reference is unbound; it must be inside a pipe body.\",\n  PipeTopicUnconfiguredToken: ({\n    token\n  }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { \"proposal\": \"hack\", \"topicToken\": \"${token}\" }.`,\n  PipeTopicUnused: \"Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.\",\n  PipeUnparenthesizedBody: ({\n    type\n  }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({\n    type\n  })}; please wrap it in parentheses.`\n}, {\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized.',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression.\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression.\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference.\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding.\",\n  PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a \"proposal\": \"hack\" or \"smart\" option.'\n});\nconst _excluded = [\"message\"];\nfunction defineHidden(obj, key, value) {\n  Object.defineProperty(obj, key, {\n    enumerable: false,\n    configurable: true,\n    value\n  });\n}\nfunction toParseErrorConstructor({\n  toMessage,\n  code,\n  reasonCode,\n  syntaxPlugin\n}) {\n  const hasMissingPlugin = reasonCode === \"MissingPlugin\" || reasonCode === \"MissingOneOfPlugins\";\n  const oldReasonCodes = {\n    AccessorCannotDeclareThisParameter: \"AccesorCannotDeclareThisParameter\",\n    AccessorCannotHaveTypeParameters: \"AccesorCannotHaveTypeParameters\",\n    ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference\",\n    SetAccessorCannotHaveOptionalParameter: \"SetAccesorCannotHaveOptionalParameter\",\n    SetAccessorCannotHaveRestParameter: \"SetAccesorCannotHaveRestParameter\",\n    SetAccessorCannotHaveReturnType: \"SetAccesorCannotHaveReturnType\"\n  };\n  if (oldReasonCodes[reasonCode]) {\n    reasonCode = oldReasonCodes[reasonCode];\n  }\n  return function constructor(loc, details) {\n    const error = new SyntaxError();\n    error.code = code;\n    error.reasonCode = reasonCode;\n    error.loc = loc;\n    error.pos = loc.index;\n    error.syntaxPlugin = syntaxPlugin;\n    if (hasMissingPlugin) {\n      error.missingPlugin = details.missingPlugin;\n    }\n    defineHidden(error, \"clone\", function clone(overrides = {}) {\n      var _overrides$loc;\n      const {\n        line,\n        column,\n        index\n      } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;\n      return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));\n    });\n    defineHidden(error, \"details\", details);\n    Object.defineProperty(error, \"message\", {\n      configurable: true,\n      get() {\n        const message = `${toMessage(details)} (${loc.line}:${loc.column})`;\n        this.message = message;\n        return message;\n      },\n      set(value) {\n        Object.defineProperty(this, \"message\", {\n          value,\n          writable: true\n        });\n      }\n    });\n    return error;\n  };\n}\nfunction ParseErrorEnum(argument, syntaxPlugin) {\n  if (Array.isArray(argument)) {\n    return parseErrorTemplates => ParseErrorEnum(parseErrorTemplates, argument[0]);\n  }\n  const ParseErrorConstructors = {};\n  for (const reasonCode of Object.keys(argument)) {\n    const template = argument[reasonCode];\n    const _ref = typeof template === \"string\" ? {\n        message: () => template\n      } : typeof template === \"function\" ? {\n        message: template\n      } : template,\n      {\n        message\n      } = _ref,\n      rest = _objectWithoutPropertiesLoose(_ref, _excluded);\n    const toMessage = typeof message === \"string\" ? () => message : message;\n    ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({\n      code: \"BABEL_PARSER_SYNTAX_ERROR\",\n      reasonCode,\n      toMessage\n    }, syntaxPlugin ? {\n      syntaxPlugin\n    } : {}, rest));\n  }\n  return ParseErrorConstructors;\n}\nconst Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum(ParseExpressionErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));\nfunction createDefaultOptions() {\n  return {\n    sourceType: \"script\",\n    sourceFilename: undefined,\n    startIndex: 0,\n    startColumn: 0,\n    startLine: 1,\n    allowAwaitOutsideFunction: false,\n    allowReturnOutsideFunction: false,\n    allowNewTargetOutsideFunction: false,\n    allowImportExportEverywhere: false,\n    allowSuperOutsideMethod: false,\n    allowUndeclaredExports: false,\n    allowYieldOutsideFunction: false,\n    plugins: [],\n    strictMode: undefined,\n    ranges: false,\n    tokens: false,\n    createImportExpressions: false,\n    createParenthesizedExpressions: false,\n    errorRecovery: false,\n    attachComment: true,\n    annexB: true\n  };\n}\nfunction getOptions(opts) {\n  const options = createDefaultOptions();\n  if (opts == null) {\n    return options;\n  }\n  if (opts.annexB != null && opts.annexB !== false) {\n    throw new Error(\"The `annexB` option can only be set to `false`.\");\n  }\n  for (const key of Object.keys(options)) {\n    if (opts[key] != null) options[key] = opts[key];\n  }\n  if (options.startLine === 1) {\n    if (opts.startIndex == null && options.startColumn > 0) {\n      options.startIndex = options.startColumn;\n    } else if (opts.startColumn == null && options.startIndex > 0) {\n      options.startColumn = options.startIndex;\n    }\n  } else if (opts.startColumn == null || opts.startIndex == null) {\n    if (opts.startIndex != null) {\n      throw new Error(\"With a `startLine > 1` you must also specify `startIndex` and `startColumn`.\");\n    }\n  }\n  if (options.sourceType === \"commonjs\") {\n    if (opts.allowAwaitOutsideFunction != null) {\n      throw new Error(\"The `allowAwaitOutsideFunction` option cannot be used with `sourceType: 'commonjs'`.\");\n    }\n    if (opts.allowReturnOutsideFunction != null) {\n      throw new Error(\"`sourceType: 'commonjs'` implies `allowReturnOutsideFunction: true`, please remove the `allowReturnOutsideFunction` option or use `sourceType: 'script'`.\");\n    }\n    if (opts.allowNewTargetOutsideFunction != null) {\n      throw new Error(\"`sourceType: 'commonjs'` implies `allowNewTargetOutsideFunction: true`, please remove the `allowNewTargetOutsideFunction` option or use `sourceType: 'script'`.\");\n    }\n  }\n  return options;\n}\nconst {\n  defineProperty\n} = Object;\nconst toUnenumerable = (object, key) => {\n  if (object) {\n    defineProperty(object, key, {\n      enumerable: false,\n      value: object[key]\n    });\n  }\n};\nfunction toESTreeLocation(node) {\n  toUnenumerable(node.loc.start, \"index\");\n  toUnenumerable(node.loc.end, \"index\");\n  return node;\n}\nvar estree = superClass => class ESTreeParserMixin extends superClass {\n  parse() {\n    const file = toESTreeLocation(super.parse());\n    if (this.optionFlags & 256) {\n      file.tokens = file.tokens.map(toESTreeLocation);\n    }\n    return file;\n  }\n  parseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (_) {}\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n  parseBigIntLiteral(value) {\n    let bigInt;\n    try {\n      bigInt = BigInt(value);\n    } catch (_unused) {\n      bigInt = null;\n    }\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n  parseDecimalLiteral(value) {\n    const decimal = null;\n    const node = this.estreeParseLiteral(decimal);\n    node.decimal = String(node.value || value);\n    return node;\n  }\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n  parseStringLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNumericLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  parseNullLiteral() {\n    return this.estreeParseLiteral(null);\n  }\n  parseBooleanLiteral(value) {\n    return this.estreeParseLiteral(value);\n  }\n  estreeParseChainExpression(node, endLoc) {\n    const chain = this.startNodeAtNode(node);\n    chain.expression = node;\n    return this.finishNodeAt(chain, \"ChainExpression\", endLoc);\n  }\n  directiveToStmt(directive) {\n    const expression = directive.value;\n    delete directive.value;\n    this.castNodeTo(expression, \"Literal\");\n    expression.raw = expression.extra.raw;\n    expression.value = expression.extra.expressionValue;\n    const stmt = this.castNodeTo(directive, \"ExpressionStatement\");\n    stmt.expression = expression;\n    stmt.directive = expression.extra.rawValue;\n    delete expression.extra;\n    return stmt;\n  }\n  fillOptionalPropertiesForTSESLint(node) {}\n  cloneEstreeStringLiteral(node) {\n    const {\n      start,\n      end,\n      loc,\n      range,\n      raw,\n      value\n    } = node;\n    const cloned = Object.create(node.constructor.prototype);\n    cloned.type = \"Literal\";\n    cloned.start = start;\n    cloned.end = end;\n    cloned.loc = loc;\n    cloned.range = range;\n    cloned.raw = raw;\n    cloned.value = value;\n    return cloned;\n  }\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n  checkDeclaration(node) {\n    if (node != null && this.isObjectProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.value.params;\n  }\n  isValidDirective(stmt) {\n    var _stmt$expression$extr;\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n  parsePrivateName() {\n    const node = super.parsePrivateName();\n    if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n      return node;\n    }\n    return this.convertPrivateNameToPrivateIdentifier(node);\n  }\n  convertPrivateNameToPrivateIdentifier(node) {\n    const name = super.getPrivateNameSV(node);\n    delete node.id;\n    node.name = name;\n    return this.castNodeTo(node, \"PrivateIdentifier\");\n  }\n  isPrivateName(node) {\n    if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n      return super.isPrivateName(node);\n    }\n    return node.type === \"PrivateIdentifier\";\n  }\n  getPrivateNameSV(node) {\n    if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n      return super.getPrivateNameSV(node);\n    }\n    return node.name;\n  }\n  parseLiteral(value, type) {\n    const node = super.parseLiteral(value, type);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    delete funcNode.kind;\n    const {\n      typeParameters\n    } = node;\n    if (typeParameters) {\n      delete node.typeParameters;\n      funcNode.typeParameters = typeParameters;\n      this.resetStartLocationFromNode(funcNode, typeParameters);\n    }\n    const valueNode = this.castNodeTo(funcNode, \"FunctionExpression\");\n    node.value = valueNode;\n    if (type === \"ClassPrivateMethod\") {\n      node.computed = false;\n    }\n    if (type === \"ObjectMethod\") {\n      if (node.kind === \"method\") {\n        node.kind = \"init\";\n      }\n      node.shorthand = false;\n      return this.finishNode(node, \"Property\");\n    } else {\n      return this.finishNode(node, \"MethodDefinition\");\n    }\n  }\n  nameIsConstructor(key) {\n    if (key.type === \"Literal\") return key.value === \"constructor\";\n    return super.nameIsConstructor(key);\n  }\n  parseClassProperty(...args) {\n    const propertyNode = super.parseClassProperty(...args);\n    if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n      return propertyNode;\n    }\n    this.castNodeTo(propertyNode, \"PropertyDefinition\");\n    return propertyNode;\n  }\n  parseClassPrivateProperty(...args) {\n    const propertyNode = super.parseClassPrivateProperty(...args);\n    if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n      return propertyNode;\n    }\n    this.castNodeTo(propertyNode, \"PropertyDefinition\");\n    propertyNode.computed = false;\n    return propertyNode;\n  }\n  parseClassAccessorProperty(node) {\n    const accessorPropertyNode = super.parseClassAccessorProperty(node);\n    if (!this.getPluginOption(\"estree\", \"classFeatures\")) {\n      return accessorPropertyNode;\n    }\n    if (accessorPropertyNode.abstract && this.hasPlugin(\"typescript\")) {\n      delete accessorPropertyNode.abstract;\n      this.castNodeTo(accessorPropertyNode, \"TSAbstractAccessorProperty\");\n    } else {\n      this.castNodeTo(accessorPropertyNode, \"AccessorProperty\");\n    }\n    return accessorPropertyNode;\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (node) {\n      node.kind = \"init\";\n      this.castNodeTo(node, \"Property\");\n    }\n    return node;\n  }\n  finishObjectProperty(node) {\n    node.kind = \"init\";\n    return this.finishNode(node, \"Property\");\n  }\n  isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {\n    return type === \"Property\" ? \"value\" : super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding);\n  }\n  isAssignable(node, isBinding) {\n    if (node != null && this.isObjectProperty(node)) {\n      return this.isAssignable(node.value, isBinding);\n    }\n    return super.isAssignable(node, isBinding);\n  }\n  toAssignable(node, isLHS = false) {\n    if (node != null && this.isObjectProperty(node)) {\n      const {\n        key,\n        value\n      } = node;\n      if (this.isPrivateName(key)) {\n        this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n      }\n      this.toAssignable(value, isLHS);\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"Property\" && (prop.kind === \"get\" || prop.kind === \"set\")) {\n      this.raise(Errors.PatternHasAccessor, prop.key);\n    } else if (prop.type === \"Property\" && prop.method) {\n      this.raise(Errors.PatternHasMethod, prop.key);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n    }\n  }\n  finishCallExpression(unfinished, optional) {\n    const node = super.finishCallExpression(unfinished, optional);\n    if (node.callee.type === \"Import\") {\n      var _ref, _ref2;\n      this.castNodeTo(node, \"ImportExpression\");\n      node.source = node.arguments[0];\n      node.options = (_ref = node.arguments[1]) != null ? _ref : null;\n      node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;\n      delete node.arguments;\n      delete node.callee;\n    } else if (node.type === \"OptionalCallExpression\") {\n      this.castNodeTo(node, \"CallExpression\");\n    } else {\n      node.optional = false;\n    }\n    return node;\n  }\n  toReferencedArguments(node) {\n    if (node.type === \"ImportExpression\") {\n      return;\n    }\n    super.toReferencedArguments(node);\n  }\n  parseExport(unfinished, decorators) {\n    const exportStartLoc = this.state.lastTokStartLoc;\n    const node = super.parseExport(unfinished, decorators);\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          this.castNodeTo(node, \"ExportAllDeclaration\");\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n      case \"ExportDefaultDeclaration\":\n        {\n          var _declaration$decorato;\n          const {\n            declaration\n          } = node;\n          if ((declaration == null ? void 0 : declaration.type) === \"ClassDeclaration\" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {\n            this.resetStartLocation(node, exportStartLoc);\n          }\n        }\n        break;\n    }\n    return node;\n  }\n  stopParseSubscript(base, state) {\n    const node = super.stopParseSubscript(base, state);\n    if (state.optionalChainMember) {\n      return this.estreeParseChainExpression(node, base.loc.end);\n    }\n    return node;\n  }\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = super.parseMember(base, startLoc, state, computed, optional);\n    if (node.type === \"OptionalMemberExpression\") {\n      this.castNodeTo(node, \"MemberExpression\");\n    } else {\n      node.optional = false;\n    }\n    return node;\n  }\n  isOptionalMemberExpression(node) {\n    if (node.type === \"ChainExpression\") {\n      return node.expression.type === \"MemberExpression\";\n    }\n    return super.isOptionalMemberExpression(node);\n  }\n  hasPropertyAsPrivateName(node) {\n    if (node.type === \"ChainExpression\") {\n      node = node.expression;\n    }\n    return super.hasPropertyAsPrivateName(node);\n  }\n  isObjectProperty(node) {\n    return node.type === \"Property\" && node.kind === \"init\" && !node.method;\n  }\n  isObjectMethod(node) {\n    return node.type === \"Property\" && (node.method || node.kind === \"get\" || node.kind === \"set\");\n  }\n  castNodeTo(node, type) {\n    const result = super.castNodeTo(node, type);\n    this.fillOptionalPropertiesForTSESLint(result);\n    return result;\n  }\n  cloneIdentifier(node) {\n    const cloned = super.cloneIdentifier(node);\n    this.fillOptionalPropertiesForTSESLint(cloned);\n    return cloned;\n  }\n  cloneStringLiteral(node) {\n    if (node.type === \"Literal\") {\n      return this.cloneEstreeStringLiteral(node);\n    }\n    return super.cloneStringLiteral(node);\n  }\n  finishNodeAt(node, type, endLoc) {\n    return toESTreeLocation(super.finishNodeAt(node, type, endLoc));\n  }\n  finishNode(node, type) {\n    const result = super.finishNode(node, type);\n    this.fillOptionalPropertiesForTSESLint(result);\n    return result;\n  }\n  resetStartLocation(node, startLoc) {\n    super.resetStartLocation(node, startLoc);\n    toESTreeLocation(node);\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    super.resetEndLocation(node, endLoc);\n    toESTreeLocation(node);\n  }\n};\nclass TokContext {\n  constructor(token, preserveSpace) {\n    this.token = void 0;\n    this.preserveSpace = void 0;\n    this.token = token;\n    this.preserveSpace = !!preserveSpace;\n  }\n}\nconst types = {\n  brace: new TokContext(\"{\"),\n  j_oTag: new TokContext(\"<tag\"),\n  j_cTag: new TokContext(\"</tag\"),\n  j_expr: new TokContext(\"<tag>...</tag>\", true)\n};\ntypes.template = new TokContext(\"`\", true);\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass ExportedTokenType {\n  constructor(label, conf = {}) {\n    this.label = void 0;\n    this.keyword = void 0;\n    this.beforeExpr = void 0;\n    this.startsExpr = void 0;\n    this.rightAssociative = void 0;\n    this.isLoop = void 0;\n    this.isAssign = void 0;\n    this.prefix = void 0;\n    this.postfix = void 0;\n    this.binop = void 0;\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    this.updateContext = null;\n  }\n}\nconst keywords$1 = new Map();\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = createToken(name, options);\n  keywords$1.set(name, token);\n  return token;\n}\nfunction createBinop(name, binop) {\n  return createToken(name, {\n    beforeExpr,\n    binop\n  });\n}\nlet tokenTypeCounter = -1;\nconst tokenTypes = [];\nconst tokenLabels = [];\nconst tokenBinops = [];\nconst tokenBeforeExprs = [];\nconst tokenStartsExprs = [];\nconst tokenPrefixes = [];\nfunction createToken(name, options = {}) {\n  var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;\n  ++tokenTypeCounter;\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);\n  tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);\n  tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);\n  tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);\n  tokenTypes.push(new ExportedTokenType(name, options));\n  return tokenTypeCounter;\n}\nfunction createKeywordLike(name, options = {}) {\n  var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;\n  ++tokenTypeCounter;\n  keywords$1.set(name, tokenTypeCounter);\n  tokenLabels.push(name);\n  tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);\n  tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);\n  tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);\n  tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);\n  tokenTypes.push(new ExportedTokenType(\"name\", options));\n  return tokenTypeCounter;\n}\nconst tt = {\n  bracketL: createToken(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: createToken(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: createToken(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: createToken(\"]\"),\n  bracketBarR: createToken(\"|]\"),\n  braceL: createToken(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: createToken(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: createToken(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: createToken(\"}\"),\n  braceBarR: createToken(\"|}\"),\n  parenL: createToken(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: createToken(\")\"),\n  comma: createToken(\",\", {\n    beforeExpr\n  }),\n  semi: createToken(\";\", {\n    beforeExpr\n  }),\n  colon: createToken(\":\", {\n    beforeExpr\n  }),\n  doubleColon: createToken(\"::\", {\n    beforeExpr\n  }),\n  dot: createToken(\".\"),\n  question: createToken(\"?\", {\n    beforeExpr\n  }),\n  questionDot: createToken(\"?.\"),\n  arrow: createToken(\"=>\", {\n    beforeExpr\n  }),\n  template: createToken(\"template\"),\n  ellipsis: createToken(\"...\", {\n    beforeExpr\n  }),\n  backQuote: createToken(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: createToken(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  templateTail: createToken(\"...`\", {\n    startsExpr\n  }),\n  templateNonTail: createToken(\"...${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: createToken(\"@\"),\n  hash: createToken(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: createToken(\"#!...\"),\n  eq: createToken(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  slashAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  xorAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  moduloAssign: createToken(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: createToken(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: createToken(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: createToken(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  doubleCaret: createToken(\"^^\", {\n    startsExpr\n  }),\n  doubleAt: createToken(\"@@\", {\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  lt: createBinop(\"</>/<=/>=\", 7),\n  gt: createBinop(\"</>/<=/>=\", 7),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  bitShiftL: createBinop(\"<</>>/>>>\", 8),\n  bitShiftR: createBinop(\"<</>>/>>>\", 8),\n  plusMin: createToken(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: createToken(\"%\", {\n    binop: 10,\n    startsExpr\n  }),\n  star: createToken(\"*\", {\n    binop: 10\n  }),\n  slash: createBinop(\"/\", 10),\n  exponent: createToken(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _as: createKeywordLike(\"as\", {\n    startsExpr\n  }),\n  _assert: createKeywordLike(\"assert\", {\n    startsExpr\n  }),\n  _async: createKeywordLike(\"async\", {\n    startsExpr\n  }),\n  _await: createKeywordLike(\"await\", {\n    startsExpr\n  }),\n  _defer: createKeywordLike(\"defer\", {\n    startsExpr\n  }),\n  _from: createKeywordLike(\"from\", {\n    startsExpr\n  }),\n  _get: createKeywordLike(\"get\", {\n    startsExpr\n  }),\n  _let: createKeywordLike(\"let\", {\n    startsExpr\n  }),\n  _meta: createKeywordLike(\"meta\", {\n    startsExpr\n  }),\n  _of: createKeywordLike(\"of\", {\n    startsExpr\n  }),\n  _sent: createKeywordLike(\"sent\", {\n    startsExpr\n  }),\n  _set: createKeywordLike(\"set\", {\n    startsExpr\n  }),\n  _source: createKeywordLike(\"source\", {\n    startsExpr\n  }),\n  _static: createKeywordLike(\"static\", {\n    startsExpr\n  }),\n  _using: createKeywordLike(\"using\", {\n    startsExpr\n  }),\n  _yield: createKeywordLike(\"yield\", {\n    startsExpr\n  }),\n  _asserts: createKeywordLike(\"asserts\", {\n    startsExpr\n  }),\n  _checks: createKeywordLike(\"checks\", {\n    startsExpr\n  }),\n  _exports: createKeywordLike(\"exports\", {\n    startsExpr\n  }),\n  _global: createKeywordLike(\"global\", {\n    startsExpr\n  }),\n  _implements: createKeywordLike(\"implements\", {\n    startsExpr\n  }),\n  _intrinsic: createKeywordLike(\"intrinsic\", {\n    startsExpr\n  }),\n  _infer: createKeywordLike(\"infer\", {\n    startsExpr\n  }),\n  _is: createKeywordLike(\"is\", {\n    startsExpr\n  }),\n  _mixins: createKeywordLike(\"mixins\", {\n    startsExpr\n  }),\n  _proto: createKeywordLike(\"proto\", {\n    startsExpr\n  }),\n  _require: createKeywordLike(\"require\", {\n    startsExpr\n  }),\n  _satisfies: createKeywordLike(\"satisfies\", {\n    startsExpr\n  }),\n  _keyof: createKeywordLike(\"keyof\", {\n    startsExpr\n  }),\n  _readonly: createKeywordLike(\"readonly\", {\n    startsExpr\n  }),\n  _unique: createKeywordLike(\"unique\", {\n    startsExpr\n  }),\n  _abstract: createKeywordLike(\"abstract\", {\n    startsExpr\n  }),\n  _declare: createKeywordLike(\"declare\", {\n    startsExpr\n  }),\n  _enum: createKeywordLike(\"enum\", {\n    startsExpr\n  }),\n  _module: createKeywordLike(\"module\", {\n    startsExpr\n  }),\n  _namespace: createKeywordLike(\"namespace\", {\n    startsExpr\n  }),\n  _interface: createKeywordLike(\"interface\", {\n    startsExpr\n  }),\n  _type: createKeywordLike(\"type\", {\n    startsExpr\n  }),\n  _opaque: createKeywordLike(\"opaque\", {\n    startsExpr\n  }),\n  name: createToken(\"name\", {\n    startsExpr\n  }),\n  placeholder: createToken(\"%%\", {\n    startsExpr\n  }),\n  string: createToken(\"string\", {\n    startsExpr\n  }),\n  num: createToken(\"num\", {\n    startsExpr\n  }),\n  bigint: createToken(\"bigint\", {\n    startsExpr\n  }),\n  decimal: createToken(\"decimal\", {\n    startsExpr\n  }),\n  regexp: createToken(\"regexp\", {\n    startsExpr\n  }),\n  privateName: createToken(\"#name\", {\n    startsExpr\n  }),\n  eof: createToken(\"eof\"),\n  jsxName: createToken(\"jsxName\"),\n  jsxText: createToken(\"jsxText\", {\n    beforeExpr\n  }),\n  jsxTagStart: createToken(\"jsxTagStart\", {\n    startsExpr\n  }),\n  jsxTagEnd: createToken(\"jsxTagEnd\")\n};\nfunction tokenIsIdentifier(token) {\n  return token >= 93 && token <= 133;\n}\nfunction tokenKeywordOrIdentifierIsKeyword(token) {\n  return token <= 92;\n}\nfunction tokenIsKeywordOrIdentifier(token) {\n  return token >= 58 && token <= 133;\n}\nfunction tokenIsLiteralPropertyName(token) {\n  return token >= 58 && token <= 137;\n}\nfunction tokenComesBeforeExpression(token) {\n  return tokenBeforeExprs[token];\n}\nfunction tokenCanStartExpression(token) {\n  return tokenStartsExprs[token];\n}\nfunction tokenIsAssignment(token) {\n  return token >= 29 && token <= 33;\n}\nfunction tokenIsFlowInterfaceOrTypeOrOpaque(token) {\n  return token >= 129 && token <= 131;\n}\nfunction tokenIsLoop(token) {\n  return token >= 90 && token <= 92;\n}\nfunction tokenIsKeyword(token) {\n  return token >= 58 && token <= 92;\n}\nfunction tokenIsOperator(token) {\n  return token >= 39 && token <= 59;\n}\nfunction tokenIsPostfix(token) {\n  return token === 34;\n}\nfunction tokenIsPrefix(token) {\n  return tokenPrefixes[token];\n}\nfunction tokenIsTSTypeOperator(token) {\n  return token >= 121 && token <= 123;\n}\nfunction tokenIsTSDeclarationStart(token) {\n  return token >= 124 && token <= 130;\n}\nfunction tokenLabelName(token) {\n  return tokenLabels[token];\n}\nfunction tokenOperatorPrecedence(token) {\n  return tokenBinops[token];\n}\nfunction tokenIsRightAssociative(token) {\n  return token === 57;\n}\nfunction tokenIsTemplate(token) {\n  return token >= 24 && token <= 25;\n}\nfunction getExportedToken(token) {\n  return tokenTypes[token];\n}\ntokenTypes[8].updateContext = context => {\n  context.pop();\n};\ntokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = context => {\n  context.push(types.brace);\n};\ntokenTypes[22].updateContext = context => {\n  if (context[context.length - 1] === types.template) {\n    context.pop();\n  } else {\n    context.push(types.template);\n  }\n};\ntokenTypes[143].updateContext = context => {\n  context.push(types.j_expr, types.j_oTag);\n};\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u0870-\\u0887\\u0889-\\u088f\\u08a0-\\u08c9\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c5c\\u0c5d\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cdc-\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u1711\\u171f-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4c\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c8a\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7dc\\ua7f1-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u0897-\\u089f\\u08ca-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3c\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0cf3\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ece\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1715\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u180f-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf-\\u1add\\u1ae0-\\u1aeb\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1dff\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\u30fb\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\\uff65\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 7, 25, 39, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 5, 57, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 24, 43, 261, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 33, 24, 3, 24, 45, 74, 6, 0, 67, 12, 65, 1, 2, 0, 15, 4, 10, 7381, 42, 31, 98, 114, 8702, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 208, 30, 2, 2, 2, 1, 2, 6, 3, 4, 10, 1, 225, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4381, 3, 5773, 3, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 8489];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 78, 5, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 199, 7, 137, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 55, 9, 266, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 233, 0, 3, 0, 8, 1, 6, 0, 475, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n  return false;\n}\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords.has(word);\n}\nfunction isIteratorStart(current, next, next2) {\n  return current === 64 && next === 64 && isIdentifierStart(next2);\n}\nconst reservedWordLikeSet = new Set([\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"eval\", \"arguments\", \"enum\", \"await\"]);\nfunction canBeReservedWord(word) {\n  return reservedWordLikeSet.has(word);\n}\nclass Scope {\n  constructor(flags) {\n    this.flags = 0;\n    this.names = new Map();\n    this.firstLexicalName = \"\";\n    this.flags = flags;\n  }\n}\nclass ScopeHandler {\n  constructor(parser, inModule) {\n    this.parser = void 0;\n    this.scopeStack = [];\n    this.inModule = void 0;\n    this.undefinedExports = new Map();\n    this.parser = parser;\n    this.inModule = inModule;\n  }\n  get inTopLevel() {\n    return (this.currentScope().flags & 1) > 0;\n  }\n  get inFunction() {\n    return (this.currentVarScopeFlags() & 2) > 0;\n  }\n  get allowSuper() {\n    return (this.currentThisScopeFlags() & 16) > 0;\n  }\n  get allowDirectSuper() {\n    return (this.currentThisScopeFlags() & 32) > 0;\n  }\n  get allowNewTarget() {\n    return (this.currentThisScopeFlags() & 512) > 0;\n  }\n  get inClass() {\n    return (this.currentThisScopeFlags() & 64) > 0;\n  }\n  get inClassAndNotInNonArrowFunction() {\n    const flags = this.currentThisScopeFlags();\n    return (flags & 64) > 0 && (flags & 2) === 0;\n  }\n  get inStaticBlock() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 128) {\n        return true;\n      }\n      if (flags & (1667 | 64)) {\n        return false;\n      }\n    }\n  }\n  get inNonArrowFunction() {\n    return (this.currentThisScopeFlags() & 2) > 0;\n  }\n  get inBareCaseStatement() {\n    return (this.currentScope().flags & 256) > 0;\n  }\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n  createScope(flags) {\n    return new Scope(flags);\n  }\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n  exit() {\n    const scope = this.scopeStack.pop();\n    return scope.flags;\n  }\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);\n  }\n  declareName(name, bindingType, loc) {\n    let scope = this.currentScope();\n    if (bindingType & 8 || bindingType & 16) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      let type = scope.names.get(name) || 0;\n      if (bindingType & 16) {\n        type = type | 4;\n      } else {\n        if (!scope.firstLexicalName) {\n          scope.firstLexicalName = name;\n        }\n        type = type | 2;\n      }\n      scope.names.set(name, type);\n      if (bindingType & 8) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & 4) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        scope.names.set(name, (scope.names.get(name) || 0) | 1);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & 1667) break;\n      }\n    }\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  maybeExportDefined(scope, name) {\n    if (this.parser.inModule && scope.flags & 1) {\n      this.undefinedExports.delete(name);\n    }\n  }\n  checkRedeclarationInScope(scope, name, bindingType, loc) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.parser.raise(Errors.VarRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & 1)) return false;\n    if (bindingType & 8) {\n      return scope.names.has(name);\n    }\n    const type = scope.names.get(name) || 0;\n    if (bindingType & 16) {\n      return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;\n    }\n    return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    const topLevelScope = this.scopeStack[0];\n    if (!topLevelScope.names.has(name)) {\n      this.undefinedExports.set(name, id.loc.start);\n    }\n  }\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n  currentVarScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & 1667) {\n        return flags;\n      }\n    }\n  }\n  currentThisScopeFlags() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const {\n        flags\n      } = this.scopeStack[i];\n      if (flags & (1667 | 64) && !(flags & 4)) {\n        return flags;\n      }\n    }\n  }\n}\nclass FlowScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.declareFunctions = new Set();\n  }\n}\nclass FlowScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new FlowScope(flags);\n  }\n  declareName(name, bindingType, loc) {\n    const scope = this.currentScope();\n    if (bindingType & 2048) {\n      this.checkRedeclarationInScope(scope, name, bindingType, loc);\n      this.maybeExportDefined(scope, name);\n      scope.declareFunctions.add(name);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (super.isRedeclaredInScope(scope, name, bindingType)) return true;\n    if (bindingType & 2048 && !scope.declareFunctions.has(name)) {\n      const type = scope.names.get(name);\n      return (type & 4) > 0 || (type & 2) > 0;\n    }\n    return false;\n  }\n  checkLocalExport(id) {\n    if (!this.scopeStack[0].declareFunctions.has(id.name)) {\n      super.checkLocalExport(id);\n    }\n  }\n}\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = ParseErrorEnum`flow`({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.\",\n  AssignReservedType: ({\n    reservedType\n  }) => `Cannot overwrite reserved type ${reservedType}.`,\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement.\",\n  EnumBooleanMemberNotInitialized: ({\n    memberName,\n    enumName\n  }) => `Boolean enum members need to be initialized. Use either \\`${memberName} = true,\\` or \\`${memberName} = false,\\` in enum \\`${enumName}\\`.`,\n  EnumDuplicateMemberName: ({\n    memberName,\n    enumName\n  }) => `Enum member names need to be unique, but the name \\`${memberName}\\` has already been used before in enum \\`${enumName}\\`.`,\n  EnumInconsistentMemberValues: ({\n    enumName\n  }) => `Enum \\`${enumName}\\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,\n  EnumInvalidExplicitType: ({\n    invalidEnumType,\n    enumName\n  }) => `Enum type \\`${invalidEnumType}\\` is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidExplicitTypeUnknownSupplied: ({\n    enumName\n  }) => `Supplied enum type is not valid. Use one of \\`boolean\\`, \\`number\\`, \\`string\\`, or \\`symbol\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerPrimaryType: ({\n    enumName,\n    memberName,\n    explicitType\n  }) => `Enum \\`${enumName}\\` has type \\`${explicitType}\\`, so the initializer of \\`${memberName}\\` needs to be a ${explicitType} literal.`,\n  EnumInvalidMemberInitializerSymbolType: ({\n    enumName,\n    memberName\n  }) => `Symbol enum members cannot be initialized. Use \\`${memberName},\\` in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberInitializerUnknownType: ({\n    enumName,\n    memberName\n  }) => `The enum member initializer for \\`${memberName}\\` needs to be a literal (either a boolean, number, or string) in enum \\`${enumName}\\`.`,\n  EnumInvalidMemberName: ({\n    enumName,\n    memberName,\n    suggestion\n  }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \\`${memberName}\\`, consider using \\`${suggestion}\\`, in enum \\`${enumName}\\`.`,\n  EnumNumberMemberNotInitialized: ({\n    enumName,\n    memberName\n  }) => `Number enum members need to be initialized, e.g. \\`${memberName} = 1\\` in enum \\`${enumName}\\`.`,\n  EnumStringMemberInconsistentlyInitialized: ({\n    enumName\n  }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \\`${enumName}\\`.`,\n  GetterMayNotHaveThisParam: \"A getter cannot have a `this` parameter.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` or `typeof` keyword.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type.\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions.\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance.\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`.\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`.\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment.\",\n  PatternIsOptional: Object.assign({\n    message: \"A binding pattern parameter cannot be optional in an implementation signature.\"\n  }, {\n    reasonCode: \"OptionalBindingPattern\"\n  }),\n  SetterMayNotHaveThisParam: \"A setter cannot have a `this` parameter.\",\n  SpreadVariance: \"Spread properties cannot have variance.\",\n  ThisParamAnnotationRequired: \"A type annotation is required for the `this` parameter.\",\n  ThisParamBannedInConstructor: \"Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.\",\n  ThisParamMayNotBeOptional: \"The `this` parameter cannot be optional.\",\n  ThisParamMustBeFirst: \"The `this` parameter must be the first function parameter.\",\n  ThisParamNoDefault: \"The `this` parameter may not have a default value.\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis.\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object.\",\n  UnexpectedReservedType: ({\n    reservedType\n  }) => `Unexpected reserved type ${reservedType}.`,\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new.\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions.\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\".',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration.\",\n  UnexpectedTypeParameterBeforeAsyncArrowFunction: \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.\",\n  UnsupportedDeclareExportKind: ({\n    unsupportedExportKind,\n    suggestion\n  }) => `\\`declare export ${unsupportedExportKind}\\` is not supported. Use \\`${suggestion}\\` instead.`,\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module.\",\n  UnterminatedFlowComment: \"Unterminated flow-comment.\"\n});\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n  return [list1, list2];\n}\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = superClass => class FlowParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.flowPragma = undefined;\n  }\n  getScopeHandler() {\n    return FlowScopeHandler;\n  }\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n  finishToken(type, val) {\n    if (type !== 134 && type !== 13 && type !== 28) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n    super.finishToken(type, val);\n  }\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n      if (!matches) ;else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n    super.addComment(comment);\n  }\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || 14);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    this.next();\n    this.expectContextual(110);\n    if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {\n      this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);\n    }\n    if (this.eat(10)) {\n      node.value = super.parseExpression();\n      this.expect(11);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(14);\n    let type = null;\n    let predicate = null;\n    if (this.match(54)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n      if (this.match(54)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n    return [type, predicate];\n  }\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n    if (this.match(47)) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n    this.expect(10);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    typeNode.this = tmp._this;\n    this.expect(11);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    this.scope.declareName(node.id.name, 2048, node.id.loc.start);\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n  flowParseDeclare(node, insideModule) {\n    if (this.match(80)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(68)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(74)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(127)) {\n      if (this.match(16)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);\n        }\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(130)) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(131)) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(129)) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(82)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    }\n    throw this.unexpected();\n  }\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, 5, node.id.loc.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n  flowParseDeclareModule(node) {\n    this.scope.enter(0);\n    if (this.match(134)) {\n      node.id = super.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      const bodyNode = this.startNode();\n      if (this.match(83)) {\n        this.next();\n        if (!this.isContextual(130) && !this.match(87)) {\n          this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);\n        }\n        body.push(super.parseImport(bodyNode));\n      } else {\n        this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);\n        body.push(this.flowParseDeclare(bodyNode, true));\n      }\n    }\n    this.scope.exit();\n    this.expect(8);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);\n        }\n        if (kind === \"ES\") {\n          this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);\n        }\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(82);\n    if (this.eat(65)) {\n      if (this.match(68) || this.match(80)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {\n        const label = this.state.value;\n        throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {\n          unsupportedExportKind: label,\n          suggestion: exportSuggestions[label]\n        });\n      }\n      if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n        node.default = false;\n        return this.finishNode(node, \"DeclareExportDeclaration\");\n      } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {\n        node = this.parseExport(node, null);\n        if (node.type === \"ExportNamedDeclaration\") {\n          node.default = false;\n          delete node.exportKind;\n          return this.castNodeTo(node, \"DeclareExportDeclaration\");\n        } else {\n          return this.castNodeTo(node, \"DeclareExportAllDeclaration\");\n        }\n      }\n    }\n    throw this.unexpected();\n  }\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(111);\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    const finished = this.flowParseTypeAlias(node);\n    this.castNodeTo(finished, \"DeclareTypeAlias\");\n    return finished;\n  }\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    const finished = this.flowParseOpaqueType(node, true);\n    this.castNodeTo(finished, \"DeclareOpaqueType\");\n    return finished;\n  }\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n  flowParseInterfaceish(node, isClass) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(12));\n    }\n    if (isClass) {\n      node.implements = [];\n      node.mixins = [];\n      if (this.eatContextual(117)) {\n        do {\n          node.mixins.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n      if (this.eatContextual(113)) {\n        do {\n          node.implements.push(this.flowParseInterfaceExtends());\n        } while (this.eat(12));\n      }\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node, false);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);\n    }\n  }\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {\n      reservedType: word\n    });\n  }\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.startLoc, declaration);\n    return this.parseIdentifier(liberal);\n  }\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.right = this.flowParseTypeInitialiser(29);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(130);\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, 8201, node.id.loc.start);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n    node.supertype = null;\n    if (this.match(14)) {\n      node.supertype = this.flowParseTypeInitialiser(14);\n    }\n    node.impltype = null;\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(29);\n    }\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStartLoc = this.state.startLoc;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n    if (this.match(29)) {\n      this.eat(29);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);\n      }\n    }\n    return this.finishNode(node, \"TypeParameter\");\n  }\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n    if (this.match(47) || this.match(143)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    let defaultRequired = false;\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    } while (!this.match(48));\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n  flowInTopLevelContext(cb) {\n    if (this.curContext() !== types.brace) {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    } else {\n      return cb();\n    }\n  }\n  flowParseTypeParameterInstantiationInExpression() {\n    if (this.reScan_lt() !== 47) return;\n    return this.flowParseTypeParameterInstantiation();\n  }\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    node.params = [];\n    this.flowInTopLevelContext(() => {\n      this.expect(47);\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = false;\n      while (!this.match(48)) {\n        node.params.push(this.flowParseType());\n        if (!this.match(48)) {\n          this.expect(12);\n        }\n      }\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    });\n    this.state.inType = oldInType;\n    if (!this.state.inType && this.curContext() === types.brace) {\n      this.reScan_lt_gt();\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseTypeParameterInstantiationCallOrNew() {\n    if (this.reScan_lt() !== 47) return null;\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expect(47);\n    while (!this.match(48)) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n      if (!this.match(48)) {\n        this.expect(12);\n      }\n    }\n    this.expect(48);\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(129);\n    node.extends = [];\n    if (this.eat(81)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(12));\n    }\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n  flowParseObjectPropertyKey() {\n    return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);\n  }\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n    if (this.lookahead().type === 14) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n    this.expect(3);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(3);\n    this.expect(3);\n    if (this.match(47) || this.match(10)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n    } else {\n      node.method = false;\n      if (this.eat(17)) {\n        node.optional = true;\n      }\n      node.value = this.flowParseTypeInitialiser();\n    }\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n    node.this = null;\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    this.expect(10);\n    if (this.match(78)) {\n      node.this = this.flowParseFunctionTypeParam(true);\n      node.this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      node.params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      node.rest = this.flowParseFunctionTypeParam(false);\n    }\n    this.expect(11);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n    if (allowExact && this.match(6)) {\n      this.expect(6);\n      endDelim = 9;\n      exact = true;\n    } else {\n      this.expect(5);\n      endDelim = 8;\n      exact = false;\n    }\n    nodeStart.exact = exact;\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStartLoc = null;\n      let inexactStartLoc = null;\n      const node = this.startNode();\n      if (allowProto && this.isContextual(118)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          protoStartLoc = this.state.startLoc;\n          allowStatic = false;\n        }\n      }\n      if (allowStatic && this.isContextual(106)) {\n        const lookahead = this.lookahead();\n        if (lookahead.type !== 14 && lookahead.type !== 17) {\n          this.next();\n          isStatic = true;\n        }\n      }\n      const variance = this.flowParseVariance();\n      if (this.eat(0)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (this.eat(0)) {\n          if (variance) {\n            this.unexpected(variance.loc.start);\n          }\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(10) || this.match(47)) {\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n        if (this.isContextual(99) || this.isContextual(104)) {\n          const lookahead = this.lookahead();\n          if (tokenIsLiteralPropertyName(lookahead.type)) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStartLoc = this.state.lastTokStartLoc;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n      this.flowObjectTypeSemicolon();\n      if (inexactStartLoc && !this.match(8) && !this.match(9)) {\n        this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);\n      }\n    }\n    this.expect(endDelim);\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n  flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(21)) {\n      const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);\n        } else if (!allowInexact) {\n          this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);\n        }\n        if (variance) {\n          this.raise(FlowErrors.InexactVariance, variance);\n        }\n        return null;\n      }\n      if (!allowSpread) {\n        this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);\n      }\n      if (protoStartLoc != null) {\n        this.unexpected(protoStartLoc);\n      }\n      if (variance) {\n        this.raise(FlowErrors.SpreadVariance, variance);\n      }\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStartLoc != null;\n      node.kind = kind;\n      let optional = false;\n      if (this.match(47) || this.match(10)) {\n        node.method = true;\n        if (protoStartLoc != null) {\n          this.unexpected(protoStartLoc);\n        }\n        if (variance) {\n          this.unexpected(variance.loc.start);\n        }\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n        if (!allowSpread && node.key.name === \"constructor\" && node.value.this) {\n          this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n        if (this.eat(17)) {\n          optional = true;\n        }\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n    if (property.value.this) {\n      this.raise(property.kind === \"get\" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);\n    }\n    if (length !== paramCount) {\n      this.raise(property.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, property);\n    }\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(Errors.BadSetterRestParameter, property);\n    }\n  }\n  flowObjectTypeSemicolon() {\n    if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {\n      this.unexpected();\n    }\n  }\n  flowParseQualifiedTypeIdentifier(startLoc, id) {\n    startLoc != null ? startLoc : startLoc = this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n    while (this.eat(16)) {\n      const node2 = this.startNodeAt(startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n    return node;\n  }\n  flowParseGenericType(startLoc, id) {\n    const node = this.startNodeAt(startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(87);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(0);\n    while (this.state.pos < this.length && !this.match(3)) {\n      node.types.push(this.flowParseType());\n      if (this.match(3)) break;\n      this.expect(12);\n    }\n    this.expect(3);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n  flowParseFunctionTypeParam(first) {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n    const isThis = this.state.type === 78;\n    if (lh.type === 14 || lh.type === 17) {\n      if (isThis && !first) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node);\n      }\n      name = this.parseIdentifier(isThis);\n      if (this.eat(17)) {\n        optional = true;\n        if (isThis) {\n          this.raise(FlowErrors.ThisParamMayNotBeOptional, node);\n        }\n      }\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n    let _this = null;\n    if (this.match(78)) {\n      _this = this.flowParseFunctionTypeParam(true);\n      _this.name = null;\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    while (!this.match(11) && !this.match(21)) {\n      params.push(this.flowParseFunctionTypeParam(false));\n      if (!this.match(11)) {\n        this.expect(12);\n      }\n    }\n    if (this.eat(21)) {\n      rest = this.flowParseFunctionTypeParam(false);\n    }\n    return {\n      params,\n      rest,\n      _this\n    };\n  }\n  flowIdentToTypeAnnotation(startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startLoc, id);\n    }\n  }\n  flowParsePrimaryType() {\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    switch (this.state.type) {\n      case 5:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n      case 6:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n      case 0:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n      case 47:\n        {\n          const node = this.startNode();\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(10);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(11);\n          this.expect(19);\n          node.returnType = this.flowParseType();\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n      case 10:\n        {\n          const node = this.startNode();\n          this.next();\n          if (!this.match(11) && !this.match(21)) {\n            if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n              const token = this.lookahead().type;\n              isGroupedType = token !== 17 && token !== 14;\n            } else {\n              isGroupedType = true;\n            }\n          }\n          if (isGroupedType) {\n            this.state.noAnonFunctionType = false;\n            type = this.flowParseType();\n            this.state.noAnonFunctionType = oldNoAnonFunctionType;\n            if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {\n              this.expect(11);\n              return type;\n            } else {\n              this.eat(12);\n            }\n          }\n          if (type) {\n            tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n          } else {\n            tmp = this.flowParseFunctionTypeParams();\n          }\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          node.this = tmp._this;\n          this.expect(11);\n          this.expect(19);\n          node.returnType = this.flowParseType();\n          node.typeParameters = null;\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n      case 134:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n      case 85:\n      case 86:\n        node.value = this.match(85);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n      case 53:\n        if (this.state.value === \"-\") {\n          this.next();\n          if (this.match(135)) {\n            return this.parseLiteralAtNode(-this.state.value, \"NumberLiteralTypeAnnotation\", node);\n          }\n          if (this.match(136)) {\n            return this.parseLiteralAtNode(-this.state.value, \"BigIntLiteralTypeAnnotation\", node);\n          }\n          throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);\n        }\n        throw this.unexpected();\n      case 135:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n      case 136:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n      case 88:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n      case 84:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n      case 78:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n      case 55:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n      case 87:\n        return this.flowParseTypeofType();\n      default:\n        if (tokenIsKeyword(this.state.type)) {\n          const label = tokenLabelName(this.state.type);\n          this.next();\n          return super.createIdentifier(node, label);\n        } else if (tokenIsIdentifier(this.state.type)) {\n          if (this.isContextual(129)) {\n            return this.flowParseInterfaceType();\n          }\n          return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());\n        }\n    }\n    throw this.unexpected();\n  }\n  flowParsePostfixType() {\n    const startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n    let seenOptionalIndexedAccess = false;\n    while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      const optional = this.eat(18);\n      seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;\n      this.expect(0);\n      if (!optional && this.match(3)) {\n        node.elementType = type;\n        this.next();\n        type = this.finishNode(node, \"ArrayTypeAnnotation\");\n      } else {\n        node.objectType = type;\n        node.indexType = this.flowParseType();\n        this.expect(3);\n        if (seenOptionalIndexedAccess) {\n          node.optional = optional;\n          type = this.finishNode(node, \"OptionalIndexedAccessType\");\n        } else {\n          type = this.finishNode(node, \"IndexedAccessType\");\n        }\n      }\n    }\n    return type;\n  }\n  flowParsePrefixType() {\n    const node = this.startNode();\n    if (this.eat(17)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n    if (!this.state.noAnonFunctionType && this.eat(19)) {\n      const node = this.startNodeAt(param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.this = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n    return param;\n  }\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(45);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n    while (this.eat(45)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(43);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n    while (this.eat(43)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    return type;\n  }\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === 132 && this.state.value === \"_\") {\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n    if (this.match(14)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n    return ident;\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  flowParseVariance() {\n    let variance = null;\n    if (this.match(53)) {\n      variance = this.startNode();\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n      this.next();\n      return this.finishNode(variance, \"Variance\");\n    }\n    return variance;\n  }\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n      return;\n    }\n    super.parseFunctionBody(node, false, isMethod);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  parseStatementLike(flags) {\n    if (this.state.strict && this.isContextual(129)) {\n      const lookahead = this.lookahead();\n      if (tokenIsKeywordOrIdentifier(lookahead.type)) {\n        const node = this.startNode();\n        this.next();\n        return this.flowParseInterface(node);\n      }\n    } else if (this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    const stmt = super.parseStatementLike(flags);\n    if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n      this.flowPragma = null;\n    }\n    return stmt;\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (tokenIsIdentifier(this.state.type)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n    return super.parseExpressionStatement(node, expr, decorators);\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {\n      return !this.state.containsEsc;\n    }\n    return super.shouldParseExportDeclaration();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {\n      return this.state.containsEsc;\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  parseExportDefaultExpression() {\n    if (this.isContextual(126)) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    this.expect(17);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n      if (failed && valid.length > 1) {\n        this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);\n      }\n      if (failed && valid.length === 1) {\n        this.state = state;\n        noArrowAt.push(valid[0].start);\n        this.state.noArrowAt = noArrowAt;\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(14);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssignAllowIn();\n    const failed = !this.match(14);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n    while (stack.length !== 0) {\n      const node = stack.pop();\n      if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n  finishArrowValidation(node) {\n    var _node$extra;\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);\n    this.scope.enter(514 | 4);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n    return result;\n  }\n  parseParenItem(node, startLoc) {\n    const newNode = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      newNode.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = newNode;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n    return newNode;\n  }\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n    super.assertModuleNodeAllowed(node);\n  }\n  parseExportDeclaration(node) {\n    if (this.isContextual(130)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      if (this.match(5)) {\n        node.specifiers = this.parseExportSpecifiers(true);\n        super.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(131)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(129)) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.isContextual(126)) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n  eatExportStar(node) {\n    if (super.eatExportStar(node)) return true;\n    if (this.isContextual(130) && this.lookahead().type === 55) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    const {\n      startLoc\n    } = this.state;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(startLoc);\n    }\n    return hasNamespace;\n  }\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n    if (this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n  parseClassMember(classBody, member, state) {\n    const {\n      startLoc\n    } = this.state;\n    if (this.isContextual(125)) {\n      if (super.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      member.declare = true;\n    }\n    super.parseClassMember(classBody, member, state);\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\" && member.type !== \"PropertyDefinition\") {\n        this.raise(FlowErrors.DeclareClassElement, startLoc);\n      } else if (member.value) {\n        this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);\n      }\n    }\n  }\n  isIterator(word) {\n    return word === \"iterator\" || word === \"asyncIterator\";\n  }\n  readIterator() {\n    const word = super.readWord1();\n    const fullWord = \"@@\" + word;\n    if (!this.isIterator(word) || !this.state.inType) {\n      this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {\n        identifierName: fullWord\n      });\n    }\n    this.finishToken(132, fullWord);\n  }\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 123 && next === 124) {\n      this.finishOp(6, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      this.finishOp(code === 62 ? 48 : 47, 1);\n    } else if (this.state.inType && code === 63) {\n      if (next === 46) {\n        this.finishOp(18, 2);\n      } else {\n        this.finishOp(17, 1);\n      }\n    } else if (isIteratorStart(code, next, this.input.charCodeAt(this.state.pos + 2))) {\n      this.state.pos += 2;\n      this.readIterator();\n    } else {\n      super.getTokenFromCode(code);\n    }\n  }\n  isAssignable(node, isBinding) {\n    if (node.type === \"TypeCastExpression\") {\n      return this.isAssignable(node.expression, isBinding);\n    } else {\n      return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    if (!isLHS && node.type === \"AssignmentExpression\" && node.left.type === \"TypeCastExpression\") {\n      node.left = this.typeCastToParameter(node.left);\n    }\n    super.toAssignable(node, isLHS);\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if ((expr == null ? void 0 : expr.type) === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n    super.toAssignableList(exprList, trailingCommaLoc, isLHS);\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      var _expr$extra;\n      const expr = exprList[i];\n      if (expr && expr.type === \"TypeCastExpression\" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);\n      }\n    }\n    return exprList;\n  }\n  parseArrayLike(close, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, isTuple, refExpressionErrors);\n    if (refExpressionErrors != null && !this.state.maybeInArrowParameters) {\n      this.toReferencedList(node.elements);\n    }\n    return node;\n  }\n  isValidLVal(type, disallowCallExpression, isParenthesized, binding) {\n    return type === \"TypeCastExpression\" || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding);\n  }\n  parseClassProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (this.match(14)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n    return super.parseClassPrivateProperty(node);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(14) || super.isClassProperty();\n  }\n  isNonstaticConstructor(method) {\n    return !this.match(14) && super.isNonstaticConstructor(method);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n    if (method.params && isConstructor) {\n      const params = method.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    } else if (method.type === \"MethodDefinition\" && isConstructor && method.value.params) {\n      const params = method.value.params;\n      if (params.length > 0 && this.isThisParam(params[0])) {\n        this.raise(FlowErrors.ThisParamBannedInConstructor, method);\n      }\n    }\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.loc.start);\n    }\n    delete method.variance;\n    if (this.match(47)) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();\n    }\n    if (this.isContextual(113)) {\n      this.next();\n      const implemented = node.implements = [];\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n        if (this.match(47)) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(12));\n    }\n  }\n  checkGetterSetterParams(method) {\n    super.checkGetterSetterParams(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length > 0) {\n      const param = params[0];\n      if (this.isThisParam(param) && method.kind === \"get\") {\n        this.raise(FlowErrors.GetterMayNotHaveThisParam, param);\n      } else if (this.isThisParam(param)) {\n        this.raise(FlowErrors.SetterMayNotHaveThisParam, param);\n      }\n    }\n  }\n  parsePropertyNamePrefixOperator(node) {\n    node.variance = this.flowParseVariance();\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.loc.start);\n    }\n    delete prop.variance;\n    let typeParameters;\n    if (this.match(47) && !isAccessor) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(10)) this.unexpected();\n    }\n    const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n    if (typeParameters) {\n      (result.value || result).typeParameters = typeParameters;\n    }\n    return result;\n  }\n  parseFunctionParamType(param) {\n    if (this.eat(17)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(FlowErrors.PatternIsOptional, param);\n      }\n      if (this.isThisParam(param)) {\n        this.raise(FlowErrors.ThisParamMayNotBeOptional, param);\n      }\n      param.optional = true;\n    }\n    if (this.match(14)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    } else if (this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamAnnotationRequired, param);\n    }\n    if (this.match(29) && this.isThisParam(param)) {\n      this.raise(FlowErrors.ThisParamNoDefault, param);\n    }\n    this.resetEndLocation(param);\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);\n    }\n    return node;\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport)) return true;\n    if (this.isContextual(130)) {\n      if (!isExport) return true;\n      const ch = this.lookaheadCharCode();\n      return ch === 123 || ch === 42;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      if (!phase && this.match(65)) {\n        return;\n      }\n      node.exportKind = phase === \"type\" ? phase : \"value\";\n    } else {\n      if (phase === \"type\" && this.match(55)) this.unexpected();\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    const firstIdent = specifier.imported;\n    let specifierTypeKind = null;\n    if (firstIdent.type === \"Identifier\") {\n      if (firstIdent.name === \"type\") {\n        specifierTypeKind = \"type\";\n      } else if (firstIdent.name === \"typeof\") {\n        specifierTypeKind = \"typeof\";\n      }\n    }\n    let isBinding = false;\n    if (this.isContextual(93) && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n      if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = this.cloneIdentifier(as_ident);\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else {\n      if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {\n        specifier.imported = this.parseIdentifier(true);\n        specifier.importKind = specifierTypeKind;\n      } else {\n        if (importedIsString) {\n          throw this.raise(Errors.ImportBindingIsString, specifier, {\n            importName: firstIdent.value\n          });\n        }\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n      }\n      if (this.eatContextual(93)) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = this.cloneIdentifier(specifier.imported);\n      }\n    }\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n    if (isInTypeOnlyImport && specifierIsTypeImport) {\n      this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);\n    }\n    if (isInTypeOnlyImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);\n    }\n    if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 78:\n        return this.parseIdentifier(true);\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n  parseFunctionParams(node, isConstructor) {\n    const kind = node.kind;\n    if (kind !== \"get\" && kind !== \"set\" && this.match(47)) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (this.match(14)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx;\n    let state = null;\n    let jsx;\n    if (this.hasPlugin(\"jsx\") && (this.match(143) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if ((_jsx = jsx) != null && _jsx.error || this.match(47)) {\n      var _jsx2, _jsx3;\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(abort => {\n        var _arrowExpression$extr;\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => {\n          const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n          this.resetStartLocationFromNode(result, typeParameters);\n          return result;\n        });\n        if ((_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) abort();\n        const expr = this.maybeUnwrapTypeCastExpression(arrowExpression);\n        if (expr.type !== \"ArrowFunctionExpression\") abort();\n        expr.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(expr, typeParameters);\n        return arrowExpression;\n      }, state);\n      let arrowExpression = null;\n      if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === \"ArrowFunctionExpression\") {\n        if (!arrow.error && !arrow.aborted) {\n          if (arrow.node.async) {\n            this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);\n          }\n          return arrow.node;\n        }\n        arrowExpression = arrow.node;\n      }\n      if ((_jsx2 = jsx) != null && _jsx2.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n      if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);\n    }\n    return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(19)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n    return super.parseArrow(node);\n  }\n  shouldParseArrow(params) {\n    return this.match(14) || super.shouldParseArrow(params);\n  }\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node.start))) {\n      return;\n    }\n    for (let i = 0; i < node.params.length; i++) {\n      if (this.isThisParam(node.params[i]) && i > 0) {\n        this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);\n      }\n    }\n    super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.includes(startLoc.index)) {\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.arguments = super.parseCallExpressionArguments();\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.match(47)) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n      throw arrow.error || result.error;\n    }\n    return super.parseSubscripts(base, startLoc, noCalls);\n  }\n  parseSubscript(base, startLoc, noCalls, subscriptState) {\n    if (this.match(18) && this.isLookaheadToken_lt()) {\n      subscriptState.optionalChainMember = true;\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n      this.next();\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();\n      this.expect(10);\n      node.arguments = this.parseCallExpressionArguments();\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(10);\n        node.arguments = super.parseCallExpressionArguments();\n        if (subscriptState.optionalChainMember) {\n          node.optional = false;\n        }\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, subscriptState);\n  }\n  parseNewCallee(node) {\n    super.parseNewCallee(node);\n    let targs = null;\n    if (this.shouldParseTypes() && this.match(47)) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n    node.typeArguments = targs;\n  }\n  parseAsyncArrowWithTypeParameters(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.parseFunctionParams(node, false);\n    if (!this.parseArrow(node)) return;\n    return super.parseArrowExpression(node, undefined, true);\n  }\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n    super.readToken_mult_modulo(code);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 124 && next === 125) {\n      this.finishOp(9, 2);\n      return;\n    }\n    super.readToken_pipe_amp(code);\n  }\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n    if (this.state.hasFlowComment) {\n      this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());\n    }\n    return fileNode;\n  }\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);\n      }\n      this.hasFlowCommentCompletion();\n      const commentSkip = this.skipFlowComment();\n      if (commentSkip) {\n        this.state.pos += commentSkip;\n        this.state.hasFlowComment = true;\n      }\n      return;\n    }\n    return super.skipBlockComment(this.state.hasFlowComment ? \"*-/\" : \"*/\");\n  }\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n    return false;\n  }\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n  }\n  flowEnumErrorBooleanMemberNotInitialized(loc, {\n    enumName,\n    memberName\n  }) {\n    this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {\n      memberName,\n      enumName\n    });\n  }\n  flowEnumErrorInvalidMemberInitializer(loc, enumContext) {\n    return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === \"symbol\" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);\n  }\n  flowEnumErrorNumberMemberNotInitialized(loc, details) {\n    this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);\n  }\n  flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {\n    this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);\n  }\n  flowEnumMemberInit() {\n    const startLoc = this.state.startLoc;\n    const endOfInit = () => this.match(12) || this.match(8);\n    switch (this.state.type) {\n      case 135:\n        {\n          const literal = this.parseNumericLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 134:\n        {\n          const literal = this.parseStringLiteral(this.state.value);\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      case 85:\n      case 86:\n        {\n          const literal = this.parseBooleanLiteral(this.match(85));\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              loc: literal.loc.start,\n              value: literal\n            };\n          }\n          return {\n            type: \"invalid\",\n            loc: startLoc\n          };\n        }\n      default:\n        return {\n          type: \"invalid\",\n          loc: startLoc\n        };\n    }\n  }\n  flowEnumMemberRaw() {\n    const loc = this.state.startLoc;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(29) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      loc\n    };\n    return {\n      id,\n      init\n    };\n  }\n  flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n    if (explicitType === null) {\n      return;\n    }\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(loc, context);\n    }\n  }\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n    let hasUnknownMembers = false;\n    while (!this.match(8)) {\n      if (this.eat(21)) {\n        hasUnknownMembers = true;\n        break;\n      }\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n      if (memberName === \"\") {\n        continue;\n      }\n      if (/^[a-z]/.test(memberName)) {\n        this.raise(FlowErrors.EnumInvalidMemberName, id, {\n          memberName,\n          suggestion: memberName[0].toUpperCase() + memberName.slice(1),\n          enumName\n        });\n      }\n      if (seenNames.has(memberName)) {\n        this.raise(FlowErrors.EnumDuplicateMemberName, id, {\n          memberName,\n          enumName\n        });\n      }\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.loc, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);\n          }\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);\n                break;\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);\n                break;\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n      if (!this.match(8)) {\n        this.expect(12);\n      }\n    }\n    return {\n      members,\n      hasUnknownMembers\n    };\n  }\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (const member of initializedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return defaultedMembers;\n    } else {\n      for (const member of defaultedMembers) {\n        this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {\n          enumName\n        });\n      }\n      return initializedMembers;\n    }\n  }\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (!this.eatContextual(102)) return null;\n    if (!tokenIsIdentifier(this.state.type)) {\n      throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {\n        enumName\n      });\n    }\n    const {\n      value\n    } = this.state;\n    this.next();\n    if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n      this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {\n        enumName,\n        invalidEnumType: value\n      });\n    }\n    return value;\n  }\n  flowEnumBody(node, id) {\n    const enumName = id.name;\n    const nameLoc = id.loc.start;\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(5);\n    const {\n      members,\n      hasUnknownMembers\n    } = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n    node.hasUnknownMembers = hasUnknownMembers;\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumBooleanBody\");\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumNumberBody\");\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(8);\n        return this.finishNode(node, \"EnumStringBody\");\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(8);\n        return this.finishNode(node, \"EnumSymbolBody\");\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(8);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.booleanMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (const member of members.defaultedMembers) {\n              this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n            node.members = members.numberMembers;\n            this.expect(8);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), id);\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.shouldParseTypes()) {\n      if (this.match(47) || this.match(51)) {\n        node.typeArguments = this.flowParseTypeParameterInstantiationInExpression();\n      }\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  isLookaheadToken_lt() {\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 60) {\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== 60 && afterNext !== 61;\n    }\n    return false;\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  maybeUnwrapTypeCastExpression(node) {\n    return node.type === \"TypeCastExpression\" ? node.expression : node;\n  }\n};\nconst entities = {\n  __proto__: null,\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\nconst lineBreak = /\\r\\n|[\\r\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction hasNewLine(input, start, end) {\n  for (let i = start; i < end; i++) {\n    if (isNewLine(input.charCodeAt(i))) {\n      return true;\n    }\n  }\n  return false;\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nconst skipWhiteSpaceInLine = /(?:[^\\S\\n\\r\\u2028\\u2029]|\\/\\/.*|\\/\\*.*?\\*\\/)*/g;\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n    default:\n      return false;\n  }\n}\nconst JsxErrors = ParseErrorEnum`jsx`({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression.\",\n  MissingClosingTagElement: ({\n    openingTagName\n  }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>.\",\n  UnexpectedSequenceExpression: \"Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?\",\n  UnexpectedToken: ({\n    unexpected,\n    HTMLEntity\n  }) => `Unexpected token \\`${unexpected}\\`. Did you mean \\`${HTMLEntity}\\` or \\`{'${unexpected}'}\\`?`,\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text.\",\n  UnterminatedJsxContent: \"Unterminated JSX contents.\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\nvar jsx = superClass => class JSXParserMixin extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.canStartJSXElement) {\n              ++this.state.pos;\n              this.finishToken(143);\n            } else {\n              super.getTokenFromCode(ch);\n            }\n            return;\n          }\n          out += this.input.slice(chunkStart, this.state.pos);\n          this.finishToken(142, out);\n          return;\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n        case 62:\n        case 125:\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n      }\n    }\n  }\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(Errors.UnterminatedString, this.state.startLoc);\n      }\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(134, out);\n  }\n  jsxReadEntity() {\n    const startPos = ++this.state.pos;\n    if (this.codePointAtPos(this.state.pos) === 35) {\n      ++this.state.pos;\n      let radix = 10;\n      if (this.codePointAtPos(this.state.pos) === 120) {\n        radix = 16;\n        ++this.state.pos;\n      }\n      const codePoint = this.readInt(radix, undefined, false, \"bail\");\n      if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {\n        ++this.state.pos;\n        return String.fromCodePoint(codePoint);\n      }\n    } else {\n      let count = 0;\n      let semi = false;\n      while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {\n        ++this.state.pos;\n      }\n      if (semi) {\n        const desc = this.input.slice(startPos, this.state.pos);\n        const entity = entities[desc];\n        ++this.state.pos;\n        if (entity) {\n          return entity;\n        }\n      }\n    }\n    this.state.pos = startPos;\n    return \"&\";\n  }\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n    this.finishToken(141, this.input.slice(start, this.state.pos));\n  }\n  jsxParseIdentifier() {\n    const node = this.startNode();\n    if (this.match(141)) {\n      node.name = this.state.value;\n    } else if (tokenIsKeyword(this.state.type)) {\n      node.name = tokenLabelName(this.state.type);\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n  jsxParseNamespacedName() {\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(14)) return name;\n    const node = this.startNodeAt(startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n  jsxParseElementName() {\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n    while (this.eat(16)) {\n      const newNode = this.startNodeAt(startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n    return node;\n  }\n  jsxParseAttributeValue() {\n    let node;\n    switch (this.state.type) {\n      case 5:\n        node = this.startNode();\n        this.setContext(types.brace);\n        this.next();\n        node = this.jsxParseExpressionContainer(node, types.j_oTag);\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(JsxErrors.AttributeIsEmpty, node);\n        }\n        return node;\n      case 143:\n      case 134:\n        return this.parseExprAtom();\n      default:\n        throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);\n    }\n  }\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.startLoc);\n  }\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.setContext(types.j_expr);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n  jsxParseExpressionContainer(node, previousContext) {\n    if (this.match(8)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      const expression = this.parseExpression();\n      node.expression = expression;\n    }\n    this.setContext(previousContext);\n    this.state.canStartJSXElement = true;\n    this.expect(8);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n  jsxParseAttribute() {\n    const node = this.startNode();\n    if (this.match(5)) {\n      this.setContext(types.brace);\n      this.next();\n      this.expect(21);\n      node.argument = this.parseMaybeAssignAllowIn();\n      this.setContext(types.j_oTag);\n      this.state.canStartJSXElement = true;\n      this.expect(8);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n  jsxParseOpeningElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(144)) {\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n    while (!this.match(56) && !this.match(144)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n    node.attributes = attributes;\n    node.selfClosing = this.eat(56);\n    this.expect(144);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n  jsxParseClosingElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    if (this.eat(144)) {\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n    node.name = this.jsxParseElementName();\n    this.expect(144);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n  jsxParseElementAt(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startLoc);\n    let closingElement = null;\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case 143:\n            startLoc = this.state.startLoc;\n            this.next();\n            if (this.eat(56)) {\n              closingElement = this.jsxParseClosingElementAt(startLoc);\n              break contents;\n            }\n            children.push(this.jsxParseElementAt(startLoc));\n            break;\n          case 142:\n            children.push(this.parseLiteral(this.state.value, \"JSXText\"));\n            break;\n          case 5:\n            {\n              const node = this.startNode();\n              this.setContext(types.brace);\n              this.next();\n              if (this.match(21)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node, types.j_expr));\n              }\n              break;\n            }\n          default:\n            this.unexpected();\n        }\n      }\n      if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {\n        this.raise(JsxErrors.MissingClosingTagFragment, closingElement);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n          openingTagName: getQualifiedJSXName(openingElement.name)\n        });\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(JsxErrors.MissingClosingTagElement, closingElement, {\n            openingTagName: getQualifiedJSXName(openingElement.name)\n          });\n        }\n      }\n    }\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n    node.children = children;\n    if (this.match(47)) {\n      throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);\n    }\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n  jsxParseElement() {\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startLoc);\n  }\n  setContext(newContext) {\n    const {\n      context\n    } = this.state;\n    context[context.length - 1] = newContext;\n  }\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(143)) {\n      return this.jsxParseElement();\n    } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.replaceToken(143);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n  skipSpace() {\n    const curContext = this.curContext();\n    if (!curContext.preserveSpace) super.skipSpace();\n  }\n  getTokenFromCode(code) {\n    const context = this.curContext();\n    if (context === types.j_expr) {\n      this.jsxReadToken();\n      return;\n    }\n    if (context === types.j_oTag || context === types.j_cTag) {\n      if (isIdentifierStart(code)) {\n        this.jsxReadWord();\n        return;\n      }\n      if (code === 62) {\n        ++this.state.pos;\n        this.finishToken(144);\n        return;\n      }\n      if ((code === 34 || code === 39) && context === types.j_oTag) {\n        this.jsxReadString(code);\n        return;\n      }\n    }\n    if (code === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      this.finishToken(143);\n      return;\n    }\n    super.getTokenFromCode(code);\n  }\n  updateContext(prevType) {\n    const {\n      context,\n      type\n    } = this.state;\n    if (type === 56 && prevType === 143) {\n      context.splice(-2, 2, types.j_cTag);\n      this.state.canStartJSXElement = false;\n    } else if (type === 143) {\n      context.push(types.j_oTag);\n    } else if (type === 144) {\n      const out = context[context.length - 1];\n      if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {\n        context.pop();\n        this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;\n      } else {\n        this.setContext(types.j_expr);\n        this.state.canStartJSXElement = true;\n      }\n    } else {\n      this.state.canStartJSXElement = tokenComesBeforeExpression(type);\n    }\n  }\n};\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.tsNames = new Map();\n  }\n}\nclass TypeScriptScopeHandler extends ScopeHandler {\n  constructor(...args) {\n    super(...args);\n    this.importsStack = [];\n  }\n  createScope(flags) {\n    this.importsStack.push(new Set());\n    return new TypeScriptScope(flags);\n  }\n  enter(flags) {\n    if (flags === 1024) {\n      this.importsStack.push(new Set());\n    }\n    super.enter(flags);\n  }\n  exit() {\n    const flags = super.exit();\n    if (flags === 1024) {\n      this.importsStack.pop();\n    }\n    return flags;\n  }\n  hasImport(name, allowShadow) {\n    const len = this.importsStack.length;\n    if (this.importsStack[len - 1].has(name)) {\n      return true;\n    }\n    if (!allowShadow && len > 1) {\n      for (let i = 0; i < len - 1; i++) {\n        if (this.importsStack[i].has(name)) return true;\n      }\n    }\n    return false;\n  }\n  declareName(name, bindingType, loc) {\n    if (bindingType & 4096) {\n      if (this.hasImport(name, true)) {\n        this.parser.raise(Errors.VarRedeclaration, loc, {\n          identifierName: name\n        });\n      }\n      this.importsStack[this.importsStack.length - 1].add(name);\n      return;\n    }\n    const scope = this.currentScope();\n    let type = scope.tsNames.get(name) || 0;\n    if (bindingType & 1024) {\n      this.maybeExportDefined(scope, name);\n      scope.tsNames.set(name, type | 16);\n      return;\n    }\n    super.declareName(name, bindingType, loc);\n    if (bindingType & 2) {\n      if (!(bindingType & 1)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, loc);\n        this.maybeExportDefined(scope, name);\n      }\n      type = type | 1;\n    }\n    if (bindingType & 256) {\n      type = type | 2;\n    }\n    if (bindingType & 512) {\n      type = type | 4;\n    }\n    if (bindingType & 128) {\n      type = type | 8;\n    }\n    if (type) scope.tsNames.set(name, type);\n  }\n  isRedeclaredInScope(scope, name, bindingType) {\n    const type = scope.tsNames.get(name);\n    if ((type & 2) > 0) {\n      if (bindingType & 256) {\n        const isConst = !!(bindingType & 512);\n        const wasConst = (type & 4) > 0;\n        return isConst !== wasConst;\n      }\n      return true;\n    }\n    if (bindingType & 128 && (type & 8) > 0) {\n      if (scope.names.get(name) & 2) {\n        return !!(bindingType & 1);\n      } else {\n        return false;\n      }\n    }\n    if (bindingType & 2 && (type & 1) > 0) {\n      return true;\n    }\n    return super.isRedeclaredInScope(scope, name, bindingType);\n  }\n  checkLocalExport(id) {\n    const {\n      name\n    } = id;\n    if (this.hasImport(name)) return;\n    const len = this.scopeStack.length;\n    for (let i = len - 1; i >= 0; i--) {\n      const scope = this.scopeStack[i];\n      const type = scope.tsNames.get(name);\n      if ((type & 1) > 0 || (type & 16) > 0) {\n        return;\n      }\n    }\n    super.checkLocalExport(id);\n  }\n}\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n  exit() {\n    this.stacks.pop();\n  }\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n  get hasAwait() {\n    return (this.currentFlags() & 2) > 0;\n  }\n  get hasYield() {\n    return (this.currentFlags() & 1) > 0;\n  }\n  get hasReturn() {\n    return (this.currentFlags() & 4) > 0;\n  }\n  get hasIn() {\n    return (this.currentFlags() & 8) > 0;\n  }\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);\n}\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n  sourceToOffsetPos(sourcePos) {\n    return sourcePos + this.startIndex;\n  }\n  offsetToSourcePos(offsetPos) {\n    return offsetPos - this.startIndex;\n  }\n  hasPlugin(pluginConfig) {\n    if (typeof pluginConfig === \"string\") {\n      return this.plugins.has(pluginConfig);\n    } else {\n      const [pluginName, pluginOptions] = pluginConfig;\n      if (!this.hasPlugin(pluginName)) {\n        return false;\n      }\n      const actualOptions = this.plugins.get(pluginName);\n      for (const key of Object.keys(pluginOptions)) {\n        if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  getPluginOption(plugin, name) {\n    var _this$plugins$get;\n    return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];\n  }\n}\nfunction setTrailingComments(node, comments) {\n  if (node.trailingComments === undefined) {\n    node.trailingComments = comments;\n  } else {\n    node.trailingComments.unshift(...comments);\n  }\n}\nfunction setLeadingComments(node, comments) {\n  if (node.leadingComments === undefined) {\n    node.leadingComments = comments;\n  } else {\n    node.leadingComments.unshift(...comments);\n  }\n}\nfunction setInnerComments(node, comments) {\n  if (node.innerComments === undefined) {\n    node.innerComments = comments;\n  } else {\n    node.innerComments.unshift(...comments);\n  }\n}\nfunction adjustInnerComments(node, elements, commentWS) {\n  let lastElement = null;\n  let i = elements.length;\n  while (lastElement === null && i > 0) {\n    lastElement = elements[--i];\n  }\n  if (lastElement === null || lastElement.start > commentWS.start) {\n    setInnerComments(node, commentWS.comments);\n  } else {\n    setTrailingComments(lastElement, commentWS.comments);\n  }\n}\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    const {\n      commentsLen\n    } = this.state;\n    if (this.comments.length !== commentsLen) {\n      this.comments.length = commentsLen;\n    }\n    this.comments.push(comment);\n    this.state.commentsLen++;\n  }\n  processComment(node) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    const lastCommentWS = commentStack[i];\n    if (lastCommentWS.start === node.end) {\n      lastCommentWS.leadingNode = node;\n      i--;\n    }\n    const {\n      start: nodeStart\n    } = node;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      if (commentEnd > nodeStart) {\n        commentWS.containingNode = node;\n        this.finalizeComment(commentWS);\n        commentStack.splice(i, 1);\n      } else {\n        if (commentEnd === nodeStart) {\n          commentWS.trailingNode = node;\n        }\n        break;\n      }\n    }\n  }\n  finalizeComment(commentWS) {\n    var _node$options;\n    const {\n      comments\n    } = commentWS;\n    if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {\n      if (commentWS.leadingNode !== null) {\n        setTrailingComments(commentWS.leadingNode, comments);\n      }\n      if (commentWS.trailingNode !== null) {\n        setLeadingComments(commentWS.trailingNode, comments);\n      }\n    } else {\n      const node = commentWS.containingNode;\n      const commentStart = commentWS.start;\n      if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {\n        switch (node.type) {\n          case \"ObjectExpression\":\n          case \"ObjectPattern\":\n            adjustInnerComments(node, node.properties, commentWS);\n            break;\n          case \"CallExpression\":\n          case \"OptionalCallExpression\":\n            adjustInnerComments(node, node.arguments, commentWS);\n            break;\n          case \"ImportExpression\":\n            adjustInnerComments(node, [node.source, (_node$options = node.options) != null ? _node$options : null], commentWS);\n            break;\n          case \"FunctionDeclaration\":\n          case \"FunctionExpression\":\n          case \"ArrowFunctionExpression\":\n          case \"ObjectMethod\":\n          case \"ClassMethod\":\n          case \"ClassPrivateMethod\":\n            adjustInnerComments(node, node.params, commentWS);\n            break;\n          case \"ArrayExpression\":\n          case \"ArrayPattern\":\n            adjustInnerComments(node, node.elements, commentWS);\n            break;\n          case \"ExportNamedDeclaration\":\n          case \"ImportDeclaration\":\n            adjustInnerComments(node, node.specifiers, commentWS);\n            break;\n          case \"TSEnumDeclaration\":\n            adjustInnerComments(node, node.members, commentWS);\n            break;\n          case \"TSEnumBody\":\n            adjustInnerComments(node, node.members, commentWS);\n            break;\n          default:\n            {\n              if (node.type === \"RecordExpression\") {\n                adjustInnerComments(node, node.properties, commentWS);\n                break;\n              }\n              if (node.type === \"TupleExpression\") {\n                adjustInnerComments(node, node.elements, commentWS);\n                break;\n              }\n              setInnerComments(node, comments);\n            }\n        }\n      } else {\n        setInnerComments(node, comments);\n      }\n    }\n  }\n  finalizeRemainingComments() {\n    const {\n      commentStack\n    } = this.state;\n    for (let i = commentStack.length - 1; i >= 0; i--) {\n      this.finalizeComment(commentStack[i]);\n    }\n    this.state.commentStack = [];\n  }\n  resetPreviousNodeTrailingComments(node) {\n    const {\n      commentStack\n    } = this.state;\n    const {\n      length\n    } = commentStack;\n    if (length === 0) return;\n    const commentWS = commentStack[length - 1];\n    if (commentWS.leadingNode === node) {\n      commentWS.leadingNode = null;\n    }\n  }\n  takeSurroundingComments(node, start, end) {\n    const {\n      commentStack\n    } = this.state;\n    const commentStackLength = commentStack.length;\n    if (commentStackLength === 0) return;\n    let i = commentStackLength - 1;\n    for (; i >= 0; i--) {\n      const commentWS = commentStack[i];\n      const commentEnd = commentWS.end;\n      const commentStart = commentWS.start;\n      if (commentStart === end) {\n        commentWS.leadingNode = node;\n      } else if (commentEnd === start) {\n        commentWS.trailingNode = node;\n      } else if (commentEnd < start) {\n        break;\n      }\n    }\n  }\n}\nclass State {\n  constructor() {\n    this.flags = 1024;\n    this.startIndex = void 0;\n    this.curLine = void 0;\n    this.lineStart = void 0;\n    this.startLoc = void 0;\n    this.endLoc = void 0;\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.labels = [];\n    this.commentsLen = 0;\n    this.commentStack = [];\n    this.pos = 0;\n    this.type = 140;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.context = [types.brace];\n    this.firstInvalidTemplateEscapePos = null;\n    this.strictErrors = new Map();\n    this.tokensLength = 0;\n  }\n  get strict() {\n    return (this.flags & 1) > 0;\n  }\n  set strict(v) {\n    if (v) this.flags |= 1;else this.flags &= -2;\n  }\n  init({\n    strictMode,\n    sourceType,\n    startIndex,\n    startLine,\n    startColumn\n  }) {\n    this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === \"module\";\n    this.startIndex = startIndex;\n    this.curLine = startLine;\n    this.lineStart = -startColumn;\n    this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);\n  }\n  get maybeInArrowParameters() {\n    return (this.flags & 2) > 0;\n  }\n  set maybeInArrowParameters(v) {\n    if (v) this.flags |= 2;else this.flags &= -3;\n  }\n  get inType() {\n    return (this.flags & 4) > 0;\n  }\n  set inType(v) {\n    if (v) this.flags |= 4;else this.flags &= -5;\n  }\n  get noAnonFunctionType() {\n    return (this.flags & 8) > 0;\n  }\n  set noAnonFunctionType(v) {\n    if (v) this.flags |= 8;else this.flags &= -9;\n  }\n  get hasFlowComment() {\n    return (this.flags & 16) > 0;\n  }\n  set hasFlowComment(v) {\n    if (v) this.flags |= 16;else this.flags &= -17;\n  }\n  get isAmbientContext() {\n    return (this.flags & 32) > 0;\n  }\n  set isAmbientContext(v) {\n    if (v) this.flags |= 32;else this.flags &= -33;\n  }\n  get inAbstractClass() {\n    return (this.flags & 64) > 0;\n  }\n  set inAbstractClass(v) {\n    if (v) this.flags |= 64;else this.flags &= -65;\n  }\n  get inDisallowConditionalTypesContext() {\n    return (this.flags & 128) > 0;\n  }\n  set inDisallowConditionalTypesContext(v) {\n    if (v) this.flags |= 128;else this.flags &= -129;\n  }\n  get soloAwait() {\n    return (this.flags & 256) > 0;\n  }\n  set soloAwait(v) {\n    if (v) this.flags |= 256;else this.flags &= -257;\n  }\n  get inFSharpPipelineDirectBody() {\n    return (this.flags & 512) > 0;\n  }\n  set inFSharpPipelineDirectBody(v) {\n    if (v) this.flags |= 512;else this.flags &= -513;\n  }\n  get canStartJSXElement() {\n    return (this.flags & 1024) > 0;\n  }\n  set canStartJSXElement(v) {\n    if (v) this.flags |= 1024;else this.flags &= -1025;\n  }\n  get containsEsc() {\n    return (this.flags & 2048) > 0;\n  }\n  set containsEsc(v) {\n    if (v) this.flags |= 2048;else this.flags &= -2049;\n  }\n  get hasTopLevelAwait() {\n    return (this.flags & 4096) > 0;\n  }\n  set hasTopLevelAwait(v) {\n    if (v) this.flags |= 4096;else this.flags &= -4097;\n  }\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);\n  }\n  clone() {\n    const state = new State();\n    state.flags = this.flags;\n    state.startIndex = this.startIndex;\n    state.curLine = this.curLine;\n    state.lineStart = this.lineStart;\n    state.startLoc = this.startLoc;\n    state.endLoc = this.endLoc;\n    state.errors = this.errors.slice();\n    state.potentialArrowAt = this.potentialArrowAt;\n    state.noArrowAt = this.noArrowAt.slice();\n    state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();\n    state.topicContext = this.topicContext;\n    state.labels = this.labels.slice();\n    state.commentsLen = this.commentsLen;\n    state.commentStack = this.commentStack.slice();\n    state.pos = this.pos;\n    state.type = this.type;\n    state.value = this.value;\n    state.start = this.start;\n    state.end = this.end;\n    state.lastTokEndLoc = this.lastTokEndLoc;\n    state.lastTokStartLoc = this.lastTokStartLoc;\n    state.context = this.context.slice();\n    state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;\n    state.strictErrors = this.strictErrors;\n    state.tokensLength = this.tokensLength;\n    return state;\n  }\n}\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),\n  hex: new Set([46, 88, 95, 120])\n};\nconst isAllowedNumericSeparatorSibling = {\n  bin: ch => ch === 48 || ch === 49,\n  oct: ch => ch >= 48 && ch <= 55,\n  dec: ch => ch >= 48 && ch <= 57,\n  hex: ch => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102\n};\nfunction readStringContents(type, input, pos, lineStart, curLine, errors) {\n  const initialPos = pos;\n  const initialLineStart = lineStart;\n  const initialCurLine = curLine;\n  let out = \"\";\n  let firstInvalidLoc = null;\n  let chunkStart = pos;\n  const {\n    length\n  } = input;\n  for (;;) {\n    if (pos >= length) {\n      errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    const ch = input.charCodeAt(pos);\n    if (isStringEnd(type, ch, input, pos)) {\n      out += input.slice(chunkStart, pos);\n      break;\n    }\n    if (ch === 92) {\n      out += input.slice(chunkStart, pos);\n      const res = readEscapedChar(input, pos, lineStart, curLine, type === \"template\", errors);\n      if (res.ch === null && !firstInvalidLoc) {\n        firstInvalidLoc = {\n          pos,\n          lineStart,\n          curLine\n        };\n      } else {\n        out += res.ch;\n      }\n      ({\n        pos,\n        lineStart,\n        curLine\n      } = res);\n      chunkStart = pos;\n    } else if (ch === 8232 || ch === 8233) {\n      ++pos;\n      ++curLine;\n      lineStart = pos;\n    } else if (ch === 10 || ch === 13) {\n      if (type === \"template\") {\n        out += input.slice(chunkStart, pos) + \"\\n\";\n        ++pos;\n        if (ch === 13 && input.charCodeAt(pos) === 10) {\n          ++pos;\n        }\n        ++curLine;\n        chunkStart = lineStart = pos;\n      } else {\n        errors.unterminated(initialPos, initialLineStart, initialCurLine);\n      }\n    } else {\n      ++pos;\n    }\n  }\n  return {\n    pos,\n    str: out,\n    firstInvalidLoc,\n    lineStart,\n    curLine,\n    containsInvalid: !!firstInvalidLoc\n  };\n}\nfunction isStringEnd(type, ch, input, pos) {\n  if (type === \"template\") {\n    return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;\n  }\n  return ch === (type === \"double\" ? 34 : 39);\n}\nfunction readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {\n  const throwOnInvalid = !inTemplate;\n  pos++;\n  const res = ch => ({\n    pos,\n    ch,\n    lineStart,\n    curLine\n  });\n  const ch = input.charCodeAt(pos++);\n  switch (ch) {\n    case 110:\n      return res(\"\\n\");\n    case 114:\n      return res(\"\\r\");\n    case 120:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCharCode(code));\n      }\n    case 117:\n      {\n        let code;\n        ({\n          code,\n          pos\n        } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));\n        return res(code === null ? null : String.fromCodePoint(code));\n      }\n    case 116:\n      return res(\"\\t\");\n    case 98:\n      return res(\"\\b\");\n    case 118:\n      return res(\"\\u000b\");\n    case 102:\n      return res(\"\\f\");\n    case 13:\n      if (input.charCodeAt(pos) === 10) {\n        ++pos;\n      }\n    case 10:\n      lineStart = pos;\n      ++curLine;\n    case 8232:\n    case 8233:\n      return res(\"\");\n    case 56:\n    case 57:\n      if (inTemplate) {\n        return res(null);\n      } else {\n        errors.strictNumericEscape(pos - 1, lineStart, curLine);\n      }\n    default:\n      if (ch >= 48 && ch <= 55) {\n        const startPos = pos - 1;\n        const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));\n        let octalStr = match[0];\n        let octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        pos += octalStr.length - 1;\n        const next = input.charCodeAt(pos);\n        if (octalStr !== \"0\" || next === 56 || next === 57) {\n          if (inTemplate) {\n            return res(null);\n          } else {\n            errors.strictNumericEscape(startPos, lineStart, curLine);\n          }\n        }\n        return res(String.fromCharCode(octal));\n      }\n      return res(String.fromCharCode(ch));\n  }\n}\nfunction readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {\n  const initialPos = pos;\n  let n;\n  ({\n    n,\n    pos\n  } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));\n  if (n === null) {\n    if (throwOnInvalid) {\n      errors.invalidEscapeSequence(initialPos, lineStart, curLine);\n    } else {\n      pos = initialPos - 1;\n    }\n  }\n  return {\n    code: n,\n    pos\n  };\n}\nfunction readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {\n  const start = pos;\n  const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n  const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;\n  let invalid = false;\n  let total = 0;\n  for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    const code = input.charCodeAt(pos);\n    let val;\n    if (code === 95 && allowNumSeparator !== \"bail\") {\n      const prev = input.charCodeAt(pos - 1);\n      const next = input.charCodeAt(pos + 1);\n      if (!allowNumSeparator) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);\n      } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {\n        if (bailOnError) return {\n          n: null,\n          pos\n        };\n        errors.unexpectedNumericSeparator(pos, lineStart, curLine);\n      }\n      ++pos;\n      continue;\n    }\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } else if (code >= 65) {\n      val = code - 65 + 10;\n    } else if (_isDigit(code)) {\n      val = code - 48;\n    } else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      if (val <= 9 && bailOnError) {\n        return {\n          n: null,\n          pos\n        };\n      } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {\n        val = 0;\n      } else if (forceLen) {\n        val = 0;\n        invalid = true;\n      } else {\n        break;\n      }\n    }\n    ++pos;\n    total = total * radix + val;\n  }\n  if (pos === start || len != null && pos - start !== len || invalid) {\n    return {\n      n: null,\n      pos\n    };\n  }\n  return {\n    n: total,\n    pos\n  };\n}\nfunction readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {\n  const ch = input.charCodeAt(pos);\n  let code;\n  if (ch === 123) {\n    ++pos;\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, input.indexOf(\"}\", pos) - pos, true, throwOnInvalid, errors));\n    ++pos;\n    if (code !== null && code > 0x10ffff) {\n      if (throwOnInvalid) {\n        errors.invalidCodePoint(pos, lineStart, curLine);\n      } else {\n        return {\n          code: null,\n          pos\n        };\n      }\n    }\n  } else {\n    ({\n      code,\n      pos\n    } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));\n  }\n  return {\n    code,\n    pos\n  };\n}\nfunction buildPosition(pos, lineStart, curLine) {\n  return new Position(curLine, pos - lineStart, pos);\n}\nconst VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100, 118]);\nclass Token {\n  constructor(state) {\n    const startIndex = state.startIndex || 0;\n    this.type = state.type;\n    this.value = state.value;\n    this.start = startIndex + state.start;\n    this.end = startIndex + state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n}\nclass Tokenizer extends CommentsParser {\n  constructor(options, input) {\n    super();\n    this.isLookahead = void 0;\n    this.tokens = [];\n    this.errorHandlers_readInt = {\n      invalidDigit: (pos, lineStart, curLine, radix) => {\n        if (!(this.optionFlags & 2048)) return false;\n        this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {\n          radix\n        });\n        return true;\n      },\n      numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),\n      unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)\n    };\n    this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {\n      invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),\n      invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)\n    });\n    this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: (pos, lineStart, curLine) => {\n        this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));\n      },\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));\n      }\n    });\n    this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {\n      strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),\n      unterminated: (pos, lineStart, curLine) => {\n        throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));\n      }\n    });\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.comments = [];\n    this.isLookahead = false;\n  }\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n  next() {\n    this.checkKeywordEscapes();\n    if (this.optionFlags & 256) {\n      this.pushToken(new Token(this.state));\n    }\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n  match(type) {\n    return this.state.type === type;\n  }\n  createLookaheadState(state) {\n    return {\n      pos: state.pos,\n      value: null,\n      type: state.type,\n      start: state.start,\n      end: state.end,\n      context: [this.curContext()],\n      inType: state.inType,\n      startLoc: state.startLoc,\n      lastTokEndLoc: state.lastTokEndLoc,\n      curLine: state.curLine,\n      lineStart: state.lineStart,\n      curPosition: state.curPosition\n    };\n  }\n  lookahead() {\n    const old = this.state;\n    this.state = this.createLookaheadState(old);\n    this.isLookahead = true;\n    this.nextToken();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n  nextTokenStart() {\n    return this.nextTokenStartSince(this.state.pos);\n  }\n  nextTokenStartSince(pos) {\n    skipWhiteSpace.lastIndex = pos;\n    return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;\n  }\n  lookaheadCharCode() {\n    return this.lookaheadCharCodeSince(this.state.pos);\n  }\n  lookaheadCharCodeSince(pos) {\n    return this.input.charCodeAt(this.nextTokenStartSince(pos));\n  }\n  nextTokenInLineStart() {\n    return this.nextTokenInLineStartSince(this.state.pos);\n  }\n  nextTokenInLineStartSince(pos) {\n    skipWhiteSpaceInLine.lastIndex = pos;\n    return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;\n  }\n  lookaheadInLineCharCode() {\n    return this.input.charCodeAt(this.nextTokenInLineStart());\n  }\n  codePointAtPos(pos) {\n    let cp = this.input.charCodeAt(pos);\n    if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {\n      const trail = this.input.charCodeAt(pos);\n      if ((trail & 0xfc00) === 0xdc00) {\n        cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);\n      }\n    }\n    return cp;\n  }\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (strict) {\n      this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));\n      this.state.strictErrors.clear();\n    }\n  }\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n  nextToken() {\n    this.skipSpace();\n    this.state.start = this.state.pos;\n    if (!this.isLookahead) this.state.startLoc = this.state.curPosition();\n    if (this.state.pos >= this.length) {\n      this.finishToken(140);\n      return;\n    }\n    this.getTokenFromCode(this.codePointAtPos(this.state.pos));\n  }\n  skipBlockComment(commentEnd) {\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(commentEnd, start + 2);\n    if (end === -1) {\n      throw this.raise(Errors.UnterminatedComment, this.state.curPosition());\n    }\n    this.state.pos = end + commentEnd.length;\n    lineBreakG.lastIndex = start + 2;\n    while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {\n      ++this.state.curLine;\n      this.state.lineStart = lineBreakG.lastIndex;\n    }\n    if (this.isLookahead) return;\n    const comment = {\n      type: \"CommentBlock\",\n      value: this.input.slice(start + 2, end),\n      start: this.sourceToOffsetPos(start),\n      end: this.sourceToOffsetPos(end + commentEnd.length),\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.optionFlags & 256) this.pushToken(comment);\n    return comment;\n  }\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    let startLoc;\n    if (!this.isLookahead) startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n    if (this.isLookahead) return;\n    const end = this.state.pos;\n    const value = this.input.slice(start + startSkip, end);\n    const comment = {\n      type: \"CommentLine\",\n      value,\n      start: this.sourceToOffsetPos(start),\n      end: this.sourceToOffsetPos(end),\n      loc: new SourceLocation(startLoc, this.state.curPosition())\n    };\n    if (this.optionFlags & 256) this.pushToken(comment);\n    return comment;\n  }\n  skipSpace() {\n    const spaceStart = this.state.pos;\n    const comments = this.optionFlags & 4096 ? [] : null;\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              {\n                const comment = this.skipBlockComment(\"*/\");\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  comments == null || comments.push(comment);\n                }\n                break;\n              }\n            case 47:\n              {\n                const comment = this.skipLineComment(2);\n                if (comment !== undefined) {\n                  this.addComment(comment);\n                  comments == null || comments.push(comment);\n                }\n                break;\n              }\n            default:\n              break loop;\n          }\n          break;\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else if (ch === 45 && !this.inModule && this.optionFlags & 8192) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {\n              const comment = this.skipLineComment(3);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                comments == null || comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else if (ch === 60 && !this.inModule && this.optionFlags & 8192) {\n            const pos = this.state.pos;\n            if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {\n              const comment = this.skipLineComment(4);\n              if (comment !== undefined) {\n                this.addComment(comment);\n                comments == null || comments.push(comment);\n              }\n            } else {\n              break loop;\n            }\n          } else {\n            break loop;\n          }\n      }\n    }\n    if ((comments == null ? void 0 : comments.length) > 0) {\n      const end = this.state.pos;\n      const commentWhitespace = {\n        start: this.sourceToOffsetPos(spaceStart),\n        end: this.sourceToOffsetPos(end),\n        comments: comments,\n        leadingNode: null,\n        trailingNode: null,\n        containingNode: null\n      };\n      this.state.commentStack.push(commentWhitespace);\n    }\n  }\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) {\n      this.updateContext(prevType);\n    }\n  }\n  replaceToken(type) {\n    this.state.type = type;\n    this.updateContext();\n  }\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n    const nextPos = this.state.pos + 1;\n    const next = this.codePointAtPos(nextPos);\n    if (next >= 48 && next <= 57) {\n      throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());\n    }\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") === \"bar\") {\n        throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());\n      }\n      this.state.pos += 2;\n      if (next === 123) {\n        this.finishToken(7);\n      } else {\n        this.finishToken(1);\n      }\n    } else if (isIdentifierStart(next)) {\n      ++this.state.pos;\n      this.finishToken(139, this.readWord1(next));\n    } else if (next === 92) {\n      ++this.state.pos;\n      this.finishToken(139, this.readWord1());\n    } else {\n      this.finishOp(27, 1);\n    }\n  }\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(21);\n    } else {\n      ++this.state.pos;\n      this.finishToken(16);\n    }\n  }\n  readToken_slash() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(31, 2);\n    } else {\n      this.finishOp(56, 1);\n    }\n  }\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(28, value);\n    return true;\n  }\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? 55 : 54;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = 57;\n    }\n    if (next === 61 && !this.state.inType) {\n      width++;\n      type = code === 37 ? 33 : 30;\n    }\n    this.finishOp(type, width);\n  }\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(code === 124 ? 41 : 42, 2);\n      }\n      return;\n    }\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(39, 2);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(9);\n        return;\n      }\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());\n        }\n        this.state.pos += 2;\n        this.finishToken(4);\n        return;\n      }\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n      return;\n    }\n    this.finishOp(code === 124 ? 43 : 45, 1);\n  }\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61 && !this.state.inType) {\n      this.finishOp(32, 2);\n    } else if (next === 94 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"^^\"\n    }])) {\n      this.finishOp(37, 2);\n      const lookaheadCh = this.input.codePointAt(this.state.pos);\n      if (lookaheadCh === 94) {\n        this.unexpected();\n      }\n    } else {\n      this.finishOp(44, 1);\n    }\n  }\n  readToken_atSign() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 64 && this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"hack\",\n      topicToken: \"@@\"\n    }])) {\n      this.finishOp(38, 2);\n    } else {\n      this.finishOp(26, 1);\n    }\n  }\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === code) {\n      this.finishOp(34, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(30, 2);\n    } else {\n      this.finishOp(53, 1);\n    }\n  }\n  readToken_lt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 60) {\n      if (this.input.charCodeAt(pos + 2) === 61) {\n        this.finishOp(30, 3);\n        return;\n      }\n      this.finishOp(51, 2);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(47, 1);\n  }\n  readToken_gt() {\n    const {\n      pos\n    } = this.state;\n    const next = this.input.charCodeAt(pos + 1);\n    if (next === 62) {\n      const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(pos + size) === 61) {\n        this.finishOp(30, size + 1);\n        return;\n      }\n      this.finishOp(52, size);\n      return;\n    }\n    if (next === 61) {\n      this.finishOp(49, 2);\n      return;\n    }\n    this.finishOp(48, 1);\n  }\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    if (next === 61) {\n      this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(19);\n      return;\n    }\n    this.finishOp(code === 61 ? 29 : 35, 1);\n  }\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n    if (next === 63) {\n      if (next2 === 61) {\n        this.finishOp(30, 3);\n      } else {\n        this.finishOp(40, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(18);\n    } else {\n      ++this.state.pos;\n      this.finishToken(17);\n    }\n  }\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n      case 40:\n        ++this.state.pos;\n        this.finishToken(10);\n        return;\n      case 41:\n        ++this.state.pos;\n        this.finishToken(11);\n        return;\n      case 59:\n        ++this.state.pos;\n        this.finishToken(13);\n        return;\n      case 44:\n        ++this.state.pos;\n        this.finishToken(12);\n        return;\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(0);\n        }\n        return;\n      case 93:\n        ++this.state.pos;\n        this.finishToken(3);\n        return;\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());\n          }\n          this.state.pos += 2;\n          this.finishToken(6);\n        } else {\n          ++this.state.pos;\n          this.finishToken(5);\n        }\n        return;\n      case 125:\n        ++this.state.pos;\n        this.finishToken(8);\n        return;\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(15, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(14);\n        }\n        return;\n      case 63:\n        this.readToken_question();\n        return;\n      case 96:\n        this.readTemplateToken();\n        return;\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n      case 47:\n        this.readToken_slash();\n        return;\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n      case 94:\n        this.readToken_caret();\n        return;\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n      case 60:\n        this.readToken_lt();\n        return;\n      case 62:\n        this.readToken_gt();\n        return;\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n      case 126:\n        this.finishOp(36, 1);\n        return;\n      case 64:\n        this.readToken_atSign();\n        return;\n      case 35:\n        this.readToken_numberSign();\n        return;\n      case 92:\n        this.readWord();\n        return;\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord(code);\n          return;\n        }\n    }\n    throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {\n      unexpected: String.fromCodePoint(code)\n    });\n  }\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n  readRegexp() {\n    const startLoc = this.state.startLoc;\n    const start = this.state.start + 1;\n    let escaped, inClass;\n    let {\n      pos\n    } = this.state;\n    for (;; ++pos) {\n      if (pos >= this.length) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      const ch = this.input.charCodeAt(pos);\n      if (isNewLine(ch)) {\n        throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));\n      }\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === 91) {\n          inClass = true;\n        } else if (ch === 93 && inClass) {\n          inClass = false;\n        } else if (ch === 47 && !inClass) {\n          break;\n        }\n        escaped = ch === 92;\n      }\n    }\n    const content = this.input.slice(start, pos);\n    ++pos;\n    let mods = \"\";\n    const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);\n    while (pos < this.length) {\n      const cp = this.codePointAtPos(pos);\n      const char = String.fromCharCode(cp);\n      if (VALID_REGEX_FLAGS.has(cp)) {\n        if (cp === 118) {\n          if (mods.includes(\"u\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        } else if (cp === 117) {\n          if (mods.includes(\"v\")) {\n            this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());\n          }\n        }\n        if (mods.includes(char)) {\n          this.raise(Errors.DuplicateRegExpFlags, nextPos());\n        }\n      } else if (isIdentifierChar(cp) || cp === 92) {\n        this.raise(Errors.MalformedRegExpFlags, nextPos());\n      } else {\n        break;\n      }\n      ++pos;\n      mods += char;\n    }\n    this.state.pos = pos;\n    this.finishToken(138, {\n      pattern: content,\n      flags: mods\n    });\n  }\n  readInt(radix, len, forceLen = false, allowNumSeparator = true) {\n    const {\n      n,\n      pos\n    } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);\n    this.state.pos = pos;\n    return n;\n  }\n  readRadixNumber(radix) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n    if (val == null) {\n      this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {\n        radix\n      });\n    }\n    const next = this.input.charCodeAt(this.state.pos);\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    } else if (next === 109) {\n      throw this.raise(Errors.InvalidDecimal, startLoc);\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(136, str);\n      return;\n    }\n    this.finishToken(135, val);\n  }\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let isFloat = false;\n    let isBigInt = false;\n    let hasExponent = false;\n    let isOctal = false;\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(Errors.InvalidNumber, this.state.curPosition());\n    }\n    const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (hasLeadingZero) {\n      const integer = this.input.slice(start, this.state.pos);\n      this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);\n      if (!this.state.strict) {\n        const underscorePos = integer.indexOf(\"_\");\n        if (underscorePos > 0) {\n          this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));\n        }\n      }\n      isOctal = hasLeadingZero && !/[89]/.test(integer);\n    }\n    let next = this.input.charCodeAt(this.state.pos);\n    if (next === 46 && !isOctal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if ((next === 69 || next === 101) && !isOctal) {\n      next = this.input.charCodeAt(++this.state.pos);\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n      if (this.readInt(10) === null) {\n        this.raise(Errors.InvalidOrMissingExponent, startLoc);\n      }\n      isFloat = true;\n      hasExponent = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n    if (next === 110) {\n      if (isFloat || hasLeadingZero) {\n        this.raise(Errors.InvalidBigIntLiteral, startLoc);\n      }\n      ++this.state.pos;\n      isBigInt = true;\n    }\n    if (next === 109) {\n      this.expectPlugin(\"decimal\", this.state.curPosition());\n      if (hasExponent || hasLeadingZero) {\n        this.raise(Errors.InvalidDecimal, startLoc);\n      }\n      ++this.state.pos;\n      var isDecimal = true;\n    }\n    if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {\n      throw this.raise(Errors.NumberIdentifier, this.state.curPosition());\n    }\n    const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, \"\");\n    if (isBigInt) {\n      this.finishToken(136, str);\n      return;\n    }\n    if (isDecimal) {\n      this.finishToken(137, str);\n      return;\n    }\n    const val = isOctal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(135, val);\n  }\n  readCodePoint(throwOnInvalid) {\n    const {\n      code,\n      pos\n    } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);\n    this.state.pos = pos;\n    return code;\n  }\n  readString(quote) {\n    const {\n      str,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(quote === 34 ? \"double\" : \"single\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    this.finishToken(134, str);\n  }\n  readTemplateContinuation() {\n    if (!this.match(8)) {\n      this.unexpected(null, 8);\n    }\n    this.state.pos--;\n    this.readTemplateToken();\n  }\n  readTemplateToken() {\n    const opening = this.input[this.state.pos];\n    const {\n      str,\n      firstInvalidLoc,\n      pos,\n      curLine,\n      lineStart\n    } = readStringContents(\"template\", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);\n    this.state.pos = pos + 1;\n    this.state.lineStart = lineStart;\n    this.state.curLine = curLine;\n    if (firstInvalidLoc) {\n      this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));\n    }\n    if (this.input.codePointAt(pos) === 96) {\n      this.finishToken(24, firstInvalidLoc ? null : opening + str + \"`\");\n    } else {\n      this.state.pos++;\n      this.finishToken(25, firstInvalidLoc ? null : opening + str + \"${\");\n    }\n  }\n  recordStrictModeErrors(toParseError, at) {\n    const index = at.index;\n    if (this.state.strict && !this.state.strictErrors.has(index)) {\n      this.raise(toParseError, at);\n    } else {\n      this.state.strictErrors.set(index, [toParseError, at]);\n    }\n  }\n  readWord1(firstCode) {\n    this.state.containsEsc = false;\n    let word = \"\";\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n    if (firstCode !== undefined) {\n      this.state.pos += firstCode <= 0xffff ? 1 : 2;\n    }\n    while (this.state.pos < this.length) {\n      const ch = this.codePointAtPos(this.state.pos);\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.curPosition();\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());\n          chunkStart = this.state.pos - 1;\n          continue;\n        }\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(Errors.EscapedCharNotAnIdentifier, escStart);\n          }\n          word += String.fromCodePoint(esc);\n        }\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n  readWord(firstCode) {\n    const word = this.readWord1(firstCode);\n    const type = keywords$1.get(word);\n    if (type !== undefined) {\n      this.finishToken(type, tokenLabelName(type));\n    } else {\n      this.finishToken(132, word);\n    }\n  }\n  checkKeywordEscapes() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsKeyword(type) && this.state.containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {\n        reservedWord: tokenLabelName(type)\n      });\n    }\n  }\n  raise(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const error = toParseError(loc, details);\n    if (!(this.optionFlags & 2048)) throw error;\n    if (!this.isLookahead) this.state.errors.push(error);\n    return error;\n  }\n  raiseOverwrite(toParseError, at, details = {}) {\n    const loc = at instanceof Position ? at : at.loc.start;\n    const pos = loc.index;\n    const errors = this.state.errors;\n    for (let i = errors.length - 1; i >= 0; i--) {\n      const error = errors[i];\n      if (error.loc.index === pos) {\n        return errors[i] = toParseError(loc, details);\n      }\n      if (error.loc.index < pos) break;\n    }\n    return this.raise(toParseError, at, details);\n  }\n  updateContext(prevType) {}\n  unexpected(loc, type) {\n    throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {\n      expected: type ? tokenLabelName(type) : null\n    });\n  }\n  expectPlugin(pluginName, loc) {\n    if (this.hasPlugin(pluginName)) {\n      return true;\n    }\n    throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {\n      missingPlugin: [pluginName]\n    });\n  }\n  expectOnePlugin(pluginNames) {\n    if (!pluginNames.some(name => this.hasPlugin(name))) {\n      throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {\n        missingPlugin: pluginNames\n      });\n    }\n  }\n  errorBuilder(error) {\n    return (pos, lineStart, curLine) => {\n      this.raise(error, buildPosition(pos, lineStart, curLine));\n    };\n  }\n}\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n}\nclass ClassScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.parser = parser;\n  }\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n    for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, loc);\n        }\n      } else {\n        this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n          identifierName: name\n        });\n      }\n    }\n  }\n  declarePrivateName(name, elementType, loc) {\n    const {\n      privateNames,\n      loneAccessors,\n      undefinedPrivateNames\n    } = this.current();\n    let redefined = privateNames.has(name);\n    if (elementType & 3) {\n      const accessor = redefined && loneAccessors.get(name);\n      if (accessor) {\n        const oldStatic = accessor & 4;\n        const newStatic = elementType & 4;\n        const oldKind = accessor & 3;\n        const newKind = elementType & 3;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) loneAccessors.delete(name);\n      } else if (!redefined) {\n        loneAccessors.set(name, elementType);\n      }\n    }\n    if (redefined) {\n      this.parser.raise(Errors.PrivateNameRedeclaration, loc, {\n        identifierName: name\n      });\n    }\n    privateNames.add(name);\n    undefinedPrivateNames.delete(name);\n  }\n  usePrivateName(name, loc) {\n    let classScope;\n    for (classScope of this.stack) {\n      if (classScope.privateNames.has(name)) return;\n    }\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, loc);\n    } else {\n      this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {\n        identifierName: name\n      });\n    }\n  }\n}\nclass ExpressionScope {\n  constructor(type = 0) {\n    this.type = type;\n  }\n  canBeArrowParameterDeclaration() {\n    return this.type === 2 || this.type === 1;\n  }\n  isCertainlyParameterDeclaration() {\n    return this.type === 3;\n  }\n}\nclass ArrowHeadParsingScope extends ExpressionScope {\n  constructor(type) {\n    super(type);\n    this.declarationErrors = new Map();\n  }\n  recordDeclarationError(ParsingErrorClass, at) {\n    const index = at.index;\n    this.declarationErrors.set(index, [ParsingErrorClass, at]);\n  }\n  clearDeclarationError(index) {\n    this.declarationErrors.delete(index);\n  }\n  iterateErrors(iterator) {\n    this.declarationErrors.forEach(iterator);\n  }\n}\nclass ExpressionScopeHandler {\n  constructor(parser) {\n    this.parser = void 0;\n    this.stack = [new ExpressionScope()];\n    this.parser = parser;\n  }\n  enter(scope) {\n    this.stack.push(scope);\n  }\n  exit() {\n    this.stack.pop();\n  }\n  recordParameterInitializerError(toParseError, node) {\n    const origin = node.loc.start;\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (!scope.isCertainlyParameterDeclaration()) {\n      if (scope.canBeArrowParameterDeclaration()) {\n        scope.recordDeclarationError(toParseError, origin);\n      } else {\n        return;\n      }\n      scope = stack[--i];\n    }\n    this.parser.raise(toParseError, origin);\n  }\n  recordArrowParameterBindingError(error, node) {\n    const {\n      stack\n    } = this;\n    const scope = stack[stack.length - 1];\n    const origin = node.loc.start;\n    if (scope.isCertainlyParameterDeclaration()) {\n      this.parser.raise(error, origin);\n    } else if (scope.canBeArrowParameterDeclaration()) {\n      scope.recordDeclarationError(error, origin);\n    } else {\n      return;\n    }\n  }\n  recordAsyncArrowParametersError(at) {\n    const {\n      stack\n    } = this;\n    let i = stack.length - 1;\n    let scope = stack[i];\n    while (scope.canBeArrowParameterDeclaration()) {\n      if (scope.type === 2) {\n        scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);\n      }\n      scope = stack[--i];\n    }\n  }\n  validateAsPattern() {\n    const {\n      stack\n    } = this;\n    const currentScope = stack[stack.length - 1];\n    if (!currentScope.canBeArrowParameterDeclaration()) return;\n    currentScope.iterateErrors(([toParseError, loc]) => {\n      this.parser.raise(toParseError, loc);\n      let i = stack.length - 2;\n      let scope = stack[i];\n      while (scope.canBeArrowParameterDeclaration()) {\n        scope.clearDeclarationError(loc.index);\n        scope = stack[--i];\n      }\n    });\n  }\n}\nfunction newParameterDeclarationScope() {\n  return new ExpressionScope(3);\n}\nfunction newArrowHeadScope() {\n  return new ArrowHeadParsingScope(1);\n}\nfunction newAsyncArrowScope() {\n  return new ArrowHeadParsingScope(2);\n}\nfunction newExpressionScope() {\n  return new ExpressionScope();\n}\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, value, enumerable = true) {\n    if (!node) return;\n    let {\n      extra\n    } = node;\n    if (extra == null) {\n      extra = {};\n      node.extra = extra;\n    }\n    if (enumerable) {\n      extra[key] = value;\n    } else {\n      Object.defineProperty(extra, key, {\n        enumerable,\n        value\n      });\n    }\n  }\n  isContextual(token) {\n    return this.state.type === token && !this.state.containsEsc;\n  }\n  isUnparsedContextual(nameStart, name) {\n    if (this.input.startsWith(name, nameStart)) {\n      const nextCh = this.input.charCodeAt(nameStart + name.length);\n      return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);\n    }\n    return false;\n  }\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n  eatContextual(token) {\n    if (this.isContextual(token)) {\n      this.next();\n      return true;\n    }\n    return false;\n  }\n  expectContextual(token, toParseError) {\n    if (!this.eatContextual(token)) {\n      if (toParseError != null) {\n        throw this.raise(toParseError, this.state.startLoc);\n      }\n      this.unexpected(null, token);\n    }\n  }\n  canInsertSemicolon() {\n    return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();\n  }\n  hasPrecedingLineBreak() {\n    return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);\n  }\n  hasFollowingLineBreak() {\n    return hasNewLine(this.input, this.state.end, this.nextTokenStart());\n  }\n  isLineTerminator() {\n    return this.eat(13) || this.canInsertSemicolon();\n  }\n  semicolon(allowAsi = true) {\n    if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;\n    this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);\n  }\n  expect(type, loc) {\n    if (!this.eat(type)) {\n      this.unexpected(loc, type);\n    }\n  }\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        this.state.tokensLength = failState.tokensLength;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n      return {\n        node: node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n      throw error;\n    }\n  }\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssignLoc,\n      doubleProtoLoc,\n      privateKeyLoc,\n      optionalParametersLoc,\n      voidPatternLoc\n    } = refExpressionErrors;\n    const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc || !!voidPatternLoc;\n    if (!andThrow) {\n      return hasErrors;\n    }\n    if (shorthandAssignLoc != null) {\n      this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n    }\n    if (doubleProtoLoc != null) {\n      this.raise(Errors.DuplicateProto, doubleProtoLoc);\n    }\n    if (privateKeyLoc != null) {\n      this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n    }\n    if (optionalParametersLoc != null) {\n      this.unexpected(optionalParametersLoc);\n    }\n    if (voidPatternLoc != null) {\n      this.raise(Errors.InvalidCoverDiscardElement, voidPatternLoc);\n    }\n  }\n  isLiteralPropertyName() {\n    return tokenIsLiteralPropertyName(this.state.type);\n  }\n  isPrivateName(node) {\n    return node.type === \"PrivateName\";\n  }\n  getPrivateNameSV(node) {\n    return node.id.name;\n  }\n  hasPropertyAsPrivateName(node) {\n    return (node.type === \"MemberExpression\" || node.type === \"OptionalMemberExpression\") && this.isPrivateName(node.property);\n  }\n  isObjectProperty(node) {\n    return node.type === \"ObjectProperty\";\n  }\n  isObjectMethod(node) {\n    return node.type === \"ObjectMethod\";\n  }\n  initializeScopes(inModule = this.options.sourceType === \"module\") {\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    const oldExportedIdentifiers = this.exportedIdentifiers;\n    this.exportedIdentifiers = new Set();\n    const oldInModule = this.inModule;\n    this.inModule = inModule;\n    const oldScope = this.scope;\n    const ScopeHandler = this.getScopeHandler();\n    this.scope = new ScopeHandler(this, inModule);\n    const oldProdParam = this.prodParam;\n    this.prodParam = new ProductionParameterHandler();\n    const oldClassScope = this.classScope;\n    this.classScope = new ClassScopeHandler(this);\n    const oldExpressionScope = this.expressionScope;\n    this.expressionScope = new ExpressionScopeHandler(this);\n    return () => {\n      this.state.labels = oldLabels;\n      this.exportedIdentifiers = oldExportedIdentifiers;\n      this.inModule = oldInModule;\n      this.scope = oldScope;\n      this.prodParam = oldProdParam;\n      this.classScope = oldClassScope;\n      this.expressionScope = oldExpressionScope;\n    };\n  }\n  enterInitialScopes() {\n    let paramFlags = 0;\n    if (this.inModule || this.optionFlags & 1) {\n      paramFlags |= 2;\n    }\n    if (this.optionFlags & 32) {\n      paramFlags |= 1;\n    }\n    const isCommonJS = !this.inModule && this.options.sourceType === \"commonjs\";\n    if (isCommonJS || this.optionFlags & 2) {\n      paramFlags |= 4;\n    }\n    this.prodParam.enter(paramFlags);\n    let scopeFlags = isCommonJS ? 514 : 1;\n    if (this.optionFlags & 4) {\n      scopeFlags |= 512;\n    }\n    this.scope.enter(scopeFlags);\n  }\n  checkDestructuringPrivate(refExpressionErrors) {\n    const {\n      privateKeyLoc\n    } = refExpressionErrors;\n    if (privateKeyLoc !== null) {\n      this.expectPlugin(\"destructuringPrivate\", privateKeyLoc);\n    }\n  }\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssignLoc = null;\n    this.doubleProtoLoc = null;\n    this.privateKeyLoc = null;\n    this.optionalParametersLoc = null;\n    this.voidPatternLoc = null;\n  }\n}\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if ((parser == null ? void 0 : parser.optionFlags) & 128) this.range = [pos, 0];\n    if (parser != null && parser.filename) this.loc.filename = parser.filename;\n  }\n}\nconst NodePrototype = Node.prototype;\nNodePrototype.__clone = function () {\n  const newNode = new Node(undefined, this.start, this.loc.start);\n  const keys = Object.keys(this);\n  for (let i = 0, length = keys.length; i < length; i++) {\n    const key = keys[i];\n    if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n      newNode[key] = this[key];\n    }\n  }\n  return newNode;\n};\nclass NodeUtils extends UtilParser {\n  startNode() {\n    const loc = this.state.startLoc;\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAt(loc) {\n    return new Node(this, loc.index, loc);\n  }\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.loc.start);\n  }\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEndLoc);\n  }\n  finishNodeAt(node, type, endLoc) {\n    node.type = type;\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.optionFlags & 128) node.range[1] = endLoc.index;\n    if (this.optionFlags & 4096) {\n      this.processComment(node);\n    }\n    return node;\n  }\n  resetStartLocation(node, startLoc) {\n    node.start = startLoc.index;\n    node.loc.start = startLoc;\n    if (this.optionFlags & 128) node.range[0] = startLoc.index;\n  }\n  resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {\n    node.end = endLoc.index;\n    node.loc.end = endLoc;\n    if (this.optionFlags & 128) node.range[1] = endLoc.index;\n  }\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.loc.start);\n  }\n  castNodeTo(node, type) {\n    node.type = type;\n    return node;\n  }\n  cloneIdentifier(node) {\n    const {\n      type,\n      start,\n      end,\n      loc,\n      range,\n      name\n    } = node;\n    const cloned = Object.create(NodePrototype);\n    cloned.type = type;\n    cloned.start = start;\n    cloned.end = end;\n    cloned.loc = loc;\n    cloned.range = range;\n    cloned.name = name;\n    if (node.extra) cloned.extra = node.extra;\n    return cloned;\n  }\n  cloneStringLiteral(node) {\n    const {\n      type,\n      start,\n      end,\n      loc,\n      range,\n      extra\n    } = node;\n    const cloned = Object.create(NodePrototype);\n    cloned.type = type;\n    cloned.start = start;\n    cloned.end = end;\n    cloned.loc = loc;\n    cloned.range = range;\n    cloned.extra = extra;\n    cloned.value = node.value;\n    return cloned;\n  }\n}\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\nclass LValParser extends NodeUtils {\n  toAssignable(node, isLHS = false) {\n    var _node$extra, _node$extra3;\n    let parenthesized = undefined;\n    if (node.type === \"ParenthesizedExpression\" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {\n      parenthesized = unwrapParenthesizedExpression(node);\n      if (isLHS) {\n        if (parenthesized.type === \"Identifier\") {\n          this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);\n        } else if (parenthesized.type !== \"CallExpression\" && parenthesized.type !== \"MemberExpression\" && !this.isOptionalMemberExpression(parenthesized)) {\n          this.raise(Errors.InvalidParenthesizedAssignment, node);\n        }\n      } else {\n        this.raise(Errors.InvalidParenthesizedAssignment, node);\n      }\n    }\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n      case \"VoidPattern\":\n        break;\n      case \"ObjectExpression\":\n        this.castNodeTo(node, \"ObjectPattern\");\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast, isLHS);\n          if (isLast && prop.type === \"RestElement\" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {\n            this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);\n          }\n        }\n        break;\n      case \"ObjectProperty\":\n        {\n          const {\n            key,\n            value\n          } = node;\n          if (this.isPrivateName(key)) {\n            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);\n          }\n          this.toAssignable(value, isLHS);\n          break;\n        }\n      case \"SpreadElement\":\n        {\n          throw new Error(\"Internal @babel/parser error (this is a bug, please report it).\" + \" SpreadElement should be converted by .toAssignable's caller.\");\n        }\n      case \"ArrayExpression\":\n        this.castNodeTo(node, \"ArrayPattern\");\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(Errors.MissingEqInAssignment, node.left.loc.end);\n        }\n        this.castNodeTo(node, \"AssignmentPattern\");\n        delete node.operator;\n        if (node.left.type === \"VoidPattern\") {\n          this.raise(Errors.VoidPatternInitializer, node.left);\n        }\n        this.toAssignable(node.left, isLHS);\n        break;\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized, isLHS);\n        break;\n    }\n  }\n  toAssignableObjectExpressionProp(prop, isLast, isLHS) {\n    if (prop.type === \"ObjectMethod\") {\n      this.raise(prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);\n    } else if (prop.type === \"SpreadElement\") {\n      this.castNodeTo(prop, \"RestElement\");\n      const arg = prop.argument;\n      this.checkToRestConversion(arg, false);\n      this.toAssignable(arg, isLHS);\n      if (!isLast) {\n        this.raise(Errors.RestTrailingComma, prop);\n      }\n    } else {\n      this.toAssignable(prop, isLHS);\n    }\n  }\n  toAssignableList(exprList, trailingCommaLoc, isLHS) {\n    const end = exprList.length - 1;\n    for (let i = 0; i <= end; i++) {\n      const elt = exprList[i];\n      if (!elt) continue;\n      this.toAssignableListItem(exprList, i, isLHS);\n      if (elt.type === \"RestElement\") {\n        if (i < end) {\n          this.raise(Errors.RestTrailingComma, elt);\n        } else if (trailingCommaLoc) {\n          this.raise(Errors.RestTrailingComma, trailingCommaLoc);\n        }\n      }\n    }\n  }\n  toAssignableListItem(exprList, index, isLHS) {\n    const node = exprList[index];\n    if (node.type === \"SpreadElement\") {\n      this.castNodeTo(node, \"RestElement\");\n      const arg = node.argument;\n      this.checkToRestConversion(arg, true);\n      this.toAssignable(arg, isLHS);\n    } else {\n      this.toAssignable(node, isLHS);\n    }\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"RestElement\":\n      case \"VoidPattern\":\n        return true;\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type !== \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n      case \"ArrayExpression\":\n        return node.elements.every(element => element === null || this.isAssignable(element));\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n      case \"ParenthesizedExpression\":\n        return this.isAssignable(node.expression);\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n      default:\n        return false;\n    }\n  }\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n    for (const expr of exprList) {\n      if ((expr == null ? void 0 : expr.type) === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n  parseSpread(refExpressionErrors) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    const argument = this.parseBindingAtom();\n    if (argument.type === \"VoidPattern\") {\n      this.raise(Errors.UnexpectedVoidPattern, argument);\n    }\n    node.argument = argument;\n    return this.finishNode(node, \"RestElement\");\n  }\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case 0:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(3, 93, 1);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n      case 5:\n        return this.parseObjectLike(8, true);\n      case 88:\n        return this.parseVoidPattern(null);\n    }\n    return this.parseIdentifier();\n  }\n  parseBindingList(close, closeCharCode, flags) {\n    const allowEmpty = flags & 1;\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n      }\n      if (allowEmpty && this.match(12)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(21)) {\n        let rest = this.parseRestBinding();\n        if (this.hasPlugin(\"flow\") || flags & 2) {\n          rest = this.parseFunctionParamType(rest);\n        }\n        elts.push(rest);\n        if (!this.checkCommaAfterRest(closeCharCode)) {\n          this.expect(close);\n          break;\n        }\n      } else {\n        const decorators = [];\n        if (flags & 2) {\n          if (this.match(26) && this.hasPlugin(\"decorators\")) {\n            this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);\n          }\n          while (this.match(26)) {\n            decorators.push(this.parseDecorator());\n          }\n        }\n        elts.push(this.parseBindingElement(flags, decorators));\n      }\n    }\n    return elts;\n  }\n  parseBindingRestProperty(prop) {\n    this.next();\n    if (this.hasPlugin(\"discardBinding\") && this.match(88)) {\n      prop.argument = this.parseVoidPattern(null);\n      this.raise(Errors.UnexpectedVoidPattern, prop.argument);\n    } else {\n      prop.argument = this.parseIdentifier();\n    }\n    this.checkCommaAfterRest(125);\n    return this.finishNode(prop, \"RestElement\");\n  }\n  parseBindingProperty() {\n    const {\n      type,\n      startLoc\n    } = this.state;\n    if (type === 21) {\n      return this.parseBindingRestProperty(this.startNode());\n    }\n    const prop = this.startNode();\n    if (type === 139) {\n      this.expectPlugin(\"destructuringPrivate\", startLoc);\n      this.classScope.usePrivateName(this.state.value, startLoc);\n      prop.key = this.parsePrivateName();\n    } else {\n      this.parsePropertyName(prop);\n    }\n    prop.method = false;\n    return this.parseObjPropValue(prop, startLoc, false, false, true, false);\n  }\n  parseBindingElement(flags, decorators) {\n    const left = this.parseMaybeDefault();\n    if (this.hasPlugin(\"flow\") || flags & 2) {\n      this.parseFunctionParamType(left);\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n      this.resetStartLocationFromNode(left, decorators[0]);\n    }\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    return elt;\n  }\n  parseFunctionParamType(param) {\n    return param;\n  }\n  parseMaybeDefault(startLoc, left) {\n    startLoc != null ? startLoc : startLoc = this.state.startLoc;\n    left = left != null ? left : this.parseBindingAtom();\n    if (!this.eat(29)) return left;\n    const node = this.startNodeAt(startLoc);\n    if (left.type === \"VoidPattern\") {\n      this.raise(Errors.VoidPatternInitializer, left);\n    }\n    node.left = left;\n    node.right = this.parseMaybeAssignAllowIn();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n  isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {\n    switch (type) {\n      case \"AssignmentPattern\":\n        return \"left\";\n      case \"RestElement\":\n        return \"argument\";\n      case \"ObjectProperty\":\n        return \"value\";\n      case \"ParenthesizedExpression\":\n        return \"expression\";\n      case \"ArrayPattern\":\n        return \"elements\";\n      case \"ObjectPattern\":\n        return \"properties\";\n      case \"VoidPattern\":\n        return true;\n      case \"CallExpression\":\n        if (!disallowCallExpression && !this.state.strict && this.optionFlags & 8192) {\n          return true;\n        }\n    }\n    return false;\n  }\n  isOptionalMemberExpression(expression) {\n    return expression.type === \"OptionalMemberExpression\";\n  }\n  checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false, disallowCallExpression = false) {\n    var _expression$extra;\n    const type = expression.type;\n    if (this.isObjectMethod(expression)) return;\n    const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);\n    if (isOptionalMemberExpression || type === \"MemberExpression\") {\n      if (isOptionalMemberExpression) {\n        this.expectPlugin(\"optionalChainingAssign\", expression.loc.start);\n        if (ancestor.type !== \"AssignmentExpression\") {\n          this.raise(Errors.InvalidLhsOptionalChaining, expression, {\n            ancestor\n          });\n        }\n      }\n      if (binding !== 64) {\n        this.raise(Errors.InvalidPropertyBindingPattern, expression);\n      }\n      return;\n    }\n    if (type === \"Identifier\") {\n      this.checkIdentifier(expression, binding, strictModeChanged);\n      const {\n        name\n      } = expression;\n      if (checkClashes) {\n        if (checkClashes.has(name)) {\n          this.raise(Errors.ParamDupe, expression);\n        } else {\n          checkClashes.add(name);\n        }\n      }\n      return;\n    } else if (type === \"VoidPattern\" && ancestor.type === \"CatchClause\") {\n      this.raise(Errors.VoidPatternCatchClauseParam, expression);\n    }\n    const unwrappedExpression = unwrapParenthesizedExpression(expression);\n    disallowCallExpression || (disallowCallExpression = unwrappedExpression.type === \"CallExpression\" && (unwrappedExpression.callee.type === \"Import\" || unwrappedExpression.callee.type === \"Super\"));\n    const validity = this.isValidLVal(type, disallowCallExpression, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === \"AssignmentExpression\", binding);\n    if (validity === true) return;\n    if (validity === false) {\n      const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;\n      this.raise(ParseErrorClass, expression, {\n        ancestor\n      });\n      return;\n    }\n    let key, isParenthesizedExpression;\n    if (typeof validity === \"string\") {\n      key = validity;\n      isParenthesizedExpression = type === \"ParenthesizedExpression\";\n    } else {\n      [key, isParenthesizedExpression] = validity;\n    }\n    const nextAncestor = type === \"ArrayPattern\" || type === \"ObjectPattern\" ? {\n      type\n    } : ancestor;\n    const val = expression[key];\n    if (Array.isArray(val)) {\n      for (const child of val) {\n        if (child) {\n          this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression, true);\n        }\n      }\n    } else if (val) {\n      this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression, disallowCallExpression);\n    }\n  }\n  checkIdentifier(at, bindingType, strictModeChanged = false) {\n    if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {\n      if (bindingType === 64) {\n        this.raise(Errors.StrictEvalArguments, at, {\n          referenceName: at.name\n        });\n      } else {\n        this.raise(Errors.StrictEvalArgumentsBinding, at, {\n          bindingName: at.name\n        });\n      }\n    }\n    if (bindingType & 8192 && at.name === \"let\") {\n      this.raise(Errors.LetInLexicalBinding, at);\n    }\n    if (!(bindingType & 64)) {\n      this.declareNameFromIdentifier(at, bindingType);\n    }\n  }\n  declareNameFromIdentifier(identifier, binding) {\n    this.scope.declareName(identifier.name, binding, identifier.loc.start);\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.checkToRestConversion(node.expression, allowPattern);\n        break;\n      case \"Identifier\":\n      case \"MemberExpression\":\n        break;\n      case \"ArrayExpression\":\n      case \"ObjectExpression\":\n        if (allowPattern) break;\n      default:\n        this.raise(Errors.InvalidRestAssignmentPattern, node);\n    }\n  }\n  checkCommaAfterRest(close) {\n    if (!this.match(12)) {\n      return false;\n    }\n    this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);\n    return true;\n  }\n}\nconst keywordAndTSRelationalOperator = /in(?:stanceof)?|as|satisfies/y;\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n  return x;\n}\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\nconst TSErrors = ParseErrorEnum`typescript`({\n  AbstractMethodHasImplementation: ({\n    methodName\n  }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,\n  AbstractPropertyHasInitializer: ({\n    propertyName\n  }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,\n  AccessorCannotBeOptional: \"An 'accessor' property cannot be declared optional.\",\n  AccessorCannotDeclareThisParameter: \"'get' and 'set' accessors cannot declare 'this' parameters.\",\n  AccessorCannotHaveTypeParameters: \"An accessor cannot have type parameters.\",\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier.\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier.\",\n  ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: \"A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.\",\n  ConstructorHasTypeParameters: \"Type parameters cannot appear on a constructor declaration.\",\n  DeclareAccessor: ({\n    kind\n  }) => `'declare' is not allowed in ${kind}ters.`,\n  DeclareClassFieldHasInitializer: \"Initializers are not allowed in ambient contexts.\",\n  DeclareFunctionHasImplementation: \"An implementation cannot be declared in ambient contexts.\",\n  DuplicateAccessibilityModifier: ({\n    modifier\n  }) => `Accessibility modifier already seen: '${modifier}'.`,\n  DuplicateModifier: ({\n    modifier\n  }) => `Duplicate modifier: '${modifier}'.`,\n  EmptyHeritageClauseType: ({\n    token\n  }) => `'${token}' list cannot be empty.`,\n  EmptyTypeArguments: \"Type argument list cannot be empty.\",\n  EmptyTypeParameters: \"Type parameter list cannot be empty.\",\n  ExpectedAmbientAfterExportDeclare: \"'export declare' must be followed by an ambient declaration.\",\n  ImportAliasHasImportType: \"An import alias can not use 'import type'.\",\n  ImportReflectionHasImportType: \"An `import module` declaration can not use `type` modifier\",\n  IncompatibleModifiers: ({\n    modifiers\n  }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier.\",\n  IndexSignatureHasAccessibility: ({\n    modifier\n  }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,\n  IndexSignatureHasDeclare: \"Index signatures cannot have the 'declare' modifier.\",\n  IndexSignatureHasOverride: \"'override' modifier cannot appear on an index signature.\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier.\",\n  InitializerNotAllowedInAmbientContext: \"Initializers are not allowed in ambient contexts.\",\n  InvalidHeritageClauseType: ({\n    token\n  }) => `'${token}' list can only include identifiers or qualified-names with optional type arguments.`,\n  InvalidModifierOnAwaitUsingDeclaration: modifier => `'${modifier}' modifier cannot appear on an await using declaration.`,\n  InvalidModifierOnTypeMember: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type member.`,\n  InvalidModifierOnTypeParameter: ({\n    modifier\n  }) => `'${modifier}' modifier cannot appear on a type parameter.`,\n  InvalidModifierOnTypeParameterPositions: ({\n    modifier\n  }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,\n  InvalidModifierOnUsingDeclaration: modifier => `'${modifier}' modifier cannot appear on a using declaration.`,\n  InvalidModifiersOrder: ({\n    orderedModifiers\n  }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,\n  InvalidPropertyAccessAfterInstantiationExpression: \"Invalid property access after an instantiation expression. \" + \"You can either wrap the instantiation expression in parentheses, or delete the type arguments.\",\n  InvalidTupleMemberLabel: \"Tuple members must be labeled with a simple identifier.\",\n  MissingInterfaceName: \"'interface' declarations must be followed by an identifier.\",\n  NonAbstractClassHasAbstractMethod: \"Abstract methods can only appear within an abstract class.\",\n  NonClassMethodPropertyHasAbstractModifier: \"'abstract' modifier can only appear on a class, method, or property declaration.\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  OverrideNotInSubClass: \"This member cannot have an 'override' modifier because its containing class does not extend another class.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: ({\n    modifier\n  }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,\n  ReadonlyForMethodSignature: \"'readonly' modifier can only appear on a property declaration or index signature.\",\n  ReservedArrowTypeParam: \"This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.\",\n  ReservedTypeAssertion: \"This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.\",\n  SetAccessorCannotHaveOptionalParameter: \"A 'set' accessor cannot have an optional parameter.\",\n  SetAccessorCannotHaveRestParameter: \"A 'set' accessor cannot have rest parameter.\",\n  SetAccessorCannotHaveReturnType: \"A 'set' accessor cannot have a return type annotation.\",\n  SingleTypeParameterWithoutTrailingComma: ({\n    typeParameterName\n  }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,\n  StaticBlockCannotHaveModifier: \"Static class blocks cannot have any modifier.\",\n  TupleOptionalAfterType: \"A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.\",\n  TypeImportCannotSpecifyDefaultAndNamed: \"A type-only import can specify a default import or named bindings, but not both.\",\n  TypeModifierIsUsedInTypeExports: \"The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.\",\n  TypeModifierIsUsedInTypeImports: \"The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.\",\n  UnexpectedParameterModifier: \"A parameter property is only allowed in a constructor implementation.\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal.\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: ({\n    type\n  }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`,\n  UsingDeclarationInAmbientContext: kind => `'${kind}' declarations are not allowed in ambient contexts.`\n});\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n    case \"never\":\n      return \"TSNeverKeyword\";\n    case \"number\":\n      return \"TSNumberKeyword\";\n    case \"object\":\n      return \"TSObjectKeyword\";\n    case \"string\":\n      return \"TSStringKeyword\";\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n    default:\n      return undefined;\n  }\n}\nfunction tsIsAccessModifier(modifier) {\n  return modifier === \"private\" || modifier === \"public\" || modifier === \"protected\";\n}\nfunction tsIsVarianceAnnotations(modifier) {\n  return modifier === \"in\" || modifier === \"out\";\n}\nvar typescript = superClass => class TypeScriptParserMixin extends superClass {\n  constructor(...args) {\n    super(...args);\n    this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\"],\n      disallowedModifiers: [\"const\", \"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n    this.tsParseConstModifier = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"const\"],\n      disallowedModifiers: [\"in\", \"out\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    });\n    this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {\n      allowedModifiers: [\"in\", \"out\", \"const\"],\n      disallowedModifiers: [\"public\", \"private\", \"protected\", \"readonly\", \"declare\", \"abstract\", \"override\"],\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameter\n    });\n  }\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n  tsIsIdentifier() {\n    return tokenIsIdentifier(this.state.type);\n  }\n  tsTokenCanFollowModifier() {\n    return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();\n  }\n  tsNextTokenOnSameLineAndCanFollowModifier() {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      return false;\n    }\n    return this.tsTokenCanFollowModifier();\n  }\n  tsNextTokenCanFollowModifier() {\n    if (this.match(106)) {\n      this.next();\n      return this.tsTokenCanFollowModifier();\n    }\n    return this.tsNextTokenOnSameLineAndCanFollowModifier();\n  }\n  tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {\n    if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {\n      return undefined;\n    }\n    const modifier = this.state.value;\n    if (allowedModifiers.includes(modifier)) {\n      if (hasSeenStaticModifier && this.match(106)) {\n        return undefined;\n      }\n      if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {\n        return undefined;\n      }\n      if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n        return modifier;\n      }\n    }\n    return undefined;\n  }\n  tsParseModifiers({\n    allowedModifiers,\n    disallowedModifiers,\n    stopOnStartOfClassStaticBlock,\n    errorTemplate = TSErrors.InvalidModifierOnTypeMember\n  }, modified) {\n    const enforceOrder = (loc, modifier, before, after) => {\n      if (modifier === before && modified[after]) {\n        this.raise(TSErrors.InvalidModifiersOrder, loc, {\n          orderedModifiers: [before, after]\n        });\n      }\n    };\n    const incompatible = (loc, modifier, mod1, mod2) => {\n      if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {\n        this.raise(TSErrors.IncompatibleModifiers, loc, {\n          modifiers: [mod1, mod2]\n        });\n      }\n    };\n    for (;;) {\n      const {\n        startLoc\n      } = this.state;\n      const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock, modified.static);\n      if (!modifier) break;\n      if (tsIsAccessModifier(modifier)) {\n        if (modified.accessibility) {\n          this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, modifier, \"override\");\n          enforceOrder(startLoc, modifier, modifier, \"static\");\n          enforceOrder(startLoc, modifier, modifier, \"readonly\");\n          modified.accessibility = modifier;\n        }\n      } else if (tsIsVarianceAnnotations(modifier)) {\n        if (modified[modifier]) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        }\n        modified[modifier] = true;\n        enforceOrder(startLoc, modifier, \"in\", \"out\");\n      } else {\n        if (hasOwnProperty.call(modified, modifier)) {\n          this.raise(TSErrors.DuplicateModifier, startLoc, {\n            modifier\n          });\n        } else {\n          enforceOrder(startLoc, modifier, \"static\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"static\", \"override\");\n          enforceOrder(startLoc, modifier, \"override\", \"readonly\");\n          enforceOrder(startLoc, modifier, \"abstract\", \"override\");\n          incompatible(startLoc, modifier, \"declare\", \"override\");\n          incompatible(startLoc, modifier, \"static\", \"abstract\");\n        }\n        modified[modifier] = true;\n      }\n      if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {\n        this.raise(errorTemplate, startLoc, {\n          modifier\n        });\n      }\n    }\n  }\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(8);\n      case \"HeritageClauseElement\":\n        return this.match(5);\n      case \"TupleElementTypes\":\n        return this.match(3);\n      case \"TypeParametersOrArguments\":\n        return this.match(48);\n    }\n  }\n  tsParseList(kind, parseElement) {\n    const result = [];\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n    return result;\n  }\n  tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));\n  }\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {\n    const result = [];\n    let trailingCommaPos = -1;\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      trailingCommaPos = -1;\n      const element = parseElement();\n      if (element == null) {\n        return undefined;\n      }\n      result.push(element);\n      if (this.eat(12)) {\n        trailingCommaPos = this.state.lastTokStartLoc.index;\n        continue;\n      }\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n      if (expectSuccess) {\n        this.expect(12);\n      }\n      return undefined;\n    }\n    if (refTrailingCommaPos) {\n      refTrailingCommaPos.value = trailingCommaPos;\n    }\n    return result;\n  }\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(0);\n      } else {\n        this.expect(47);\n      }\n    }\n    const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);\n    if (bracket) {\n      this.expect(3);\n    } else {\n      this.expect(48);\n    }\n    return result;\n  }\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(83);\n    this.expect(10);\n    if (!this.match(134)) {\n      this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);\n      node.argument = super.parseExprAtom();\n    } else {\n      node.argument = this.parseStringLiteral(this.state.value);\n    }\n    if (this.eat(12)) {\n      node.options = this.tsParseImportTypeOptions();\n    } else {\n      node.options = null;\n    }\n    this.expect(11);\n    if (this.eat(16)) {\n      node.qualifier = this.tsParseEntityName(1 | 2);\n    }\n    if (this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSImportType\");\n  }\n  tsParseImportTypeOptions() {\n    const node = this.startNode();\n    this.expect(5);\n    const withProperty = this.startNode();\n    if (this.isContextual(76)) {\n      withProperty.method = false;\n      withProperty.key = this.parseIdentifier(true);\n      withProperty.computed = false;\n      withProperty.shorthand = false;\n    } else {\n      this.unexpected(null, 76);\n    }\n    this.expect(14);\n    withProperty.value = this.tsParseImportTypeWithPropertyValue();\n    node.properties = [this.finishObjectProperty(withProperty)];\n    this.eat(12);\n    this.expect(8);\n    return this.finishNode(node, \"ObjectExpression\");\n  }\n  tsParseImportTypeWithPropertyValue() {\n    const node = this.startNode();\n    const properties = [];\n    this.expect(5);\n    while (!this.match(8)) {\n      const type = this.state.type;\n      if (tokenIsIdentifier(type) || type === 134) {\n        properties.push(super.parsePropertyDefinition(null));\n      } else {\n        this.unexpected();\n      }\n      this.eat(12);\n    }\n    node.properties = properties;\n    this.next();\n    return this.finishNode(node, \"ObjectExpression\");\n  }\n  tsParseEntityName(flags) {\n    let entity;\n    if (flags & 1 && this.match(78)) {\n      if (flags & 2) {\n        entity = this.parseIdentifier(true);\n      } else {\n        const node = this.startNode();\n        this.next();\n        entity = this.finishNode(node, \"ThisExpression\");\n      }\n    } else {\n      entity = this.parseIdentifier(!!(flags & 1));\n    }\n    while (this.eat(16)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(!!(flags & 1));\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n    return entity;\n  }\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName(1);\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    node.asserts = false;\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(87);\n    if (this.match(83)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName(1 | 2);\n    }\n    if (!this.hasPrecedingLineBreak() && this.match(47)) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n  tsParseTypeParameter(parseModifiers) {\n    const node = this.startNode();\n    parseModifiers(node);\n    node.name = this.tsParseTypeParameterName();\n    node.constraint = this.tsEatThenParseType(81);\n    node.default = this.tsEatThenParseType(29);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n  tsTryParseTypeParameters(parseModifiers) {\n    if (this.match(47)) {\n      return this.tsParseTypeParameters(parseModifiers);\n    }\n  }\n  tsParseTypeParameters(parseModifiers) {\n    const node = this.startNode();\n    if (this.match(47) || this.match(143)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n    const refTrailingCommaPos = {\n      value: -1\n    };\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeParameters, node);\n    }\n    if (refTrailingCommaPos.value !== -1) {\n      this.addExtra(node, \"trailingComma\", refTrailingCommaPos.value);\n    }\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === 19;\n    const paramsKey = \"parameters\";\n    const returnTypeKey = \"typeAnnotation\";\n    signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    this.expect(10);\n    signature[paramsKey] = this.tsParseBindingListForSignature();\n    if (returnTokenRequired) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n  tsParseBindingListForSignature() {\n    const list = super.parseBindingList(11, 41, 2);\n    for (const pattern of list) {\n      const {\n        type\n      } = pattern;\n      if (type === \"AssignmentPattern\" || type === \"TSParameterProperty\") {\n        this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {\n          type\n        });\n      }\n    }\n    return list;\n  }\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(12) && !this.isLineTerminator()) {\n      this.expect(13);\n    }\n  }\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(14, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    if (tokenIsIdentifier(this.state.type)) {\n      this.next();\n      return this.match(14);\n    }\n    return false;\n  }\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return;\n    }\n    this.expect(0);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(3);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(17)) node.optional = true;\n    if (this.match(10) || this.match(47)) {\n      if (readonly) {\n        this.raise(TSErrors.ReadonlyForMethodSignature, node);\n      }\n      const method = node;\n      if (method.kind && this.match(47)) {\n        this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());\n      }\n      this.tsFillSignature(14, method);\n      this.tsParseTypeMemberSemicolon();\n      const paramsKey = \"parameters\";\n      const returnTypeKey = \"typeAnnotation\";\n      if (method.kind === \"get\") {\n        if (method[paramsKey].length > 0) {\n          this.raise(Errors.BadGetterArity, this.state.curPosition());\n          if (this.isThisParam(method[paramsKey][0])) {\n            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());\n          }\n        }\n      } else if (method.kind === \"set\") {\n        if (method[paramsKey].length !== 1) {\n          this.raise(Errors.BadSetterArity, this.state.curPosition());\n        } else {\n          const firstParameter = method[paramsKey][0];\n          if (this.isThisParam(firstParameter)) {\n            this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"Identifier\" && firstParameter.optional) {\n            this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());\n          }\n          if (firstParameter.type === \"RestElement\") {\n            this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());\n          }\n        }\n        if (method[returnTypeKey]) {\n          this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);\n        }\n      } else {\n        method.kind = \"method\";\n      }\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = node;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n  tsParseTypeMember() {\n    const node = this.startNode();\n    if (this.match(10) || this.match(47)) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n    if (this.match(77)) {\n      const id = this.startNode();\n      this.next();\n      if (this.match(10) || this.match(47)) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n    this.tsParseModifiers({\n      allowedModifiers: [\"readonly\"],\n      disallowedModifiers: [\"declare\", \"abstract\", \"private\", \"protected\", \"public\", \"static\", \"override\"]\n    }, node);\n    const idx = this.tsTryParseIndexSignature(node);\n    if (idx) {\n      return idx;\n    }\n    super.parsePropertyName(node);\n    if (!node.computed && node.key.type === \"Identifier\" && (node.key.name === \"get\" || node.key.name === \"set\") && this.tsTokenCanFollowModifier()) {\n      node.kind = node.key.name;\n      super.parsePropertyName(node);\n      if (!this.match(10) && !this.match(47)) {\n        this.unexpected(null, 10);\n      }\n    }\n    return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);\n  }\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n  tsParseObjectTypeMembers() {\n    this.expect(5);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(8);\n    return members;\n  }\n  tsIsStartOfMappedType() {\n    this.next();\n    if (this.eat(53)) {\n      return this.isContextual(122);\n    }\n    if (this.isContextual(122)) {\n      this.next();\n    }\n    if (!this.match(0)) {\n      return false;\n    }\n    this.next();\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n    this.next();\n    return this.match(58);\n  }\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(5);\n    if (this.match(53)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(122);\n    } else if (this.eatContextual(122)) {\n      node.readonly = true;\n    }\n    this.expect(0);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsExpectThenParseType(58);\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    node.nameType = this.eatContextual(93) ? this.tsParseType() : null;\n    this.expect(3);\n    if (this.match(53)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(17);\n    } else if (this.eat(17)) {\n      node.optional = true;\n    }\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(8);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    node.elementTypes.forEach(elementNode => {\n      const {\n        type\n      } = elementNode;\n      if (seenOptionalElement && type !== \"TSRestType\" && type !== \"TSOptionalType\" && !(type === \"TSNamedTupleMember\" && elementNode.optional)) {\n        this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);\n      }\n      seenOptionalElement || (seenOptionalElement = type === \"TSNamedTupleMember\" && elementNode.optional || type === \"TSOptionalType\");\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n  tsParseTupleElementType() {\n    const restStartLoc = this.state.startLoc;\n    const rest = this.eat(21);\n    const {\n      startLoc\n    } = this.state;\n    let labeled;\n    let label;\n    let optional;\n    let type;\n    const isWord = tokenIsKeywordOrIdentifier(this.state.type);\n    const chAfterWord = isWord ? this.lookaheadCharCode() : null;\n    if (chAfterWord === 58) {\n      labeled = true;\n      optional = false;\n      label = this.parseIdentifier(true);\n      this.expect(14);\n      type = this.tsParseType();\n    } else if (chAfterWord === 63) {\n      optional = true;\n      const wordName = this.state.value;\n      const typeOrLabel = this.tsParseNonArrayType();\n      if (this.lookaheadCharCode() === 58) {\n        labeled = true;\n        label = this.createIdentifier(this.startNodeAt(startLoc), wordName);\n        this.expect(17);\n        this.expect(14);\n        type = this.tsParseType();\n      } else {\n        labeled = false;\n        type = typeOrLabel;\n        this.expect(17);\n      }\n    } else {\n      type = this.tsParseType();\n      optional = this.eat(17);\n      labeled = this.eat(14);\n    }\n    if (labeled) {\n      let labeledNode;\n      if (label) {\n        labeledNode = this.startNodeAt(startLoc);\n        labeledNode.optional = optional;\n        labeledNode.label = label;\n        labeledNode.elementType = type;\n        if (this.eat(17)) {\n          labeledNode.optional = true;\n          this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);\n        }\n      } else {\n        labeledNode = this.startNodeAt(startLoc);\n        labeledNode.optional = optional;\n        this.raise(TSErrors.InvalidTupleMemberLabel, type);\n        labeledNode.label = type;\n        labeledNode.elementType = this.tsParseType();\n      }\n      type = this.finishNode(labeledNode, \"TSNamedTupleMember\");\n    } else if (optional) {\n      const optionalTypeNode = this.startNodeAt(startLoc);\n      optionalTypeNode.typeAnnotation = type;\n      type = this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n    if (rest) {\n      const restNode = this.startNodeAt(restStartLoc);\n      restNode.typeAnnotation = type;\n      type = this.finishNode(restNode, \"TSRestType\");\n    }\n    return type;\n  }\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(10);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(11);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n  tsParseFunctionOrConstructorType(type, abstract) {\n    const node = this.startNode();\n    if (type === \"TSConstructorType\") {\n      node.abstract = !!abstract;\n      if (abstract) this.next();\n      this.next();\n    }\n    this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));\n    return this.finishNode(node, type);\n  }\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n    switch (this.state.type) {\n      case 135:\n      case 136:\n      case 134:\n      case 85:\n      case 86:\n        node.literal = super.parseExprAtom();\n        break;\n      default:\n        this.unexpected();\n    }\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    node.literal = super.parseTemplate(false);\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n  parseTemplateSubstitution() {\n    if (this.state.inType) return this.tsParseType();\n    return super.parseTemplateSubstitution();\n  }\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case 134:\n      case 135:\n      case 136:\n      case 85:\n      case 86:\n        return this.tsParseLiteralTypeNode();\n      case 53:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n          const nextToken = this.lookahead();\n          if (nextToken.type !== 135 && nextToken.type !== 136) {\n            this.unexpected();\n          }\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n        break;\n      case 78:\n        return this.tsParseThisTypeOrThisTypePredicate();\n      case 87:\n        return this.tsParseTypeQuery();\n      case 83:\n        return this.tsParseImportType();\n      case 5:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n      case 0:\n        return this.tsParseTupleType();\n      case 10:\n        return this.tsParseParenthesizedType();\n      case 25:\n      case 24:\n        return this.tsParseTemplateLiteralType();\n      default:\n        {\n          const {\n            type\n          } = this.state;\n          if (tokenIsIdentifier(type) || type === 88 || type === 84) {\n            const nodeType = type === 88 ? \"TSVoidKeyword\" : type === 84 ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n            if (nodeType !== undefined && this.lookaheadCharCode() !== 46) {\n              const node = this.startNode();\n              this.next();\n              return this.finishNode(node, nodeType);\n            }\n            return this.tsParseTypeReference();\n          }\n        }\n    }\n    throw this.unexpected();\n  }\n  tsParseArrayTypeOrHigher() {\n    const {\n      startLoc\n    } = this.state;\n    let type = this.tsParseNonArrayType();\n    while (!this.hasPrecedingLineBreak() && this.eat(0)) {\n      if (this.match(3)) {\n        const node = this.startNodeAt(startLoc);\n        node.elementType = type;\n        this.expect(3);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAt(startLoc);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(3);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n    return type;\n  }\n  tsParseTypeOperator() {\n    const node = this.startNode();\n    const operator = this.state.value;\n    this.next();\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n      default:\n        this.raise(TSErrors.UnexpectedReadonly, node);\n    }\n  }\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(115);\n    const typeParameter = this.startNode();\n    typeParameter.name = this.tsParseTypeParameterName();\n    typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n  tsParseConstraintForInferType() {\n    if (this.eat(81)) {\n      const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());\n      if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {\n        return constraint;\n      }\n    }\n  }\n  tsParseTypeOperatorOrHigher() {\n    const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;\n    return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());\n  }\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    const node = this.startNode();\n    const hasLeadingOperator = this.eat(operator);\n    const types = [];\n    do {\n      types.push(parseConstituentType());\n    } while (this.eat(operator));\n    if (types.length === 1 && !hasLeadingOperator) {\n      return types[0];\n    }\n    node.types = types;\n    return this.finishNode(node, kind);\n  }\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), 45);\n  }\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), 43);\n  }\n  tsIsStartOfFunctionType() {\n    if (this.match(47)) {\n      return true;\n    }\n    return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n  tsSkipParameterStart() {\n    if (tokenIsIdentifier(this.state.type) || this.match(78)) {\n      this.next();\n      return true;\n    }\n    if (this.match(5)) {\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        this.parseObjectLike(8, true);\n        return errors.length === previousErrorCount;\n      } catch (_unused) {\n        return false;\n      }\n    }\n    if (this.match(0)) {\n      this.next();\n      const {\n        errors\n      } = this.state;\n      const previousErrorCount = errors.length;\n      try {\n        super.parseBindingList(3, 93, 1);\n        return errors.length === previousErrorCount;\n      } catch (_unused2) {\n        return false;\n      }\n    }\n    return false;\n  }\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n    if (this.match(11) || this.match(21)) {\n      return true;\n    }\n    if (this.tsSkipParameterStart()) {\n      if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {\n        return true;\n      }\n      if (this.match(11)) {\n        this.next();\n        if (this.match(19)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const node = this.startNode();\n      const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n      if (asserts && this.match(78)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n        if (thisTypePredicate.type === \"TSThisType\") {\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          node.typeAnnotation = null;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          this.resetStartLocationFromNode(thisTypePredicate, node);\n          thisTypePredicate.asserts = true;\n        }\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        node.typeAnnotation = null;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n      const type = this.tsParseTypeAnnotation(false);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n  }\n  tsTryParseTypeAnnotation() {\n    if (this.match(14)) {\n      return this.tsParseTypeAnnotation();\n    }\n  }\n  tsTryParseType() {\n    return this.tsEatThenParseType(14);\n  }\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n    if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n  tsParseTypePredicateAsserts() {\n    if (this.state.type !== 109) {\n      return false;\n    }\n    const containsEsc = this.state.containsEsc;\n    this.next();\n    if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {\n      return false;\n    }\n    if (containsEsc) {\n      this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {\n        reservedWord: \"asserts\"\n      });\n    }\n    return true;\n  }\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(14);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n    if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {\n      return type;\n    }\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());\n    this.expect(17);\n    node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    this.expect(14);\n    node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n  isAbstractConstructorSignature() {\n    return this.isContextual(124) && this.isLookaheadContextual(\"new\");\n  }\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n    if (this.match(77)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    } else if (this.isAbstractConstructorSignature()) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\", true);\n    }\n    return this.tsParseUnionTypeOrHigher();\n  }\n  tsParseTypeAssertion() {\n    if (this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);\n    }\n    const node = this.startNode();\n    node.typeAnnotation = this.tsInType(() => {\n      this.next();\n      return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();\n    });\n    this.expect(48);\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n  tsParseHeritageClause(token) {\n    const originalStartLoc = this.state.startLoc;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", () => {\n      const node = this.startNode();\n      node.expression = this.tsParseEntityName(1 | 2);\n      if (this.match(47)) {\n        node.typeParameters = this.tsParseTypeArguments();\n      }\n      return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n    });\n    if (!delimitedList.length) {\n      this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {\n        token\n      });\n    }\n    return delimitedList;\n  }\n  tsParseInterfaceDeclaration(node, properties = {}) {\n    if (this.hasFollowingLineBreak()) return null;\n    this.expectContextual(129);\n    if (properties.declare) node.declare = true;\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      this.checkIdentifier(node.id, 130);\n    } else {\n      node.id = null;\n      this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);\n    }\n    node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (this.eat(81)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, 2);\n    node.typeAnnotation = this.tsInType(() => {\n      node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);\n      this.expect(29);\n      if (this.isContextual(114) && this.lookaheadCharCode() !== 46) {\n        const node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"TSIntrinsicKeyword\");\n      }\n      return this.tsParseType();\n    });\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n  tsInTopLevelContext(cb) {\n    if (this.curContext() !== types.brace) {\n      const oldContext = this.state.context;\n      this.state.context = [oldContext[0]];\n      try {\n        return cb();\n      } finally {\n        this.state.context = oldContext;\n      }\n    } else {\n      return cb();\n    }\n  }\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n  tsInDisallowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = true;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsInAllowConditionalTypesContext(cb) {\n    const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;\n    this.state.inDisallowConditionalTypesContext = false;\n    try {\n      return cb();\n    } finally {\n      this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;\n    }\n  }\n  tsEatThenParseType(token) {\n    if (this.match(token)) {\n      return this.tsNextThenParseType();\n    }\n  }\n  tsExpectThenParseType(token) {\n    return this.tsInType(() => {\n      this.expect(token);\n      return this.tsParseType();\n    });\n  }\n  tsNextThenParseType() {\n    return this.tsInType(() => {\n      this.next();\n      return this.tsParseType();\n    });\n  }\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);\n    if (this.eat(29)) {\n      node.initializer = super.parseMaybeAssignAllowIn();\n    }\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n  tsParseEnumDeclaration(node, properties = {}) {\n    if (properties.const) node.const = true;\n    if (properties.declare) node.declare = true;\n    this.expectContextual(126);\n    node.id = this.parseIdentifier();\n    this.checkIdentifier(node.id, node.const ? 8971 : 8459);\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n  tsParseEnumBody() {\n    const node = this.startNode();\n    this.expect(5);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(8);\n    return this.finishNode(node, \"TSEnumBody\");\n  }\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(0);\n    this.expect(5);\n    super.parseBlockOrModuleBlockBody(node.body = [], undefined, true, 8);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n    if (!nested) {\n      this.checkIdentifier(node.id, 1024);\n    }\n    if (this.eat(16)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(1024);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(112)) {\n      node.kind = \"global\";\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(134)) {\n      node.kind = \"module\";\n      node.id = super.parseStringLiteral(this.state.value);\n    } else {\n      this.unexpected();\n    }\n    if (this.match(5)) {\n      this.scope.enter(1024);\n      this.prodParam.enter(0);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n  tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {\n    node.isExport = isExport || false;\n    node.id = maybeDefaultIdentifier || this.parseIdentifier();\n    this.checkIdentifier(node.id, 4096);\n    this.expect(29);\n    const moduleReference = this.tsParseModuleReference();\n    if (node.importKind === \"type\" && moduleReference.type !== \"TSExternalModuleReference\") {\n      this.raise(TSErrors.ImportAliasHasImportType, moduleReference);\n    }\n    node.moduleReference = moduleReference;\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n  tsIsExternalModuleReference() {\n    return this.isContextual(119) && this.lookaheadCharCode() === 40;\n  }\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);\n  }\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(119);\n    this.expect(10);\n    if (!this.match(134)) {\n      this.unexpected();\n    }\n    node.expression = super.parseExprAtom();\n    this.expect(11);\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n    if (result !== undefined && result !== false) {\n      return result;\n    }\n    this.state = state;\n  }\n  tsTryParseDeclare(node) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n    const startType = this.state.type;\n    return this.tsInAmbientContext(() => {\n      switch (startType) {\n        case 68:\n          node.declare = true;\n          return super.parseFunctionStatement(node, false, false);\n        case 80:\n          node.declare = true;\n          return this.parseClass(node, true, false);\n        case 126:\n          return this.tsParseEnumDeclaration(node, {\n            declare: true\n          });\n        case 112:\n          return this.tsParseAmbientExternalModuleDeclaration(node);\n        case 100:\n          if (this.state.containsEsc) {\n            return;\n          }\n        case 75:\n        case 74:\n          if (!this.match(75) || !this.isLookaheadContextual(\"enum\")) {\n            node.declare = true;\n            return this.parseVarStatement(node, this.state.value, true);\n          }\n          this.expect(75);\n          return this.tsParseEnumDeclaration(node, {\n            const: true,\n            declare: true\n          });\n        case 107:\n          if (this.isUsing()) {\n            this.raise(TSErrors.InvalidModifierOnUsingDeclaration, this.state.startLoc, \"declare\");\n            node.declare = true;\n            return this.parseVarStatement(node, \"using\", true);\n          }\n          break;\n        case 96:\n          if (this.isAwaitUsing()) {\n            this.raise(TSErrors.InvalidModifierOnAwaitUsingDeclaration, this.state.startLoc, \"declare\");\n            node.declare = true;\n            this.next();\n            return this.parseVarStatement(node, \"await using\", true);\n          }\n          break;\n        case 129:\n          {\n            const result = this.tsParseInterfaceDeclaration(node, {\n              declare: true\n            });\n            if (result) return result;\n          }\n        default:\n          if (tokenIsIdentifier(startType)) {\n            return this.tsParseDeclaration(node, this.state.type, true, null);\n          }\n      }\n    });\n  }\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.type, true, null);\n  }\n  tsParseDeclaration(node, type, next, decorators) {\n    switch (type) {\n      case 124:\n        if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {\n          return this.tsParseAbstractDeclaration(node, decorators);\n        }\n        break;\n      case 127:\n        if (this.tsCheckLineTerminator(next)) {\n          if (this.match(134)) {\n            return this.tsParseAmbientExternalModuleDeclaration(node);\n          } else if (tokenIsIdentifier(this.state.type)) {\n            node.kind = \"module\";\n            return this.tsParseModuleOrNamespaceDeclaration(node);\n          }\n        }\n        break;\n      case 128:\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          node.kind = \"namespace\";\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n        break;\n      case 130:\n        if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n        break;\n    }\n  }\n  tsCheckLineTerminator(next) {\n    if (next) {\n      if (this.hasFollowingLineBreak()) return false;\n      this.next();\n      return true;\n    }\n    return !this.isLineTerminator();\n  }\n  tsTryParseGenericAsyncArrowFunction(startLoc) {\n    if (!this.match(47)) return;\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = true;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startLoc);\n      node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(19);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    if (!res) return;\n    return super.parseArrowExpression(res, null, true);\n  }\n  tsParseTypeArgumentsInExpression() {\n    if (this.reScan_lt() !== 47) return;\n    return this.tsParseTypeArguments();\n  }\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInTopLevelContext(() => {\n      this.expect(47);\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n    if (node.params.length === 0) {\n      this.raise(TSErrors.EmptyTypeArguments, node);\n    } else if (!this.state.inType && this.curContext() === types.brace) {\n      this.reScan_lt_gt();\n    }\n    this.expect(48);\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n  tsIsDeclarationStart() {\n    return tokenIsTSDeclarationStart(this.state.type);\n  }\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n  parseBindingElement(flags, decorators) {\n    const startLoc = decorators.length ? decorators[0].loc.start : this.state.startLoc;\n    const modified = {};\n    this.tsParseModifiers({\n      allowedModifiers: [\"public\", \"private\", \"protected\", \"override\", \"readonly\"]\n    }, modified);\n    const accessibility = modified.accessibility;\n    const override = modified.override;\n    const readonly = modified.readonly;\n    if (!(flags & 4) && (accessibility || readonly || override)) {\n      this.raise(TSErrors.UnexpectedParameterModifier, startLoc);\n    }\n    const left = this.parseMaybeDefault();\n    if (flags & 2) {\n      this.parseFunctionParamType(left);\n    }\n    const elt = this.parseMaybeDefault(left.loc.start, left);\n    if (accessibility || readonly || override) {\n      const pp = this.startNodeAt(startLoc);\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n      if (override) pp.override = override;\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);\n      }\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n    return elt;\n  }\n  isSimpleParameter(node) {\n    return node.type === \"TSParameterProperty\" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);\n  }\n  tsDisallowOptionalPattern(node) {\n    for (const param of node.params) {\n      if (param.type !== \"Identifier\" && param.optional && !this.state.isAmbientContext) {\n        this.raise(TSErrors.PatternIsOptional, param);\n      }\n    }\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    super.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    this.tsDisallowOptionalPattern(node);\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n    }\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" || type === \"ClassPrivateMethod\" ? \"TSDeclareMethod\" : undefined;\n    if (bodilessType && !this.match(5) && this.isLineTerminator()) {\n      return this.finishNode(node, bodilessType);\n    }\n    if (bodilessType === \"TSDeclareFunction\" && this.state.isAmbientContext) {\n      this.raise(TSErrors.DeclareFunctionHasImplementation, node);\n      if (node.declare) {\n        return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);\n      }\n    }\n    this.tsDisallowOptionalPattern(node);\n    return super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkIdentifier(node.id, 1024);\n    } else {\n      super.registerFunctionStatementId(node);\n    }\n  }\n  tsCheckForInvalidTypeCasts(items) {\n    items.forEach(node => {\n      if ((node == null ? void 0 : node.type) === \"TSTypeCastExpression\") {\n        this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);\n      }\n    });\n  }\n  toReferencedList(exprList, isInParens) {\n    this.tsCheckForInvalidTypeCasts(exprList);\n    return exprList;\n  }\n  parseArrayLike(close, isTuple, refExpressionErrors) {\n    const node = super.parseArrayLike(close, isTuple, refExpressionErrors);\n    if (node.type === \"ArrayExpression\") {\n      this.tsCheckForInvalidTypeCasts(node.elements);\n    }\n    return node;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(35)) {\n      this.state.canStartJSXElement = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n    let isOptionalCall = false;\n    if (this.match(18) && this.lookaheadCharCode() === 60) {\n      if (noCalls) {\n        state.stop = true;\n        return base;\n      }\n      state.optionalChainMember = isOptionalCall = true;\n      this.next();\n    }\n    if (this.match(47) || this.match(51)) {\n      let missingParenErrorLoc;\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);\n          if (asyncArrowFn) {\n            state.stop = true;\n            return asyncArrowFn;\n          }\n        }\n        const typeArguments = this.tsParseTypeArgumentsInExpression();\n        if (!typeArguments) return;\n        if (isOptionalCall && !this.match(10)) {\n          missingParenErrorLoc = this.state.curPosition();\n          return;\n        }\n        if (tokenIsTemplate(this.state.type)) {\n          const result = super.parseTaggedTemplateExpression(base, startLoc, state);\n          result.typeParameters = typeArguments;\n          return result;\n        }\n        if (!noCalls && this.eat(10)) {\n          const node = this.startNodeAt(startLoc);\n          node.callee = base;\n          node.arguments = this.parseCallExpressionArguments();\n          this.tsCheckForInvalidTypeCasts(node.arguments);\n          node.typeParameters = typeArguments;\n          if (state.optionalChainMember) {\n            node.optional = isOptionalCall;\n          }\n          return this.finishCallExpression(node, state.optionalChainMember);\n        }\n        const tokenType = this.state.type;\n        if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {\n          return;\n        }\n        const node = this.startNodeAt(startLoc);\n        node.expression = base;\n        node.typeParameters = typeArguments;\n        return this.finishNode(node, \"TSInstantiationExpression\");\n      });\n      if (missingParenErrorLoc) {\n        this.unexpected(missingParenErrorLoc, 10);\n      }\n      if (result) {\n        if (result.type === \"TSInstantiationExpression\") {\n          if (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40) {\n            this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);\n          }\n          if (!this.match(16) && !this.match(18)) {\n            result.expression = super.stopParseSubscript(base, state);\n          }\n        }\n        return result;\n      }\n    }\n    return super.parseSubscript(base, startLoc, noCalls, state);\n  }\n  parseNewCallee(node) {\n    var _callee$extra;\n    super.parseNewCallee(node);\n    const {\n      callee\n    } = node;\n    if (callee.type === \"TSInstantiationExpression\" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {\n      node.typeParameters = callee.typeParameters;\n      node.callee = callee.expression;\n    }\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    let isSatisfies;\n    if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {\n      const node = this.startNodeAt(leftStartLoc);\n      node.expression = left;\n      node.typeAnnotation = this.tsInType(() => {\n        this.next();\n        if (this.match(75)) {\n          if (isSatisfies) {\n            this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {\n              keyword: \"const\"\n            });\n          }\n          return this.tsParseTypeReference();\n        }\n        return this.tsParseType();\n      });\n      this.finishNode(node, isSatisfies ? \"TSSatisfiesExpression\" : \"TSAsExpression\");\n      this.reScan_lt_gt();\n      return this.parseExprOp(node, leftStartLoc, minPrec);\n    }\n    return super.parseExprOp(left, leftStartLoc, minPrec);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (!this.state.isAmbientContext) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  checkImportReflection(node) {\n    super.checkImportReflection(node);\n    if (node.module && node.importKind !== \"value\") {\n      this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);\n    }\n  }\n  checkDuplicateExports() {}\n  isPotentialImportPhase(isExport) {\n    if (super.isPotentialImportPhase(isExport)) return true;\n    if (this.isContextual(130)) {\n      const ch = this.lookaheadCharCode();\n      return isExport ? ch === 123 || ch === 42 : ch !== 61;\n    }\n    return !isExport && this.isContextual(87);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    super.applyImportPhase(node, isExport, phase, loc);\n    if (isExport) {\n      node.exportKind = phase === \"type\" ? \"type\" : \"value\";\n    } else {\n      node.importKind = phase === \"type\" || phase === \"typeof\" ? phase : \"value\";\n    }\n  }\n  parseImport(node) {\n    if (this.match(134)) {\n      node.importKind = \"value\";\n      return super.parseImport(node);\n    }\n    let importNode;\n    if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {\n      node.importKind = \"value\";\n      return this.tsParseImportEqualsDeclaration(node);\n    } else if (this.isContextual(130)) {\n      const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);\n      if (this.lookaheadCharCode() === 61) {\n        return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);\n      } else {\n        importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);\n      }\n    } else {\n      importNode = super.parseImport(node);\n    }\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);\n    }\n    return importNode;\n  }\n  parseExport(node, decorators) {\n    if (this.match(83)) {\n      const nodeImportEquals = node;\n      this.next();\n      let maybeDefaultIdentifier = null;\n      if (this.isContextual(130) && this.isPotentialImportPhase(false)) {\n        maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);\n      } else {\n        nodeImportEquals.importKind = \"value\";\n      }\n      const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);\n      return declaration;\n    } else if (this.eat(29)) {\n      const assign = node;\n      assign.expression = super.parseExpression();\n      this.semicolon();\n      this.sawUnambiguousESM = true;\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(93)) {\n      const decl = node;\n      this.expectContextual(128);\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      return super.parseExport(node, decorators);\n    }\n  }\n  isAbstractClass() {\n    return this.isContextual(124) && this.isLookaheadContextual(\"class\");\n  }\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      cls.abstract = true;\n      return this.parseClass(cls, true, true);\n    }\n    if (this.match(129)) {\n      const result = this.tsParseInterfaceDeclaration(this.startNode());\n      if (result) return result;\n    }\n    return super.parseExportDefaultExpression();\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    const {\n      isAmbientContext\n    } = this.state;\n    const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);\n    if (!isAmbientContext) return declaration;\n    if (!node.declare && (kind === \"using\" || kind === \"await using\")) {\n      this.raiseOverwrite(TSErrors.UsingDeclarationInAmbientContext, node, kind);\n      return declaration;\n    }\n    for (const {\n      id,\n      init\n    } of declaration.declarations) {\n      if (!init) continue;\n      if (kind === \"var\" || kind === \"let\" || !!id.typeAnnotation) {\n        this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);\n      } else if (!isValidAmbientConstInitializer(init, this.hasPlugin(\"estree\"))) {\n        this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);\n      }\n    }\n    return declaration;\n  }\n  parseStatementContent(flags, decorators) {\n    if (!this.state.containsEsc) {\n      switch (this.state.type) {\n        case 75:\n          {\n            if (this.isLookaheadContextual(\"enum\")) {\n              const node = this.startNode();\n              this.expect(75);\n              return this.tsParseEnumDeclaration(node, {\n                const: true\n              });\n            }\n            break;\n          }\n        case 124:\n        case 125:\n          {\n            if (this.nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine()) {\n              const token = this.state.type;\n              const node = this.startNode();\n              this.next();\n              const declaration = token === 125 ? this.tsTryParseDeclare(node) : this.tsParseAbstractDeclaration(node, decorators);\n              if (declaration) {\n                if (token === 125) {\n                  declaration.declare = true;\n                }\n                return declaration;\n              } else {\n                node.expression = this.createIdentifier(this.startNodeAt(node.loc.start), token === 125 ? \"declare\" : \"abstract\");\n                this.semicolon(false);\n                return this.finishNode(node, \"ExpressionStatement\");\n              }\n            }\n            break;\n          }\n        case 126:\n          return this.tsParseEnumDeclaration(this.startNode());\n        case 112:\n          {\n            const nextCh = this.lookaheadCharCode();\n            if (nextCh === 123) {\n              const node = this.startNode();\n              return this.tsParseAmbientExternalModuleDeclaration(node);\n            }\n            break;\n          }\n        case 129:\n          {\n            const result = this.tsParseInterfaceDeclaration(this.startNode());\n            if (result) return result;\n            break;\n          }\n        case 127:\n          {\n            if (this.nextTokenIsIdentifierOrStringLiteralOnSameLine()) {\n              const node = this.startNode();\n              this.next();\n              return this.tsParseDeclaration(node, 127, false, decorators);\n            }\n            break;\n          }\n        case 128:\n          {\n            if (this.nextTokenIsIdentifierOnSameLine()) {\n              const node = this.startNode();\n              this.next();\n              return this.tsParseDeclaration(node, 128, false, decorators);\n            }\n            break;\n          }\n        case 130:\n          {\n            if (this.nextTokenIsIdentifierOnSameLine()) {\n              const node = this.startNode();\n              this.next();\n              return this.tsParseTypeAliasDeclaration(node);\n            }\n            break;\n          }\n      }\n    }\n    return super.parseStatementContent(flags, decorators);\n  }\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n  tsHasSomeModifiers(member, modifiers) {\n    return modifiers.some(modifier => {\n      if (tsIsAccessModifier(modifier)) {\n        return member.accessibility === modifier;\n      }\n      return !!member[modifier];\n    });\n  }\n  tsIsStartOfStaticBlocks() {\n    return this.isContextual(106) && this.lookaheadCharCode() === 123;\n  }\n  parseClassMember(classBody, member, state) {\n    const modifiers = [\"declare\", \"private\", \"public\", \"protected\", \"override\", \"abstract\", \"readonly\", \"static\"];\n    this.tsParseModifiers({\n      allowedModifiers: modifiers,\n      disallowedModifiers: [\"in\", \"out\"],\n      stopOnStartOfClassStaticBlock: true,\n      errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions\n    }, member);\n    const callParseClassMemberWithIsStatic = () => {\n      if (this.tsIsStartOfStaticBlocks()) {\n        this.next();\n        this.next();\n        if (this.tsHasSomeModifiers(member, modifiers)) {\n          this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());\n        }\n        super.parseClassStaticBlock(classBody, member);\n      } else {\n        this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);\n      }\n    };\n    if (member.declare) {\n      this.tsInAmbientContext(callParseClassMemberWithIsStatic);\n    } else {\n      callParseClassMemberWithIsStatic();\n    }\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const idx = this.tsTryParseIndexSignature(member);\n    if (idx) {\n      classBody.body.push(idx);\n      if (member.abstract) {\n        this.raise(TSErrors.IndexSignatureHasAbstract, member);\n      }\n      if (member.accessibility) {\n        this.raise(TSErrors.IndexSignatureHasAccessibility, member, {\n          modifier: member.accessibility\n        });\n      }\n      if (member.declare) {\n        this.raise(TSErrors.IndexSignatureHasDeclare, member);\n      }\n      if (member.override) {\n        this.raise(TSErrors.IndexSignatureHasOverride, member);\n      }\n      return;\n    }\n    if (!this.state.inAbstractClass && member.abstract) {\n      this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);\n    }\n    if (member.override) {\n      if (!state.hadSuperClass) {\n        this.raise(TSErrors.OverrideNotInSubClass, member);\n      }\n    }\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(17);\n    if (optional) methodOrProp.optional = true;\n    if (methodOrProp.readonly && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);\n    }\n    if (methodOrProp.declare && this.match(10)) {\n      this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);\n    }\n  }\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (!this.match(17)) return expr;\n    if (this.state.maybeInArrowParameters) {\n      const nextCh = this.lookaheadCharCode();\n      if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {\n        this.setOptionalParametersError(refExpressionErrors);\n        return expr;\n      }\n    }\n    return super.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseParenItem(node, startLoc) {\n    const newNode = super.parseParenItem(node, startLoc);\n    if (this.eat(17)) {\n      newNode.optional = true;\n      this.resetEndLocation(node);\n    }\n    if (this.match(14)) {\n      const typeCastNode = this.startNodeAt(startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n    return node;\n  }\n  parseExportDeclaration(node) {\n    if (!this.state.isAmbientContext && this.isContextual(125)) {\n      return this.tsInAmbientContext(() => this.parseExportDeclaration(node));\n    }\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(125);\n    if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {\n      throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);\n    }\n    const isIdentifier = tokenIsIdentifier(this.state.type);\n    const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);\n    if (!declaration) return null;\n    if (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare) {\n      node.exportKind = \"type\";\n    }\n    if (isDeclare && declaration.type !== \"TSImportEqualsDeclaration\") {\n      this.resetStartLocation(declaration, startLoc);\n      declaration.declare = true;\n    }\n    return declaration;\n  }\n  parseClassId(node, isStatement, optionalId, bindingType) {\n    if ((!isStatement || optionalId) && this.isContextual(113)) {\n      return;\n    }\n    super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional) {\n      if (this.eat(35)) {\n        node.definite = true;\n      } else if (this.eat(17)) {\n        node.optional = true;\n      }\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {\n      this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);\n    }\n    if (node.abstract && this.match(29)) {\n      const {\n        key\n      } = node;\n      this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {\n        propertyName: key.type === \"Identifier\" && !node.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`\n      });\n    }\n    return super.parseClassProperty(node);\n  }\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(TSErrors.PrivateElementHasAbstract, node);\n    }\n    if (node.accessibility) {\n      this.raise(TSErrors.PrivateElementHasAccessibility, node, {\n        modifier: node.accessibility\n      });\n    }\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n  parseClassAccessorProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n    if (node.optional) {\n      this.raise(TSErrors.AccessorCannotBeOptional, node);\n    }\n    return super.parseClassAccessorProperty(node);\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters && isConstructor) {\n      this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);\n    }\n    const {\n      declare = false,\n      kind\n    } = method;\n    if (declare && (kind === \"get\" || kind === \"set\")) {\n      this.raise(TSErrors.DeclareAccessor, method, {\n        kind\n      });\n    }\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    if (node.type === \"TSDeclareMethod\") return;\n    if (node.type === \"MethodDefinition\" && node.value.body == null) {\n      return;\n    }\n    super.declareClassPrivateMethodInScope(node, kind);\n  }\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n    if (node.superClass && (this.match(47) || this.match(51))) {\n      node.superTypeParameters = this.tsParseTypeArgumentsInExpression();\n    }\n    if (this.eatContextual(113)) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) prop.typeParameters = typeParameters;\n    return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);\n  }\n  parseFunctionParams(node, isConstructor) {\n    const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, isConstructor);\n  }\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n    if (decl.id.type === \"Identifier\" && !this.hasPrecedingLineBreak() && this.eat(35)) {\n      decl.definite = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(14)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;\n    let state;\n    let jsx;\n    let typeCast;\n    if (this.hasPlugin(\"jsx\") && (this.match(143) || this.match(47))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n      const currentContext = context[context.length - 1];\n      if (currentContext === types.j_oTag || currentContext === types.j_expr) {\n        context.pop();\n      }\n    }\n    if (!((_jsx = jsx) != null && _jsx.error) && !this.match(47)) {\n      return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n    }\n    if (!state || state === this.state) state = this.state.clone();\n    let typeParameters;\n    const arrow = this.tryParse(abort => {\n      var _expr$extra, _typeParameters;\n      typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);\n      const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);\n      if (expr.type !== \"ArrowFunctionExpression\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n        abort();\n      }\n      if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) {\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n    if ((_jsx2 = jsx) != null && _jsx2.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n    if (arrow.node) {\n      this.state = arrow.failState;\n      if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);\n      return arrow.node;\n    }\n    if ((_typeCast = typeCast) != null && _typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n    throw ((_jsx3 = jsx) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);\n  }\n  reportReservedArrowTypeParam(node) {\n    var _node$extra2;\n    if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra2 = node.extra) != null && _node$extra2.trailingComma) && this.getPluginOption(\"typescript\", \"disallowAmbiguousJSXLike\")) {\n      this.raise(TSErrors.ReservedArrowTypeParam, node);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    if (!this.hasPlugin(\"jsx\") && this.match(47)) {\n      return this.tsParseTypeAssertion();\n    }\n    return super.parseMaybeUnary(refExpressionErrors, sawUnary);\n  }\n  parseArrow(node) {\n    if (this.match(14)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);\n        if (this.canInsertSemicolon() || !this.match(19)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n    return super.parseArrow(node);\n  }\n  parseFunctionParamType(param) {\n    if (this.eat(17)) {\n      param.optional = true;\n    }\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return this.isAssignable(node.expression, isBinding);\n      case \"TSParameterProperty\":\n        return true;\n      default:\n        return super.isAssignable(node, isBinding);\n    }\n  }\n  toAssignable(node, isLHS = false) {\n    switch (node.type) {\n      case \"ParenthesizedExpression\":\n        this.toAssignableParenthesizedExpression(node, isLHS);\n        break;\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        if (isLHS) {\n          this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);\n        } else {\n          this.raise(TSErrors.UnexpectedTypeCastInParameter, node);\n        }\n        this.toAssignable(node.expression, isLHS);\n        break;\n      case \"AssignmentExpression\":\n        if (!isLHS && node.left.type === \"TSTypeCastExpression\") {\n          node.left = this.typeCastToParameter(node.left);\n        }\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  toAssignableParenthesizedExpression(node, isLHS) {\n    switch (node.expression.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isLHS);\n        break;\n      default:\n        super.toAssignable(node, isLHS);\n    }\n  }\n  checkToRestConversion(node, allowPattern) {\n    switch (node.type) {\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n      case \"TSNonNullExpression\":\n        this.checkToRestConversion(node.expression, false);\n        break;\n      default:\n        super.checkToRestConversion(node, allowPattern);\n    }\n  }\n  isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding) {\n    switch (type) {\n      case \"TSTypeCastExpression\":\n        return true;\n      case \"TSParameterProperty\":\n        return \"parameter\";\n      case \"TSNonNullExpression\":\n        return \"expression\";\n      case \"TSAsExpression\":\n      case \"TSSatisfiesExpression\":\n      case \"TSTypeAssertion\":\n        return (binding !== 64 || !isUnparenthesizedInAssign) && [\"expression\", true];\n      default:\n        return super.isValidLVal(type, disallowCallExpression, isUnparenthesizedInAssign, binding);\n    }\n  }\n  parseBindingAtom() {\n    if (this.state.type === 78) {\n      return this.parseIdentifier(true);\n    }\n    return super.parseBindingAtom();\n  }\n  parseMaybeDecoratorArguments(expr, startLoc) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsParseTypeArgumentsInExpression();\n      if (this.match(10)) {\n        const call = super.parseMaybeDecoratorArguments(expr, startLoc);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n      this.unexpected(null, 10);\n    }\n    return super.parseMaybeDecoratorArguments(expr, startLoc);\n  }\n  checkCommaAfterRest(close) {\n    if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {\n      this.next();\n      return false;\n    }\n    return super.checkCommaAfterRest(close);\n  }\n  isClassMethod() {\n    return this.match(47) || super.isClassMethod();\n  }\n  isClassProperty() {\n    return this.match(35) || this.match(14) || super.isClassProperty();\n  }\n  parseMaybeDefault(startLoc, left) {\n    const node = super.parseMaybeDefault(startLoc, left);\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);\n    }\n    return node;\n  }\n  getTokenFromCode(code) {\n    if (this.state.inType) {\n      if (code === 62) {\n        this.finishOp(48, 1);\n        return;\n      }\n      if (code === 60) {\n        this.finishOp(47, 1);\n        return;\n      }\n    }\n    super.getTokenFromCode(code);\n  }\n  reScan_lt_gt() {\n    const {\n      type\n    } = this.state;\n    if (type === 47) {\n      this.state.pos -= 1;\n      this.readToken_lt();\n    } else if (type === 48) {\n      this.state.pos -= 1;\n      this.readToken_gt();\n    }\n  }\n  reScan_lt() {\n    const {\n      type\n    } = this.state;\n    if (type === 51) {\n      this.state.pos -= 2;\n      this.finishOp(47, 1);\n      return 47;\n    }\n    return type;\n  }\n  toAssignableListItem(exprList, index, isLHS) {\n    const node = exprList[index];\n    if (node.type === \"TSTypeCastExpression\") {\n      exprList[index] = this.typeCastToParameter(node);\n    }\n    super.toAssignableListItem(exprList, index, isLHS);\n  }\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n  shouldParseArrow(params) {\n    if (this.match(14)) {\n      return params.every(expr => this.isAssignable(expr, true));\n    }\n    return super.shouldParseArrow(params);\n  }\n  shouldParseAsyncArrow() {\n    return this.match(14) || super.shouldParseAsyncArrow();\n  }\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n  jsxParseOpeningElementAfterName(node) {\n    if (this.match(47) || this.match(51)) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());\n      if (typeArguments) {\n        node.typeParameters = typeArguments;\n      }\n    }\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    const firstParam = params[0];\n    const hasContextParam = firstParam && this.isThisParam(firstParam);\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n  parseCatchClauseParam() {\n    const param = super.parseCatchClauseParam();\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) {\n      param.typeAnnotation = type;\n      this.resetEndLocation(param);\n    }\n    return param;\n  }\n  tsInAmbientContext(cb) {\n    const {\n      isAmbientContext: oldIsAmbientContext,\n      strict: oldStrict\n    } = this.state;\n    this.state.isAmbientContext = true;\n    this.state.strict = false;\n    try {\n      return cb();\n    } finally {\n      this.state.isAmbientContext = oldIsAmbientContext;\n      this.state.strict = oldStrict;\n    }\n  }\n  parseClass(node, isStatement, optionalId) {\n    const oldInAbstractClass = this.state.inAbstractClass;\n    this.state.inAbstractClass = !!node.abstract;\n    try {\n      return super.parseClass(node, isStatement, optionalId);\n    } finally {\n      this.state.inAbstractClass = oldInAbstractClass;\n    }\n  }\n  tsParseAbstractDeclaration(node, decorators) {\n    if (this.match(80)) {\n      node.abstract = true;\n      return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));\n    } else if (this.isContextual(129)) {\n      if (!this.hasFollowingLineBreak()) {\n        node.abstract = true;\n        this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifier, node);\n        return this.tsParseInterfaceDeclaration(node);\n      } else {\n        return null;\n      }\n    }\n    throw this.unexpected(null, 80);\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {\n    const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    if (method.abstract || method.type === \"TSAbstractMethodDefinition\") {\n      const hasEstreePlugin = this.hasPlugin(\"estree\");\n      const methodFn = hasEstreePlugin ? method.value : method;\n      if (methodFn.body) {\n        const {\n          key\n        } = method;\n        this.raise(TSErrors.AbstractMethodHasImplementation, method, {\n          methodName: key.type === \"Identifier\" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`\n        });\n      }\n    }\n    return method;\n  }\n  tsParseTypeParameterName() {\n    const typeName = this.parseIdentifier();\n    return typeName.name;\n  }\n  shouldParseAsAmbientContext() {\n    return !!this.getPluginOption(\"typescript\", \"dts\");\n  }\n  parse() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.parse();\n  }\n  getExpression() {\n    if (this.shouldParseAsAmbientContext()) {\n      this.state.isAmbientContext = true;\n    }\n    return super.getExpression();\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (!isString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);\n      return this.finishNode(node, \"ExportSpecifier\");\n    }\n    node.exportKind = \"value\";\n    return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (!importedIsString && isMaybeTypeOnly) {\n      this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);\n      return this.finishNode(specifier, \"ImportSpecifier\");\n    }\n    specifier.importKind = \"value\";\n    return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);\n  }\n  parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {\n    const leftOfAsKey = isImport ? \"imported\" : \"local\";\n    const rightOfAsKey = isImport ? \"local\" : \"exported\";\n    let leftOfAs = node[leftOfAsKey];\n    let rightOfAs;\n    let hasTypeSpecifier = false;\n    let canParseAsKeyword = true;\n    const loc = leftOfAs.loc.start;\n    if (this.isContextual(93)) {\n      const firstAs = this.parseIdentifier();\n      if (this.isContextual(93)) {\n        const secondAs = this.parseIdentifier();\n        if (tokenIsKeywordOrIdentifier(this.state.type)) {\n          hasTypeSpecifier = true;\n          leftOfAs = firstAs;\n          rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n          canParseAsKeyword = false;\n        } else {\n          rightOfAs = secondAs;\n          canParseAsKeyword = false;\n        }\n      } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n        canParseAsKeyword = false;\n        rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n      } else {\n        hasTypeSpecifier = true;\n        leftOfAs = firstAs;\n      }\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      hasTypeSpecifier = true;\n      if (isImport) {\n        leftOfAs = this.parseIdentifier(true);\n        if (!this.isContextual(93)) {\n          this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);\n        }\n      } else {\n        leftOfAs = this.parseModuleExportName();\n      }\n    }\n    if (hasTypeSpecifier && isInTypeOnlyImportExport) {\n      this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);\n    }\n    node[leftOfAsKey] = leftOfAs;\n    node[rightOfAsKey] = rightOfAs;\n    const kindKey = isImport ? \"importKind\" : \"exportKind\";\n    node[kindKey] = hasTypeSpecifier ? \"type\" : \"value\";\n    if (canParseAsKeyword && this.eatContextual(93)) {\n      node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();\n    }\n    if (!node[rightOfAsKey]) {\n      node[rightOfAsKey] = this.cloneIdentifier(node[leftOfAsKey]);\n    }\n    if (isImport) {\n      this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);\n    }\n  }\n  fillOptionalPropertiesForTSESLint(node) {\n    var _node$directive, _node$decorators, _node$optional, _node$typeAnnotation, _node$accessibility, _node$decorators2, _node$override, _node$readonly, _node$static, _node$declare, _node$returnType, _node$typeParameters, _node$optional2, _node$optional3, _node$accessibility2, _node$readonly2, _node$static2, _node$declare2, _node$definite, _node$readonly3, _node$typeAnnotation2, _node$accessibility3, _node$decorators3, _node$override2, _node$optional4, _node$id, _node$abstract, _node$declare3, _node$decorators4, _node$implements, _node$superTypeArgume, _node$typeParameters2, _node$declare4, _node$definite2, _node$const, _node$declare5, _node$computed, _node$qualifier, _node$options, _node$declare6, _node$extends, _node$optional5, _node$readonly4, _node$declare7, _node$global, _node$const2, _node$in, _node$out;\n    switch (node.type) {\n      case \"ExpressionStatement\":\n        (_node$directive = node.directive) != null ? _node$directive : node.directive = undefined;\n        return;\n      case \"RestElement\":\n        node.value = undefined;\n      case \"Identifier\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n      case \"ObjectPattern\":\n        (_node$decorators = node.decorators) != null ? _node$decorators : node.decorators = [];\n        (_node$optional = node.optional) != null ? _node$optional : node.optional = false;\n        (_node$typeAnnotation = node.typeAnnotation) != null ? _node$typeAnnotation : node.typeAnnotation = undefined;\n        return;\n      case \"TSParameterProperty\":\n        (_node$accessibility = node.accessibility) != null ? _node$accessibility : node.accessibility = undefined;\n        (_node$decorators2 = node.decorators) != null ? _node$decorators2 : node.decorators = [];\n        (_node$override = node.override) != null ? _node$override : node.override = false;\n        (_node$readonly = node.readonly) != null ? _node$readonly : node.readonly = false;\n        (_node$static = node.static) != null ? _node$static : node.static = false;\n        return;\n      case \"TSEmptyBodyFunctionExpression\":\n        node.body = null;\n      case \"TSDeclareFunction\":\n      case \"FunctionDeclaration\":\n      case \"FunctionExpression\":\n      case \"ClassMethod\":\n      case \"ClassPrivateMethod\":\n        (_node$declare = node.declare) != null ? _node$declare : node.declare = false;\n        (_node$returnType = node.returnType) != null ? _node$returnType : node.returnType = undefined;\n        (_node$typeParameters = node.typeParameters) != null ? _node$typeParameters : node.typeParameters = undefined;\n        return;\n      case \"Property\":\n        (_node$optional2 = node.optional) != null ? _node$optional2 : node.optional = false;\n        return;\n      case \"TSMethodSignature\":\n      case \"TSPropertySignature\":\n        (_node$optional3 = node.optional) != null ? _node$optional3 : node.optional = false;\n      case \"TSIndexSignature\":\n        (_node$accessibility2 = node.accessibility) != null ? _node$accessibility2 : node.accessibility = undefined;\n        (_node$readonly2 = node.readonly) != null ? _node$readonly2 : node.readonly = false;\n        (_node$static2 = node.static) != null ? _node$static2 : node.static = false;\n        return;\n      case \"TSAbstractPropertyDefinition\":\n      case \"PropertyDefinition\":\n      case \"TSAbstractAccessorProperty\":\n      case \"AccessorProperty\":\n        (_node$declare2 = node.declare) != null ? _node$declare2 : node.declare = false;\n        (_node$definite = node.definite) != null ? _node$definite : node.definite = false;\n        (_node$readonly3 = node.readonly) != null ? _node$readonly3 : node.readonly = false;\n        (_node$typeAnnotation2 = node.typeAnnotation) != null ? _node$typeAnnotation2 : node.typeAnnotation = undefined;\n      case \"TSAbstractMethodDefinition\":\n      case \"MethodDefinition\":\n        (_node$accessibility3 = node.accessibility) != null ? _node$accessibility3 : node.accessibility = undefined;\n        (_node$decorators3 = node.decorators) != null ? _node$decorators3 : node.decorators = [];\n        (_node$override2 = node.override) != null ? _node$override2 : node.override = false;\n        (_node$optional4 = node.optional) != null ? _node$optional4 : node.optional = false;\n        return;\n      case \"ClassExpression\":\n        (_node$id = node.id) != null ? _node$id : node.id = null;\n      case \"ClassDeclaration\":\n        (_node$abstract = node.abstract) != null ? _node$abstract : node.abstract = false;\n        (_node$declare3 = node.declare) != null ? _node$declare3 : node.declare = false;\n        (_node$decorators4 = node.decorators) != null ? _node$decorators4 : node.decorators = [];\n        (_node$implements = node.implements) != null ? _node$implements : node.implements = [];\n        (_node$superTypeArgume = node.superTypeArguments) != null ? _node$superTypeArgume : node.superTypeArguments = undefined;\n        (_node$typeParameters2 = node.typeParameters) != null ? _node$typeParameters2 : node.typeParameters = undefined;\n        return;\n      case \"TSTypeAliasDeclaration\":\n      case \"VariableDeclaration\":\n        (_node$declare4 = node.declare) != null ? _node$declare4 : node.declare = false;\n        return;\n      case \"VariableDeclarator\":\n        (_node$definite2 = node.definite) != null ? _node$definite2 : node.definite = false;\n        return;\n      case \"TSEnumDeclaration\":\n        (_node$const = node.const) != null ? _node$const : node.const = false;\n        (_node$declare5 = node.declare) != null ? _node$declare5 : node.declare = false;\n        return;\n      case \"TSEnumMember\":\n        (_node$computed = node.computed) != null ? _node$computed : node.computed = false;\n        return;\n      case \"TSImportType\":\n        (_node$qualifier = node.qualifier) != null ? _node$qualifier : node.qualifier = null;\n        (_node$options = node.options) != null ? _node$options : node.options = null;\n        return;\n      case \"TSInterfaceDeclaration\":\n        (_node$declare6 = node.declare) != null ? _node$declare6 : node.declare = false;\n        (_node$extends = node.extends) != null ? _node$extends : node.extends = [];\n        return;\n      case \"TSMappedType\":\n        (_node$optional5 = node.optional) != null ? _node$optional5 : node.optional = false;\n        (_node$readonly4 = node.readonly) != null ? _node$readonly4 : node.readonly = undefined;\n        return;\n      case \"TSModuleDeclaration\":\n        (_node$declare7 = node.declare) != null ? _node$declare7 : node.declare = false;\n        (_node$global = node.global) != null ? _node$global : node.global = node.kind === \"global\";\n        return;\n      case \"TSTypeParameter\":\n        (_node$const2 = node.const) != null ? _node$const2 : node.const = false;\n        (_node$in = node.in) != null ? _node$in : node.in = false;\n        (_node$out = node.out) != null ? _node$out : node.out = false;\n        return;\n    }\n  }\n  chStartsBindingIdentifierAndNotRelationalOperator(ch, pos) {\n    if (isIdentifierStart(ch)) {\n      keywordAndTSRelationalOperator.lastIndex = pos;\n      if (keywordAndTSRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordAndTSRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === 92) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  nextTokenIsIdentifierAndNotTSRelationalOperatorOnSameLine() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifierAndNotRelationalOperator(nextCh, next);\n  }\n  nextTokenIsIdentifierOrStringLiteralOnSameLine() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifier(nextCh, next) || nextCh === 34 || nextCh === 39;\n  }\n};\nfunction isPossiblyLiteralEnum(expression) {\n  if (expression.type !== \"MemberExpression\") return false;\n  const {\n    computed,\n    property\n  } = expression;\n  if (computed && property.type !== \"StringLiteral\" && (property.type !== \"TemplateLiteral\" || property.expressions.length > 0)) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nfunction isValidAmbientConstInitializer(expression, estree) {\n  var _expression$extra;\n  const {\n    type\n  } = expression;\n  if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {\n    return false;\n  }\n  if (estree) {\n    if (type === \"Literal\") {\n      const {\n        value\n      } = expression;\n      if (typeof value === \"string\" || typeof value === \"boolean\") {\n        return true;\n      }\n    }\n  } else {\n    if (type === \"StringLiteral\" || type === \"BooleanLiteral\") {\n      return true;\n    }\n  }\n  if (isNumber(expression, estree) || isNegativeNumber(expression, estree)) {\n    return true;\n  }\n  if (type === \"TemplateLiteral\" && expression.expressions.length === 0) {\n    return true;\n  }\n  if (isPossiblyLiteralEnum(expression)) {\n    return true;\n  }\n  return false;\n}\nfunction isNumber(expression, estree) {\n  if (estree) {\n    return expression.type === \"Literal\" && (typeof expression.value === \"number\" || \"bigint\" in expression);\n  }\n  return expression.type === \"NumericLiteral\" || expression.type === \"BigIntLiteral\";\n}\nfunction isNegativeNumber(expression, estree) {\n  if (expression.type === \"UnaryExpression\") {\n    const {\n      operator,\n      argument\n    } = expression;\n    if (operator === \"-\" && isNumber(argument, estree)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction isUncomputedMemberExpressionChain(expression) {\n  if (expression.type === \"Identifier\") return true;\n  if (expression.type !== \"MemberExpression\" || expression.computed) {\n    return false;\n  }\n  return isUncomputedMemberExpressionChain(expression.object);\n}\nconst PlaceholderErrors = ParseErrorEnum`placeholders`({\n  ClassNameIsRequired: \"A class name is required.\",\n  UnexpectedSpace: \"Unexpected space in placeholder.\"\n});\nvar placeholders = superClass => class PlaceholdersParserMixin extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(133)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace();\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace();\n      this.expect(133);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n  finishPlaceholder(node, expectedNode) {\n    let placeholder = node;\n    if (!placeholder.expectedNode || !placeholder.type) {\n      placeholder = this.finishNode(placeholder, \"Placeholder\");\n    }\n    placeholder.expectedNode = expectedNode;\n    return placeholder;\n  }\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      this.finishOp(133, 2);\n    } else {\n      super.getTokenFromCode(code);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(refExpressionErrors);\n  }\n  parseIdentifier(liberal) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(liberal);\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word !== undefined) {\n      super.checkReservedWord(word, startLoc, checkKeywords, isBinding);\n    }\n  }\n  cloneIdentifier(node) {\n    const cloned = super.cloneIdentifier(node);\n    if (cloned.type === \"Placeholder\") {\n      cloned.expectedNode = node.expectedNode;\n    }\n    return cloned;\n  }\n  cloneStringLiteral(node) {\n    if (node.type === \"Placeholder\") {\n      return this.cloneIdentifier(node);\n    }\n    return super.cloneStringLiteral(node);\n  }\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom();\n  }\n  isValidLVal(type, disallowCallExpression, isParenthesized, binding) {\n    return type === \"Placeholder\" || super.isValidLVal(type, disallowCallExpression, isParenthesized, binding);\n  }\n  toAssignable(node, isLHS) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n    } else {\n      super.toAssignable(node, isLHS);\n    }\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (super.chStartsBindingIdentifier(ch, pos)) {\n      return true;\n    }\n    const next = this.nextTokenStart();\n    if (this.input.charCodeAt(next) === 37 && this.input.charCodeAt(next + 1) === 37) {\n      return true;\n    }\n    return false;\n  }\n  verifyBreakContinue(node, isBreak) {\n    var _node$label;\n    if (((_node$label = node.label) == null ? void 0 : _node$label.type) === \"Placeholder\") return;\n    super.verifyBreakContinue(node, isBreak);\n  }\n  parseExpressionStatement(node, expr) {\n    var _expr$extra;\n    if (expr.type !== \"Placeholder\" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {\n      return super.parseExpressionStatement(node, expr);\n    }\n    if (this.match(14)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n    this.semicolon();\n    const stmtPlaceholder = node;\n    stmtPlaceholder.name = expr.name;\n    return this.finishPlaceholder(stmtPlaceholder, \"Statement\");\n  }\n  parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);\n  }\n  parseFunctionId(requireId) {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(requireId);\n  }\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    const oldStrict = this.state.strict;\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (placeholder) {\n      if (this.match(81) || this.match(133) || this.match(5)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n    super.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || super.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, type);\n  }\n  parseExport(node, decorators) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(node, decorators);\n    const node2 = node;\n    if (!this.isContextual(98) && !this.match(12)) {\n      node2.specifiers = [];\n      node2.source = null;\n      node2.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node2.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node2, decorators);\n  }\n  isExportDefaultSpecifier() {\n    if (this.match(65)) {\n      const next = this.nextTokenStart();\n      if (this.isUnparsedContextual(next, \"from\")) {\n        if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {\n          return true;\n        }\n      }\n    }\n    return super.isExportDefaultSpecifier();\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    var _specifiers;\n    if ((_specifiers = node.specifiers) != null && _specifiers.length) {\n      return true;\n    }\n    return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n  }\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n    if (specifiers != null && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(node);\n    node.specifiers = [];\n    if (!this.isContextual(98) && !this.match(12)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    node.specifiers.push(this.finishNode(specifier, \"ImportDefaultSpecifier\"));\n    if (this.eat(12)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n    this.expectContextual(98);\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource();\n  }\n  assertNoSpace() {\n    if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {\n      this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);\n    }\n  }\n};\nvar v8intrinsic = superClass => class V8IntrinsicMixin extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(54)) {\n      const v8IntrinsicStartLoc = this.state.startLoc;\n      const node = this.startNode();\n      this.next();\n      if (tokenIsIdentifier(this.state.type)) {\n        const name = this.parseIdentifierName();\n        const identifier = this.createIdentifier(node, name);\n        this.castNodeTo(identifier, \"V8IntrinsicIdentifier\");\n        if (this.match(10)) {\n          return identifier;\n        }\n      }\n      this.unexpected(v8IntrinsicStartLoc);\n    }\n  }\n  parseExprAtom(refExpressionErrors) {\n    return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);\n  }\n};\nconst PIPELINE_PROPOSALS = [\"minimal\", \"fsharp\", \"hack\", \"smart\"];\nconst TOPIC_TOKENS = [\"^^\", \"@@\", \"^\", \"%\", \"#\"];\nfunction validatePlugins(pluginsMap) {\n  if (pluginsMap.has(\"decorators\")) {\n    if (pluginsMap.has(\"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n    const decoratorsBeforeExport = pluginsMap.get(\"decorators\").decoratorsBeforeExport;\n    if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean, if specified.\");\n    }\n    const allowCallParenthesized = pluginsMap.get(\"decorators\").allowCallParenthesized;\n    if (allowCallParenthesized != null && typeof allowCallParenthesized !== \"boolean\") {\n      throw new Error(\"'allowCallParenthesized' must be a boolean.\");\n    }\n  }\n  if (pluginsMap.has(\"flow\") && pluginsMap.has(\"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n  if (pluginsMap.has(\"placeholders\") && pluginsMap.has(\"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n  if (pluginsMap.has(\"pipelineOperator\")) {\n    var _pluginsMap$get2;\n    const proposal = pluginsMap.get(\"pipelineOperator\").proposal;\n    if (!PIPELINE_PROPOSALS.includes(proposal)) {\n      const proposalList = PIPELINE_PROPOSALS.map(p => `\"${p}\"`).join(\", \");\n      throw new Error(`\"pipelineOperator\" requires \"proposal\" option whose value must be one of: ${proposalList}.`);\n    }\n    if (proposal === \"hack\") {\n      var _pluginsMap$get;\n      if (pluginsMap.has(\"placeholders\")) {\n        throw new Error(\"Cannot combine placeholders plugin and Hack-style pipes.\");\n      }\n      if (pluginsMap.has(\"v8intrinsic\")) {\n        throw new Error(\"Cannot combine v8intrinsic plugin and Hack-style pipes.\");\n      }\n      const topicToken = pluginsMap.get(\"pipelineOperator\").topicToken;\n      if (!TOPIC_TOKENS.includes(topicToken)) {\n        const tokenList = TOPIC_TOKENS.map(t => `\"${t}\"`).join(\", \");\n        throw new Error(`\"pipelineOperator\" in \"proposal\": \"hack\" mode also requires a \"topicToken\" option whose value must be one of: ${tokenList}.`);\n      }\n      if (topicToken === \"#\" && ((_pluginsMap$get = pluginsMap.get(\"recordAndTuple\")) == null ? void 0 : _pluginsMap$get.syntaxType) === \"hash\") {\n        throw new Error(`Plugin conflict between \\`[\"pipelineOperator\", { proposal: \"hack\", topicToken: \"#\" }]\\` and \\`${JSON.stringify([\"recordAndTuple\", pluginsMap.get(\"recordAndTuple\")])}\\`.`);\n      }\n    } else if (proposal === \"smart\" && ((_pluginsMap$get2 = pluginsMap.get(\"recordAndTuple\")) == null ? void 0 : _pluginsMap$get2.syntaxType) === \"hash\") {\n      throw new Error(`Plugin conflict between \\`[\"pipelineOperator\", { proposal: \"smart\" }]\\` and \\`${JSON.stringify([\"recordAndTuple\", pluginsMap.get(\"recordAndTuple\")])}\\`.`);\n    }\n  }\n  if (pluginsMap.has(\"moduleAttributes\")) {\n    if (pluginsMap.has(\"deprecatedImportAssert\") || pluginsMap.has(\"importAssertions\")) {\n      throw new Error(\"Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.\");\n    }\n    const moduleAttributesVersionPluginOption = pluginsMap.get(\"moduleAttributes\").version;\n    if (moduleAttributesVersionPluginOption !== \"may-2020\") {\n      throw new Error(\"The 'moduleAttributes' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is 'may-2020'.\");\n    }\n  }\n  if (pluginsMap.has(\"importAssertions\")) {\n    if (pluginsMap.has(\"deprecatedImportAssert\")) {\n      throw new Error(\"Cannot combine importAssertions and deprecatedImportAssert plugins.\");\n    }\n  }\n  if (pluginsMap.has(\"deprecatedImportAssert\")) ;else if (pluginsMap.has(\"importAttributes\") && pluginsMap.get(\"importAttributes\").deprecatedAssertSyntax) {\n    pluginsMap.set(\"deprecatedImportAssert\", {});\n  }\n  if (pluginsMap.has(\"recordAndTuple\")) {\n    const syntaxType = pluginsMap.get(\"recordAndTuple\").syntaxType;\n    if (syntaxType != null) {\n      const RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\n      if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {\n        throw new Error(\"The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n      }\n    }\n  }\n  if (pluginsMap.has(\"asyncDoExpressions\") && !pluginsMap.has(\"doExpressions\")) {\n    const error = new Error(\"'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.\");\n    error.missingPlugins = \"doExpressions\";\n    throw error;\n  }\n  if (pluginsMap.has(\"optionalChainingAssign\") && pluginsMap.get(\"optionalChainingAssign\").version !== \"2023-07\") {\n    throw new Error(\"The 'optionalChainingAssign' plugin requires a 'version' option,\" + \" representing the last proposal update. Currently, the\" + \" only supported value is '2023-07'.\");\n  }\n  if (pluginsMap.has(\"discardBinding\") && pluginsMap.get(\"discardBinding\").syntaxType !== \"void\") {\n    throw new Error(\"The 'discardBinding' plugin requires a 'syntaxType' option. Currently the only supported value is 'void'.\");\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\nclass ExpressionParser extends LValParser {\n  checkProto(prop, isRecord, sawProto, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {\n      return sawProto;\n    }\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : key.value;\n    if (name === \"__proto__\") {\n      if (isRecord) {\n        this.raise(Errors.RecordNoProto, key);\n        return true;\n      }\n      if (sawProto) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProtoLoc === null) {\n            refExpressionErrors.doubleProtoLoc = key.loc.start;\n          }\n        } else {\n          this.raise(Errors.DuplicateProto, key);\n        }\n      }\n      return true;\n    }\n    return sawProto;\n  }\n  shouldExitDescending(expr, potentialArrowAt) {\n    return expr.type === \"ArrowFunctionExpression\" && this.offsetToSourcePos(expr.start) === potentialArrowAt;\n  }\n  getExpression() {\n    this.enterInitialScopes();\n    this.nextToken();\n    if (this.match(140)) {\n      throw this.raise(Errors.ParseExpressionEmptyInput, this.state.startLoc);\n    }\n    const expr = this.parseExpression();\n    if (!this.match(140)) {\n      throw this.raise(Errors.ParseExpressionExpectsEOF, this.state.startLoc, {\n        unexpected: this.input.codePointAt(this.state.start)\n      });\n    }\n    this.finalizeRemainingComments();\n    expr.comments = this.comments;\n    expr.errors = this.state.errors;\n    if (this.optionFlags & 256) {\n      expr.tokens = this.tokens;\n    }\n    return expr;\n  }\n  parseExpression(disallowIn, refExpressionErrors) {\n    if (disallowIn) {\n      return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n    }\n    return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));\n  }\n  parseExpressionBase(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(refExpressionErrors);\n    if (this.match(12)) {\n      const node = this.startNodeAt(startLoc);\n      node.expressions = [expr];\n      while (this.eat(12)) {\n        node.expressions.push(this.parseMaybeAssign(refExpressionErrors));\n      }\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n    return expr;\n  }\n  parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {\n    return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {\n    return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));\n  }\n  setOptionalParametersError(refExpressionErrors) {\n    refExpressionErrors.optionalParametersLoc = this.state.startLoc;\n  }\n  parseMaybeAssign(refExpressionErrors, afterLeftParse) {\n    const startLoc = this.state.startLoc;\n    const isYield = this.isContextual(108);\n    if (isYield) {\n      if (this.prodParam.hasYield) {\n        this.next();\n        let left = this.parseYield(startLoc);\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startLoc);\n        }\n        return left;\n      }\n    }\n    let ownExpressionErrors;\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n    const {\n      type\n    } = this.state;\n    if (type === 10 || tokenIsIdentifier(type)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n    let left = this.parseMaybeConditional(refExpressionErrors);\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startLoc);\n    }\n    if (tokenIsAssignment(this.state.type)) {\n      const node = this.startNodeAt(startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n      if (this.match(29)) {\n        this.toAssignable(left, true);\n        node.left = left;\n        const startIndex = startLoc.index;\n        if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {\n          refExpressionErrors.doubleProtoLoc = null;\n        }\n        if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {\n          refExpressionErrors.shorthandAssignLoc = null;\n        }\n        if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {\n          this.checkDestructuringPrivate(refExpressionErrors);\n          refExpressionErrors.privateKeyLoc = null;\n        }\n        if (refExpressionErrors.voidPatternLoc != null && refExpressionErrors.voidPatternLoc.index >= startIndex) {\n          refExpressionErrors.voidPatternLoc = null;\n        }\n      } else {\n        node.left = left;\n      }\n      this.next();\n      node.right = this.parseMaybeAssign();\n      this.checkLVal(left, this.finishNode(node, \"AssignmentExpression\"), undefined, undefined, undefined, undefined, operator === \"||=\" || operator === \"&&=\" || operator === \"??=\");\n      return node;\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (isYield) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {\n        this.raiseOverwrite(Errors.YieldNotInGeneratorFunction, startLoc);\n        return this.parseYield(startLoc);\n      }\n    }\n    return left;\n  }\n  parseMaybeConditional(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseConditional(expr, startLoc, refExpressionErrors);\n  }\n  parseConditional(expr, startLoc, refExpressionErrors) {\n    if (this.eat(17)) {\n      const node = this.startNodeAt(startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssignAllowIn();\n      this.expect(14);\n      node.alternate = this.parseMaybeAssign();\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n    return expr;\n  }\n  parseMaybeUnaryOrPrivate(refExpressionErrors) {\n    return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);\n  }\n  parseExprOps(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseExprOp(expr, startLoc, -1);\n  }\n  parseExprOp(left, leftStartLoc, minPrec) {\n    if (this.isPrivateName(left)) {\n      const value = this.getPrivateNameSV(left);\n      if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {\n        this.raise(Errors.PrivateInExpectedIn, left, {\n          identifierName: value\n        });\n      }\n      this.classScope.usePrivateName(value, left.loc.start);\n    }\n    const op = this.state.type;\n    if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {\n      let prec = tokenOperatorPrecedence(op);\n      if (prec > minPrec) {\n        if (op === 39) {\n          this.expectPlugin(\"pipelineOperator\");\n          if (this.state.inFSharpPipelineDirectBody) {\n            return left;\n          }\n          this.checkPipelineAtInfixOperator(left, leftStartLoc);\n        }\n        const node = this.startNodeAt(leftStartLoc);\n        node.left = left;\n        node.operator = this.state.value;\n        const logical = op === 41 || op === 42;\n        const coalesce = op === 40;\n        if (coalesce) {\n          prec = tokenOperatorPrecedence(42);\n        }\n        this.next();\n        if (op === 39 && this.hasPlugin([\"pipelineOperator\", {\n          proposal: \"minimal\"\n        }])) {\n          if (this.state.type === 96 && this.prodParam.hasAwait) {\n            throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);\n          }\n        }\n        node.right = this.parseExprOpRightExpr(op, prec);\n        const finishedNode = this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n        if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {\n          throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);\n        }\n        return this.parseExprOp(finishedNode, leftStartLoc, minPrec);\n      }\n    }\n    return left;\n  }\n  parseExprOpRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    switch (op) {\n      case 39:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"hack\":\n            return this.withTopicBindingContext(() => {\n              return this.parseHackPipeBody();\n            });\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec);\n            });\n        }\n        if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n          return this.withTopicBindingContext(() => {\n            if (this.prodParam.hasYield && this.isContextual(108)) {\n              throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);\n            }\n            return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);\n          });\n        }\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec);\n    }\n  }\n  parseExprOpBaseRightExpr(op, prec) {\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);\n  }\n  parseHackPipeBody() {\n    var _body$extra;\n    const {\n      startLoc\n    } = this.state;\n    const body = this.parseMaybeAssign();\n    const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);\n    if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {\n      this.raise(Errors.PipeUnparenthesizedBody, startLoc, {\n        type: body.type\n      });\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipeTopicUnused, startLoc);\n    }\n    return body;\n  }\n  checkExponentialAfterUnary(node) {\n    if (this.match(57)) {\n      this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);\n    }\n  }\n  parseMaybeUnary(refExpressionErrors, sawUnary) {\n    const startLoc = this.state.startLoc;\n    const isAwait = this.isContextual(96);\n    if (isAwait && this.recordAwaitIfAllowed()) {\n      this.next();\n      const expr = this.parseAwait(startLoc);\n      if (!sawUnary) this.checkExponentialAfterUnary(expr);\n      return expr;\n    }\n    const update = this.match(34);\n    const node = this.startNode();\n    if (tokenIsPrefix(this.state.type)) {\n      node.operator = this.state.value;\n      node.prefix = true;\n      if (this.match(72)) {\n        this.expectPlugin(\"throwExpressions\");\n      }\n      const isDelete = this.match(89);\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refExpressionErrors, true);\n      if (this.state.strict && isDelete) {\n        const arg = node.argument;\n        if (arg.type === \"Identifier\") {\n          this.raise(Errors.StrictDelete, node);\n        } else if (this.hasPropertyAsPrivateName(arg)) {\n          this.raise(Errors.DeletePrivateField, node);\n        }\n      }\n      if (!update) {\n        if (!sawUnary) {\n          this.checkExponentialAfterUnary(node);\n        }\n        return this.finishNode(node, \"UnaryExpression\");\n      }\n    }\n    const expr = this.parseUpdate(node, update, refExpressionErrors);\n    if (isAwait) {\n      const {\n        type\n      } = this.state;\n      const startsExpr = this.hasPlugin(\"v8intrinsic\") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);\n      if (startsExpr && !this.isAmbiguousPrefixOrIdentifier()) {\n        this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);\n        return this.parseAwait(startLoc);\n      }\n    }\n    return expr;\n  }\n  parseUpdate(node, update, refExpressionErrors) {\n    if (update) {\n      const updateExpressionNode = node;\n      this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, \"UpdateExpression\"));\n      return node;\n    }\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.next();\n      this.checkLVal(expr, expr = this.finishNode(node, \"UpdateExpression\"));\n    }\n    return expr;\n  }\n  parseExprSubscripts(refExpressionErrors) {\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n    if (this.shouldExitDescending(expr, potentialArrowAt)) {\n      return expr;\n    }\n    return this.parseSubscripts(expr, startLoc);\n  }\n  parseSubscripts(base, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n    do {\n      base = this.parseSubscript(base, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n    } while (!state.stop);\n    return base;\n  }\n  parseSubscript(base, startLoc, noCalls, state) {\n    const {\n      type\n    } = this.state;\n    if (!noCalls && type === 15) {\n      return this.parseBind(base, startLoc, noCalls, state);\n    } else if (tokenIsTemplate(type)) {\n      return this.parseTaggedTemplateExpression(base, startLoc, state);\n    }\n    let optional = false;\n    if (type === 18) {\n      if (noCalls) {\n        this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);\n        if (this.lookaheadCharCode() === 40) {\n          return this.stopParseSubscript(base, state);\n        }\n      }\n      state.optionalChainMember = optional = true;\n      this.next();\n    }\n    if (!noCalls && this.match(10)) {\n      return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);\n    } else {\n      const computed = this.eat(0);\n      if (computed || optional || this.eat(16)) {\n        return this.parseMember(base, startLoc, state, computed, optional);\n      } else {\n        return this.stopParseSubscript(base, state);\n      }\n    }\n  }\n  stopParseSubscript(base, state) {\n    state.stop = true;\n    return base;\n  }\n  parseMember(base, startLoc, state, computed, optional) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    node.computed = computed;\n    if (computed) {\n      node.property = this.parseExpression();\n      this.expect(3);\n    } else if (this.match(139)) {\n      if (base.type === \"Super\") {\n        this.raise(Errors.SuperPrivateField, startLoc);\n      }\n      this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n      node.property = this.parsePrivateName();\n    } else {\n      node.property = this.parseIdentifier(true);\n    }\n    if (state.optionalChainMember) {\n      node.optional = optional;\n      return this.finishNode(node, \"OptionalMemberExpression\");\n    } else {\n      return this.finishNode(node, \"MemberExpression\");\n    }\n  }\n  parseBind(base, startLoc, noCalls, state) {\n    const node = this.startNodeAt(startLoc);\n    node.object = base;\n    this.next();\n    node.callee = this.parseNoCallExpr();\n    state.stop = true;\n    return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startLoc, noCalls);\n  }\n  parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    let refExpressionErrors = null;\n    this.state.maybeInArrowParameters = true;\n    this.next();\n    const node = this.startNodeAt(startLoc);\n    node.callee = base;\n    const {\n      maybeAsyncArrow,\n      optionalChainMember\n    } = state;\n    if (maybeAsyncArrow) {\n      this.expressionScope.enter(newAsyncArrowScope());\n      refExpressionErrors = new ExpressionErrors();\n    }\n    if (optionalChainMember) {\n      node.optional = optional;\n    }\n    if (optional) {\n      node.arguments = this.parseCallExpressionArguments();\n    } else {\n      node.arguments = this.parseCallExpressionArguments(base.type !== \"Super\", node, refExpressionErrors);\n    }\n    let finishedNode = this.finishCallExpression(node, optionalChainMember);\n    if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n      state.stop = true;\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);\n    } else {\n      if (maybeAsyncArrow) {\n        this.checkExpressionErrors(refExpressionErrors, true);\n        this.expressionScope.exit();\n      }\n      this.toReferencedArguments(finishedNode);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return finishedNode;\n  }\n  toReferencedArguments(node, isParenthesizedExpr) {\n    this.toReferencedListDeep(node.arguments, isParenthesizedExpr);\n  }\n  parseTaggedTemplateExpression(base, startLoc, state) {\n    const node = this.startNodeAt(startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (state.optionalChainMember) {\n      this.raise(Errors.OptionalChainingNoTemplate, startLoc);\n    }\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;\n  }\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length === 0 || node.arguments.length > 2) {\n        this.raise(Errors.ImportCallArity, node);\n      } else {\n        for (const arg of node.arguments) {\n          if (arg.type === \"SpreadElement\") {\n            this.raise(Errors.ImportCallSpreadArgument, arg);\n          }\n        }\n      }\n    }\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n  parseCallExpressionArguments(allowPlaceholder, nodeForExtra, refExpressionErrors) {\n    const elts = [];\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    while (!this.eat(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(11)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(11, false, refExpressionErrors, allowPlaceholder));\n    }\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n  shouldParseAsyncArrow() {\n    return this.match(19) && !this.canInsertSemicolon();\n  }\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n    this.resetPreviousNodeTrailingComments(call);\n    this.expect(19);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);\n    if (call.innerComments) {\n      setInnerComments(node, call.innerComments);\n    }\n    if (call.callee.trailingComments) {\n      setInnerComments(node, call.callee.trailingComments);\n    }\n    return node;\n  }\n  parseNoCallExpr() {\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startLoc, true);\n  }\n  parseExprAtom(refExpressionErrors) {\n    let node;\n    let decorators = null;\n    const {\n      type\n    } = this.state;\n    switch (type) {\n      case 79:\n        return this.parseSuper();\n      case 83:\n        node = this.startNode();\n        this.next();\n        if (this.match(16)) {\n          return this.parseImportMetaPropertyOrPhaseCall(node);\n        }\n        if (this.match(10)) {\n          if (this.optionFlags & 512) {\n            return this.parseImportCall(node);\n          } else {\n            return this.finishNode(node, \"Import\");\n          }\n        } else {\n          this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);\n          return this.finishNode(node, \"Import\");\n        }\n      case 78:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n      case 90:\n        {\n          return this.parseDo(this.startNode(), false);\n        }\n      case 56:\n      case 31:\n        {\n          this.readRegexp();\n          return this.parseRegExpLiteral(this.state.value);\n        }\n      case 135:\n        return this.parseNumericLiteral(this.state.value);\n      case 136:\n        return this.parseBigIntLiteral(this.state.value);\n      case 134:\n        return this.parseStringLiteral(this.state.value);\n      case 84:\n        return this.parseNullLiteral();\n      case 85:\n        return this.parseBooleanLiteral(true);\n      case 86:\n        return this.parseBooleanLiteral(false);\n      case 10:\n        {\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          return this.parseParenAndDistinguishExpression(canBeArrow);\n        }\n      case 0:\n        {\n          return this.parseArrayLike(3, false, refExpressionErrors);\n        }\n      case 5:\n        {\n          return this.parseObjectLike(8, false, false, refExpressionErrors);\n        }\n      case 68:\n        return this.parseFunctionOrFunctionSent();\n      case 26:\n        decorators = this.parseDecorators();\n      case 80:\n        return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);\n      case 77:\n        return this.parseNewOrNewTarget();\n      case 25:\n      case 24:\n        return this.parseTemplate(false);\n      case 15:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(Errors.UnsupportedBind, callee);\n          }\n        }\n      case 139:\n        {\n          this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {\n            identifierName: this.state.value\n          });\n          return this.parsePrivateName();\n        }\n      case 33:\n        {\n          return this.parseTopicReferenceThenEqualsSign(54, \"%\");\n        }\n      case 32:\n        {\n          return this.parseTopicReferenceThenEqualsSign(44, \"^\");\n        }\n      case 37:\n      case 38:\n        {\n          return this.parseTopicReference(\"hack\");\n        }\n      case 44:\n      case 54:\n      case 27:\n        {\n          const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n          if (pipeProposal) {\n            return this.parseTopicReference(pipeProposal);\n          }\n          throw this.unexpected();\n        }\n      case 47:\n        {\n          const lookaheadCh = this.input.codePointAt(this.nextTokenStart());\n          if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {\n            throw this.expectOnePlugin([\"jsx\", \"flow\", \"typescript\"]);\n          }\n          throw this.unexpected();\n        }\n      default:\n        if (type === 137) {\n          return this.parseDecimalLiteral(this.state.value);\n        } else if (type === 2 || type === 1) {\n          return this.parseArrayLike(this.state.type === 2 ? 4 : 3, true);\n        } else if (type === 6 || type === 7) {\n          return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);\n        }\n        if (tokenIsIdentifier(type)) {\n          if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {\n            return this.parseModuleExpression();\n          }\n          const canBeArrow = this.state.potentialArrowAt === this.state.start;\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n          if (!containsEsc && id.name === \"async\" && !this.canInsertSemicolon()) {\n            const {\n              type\n            } = this.state;\n            if (type === 68) {\n              this.resetPreviousNodeTrailingComments(id);\n              this.next();\n              return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));\n            } else if (tokenIsIdentifier(type)) {\n              if (this.lookaheadCharCode() === 61) {\n                return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));\n              } else {\n                return id;\n              }\n            } else if (type === 90) {\n              this.resetPreviousNodeTrailingComments(id);\n              return this.parseDo(this.startNodeAtNode(id), true);\n            }\n          }\n          if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {\n            this.next();\n            return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);\n          }\n          return id;\n        } else {\n          throw this.unexpected();\n        }\n    }\n  }\n  parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {\n    const pipeProposal = this.getPluginOption(\"pipelineOperator\", \"proposal\");\n    if (pipeProposal) {\n      this.state.type = topicTokenType;\n      this.state.value = topicTokenValue;\n      this.state.pos--;\n      this.state.end--;\n      this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);\n      return this.parseTopicReference(pipeProposal);\n    }\n    throw this.unexpected();\n  }\n  parseTopicReference(pipeProposal) {\n    const node = this.startNode();\n    const startLoc = this.state.startLoc;\n    const tokenType = this.state.type;\n    this.next();\n    return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);\n  }\n  finishTopicReference(node, startLoc, pipeProposal, tokenType) {\n    if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {\n      if (pipeProposal === \"hack\") {\n        if (!this.topicReferenceIsAllowedInCurrentContext()) {\n          this.raise(Errors.PipeTopicUnbound, startLoc);\n        }\n        this.registerTopicReference();\n        return this.finishNode(node, \"TopicReference\");\n      } else {\n        if (!this.topicReferenceIsAllowedInCurrentContext()) {\n          this.raise(Errors.PrimaryTopicNotAllowed, startLoc);\n        }\n        this.registerTopicReference();\n        return this.finishNode(node, \"PipelinePrimaryTopicReference\");\n      }\n    } else {\n      throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {\n        token: tokenLabelName(tokenType)\n      });\n    }\n  }\n  testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {\n    switch (pipeProposal) {\n      case \"hack\":\n        {\n          return this.hasPlugin([\"pipelineOperator\", {\n            topicToken: tokenLabelName(tokenType)\n          }]);\n        }\n      case \"smart\":\n        return tokenType === 27;\n      default:\n        throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);\n    }\n  }\n  parseAsyncArrowUnaryFunction(node) {\n    this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));\n    const params = [this.parseIdentifier()];\n    this.prodParam.exit();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());\n    }\n    this.expect(19);\n    return this.parseArrowExpression(node, params, true);\n  }\n  parseDo(node, isAsync) {\n    this.expectPlugin(\"doExpressions\");\n    if (isAsync) {\n      this.expectPlugin(\"asyncDoExpressions\");\n    }\n    node.async = isAsync;\n    this.next();\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    if (isAsync) {\n      this.prodParam.enter(2);\n      node.body = this.parseBlock();\n      this.prodParam.exit();\n    } else {\n      node.body = this.parseBlock();\n    }\n    this.state.labels = oldLabels;\n    return this.finishNode(node, \"DoExpression\");\n  }\n  parseSuper() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(10) && !this.scope.allowDirectSuper) {\n      if (!(this.optionFlags & 16)) {\n        this.raise(Errors.SuperNotAllowed, node);\n      }\n    } else if (!this.scope.allowSuper) {\n      if (!(this.optionFlags & 16)) {\n        this.raise(Errors.UnexpectedSuper, node);\n      }\n    }\n    if (!this.match(10) && !this.match(0) && !this.match(16)) {\n      this.raise(Errors.UnsupportedSuper, node);\n    }\n    return this.finishNode(node, \"Super\");\n  }\n  parsePrivateName() {\n    const node = this.startNode();\n    const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));\n    const name = this.state.value;\n    this.next();\n    node.id = this.createIdentifier(id, name);\n    return this.finishNode(node, \"PrivateName\");\n  }\n  parseFunctionOrFunctionSent() {\n    const node = this.startNode();\n    this.next();\n    if (this.prodParam.hasYield && this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"function\");\n      this.next();\n      if (this.match(103)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n    return this.parseFunction(node);\n  }\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(Errors.UnsupportedMetaProperty, node.property, {\n        target: meta.name,\n        onlyValidPropertyName: propertyName\n      });\n    }\n    return this.finishNode(node, \"MetaProperty\");\n  }\n  parseImportMetaPropertyOrPhaseCall(node) {\n    this.next();\n    if (this.isContextual(105) || this.isContextual(97)) {\n      const isSource = this.isContextual(105);\n      this.expectPlugin(isSource ? \"sourcePhaseImports\" : \"deferredImportEvaluation\");\n      this.next();\n      node.phase = isSource ? \"source\" : \"defer\";\n      return this.parseImportCall(node);\n    } else {\n      const id = this.createIdentifierAt(this.startNodeAtNode(node), \"import\", this.state.lastTokStartLoc);\n      if (this.isContextual(101)) {\n        if (!this.inModule) {\n          this.raise(Errors.ImportMetaOutsideModule, id);\n        }\n        this.sawUnambiguousESM = true;\n      }\n      return this.parseMetaProperty(node, id, \"meta\");\n    }\n  }\n  parseLiteralAtNode(value, type, node) {\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n  parseLiteral(value, type) {\n    const node = this.startNode();\n    return this.parseLiteralAtNode(value, type, node);\n  }\n  parseStringLiteral(value) {\n    return this.parseLiteral(value, \"StringLiteral\");\n  }\n  parseNumericLiteral(value) {\n    return this.parseLiteral(value, \"NumericLiteral\");\n  }\n  parseBigIntLiteral(value) {\n    return this.parseLiteral(value, \"BigIntLiteral\");\n  }\n  parseDecimalLiteral(value) {\n    return this.parseLiteral(value, \"DecimalLiteral\");\n  }\n  parseRegExpLiteral(value) {\n    const node = this.startNode();\n    this.addExtra(node, \"raw\", this.input.slice(this.offsetToSourcePos(node.start), this.state.end));\n    node.pattern = value.pattern;\n    node.flags = value.flags;\n    this.next();\n    return this.finishNode(node, \"RegExpLiteral\");\n  }\n  parseBooleanLiteral(value) {\n    const node = this.startNode();\n    node.value = value;\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n  parseNullLiteral() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"NullLiteral\");\n  }\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startLoc = this.state.startLoc;\n    let val;\n    this.next();\n    this.expressionScope.enter(newArrowHeadScope());\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    let first = true;\n    let spreadStartLoc;\n    let optionalCommaStartLoc;\n    while (!this.match(11)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);\n        if (this.match(11)) {\n          optionalCommaStartLoc = this.state.startLoc;\n          break;\n        }\n      }\n      if (this.match(21)) {\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStartLoc = this.state.startLoc;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));\n        if (!this.checkCommaAfterRest(41)) {\n          break;\n        }\n      } else {\n        exprList.push(this.parseMaybeAssignAllowInOrVoidPattern(11, refExpressionErrors, this.parseParenItem));\n      }\n    }\n    const innerEndLoc = this.state.lastTokEndLoc;\n    this.expect(11);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startLoc);\n    if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.expressionScope.validateAsPattern();\n      this.expressionScope.exit();\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n    this.expressionScope.exit();\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStartLoc);\n    }\n    if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);\n    if (spreadStartLoc) this.unexpected(spreadStartLoc);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    this.toReferencedListDeep(exprList, true);\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartLoc);\n      val.expressions = exprList;\n      this.finishNode(val, \"SequenceExpression\");\n      this.resetEndLocation(val, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n    return this.wrapParenthesis(startLoc, val);\n  }\n  wrapParenthesis(startLoc, expression) {\n    if (!(this.optionFlags & 1024)) {\n      this.addExtra(expression, \"parenthesized\", true);\n      this.addExtra(expression, \"parenStart\", startLoc.index);\n      this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);\n      return expression;\n    }\n    const parenExpression = this.startNodeAt(startLoc);\n    parenExpression.expression = expression;\n    return this.finishNode(parenExpression, \"ParenthesizedExpression\");\n  }\n  shouldParseArrow(params) {\n    return !this.canInsertSemicolon();\n  }\n  parseArrow(node) {\n    if (this.eat(19)) {\n      return node;\n    }\n  }\n  parseParenItem(node, startLoc) {\n    return node;\n  }\n  parseNewOrNewTarget() {\n    const node = this.startNode();\n    this.next();\n    if (this.match(16)) {\n      const meta = this.createIdentifier(this.startNodeAtNode(node), \"new\");\n      this.next();\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n      if (!this.scope.allowNewTarget) {\n        this.raise(Errors.UnexpectedNewTarget, metaProp);\n      }\n      return metaProp;\n    }\n    return this.parseNew(node);\n  }\n  parseNew(node) {\n    this.parseNewCallee(node);\n    if (this.eat(10)) {\n      const args = this.parseExprList(11);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n    return this.finishNode(node, \"NewExpression\");\n  }\n  parseNewCallee(node) {\n    const isImport = this.match(83);\n    const callee = this.parseNoCallExpr();\n    node.callee = callee;\n    if (isImport && (callee.type === \"Import\" || callee.type === \"ImportExpression\")) {\n      this.raise(Errors.ImportCallNotNewExpression, callee);\n    }\n  }\n  parseTemplateElement(isTagged) {\n    const {\n      start,\n      startLoc,\n      end,\n      value\n    } = this.state;\n    const elemStart = start + 1;\n    const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));\n    if (value === null) {\n      if (!isTagged) {\n        this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));\n      }\n    }\n    const isTail = this.match(24);\n    const endOffset = isTail ? -1 : -2;\n    const elemEnd = end + endOffset;\n    elem.value = {\n      raw: this.input.slice(elemStart, elemEnd).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: value === null ? null : value.slice(1, endOffset)\n    };\n    elem.tail = isTail;\n    this.next();\n    const finishedNode = this.finishNode(elem, \"TemplateElement\");\n    this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));\n    return finishedNode;\n  }\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    let curElt = this.parseTemplateElement(isTagged);\n    const quasis = [curElt];\n    const substitutions = [];\n    while (!curElt.tail) {\n      substitutions.push(this.parseTemplateSubstitution());\n      this.readTemplateContinuation();\n      quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n    node.expressions = substitutions;\n    node.quasis = quasis;\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n  parseTemplateSubstitution() {\n    return this.parseExpression();\n  }\n  parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {\n    if (isRecord) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    let sawProto = false;\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n    while (!this.match(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          this.addTrailingCommaExtraToNode(node);\n          break;\n        }\n      }\n      let prop;\n      if (isPattern) {\n        prop = this.parseBindingProperty();\n      } else {\n        prop = this.parsePropertyDefinition(refExpressionErrors);\n        sawProto = this.checkProto(prop, isRecord, sawProto, refExpressionErrors);\n      }\n      if (isRecord && !this.isObjectProperty(prop) && prop.type !== \"SpreadElement\") {\n        this.raise(Errors.InvalidRecordProperty, prop);\n      }\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n      node.properties.push(prop);\n    }\n    this.next();\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let type = \"ObjectExpression\";\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n    return this.finishNode(node, type);\n  }\n  addTrailingCommaExtraToNode(node) {\n    this.addExtra(node, \"trailingComma\", this.state.lastTokStartLoc.index);\n    this.addExtra(node, \"trailingCommaLoc\", this.state.lastTokStartLoc, false);\n  }\n  maybeAsyncOrAccessorProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));\n  }\n  parsePropertyDefinition(refExpressionErrors) {\n    let decorators = [];\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);\n      }\n      while (this.match(26)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n    const prop = this.startNode();\n    let isAsync = false;\n    let isAccessor = false;\n    let startLoc;\n    if (this.match(21)) {\n      if (decorators.length) this.unexpected();\n      return this.parseSpread();\n    }\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n    prop.method = false;\n    if (refExpressionErrors) {\n      startLoc = this.state.startLoc;\n    }\n    let isGenerator = this.eat(55);\n    this.parsePropertyNamePrefixOperator(prop);\n    const containsEsc = this.state.containsEsc;\n    this.parsePropertyName(prop, refExpressionErrors);\n    if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {\n      const {\n        key\n      } = prop;\n      const keyName = key.name;\n      if (keyName === \"async\" && !this.hasPrecedingLineBreak()) {\n        isAsync = true;\n        this.resetPreviousNodeTrailingComments(key);\n        isGenerator = this.eat(55);\n        this.parsePropertyName(prop);\n      }\n      if (keyName === \"get\" || keyName === \"set\") {\n        isAccessor = true;\n        this.resetPreviousNodeTrailingComments(key);\n        prop.kind = keyName;\n        if (this.match(55)) {\n          isGenerator = true;\n          this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {\n            kind: keyName\n          });\n          this.next();\n        }\n        this.parsePropertyName(prop);\n      }\n    }\n    return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);\n  }\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n  getObjectOrClassMethodParams(method) {\n    return method.params;\n  }\n  checkGetterSetterParams(method) {\n    var _params;\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const params = this.getObjectOrClassMethodParams(method);\n    if (params.length !== paramCount) {\n      this.raise(method.kind === \"get\" ? Errors.BadGetterArity : Errors.BadSetterArity, method);\n    }\n    if (method.kind === \"set\" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === \"RestElement\") {\n      this.raise(Errors.BadSetterRestParameter, method);\n    }\n  }\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {\n    if (isAccessor) {\n      const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(finishedProp);\n      return finishedProp;\n    }\n    if (isAsync || isGenerator || this.match(10)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n  }\n  parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n    if (this.eat(14)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowInOrVoidPattern(8, refExpressionErrors);\n      return this.finishObjectProperty(prop);\n    }\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));\n      } else if (this.match(29)) {\n        const shorthandAssignLoc = this.state.startLoc;\n        if (refExpressionErrors != null) {\n          if (refExpressionErrors.shorthandAssignLoc === null) {\n            refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;\n          }\n        } else {\n          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);\n        }\n        prop.value = this.parseMaybeDefault(startLoc, this.cloneIdentifier(prop.key));\n      } else {\n        prop.value = this.cloneIdentifier(prop.key);\n      }\n      prop.shorthand = true;\n      return this.finishObjectProperty(prop);\n    }\n  }\n  finishObjectProperty(node) {\n    return this.finishNode(node, \"ObjectProperty\");\n  }\n  parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n  parsePropertyName(prop, refExpressionErrors) {\n    if (this.eat(0)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssignAllowIn();\n      this.expect(3);\n    } else {\n      const {\n        type,\n        value\n      } = this.state;\n      let key;\n      if (tokenIsKeywordOrIdentifier(type)) {\n        key = this.parseIdentifier(true);\n      } else {\n        switch (type) {\n          case 135:\n            key = this.parseNumericLiteral(value);\n            break;\n          case 134:\n            key = this.parseStringLiteral(value);\n            break;\n          case 136:\n            key = this.parseBigIntLiteral(value);\n            break;\n          case 139:\n            {\n              const privateKeyLoc = this.state.startLoc;\n              if (refExpressionErrors != null) {\n                if (refExpressionErrors.privateKeyLoc === null) {\n                  refExpressionErrors.privateKeyLoc = privateKeyLoc;\n                }\n              } else {\n                this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);\n              }\n              key = this.parsePrivateName();\n              break;\n            }\n          default:\n            if (type === 137) {\n              key = this.parseDecimalLiteral(value);\n              break;\n            }\n            this.unexpected();\n        }\n      }\n      prop.key = key;\n      if (type !== 139) {\n        prop.computed = false;\n      }\n    }\n  }\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = isAsync;\n  }\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    this.initFunction(node, isAsync);\n    node.generator = isGenerator;\n    this.scope.enter(514 | 16 | (inClassScope ? 576 : 0) | (allowDirectSuper ? 32 : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, isConstructor);\n    const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    return finishedNode;\n  }\n  parseArrayLike(close, isTuple, refExpressionErrors) {\n    if (isTuple) {\n      this.expectPlugin(\"recordAndTuple\");\n    }\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n    const node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return this.finishNode(node, isTuple ? \"TupleExpression\" : \"ArrayExpression\");\n  }\n  parseArrowExpression(node, params, isAsync, trailingCommaLoc) {\n    this.scope.enter(514 | 4);\n    let flags = functionFlags(isAsync, false);\n    if (!this.match(5) && this.prodParam.hasIn) {\n      flags |= 8;\n    }\n    this.prodParam.enter(flags);\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaLoc);\n    }\n    this.state.maybeInArrowParameters = false;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n  setArrowFunctionParameters(node, params, trailingCommaLoc) {\n    this.toAssignableList(params, trailingCommaLoc, false);\n    node.params = params;\n  }\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    return this.finishNode(node, type);\n  }\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(5);\n    this.expressionScope.enter(newExpressionScope());\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | 4);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n        if (hasStrictModeDirective && nonSimple) {\n          this.raise(Errors.IllegalLanguageModeDirective, (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.loc.end : node);\n        }\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n        if (this.state.strict && node.id) {\n          this.checkIdentifier(node.id, 65, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n    this.expressionScope.exit();\n  }\n  isSimpleParameter(node) {\n    return node.type === \"Identifier\";\n  }\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (!this.isSimpleParameter(params[i])) return false;\n    }\n    return true;\n  }\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const checkClashes = !allowDuplicates && new Set();\n    const formalParameters = {\n      type: \"FormalParameters\"\n    };\n    for (const param of node.params) {\n      this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);\n    }\n  }\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addTrailingCommaExtraToNode(nodeForExtra);\n          }\n          this.next();\n          break;\n        }\n      }\n      elts.push(this.parseExprListItem(close, allowEmpty, refExpressionErrors));\n    }\n    return elts;\n  }\n  parseExprListItem(close, allowEmpty, refExpressionErrors, allowPlaceholder) {\n    let elt;\n    if (this.match(12)) {\n      if (!allowEmpty) {\n        this.raise(Errors.UnexpectedToken, this.state.curPosition(), {\n          unexpected: \",\"\n        });\n      }\n      elt = null;\n    } else if (this.match(21)) {\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);\n    } else if (this.match(17)) {\n      this.expectPlugin(\"partialApplication\");\n      if (!allowPlaceholder) {\n        this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);\n      }\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, this.parseParenItem);\n    }\n    return elt;\n  }\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(liberal);\n    return this.createIdentifier(node, name);\n  }\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n  createIdentifierAt(node, name, endLoc) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNodeAt(node, \"Identifier\", endLoc);\n  }\n  parseIdentifierName(liberal) {\n    let name;\n    const {\n      startLoc,\n      type\n    } = this.state;\n    if (tokenIsKeywordOrIdentifier(type)) {\n      name = this.state.value;\n    } else {\n      this.unexpected();\n    }\n    const tokenIsKeyword = tokenKeywordOrIdentifierIsKeyword(type);\n    if (liberal) {\n      if (tokenIsKeyword) {\n        this.replaceToken(132);\n      }\n    } else {\n      this.checkReservedWord(name, startLoc, tokenIsKeyword, false);\n    }\n    this.next();\n    return name;\n  }\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (word.length > 10) {\n      return;\n    }\n    if (!canBeReservedWord(word)) {\n      return;\n    }\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(Errors.UnexpectedKeyword, startLoc, {\n        keyword: word\n      });\n      return;\n    }\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n    if (reservedTest(word, this.inModule)) {\n      this.raise(Errors.UnexpectedReservedWord, startLoc, {\n        reservedWord: word\n      });\n      return;\n    } else if (word === \"yield\") {\n      if (this.prodParam.hasYield) {\n        this.raise(Errors.YieldBindingIdentifier, startLoc);\n        return;\n      }\n    } else if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(Errors.AwaitBindingIdentifier, startLoc);\n        return;\n      }\n      if (this.scope.inStaticBlock) {\n        this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);\n        return;\n      }\n      this.expressionScope.recordAsyncArrowParametersError(startLoc);\n    } else if (word === \"arguments\") {\n      if (this.scope.inClassAndNotInNonArrowFunction) {\n        this.raise(Errors.ArgumentsInClass, startLoc);\n        return;\n      }\n    }\n  }\n  recordAwaitIfAllowed() {\n    const isAwaitAllowed = this.prodParam.hasAwait;\n    if (isAwaitAllowed && !this.scope.inFunction) {\n      this.state.hasTopLevelAwait = true;\n    }\n    return isAwaitAllowed;\n  }\n  parseAwait(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);\n    if (this.eat(55)) {\n      this.raise(Errors.ObsoleteAwaitStar, node);\n    }\n    if (!this.scope.inFunction && !(this.optionFlags & 1)) {\n      if (this.isAmbiguousPrefixOrIdentifier()) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary(null, true);\n    }\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n  isAmbiguousPrefixOrIdentifier() {\n    if (this.hasPrecedingLineBreak()) return true;\n    const {\n      type\n    } = this.state;\n    return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin(\"v8intrinsic\") && type === 54;\n  }\n  parseYield(startLoc) {\n    const node = this.startNodeAt(startLoc);\n    this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);\n    let delegating = false;\n    let argument = null;\n    if (!this.hasPrecedingLineBreak()) {\n      delegating = this.eat(55);\n      switch (this.state.type) {\n        case 13:\n        case 140:\n        case 8:\n        case 11:\n        case 3:\n        case 9:\n        case 14:\n        case 12:\n          if (!delegating) break;\n        default:\n          argument = this.parseMaybeAssign();\n      }\n    }\n    node.delegate = delegating;\n    node.argument = argument;\n    return this.finishNode(node, \"YieldExpression\");\n  }\n  parseImportCall(node) {\n    this.next();\n    node.source = this.parseMaybeAssignAllowIn();\n    node.options = null;\n    if (this.eat(12)) {\n      if (!this.match(11)) {\n        node.options = this.parseMaybeAssignAllowIn();\n        if (this.eat(12)) {\n          this.addTrailingCommaExtraToNode(node.options);\n          if (!this.match(11)) {\n            do {\n              this.parseMaybeAssignAllowIn();\n            } while (this.eat(12) && !this.match(11));\n            this.raise(Errors.ImportCallArity, node);\n          }\n        }\n      } else {\n        this.addTrailingCommaExtraToNode(node.source);\n      }\n    }\n    this.expect(11);\n    return this.finishNode(node, \"ImportExpression\");\n  }\n  checkPipelineAtInfixOperator(left, leftStartLoc) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);\n      }\n    }\n  }\n  parseSmartPipelineBodyInStyle(childExpr, startLoc) {\n    if (this.isSimpleReference(childExpr)) {\n      const bodyNode = this.startNodeAt(startLoc);\n      bodyNode.callee = childExpr;\n      return this.finishNode(bodyNode, \"PipelineBareFunction\");\n    } else {\n      const bodyNode = this.startNodeAt(startLoc);\n      this.checkSmartPipeTopicBodyEarlyErrors(startLoc);\n      bodyNode.expression = childExpr;\n      return this.finishNode(bodyNode, \"PipelineTopicExpression\");\n    }\n  }\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n      case \"Identifier\":\n        return true;\n      default:\n        return false;\n    }\n  }\n  checkSmartPipeTopicBodyEarlyErrors(startLoc) {\n    if (this.match(19)) {\n      throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);\n    }\n    if (!this.topicReferenceWasUsedInCurrentContext()) {\n      this.raise(Errors.PipelineTopicUnused, startLoc);\n    }\n  }\n  withTopicBindingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n  withSmartMixTopicForbiddingContext(callback) {\n    if (this.hasPlugin([\"pipelineOperator\", {\n      proposal: \"smart\"\n    }])) {\n      const outerContextTopicState = this.state.topicContext;\n      this.state.topicContext = {\n        maxNumOfResolvableTopics: 0,\n        maxTopicIndex: null\n      };\n      try {\n        return callback();\n      } finally {\n        this.state.topicContext = outerContextTopicState;\n      }\n    } else {\n      return callback();\n    }\n  }\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n  allowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToSet = 8 & ~flags;\n    if (prodParamToSet) {\n      this.prodParam.enter(flags | 8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  disallowInAnd(callback) {\n    const flags = this.prodParam.currentFlags();\n    const prodParamToClear = 8 & flags;\n    if (prodParamToClear) {\n      this.prodParam.enter(flags & ~8);\n      try {\n        return callback();\n      } finally {\n        this.prodParam.exit();\n      }\n    }\n    return callback();\n  }\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n  topicReferenceIsAllowedInCurrentContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n  topicReferenceWasUsedInCurrentContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n  parseFSharpPipelineBody(prec) {\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n  parseModuleExpression() {\n    this.expectPlugin(\"moduleBlocks\");\n    const node = this.startNode();\n    this.next();\n    if (!this.match(5)) {\n      this.unexpected(null, 5);\n    }\n    const program = this.startNodeAt(this.state.endLoc);\n    this.next();\n    const revertScopes = this.initializeScopes(true);\n    this.enterInitialScopes();\n    try {\n      node.body = this.parseProgram(program, 8, \"module\");\n    } finally {\n      revertScopes();\n    }\n    return this.finishNode(node, \"ModuleExpression\");\n  }\n  parseVoidPattern(refExpressionErrors) {\n    this.expectPlugin(\"discardBinding\");\n    const node = this.startNode();\n    if (refExpressionErrors != null) {\n      refExpressionErrors.voidPatternLoc = this.state.startLoc;\n    }\n    this.next();\n    return this.finishNode(node, \"VoidPattern\");\n  }\n  parseMaybeAssignAllowInOrVoidPattern(close, refExpressionErrors, afterLeftParse) {\n    if (refExpressionErrors != null && this.match(88)) {\n      const nextCode = this.lookaheadCharCode();\n      if (nextCode === 44 || nextCode === (close === 3 ? 93 : close === 8 ? 125 : 41) || nextCode === 61) {\n        return this.parseMaybeDefault(this.state.startLoc, this.parseVoidPattern(refExpressionErrors));\n      }\n    }\n    return this.parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse);\n  }\n  parsePropertyNamePrefixOperator(prop) {}\n}\nconst loopLabel = {\n    kind: 1\n  },\n  switchLabel = {\n    kind: 2\n  };\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\nfunction babel7CompatTokens(tokens, input, startIndex) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const {\n      type\n    } = token;\n    if (typeof type === \"number\") {\n      if (type === 139) {\n        const {\n          loc,\n          start,\n          value,\n          end\n        } = token;\n        const hashEndPos = start + 1;\n        const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n        tokens.splice(i, 1, new Token({\n          type: getExportedToken(27),\n          value: \"#\",\n          start: start,\n          end: hashEndPos,\n          startLoc: loc.start,\n          endLoc: hashEndLoc\n        }), new Token({\n          type: getExportedToken(132),\n          value: value,\n          start: hashEndPos,\n          end: end,\n          startLoc: hashEndLoc,\n          endLoc: loc.end\n        }));\n        i++;\n        continue;\n      }\n      if (tokenIsTemplate(type)) {\n        const {\n          loc,\n          start,\n          value,\n          end\n        } = token;\n        const backquoteEnd = start + 1;\n        const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n        let startToken;\n        if (input.charCodeAt(start - startIndex) === 96) {\n          startToken = new Token({\n            type: getExportedToken(22),\n            value: \"`\",\n            start: start,\n            end: backquoteEnd,\n            startLoc: loc.start,\n            endLoc: backquoteEndLoc\n          });\n        } else {\n          startToken = new Token({\n            type: getExportedToken(8),\n            value: \"}\",\n            start: start,\n            end: backquoteEnd,\n            startLoc: loc.start,\n            endLoc: backquoteEndLoc\n          });\n        }\n        let templateValue, templateElementEnd, templateElementEndLoc, endToken;\n        if (type === 24) {\n          templateElementEnd = end - 1;\n          templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n          templateValue = value === null ? null : value.slice(1, -1);\n          endToken = new Token({\n            type: getExportedToken(22),\n            value: \"`\",\n            start: templateElementEnd,\n            end: end,\n            startLoc: templateElementEndLoc,\n            endLoc: loc.end\n          });\n        } else {\n          templateElementEnd = end - 2;\n          templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n          templateValue = value === null ? null : value.slice(1, -2);\n          endToken = new Token({\n            type: getExportedToken(23),\n            value: \"${\",\n            start: templateElementEnd,\n            end: end,\n            startLoc: templateElementEndLoc,\n            endLoc: loc.end\n          });\n        }\n        tokens.splice(i, 1, startToken, new Token({\n          type: getExportedToken(20),\n          value: templateValue,\n          start: backquoteEnd,\n          end: templateElementEnd,\n          startLoc: backquoteEndLoc,\n          endLoc: templateElementEndLoc\n        }), endToken);\n        i += 2;\n        continue;\n      }\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    file.program = this.parseProgram(program, 140, this.options.sourceType === \"module\" ? \"module\" : \"script\");\n    file.comments = this.comments;\n    if (this.optionFlags & 256) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);\n    }\n    return this.finishNode(file, \"File\");\n  }\n  parseProgram(program, end, sourceType) {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (this.inModule) {\n      if (!(this.optionFlags & 64) && this.scope.undefinedExports.size > 0) {\n        for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n          this.raise(Errors.ModuleExportUndefined, at, {\n            localName\n          });\n        }\n      }\n      this.addExtra(program, \"topLevelAwait\", this.state.hasTopLevelAwait);\n    }\n    let finishedProgram;\n    if (end === 140) {\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      finishedProgram = this.finishNodeAt(program, \"Program\", createPositionWithColumnOffset(this.state.startLoc, -1));\n    }\n    return finishedProgram;\n  }\n  stmtToDirective(stmt) {\n    const directive = this.castNodeTo(stmt, \"Directive\");\n    const directiveLiteral = this.castNodeTo(stmt.expression, \"DirectiveLiteral\");\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n    directive.value = directiveLiteral;\n    delete stmt.expression;\n    return directive;\n  }\n  parseInterpreterDirective() {\n    if (!this.match(28)) {\n      return null;\n    }\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n  isLet() {\n    if (!this.isContextual(100)) {\n      return false;\n    }\n    return this.hasFollowingBindingAtom();\n  }\n  isUsing() {\n    if (!this.isContextual(107)) {\n      return false;\n    }\n    return this.nextTokenIsIdentifierOnSameLine();\n  }\n  isForUsing() {\n    if (!this.isContextual(107)) {\n      return false;\n    }\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    if (this.isUnparsedContextual(next, \"of\")) {\n      const nextCharAfterOf = this.lookaheadCharCodeSince(next + 2);\n      if (nextCharAfterOf !== 61 && nextCharAfterOf !== 58 && nextCharAfterOf !== 59) {\n        return false;\n      }\n    }\n    if (this.chStartsBindingIdentifier(nextCh, next) || this.isUnparsedContextual(next, \"void\")) {\n      return true;\n    }\n    return false;\n  }\n  nextTokenIsIdentifierOnSameLine() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifier(nextCh, next);\n  }\n  isAwaitUsing() {\n    if (!this.isContextual(96)) {\n      return false;\n    }\n    let next = this.nextTokenInLineStart();\n    if (this.isUnparsedContextual(next, \"using\")) {\n      next = this.nextTokenInLineStartSince(next + 5);\n      const nextCh = this.codePointAtPos(next);\n      if (this.chStartsBindingIdentifier(nextCh, next)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  chStartsBindingIdentifier(ch, pos) {\n    if (isIdentifierStart(ch)) {\n      keywordRelationalOperator.lastIndex = pos;\n      if (keywordRelationalOperator.test(this.input)) {\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== 92) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === 92) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  chStartsBindingPattern(ch) {\n    return ch === 91 || ch === 123;\n  }\n  hasFollowingBindingAtom() {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  hasInLineFollowingBindingIdentifierOrBrace() {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);\n  }\n  allowsUsing() {\n    return (this.scope.inModule || !this.scope.inTopLevel) && !this.scope.inBareCaseStatement;\n  }\n  parseModuleItem() {\n    return this.parseStatementLike(1 | 2 | 4 | 8);\n  }\n  parseStatementListItem() {\n    return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));\n  }\n  parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {\n    let flags = 0;\n    if (this.options.annexB && !this.state.strict) {\n      flags |= 4;\n      if (allowLabeledFunction) {\n        flags |= 8;\n      }\n    }\n    return this.parseStatementLike(flags);\n  }\n  parseStatement() {\n    return this.parseStatementLike(0);\n  }\n  parseStatementLike(flags) {\n    let decorators = null;\n    if (this.match(26)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(flags, decorators);\n  }\n  parseStatementContent(flags, decorators) {\n    const startType = this.state.type;\n    const node = this.startNode();\n    const allowDeclaration = !!(flags & 2);\n    const allowFunctionDeclaration = !!(flags & 4);\n    const topLevel = flags & 1;\n    switch (startType) {\n      case 60:\n        return this.parseBreakContinueStatement(node, true);\n      case 63:\n        return this.parseBreakContinueStatement(node, false);\n      case 64:\n        return this.parseDebuggerStatement(node);\n      case 90:\n        return this.parseDoWhileStatement(node);\n      case 91:\n        return this.parseForStatement(node);\n      case 68:\n        if (this.lookaheadCharCode() === 46) break;\n        if (!allowFunctionDeclaration) {\n          this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);\n        }\n        return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);\n      case 80:\n        if (!allowDeclaration) this.unexpected();\n        return this.parseClass(this.maybeTakeDecorators(decorators, node), true);\n      case 69:\n        return this.parseIfStatement(node);\n      case 70:\n        return this.parseReturnStatement(node);\n      case 71:\n        return this.parseSwitchStatement(node);\n      case 72:\n        return this.parseThrowStatement(node);\n      case 73:\n        return this.parseTryStatement(node);\n      case 96:\n        if (this.isAwaitUsing()) {\n          if (!this.allowsUsing()) {\n            this.raise(Errors.UnexpectedUsingDeclaration, node);\n          } else if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, node);\n          } else if (!this.recordAwaitIfAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, node);\n          }\n          this.next();\n          return this.parseVarStatement(node, \"await using\");\n        }\n        break;\n      case 107:\n        if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {\n          break;\n        }\n        if (!this.allowsUsing()) {\n          this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);\n        } else if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n        }\n        return this.parseVarStatement(node, \"using\");\n      case 100:\n        {\n          if (this.state.containsEsc) {\n            break;\n          }\n          const next = this.nextTokenStart();\n          const nextCh = this.codePointAtPos(next);\n          if (nextCh !== 91) {\n            if (!allowDeclaration && this.hasFollowingLineBreak()) break;\n            if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {\n              break;\n            }\n          }\n        }\n      case 75:\n        {\n          if (!allowDeclaration) {\n            this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);\n          }\n        }\n      case 74:\n        {\n          const kind = this.state.value;\n          return this.parseVarStatement(node, kind);\n        }\n      case 92:\n        return this.parseWhileStatement(node);\n      case 76:\n        return this.parseWithStatement(node);\n      case 5:\n        return this.parseBlock();\n      case 13:\n        return this.parseEmptyStatement(node);\n      case 83:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n        }\n      case 82:\n        {\n          if (!(this.optionFlags & 8) && !topLevel) {\n            this.raise(Errors.UnexpectedImportExport, this.state.startLoc);\n          }\n          this.next();\n          let result;\n          if (startType === 83) {\n            result = this.parseImport(node);\n          } else {\n            result = this.parseExport(node, decorators);\n          }\n          this.assertModuleNodeAllowed(result);\n          return result;\n        }\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (!allowDeclaration) {\n              this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);\n            }\n            this.next();\n            return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);\n          }\n        }\n    }\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n    if (tokenIsIdentifier(startType) && expr.type === \"Identifier\" && this.eat(14)) {\n      return this.parseLabeledStatement(node, maybeName, expr, flags);\n    } else {\n      return this.parseExpressionStatement(node, expr, decorators);\n    }\n  }\n  assertModuleNodeAllowed(node) {\n    if (!(this.optionFlags & 8) && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, node);\n    }\n  }\n  decoratorsEnabledBeforeExport() {\n    if (this.hasPlugin(\"decorators-legacy\")) return true;\n    return this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== false;\n  }\n  maybeTakeDecorators(maybeDecorators, classNode, exportNode) {\n    if (maybeDecorators) {\n      var _classNode$decorators;\n      if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {\n        if (typeof this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== \"boolean\") {\n          this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);\n        }\n        classNode.decorators.unshift(...maybeDecorators);\n      } else {\n        classNode.decorators = maybeDecorators;\n      }\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n  canHaveLeadingDecorator() {\n    return this.match(80);\n  }\n  parseDecorators(allowExport) {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(26));\n    if (this.match(82)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, this.state.startLoc);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);\n    }\n    return decorators;\n  }\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n    const node = this.startNode();\n    this.next();\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr;\n      if (this.match(10)) {\n        const startLoc = this.state.startLoc;\n        this.next();\n        expr = this.parseExpression();\n        this.expect(11);\n        expr = this.wrapParenthesis(startLoc, expr);\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);\n        if (this.getPluginOption(\"decorators\", \"allowCallParenthesized\") === false && node.expression !== expr) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n        while (this.eat(16)) {\n          const node = this.startNodeAt(startLoc);\n          node.object = expr;\n          if (this.match(139)) {\n            this.classScope.usePrivateName(this.state.value, this.state.startLoc);\n            node.property = this.parsePrivateName();\n          } else {\n            node.property = this.parseIdentifier(true);\n          }\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n        node.expression = this.parseMaybeDecoratorArguments(expr, startLoc);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n  parseMaybeDecoratorArguments(expr, startLoc) {\n    if (this.eat(10)) {\n      const node = this.startNodeAt(startLoc);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments();\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n    return expr;\n  }\n  parseBreakContinueStatement(node, isBreak) {\n    this.next();\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n    this.verifyBreakContinue(node, isBreak);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n  verifyBreakContinue(node, isBreak) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === 1)) {\n          break;\n        }\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, node, {\n        type\n      });\n    }\n  }\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n  parseHeaderExpression() {\n    this.expect(10);\n    const val = this.parseExpression();\n    this.expect(11);\n    return val;\n  }\n  parseDoWhileStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    this.expect(92);\n    node.test = this.parseHeaderExpression();\n    this.eat(13);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = null;\n    if (this.isContextual(96) && this.recordAwaitIfAllowed()) {\n      awaitAt = this.state.startLoc;\n      this.next();\n    }\n    this.scope.enter(0);\n    this.expect(10);\n    if (this.match(13)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node, null);\n    }\n    const startsWithLet = this.isContextual(100);\n    {\n      const startsWithAwaitUsing = this.isAwaitUsing();\n      const starsWithUsingDeclaration = startsWithAwaitUsing || this.isForUsing();\n      const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;\n      if (this.match(74) || this.match(75) || isLetOrUsing) {\n        const initNode = this.startNode();\n        let kind;\n        if (startsWithAwaitUsing) {\n          kind = \"await using\";\n          if (!this.recordAwaitIfAllowed()) {\n            this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);\n          }\n          this.next();\n        } else {\n          kind = this.state.value;\n        }\n        this.next();\n        this.parseVar(initNode, true, kind);\n        const init = this.finishNode(initNode, \"VariableDeclaration\");\n        const isForIn = this.match(58);\n        if (isForIn && starsWithUsingDeclaration) {\n          this.raise(Errors.ForInUsing, init);\n        }\n        if ((isForIn || this.isContextual(102)) && init.declarations.length === 1) {\n          return this.parseForIn(node, init, awaitAt);\n        }\n        if (awaitAt !== null) {\n          this.unexpected(awaitAt);\n        }\n        return this.parseFor(node, init);\n      }\n    }\n    const startsWithAsync = this.isContextual(95);\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(102);\n    if (isForOf) {\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, init);\n      }\n      if (awaitAt === null && startsWithAsync && init.type === \"Identifier\") {\n        this.raise(Errors.ForOfAsync, init);\n      }\n    }\n    if (isForOf || this.match(58)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, {\n        type\n      });\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init);\n  }\n  parseFunctionStatement(node, isAsync, isHangingDeclaration) {\n    this.next();\n    return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));\n  }\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\n    node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn) {\n      this.raise(Errors.IllegalReturn, this.state.startLoc);\n    }\n    this.next();\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(5);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(256);\n    let cur;\n    for (let sawDefault; !this.match(8);) {\n      if (this.match(61) || this.match(65)) {\n        const isCase = this.match(61);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(14);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatementListItem());\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n  parseThrowStatement(node) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n  parseCatchClauseParam() {\n    const param = this.parseBindingAtom();\n    this.scope.enter(this.options.annexB && param.type === \"Identifier\" ? 8 : 0);\n    this.checkLVal(param, {\n      type: \"CatchClause\"\n    }, 9);\n    return param;\n  }\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.match(62)) {\n      const clause = this.startNode();\n      this.next();\n      if (this.match(10)) {\n        this.expect(10);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(11);\n      } else {\n        clause.param = null;\n        this.scope.enter(0);\n      }\n      clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(67) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, node);\n    }\n    return this.finishNode(node, \"TryStatement\");\n  }\n  parseVarStatement(node, kind, allowMissingInitializer = false) {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, this.state.startLoc);\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    return this.finishNode(node, \"WithStatement\");\n  }\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n  parseLabeledStatement(node, maybeName, expr, flags) {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, expr, {\n          labelName: maybeName\n        });\n      }\n    }\n    const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.sourceToOffsetPos(this.state.start);\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.sourceToOffsetPos(this.state.start)\n    });\n    node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n  parseExpressionStatement(node, expr, decorators) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(5);\n    if (createNewLexicalScope) {\n      this.scope.enter(0);\n    }\n    this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n    while (!this.match(end)) {\n      const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n          if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n          continue;\n        }\n        parsedNonDirective = true;\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n    afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n    this.next();\n  }\n  parseFor(node, init) {\n    node.init = init;\n    this.semicolon(false);\n    node.test = this.match(13) ? null : this.parseExpression();\n    this.semicolon(false);\n    node.update = this.match(11) ? null : this.parseExpression();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(58);\n    this.next();\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(Errors.ForInOfLoopInitializer, init, {\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\"\n      });\n    }\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, init, {\n        ancestor: {\n          type: \"ForStatement\"\n        }\n      });\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();\n    this.expect(11);\n    node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n  parseVar(node, isFor, kind, allowMissingInitializer = false) {\n    const declarations = node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();\n      if (decl.init === null && !allowMissingInitializer) {\n        if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(58) || this.isContextual(102)))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind: \"destructuring\"\n          });\n        } else if ((kind === \"const\" || kind === \"using\" || kind === \"await using\") && !(this.match(58) || this.isContextual(102))) {\n          this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {\n            kind\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(12)) break;\n    }\n    return node;\n  }\n  parseVarId(decl, kind) {\n    const id = this.parseBindingAtom();\n    if (kind === \"using\" || kind === \"await using\") {\n      if (id.type === \"ArrayPattern\" || id.type === \"ObjectPattern\") {\n        this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);\n      }\n    } else {\n      if (id.type === \"VoidPattern\") {\n        this.raise(Errors.UnexpectedVoidPattern, id.loc.start);\n      }\n    }\n    this.checkLVal(id, {\n      type: \"VariableDeclarator\"\n    }, kind === \"var\" ? 5 : 8201);\n    decl.id = id;\n  }\n  parseAsyncFunctionExpression(node) {\n    return this.parseFunction(node, 8);\n  }\n  parseFunction(node, flags = 0) {\n    const hangingDeclaration = flags & 2;\n    const isDeclaration = !!(flags & 1);\n    const requireId = isDeclaration && !(flags & 4);\n    const isAsync = !!(flags & 8);\n    this.initFunction(node, isAsync);\n    if (this.match(55)) {\n      if (hangingDeclaration) {\n        this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);\n      }\n      this.next();\n      node.generator = true;\n    }\n    if (isDeclaration) {\n      node.id = this.parseFunctionId(requireId);\n    }\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(514);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    if (!isDeclaration) {\n      node.id = this.parseFunctionId();\n    }\n    this.parseFunctionParams(node, false);\n    this.withSmartMixTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isDeclaration ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n    if (isDeclaration && !hangingDeclaration) {\n      this.registerFunctionStatementId(node);\n    }\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node;\n  }\n  parseFunctionId(requireId) {\n    return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;\n  }\n  parseFunctionParams(node, isConstructor) {\n    this.expect(10);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));\n    this.expressionScope.exit();\n  }\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);\n  }\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n  isClassProperty() {\n    return this.match(29) || this.match(13) || this.match(8);\n  }\n  isClassMethod() {\n    return this.match(10);\n  }\n  nameIsConstructor(key) {\n    return key.type === \"Identifier\" && key.name === \"constructor\" || key.type === \"StringLiteral\" && key.value === \"constructor\";\n  }\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && this.nameIsConstructor(method.key);\n  }\n  parseClassBody(hadSuperClass, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false,\n      hadSuperClass\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(5);\n    this.withSmartMixTopicForbiddingContext(() => {\n      while (!this.match(8)) {\n        if (this.eat(13)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);\n          }\n          continue;\n        }\n        if (this.match(26)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n        const member = this.startNode();\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n        this.parseClassMember(classBody, member, state);\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(Errors.DecoratorConstructor, member);\n        }\n      }\n    });\n    this.state.strict = oldStrict;\n    this.next();\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, this.state.startLoc);\n    }\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n  parseClassMemberFromModifier(classBody, member) {\n    const key = this.parseIdentifier(true);\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n  parseClassMember(classBody, member, state) {\n    const isStatic = this.isContextual(106);\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n      if (this.eat(5)) {\n        this.parseClassStaticBlock(classBody, member);\n        return;\n      }\n    }\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const accessorProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n    if (this.eat(55)) {\n      method.kind = \"method\";\n      const isPrivateName = this.match(139);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(method);\n      if (isPrivateName) {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, publicMethod.key);\n      }\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n    const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);\n    const key = this.parseClassElementName(member);\n    const maybeContextualKw = isContextual ? key.name : null;\n    const isPrivate = this.isPrivateName(key);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n    this.parsePostMemberNameModifiers(publicMember);\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, key);\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, key);\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (maybeContextualKw === \"async\" && !this.isLineTerminator()) {\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(55);\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n      method.kind = \"method\";\n      const isPrivate = this.match(139);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if ((maybeContextualKw === \"get\" || maybeContextualKw === \"set\") && !(this.match(55) && this.isLineTerminator())) {\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = maybeContextualKw;\n      const isPrivate = this.match(139);\n      this.parseClassElementName(publicMethod);\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, publicMethod.key);\n        }\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n      this.checkGetterSetterParams(publicMethod);\n    } else if (maybeContextualKw === \"accessor\" && !this.isLineTerminator()) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n      const isPrivate = this.match(139);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n  parseClassElementName(member) {\n    const {\n      type,\n      value\n    } = this.state;\n    if ((type === 132 || type === 134) && member.static && value === \"prototype\") {\n      this.raise(Errors.StaticPrototype, this.state.startLoc);\n    }\n    if (type === 139) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n    this.parsePropertyName(member);\n    return member.key;\n  }\n  parseClassStaticBlock(classBody, member) {\n    var _member$decorators;\n    this.scope.enter(576 | 128 | 16);\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    this.prodParam.enter(0);\n    const body = member.body = [];\n    this.parseBlockOrModuleBlockBody(body, undefined, false, 8);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode(member, \"StaticBlock\"));\n    if ((_member$decorators = member.decorators) != null && _member$decorators.length) {\n      this.raise(Errors.DecoratorStaticBlock, member);\n    }\n  }\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && this.nameIsConstructor(prop.key)) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n  pushClassPrivateProperty(classBody, prop) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n  }\n  pushClassAccessorProperty(classBody, prop, isPrivate) {\n    if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {\n      this.raise(Errors.ConstructorClassField, prop.key);\n    }\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n    if (isPrivate) {\n      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);\n    }\n  }\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? 6 : 2 : node.kind === \"set\" ? node.static ? 5 : 1 : 0;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n  declareClassPrivateMethodInScope(node, kind) {\n    this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);\n  }\n  parsePostMemberNameModifiers(methodOrProp) {}\n  parseClassPrivateProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n  parseClassProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n  parseClassAccessorProperty(node) {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n  parseInitializer(node) {\n    this.scope.enter(576 | 16);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(0);\n    node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n  parseClassId(node, isStatement, optionalId, bindingType = 8331) {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, this.state.startLoc);\n      }\n    }\n  }\n  parseClassSuper(node) {\n    node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;\n  }\n  parseExport(node, decorators) {\n    const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);\n    const parseAfterDefault = !hasDefault || this.eat(12);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));\n    const isFromRequired = hasDefault || hasStar;\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, true);\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\n      this.unexpected(null, 5);\n    }\n    if (hasNamespace && parseAfterNamespace) {\n      this.unexpected(null, 98);\n    }\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      var _node2$declaration;\n      const node2 = node;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n    if (this.eat(65)) {\n      const node2 = node;\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, node);\n      }\n      this.checkExport(node2, true, true);\n      this.sawUnambiguousESM = true;\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n    throw this.unexpected(null, 5);\n  }\n  eatExportStar(node) {\n    return this.eat(55);\n  }\n  maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);\n      const id = maybeDefaultIdentifier || this.parseIdentifier(true);\n      const specifier = this.startNodeAtNode(id);\n      specifier.exported = id;\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(93)) {\n      var _ref, _ref$specifiers;\n      (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(5)) {\n      const node2 = node;\n      if (!node2.specifiers) node2.specifiers = [];\n      const isTypeExport = node2.exportKind === \"type\";\n      node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n      node2.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node2.assertions = [];\n      } else {\n        node2.attributes = [];\n      }\n      node2.declaration = null;\n      return true;\n    }\n    return false;\n  }\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      } else {\n        node.attributes = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n  isAsyncFunction() {\n    if (!this.isContextual(95)) return false;\n    const next = this.nextTokenInLineStart();\n    return this.isUnparsedContextual(next, \"function\");\n  }\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    if (this.match(68)) {\n      this.next();\n      return this.parseFunction(expr, 1 | 4);\n    } else if (this.isAsyncFunction()) {\n      this.next();\n      this.next();\n      return this.parseFunction(expr, 1 | 4 | 8);\n    }\n    if (this.match(80)) {\n      return this.parseClass(expr, true, true);\n    }\n    if (this.match(26)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n        this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n      }\n      return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);\n    }\n    if (this.match(75) || this.match(74) || this.isLet() || this.isUsing() || this.isAwaitUsing()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);\n    }\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n  parseExportDeclaration(node) {\n    if (this.match(80)) {\n      const node = this.parseClass(this.startNode(), true, false);\n      return node;\n    }\n    return this.parseStatementListItem();\n  }\n  isExportDefaultSpecifier() {\n    const {\n      type\n    } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if (type === 95 && !this.state.containsEsc || type === 100) {\n        return false;\n      }\n      if ((type === 130 || type === 129) && !this.state.containsEsc) {\n        const next = this.nextTokenStart();\n        const nextChar = this.input.charCodeAt(next);\n        if (nextChar === 123 || this.chStartsBindingIdentifier(nextChar, next) && !this.input.startsWith(\"from\", next)) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(65)) {\n      return false;\n    }\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {\n      return true;\n    }\n    if (this.match(65) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));\n      return nextAfterFrom === 34 || nextAfterFrom === 39;\n    }\n    return false;\n  }\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(98)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      this.maybeParseImportAttributes(node);\n      this.checkJSONModuleImport(node);\n    } else if (expect) {\n      this.unexpected();\n    }\n    this.semicolon();\n  }\n  shouldParseExportDeclaration() {\n    const {\n      type\n    } = this.state;\n    if (type === 26) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true) {\n          this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);\n        }\n        return true;\n      }\n    }\n    if (this.isUsing()) {\n      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);\n      return true;\n    }\n    if (this.isAwaitUsing()) {\n      this.raise(Errors.UsingDeclarationExport, this.state.startLoc);\n      return true;\n    }\n    return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();\n  }\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      var _node$specifiers;\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          var _declaration$extra;\n          const declaration = node.declaration;\n          if (declaration.type === \"Identifier\" && declaration.name === \"from\" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);\n          }\n        }\n      } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {\n        for (const specifier of node.specifiers) {\n          const {\n            exported\n          } = specifier;\n          const exportName = exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const {\n              local\n            } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, specifier, {\n                localName: local.value,\n                exportName\n              });\n            } else {\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        const decl = node.declaration;\n        if (decl.type === \"FunctionDeclaration\" || decl.type === \"ClassDeclaration\") {\n          const {\n            id\n          } = decl;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (decl.type === \"VariableDeclaration\") {\n          for (const declaration of decl.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n  checkDuplicateExports(node, exportName) {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, node);\n      } else {\n        this.raise(Errors.DuplicateExport, node, {\n          exportName\n        });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n  parseExportSpecifiers(isInTypeExport) {\n    const nodes = [];\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(130);\n      const isString = this.match(134);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));\n    }\n    return nodes;\n  }\n  parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {\n    if (this.eatContextual(93)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = this.cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = this.cloneIdentifier(node.local);\n    }\n    return this.finishNode(node, \"ExportSpecifier\");\n  }\n  parseModuleExportName() {\n    if (this.match(134)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = loneSurrogate.exec(result.value);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {\n          surrogateCharCode: surrogate[0].charCodeAt(0)\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n  isJSONModuleImport(node) {\n    if (node.assertions != null) {\n      return node.assertions.some(({\n        key,\n        value\n      }) => {\n        return value.value === \"json\" && (key.type === \"Identifier\" ? key.name === \"type\" : key.value === \"type\");\n      });\n    }\n    return false;\n  }\n  checkImportReflection(node) {\n    const {\n      specifiers\n    } = node;\n    const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;\n    if (node.phase === \"source\") {\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);\n      }\n    } else if (node.phase === \"defer\") {\n      if (singleBindingType !== \"ImportNamespaceSpecifier\") {\n        this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);\n      }\n    } else if (node.module) {\n      var _node$assertions;\n      if (singleBindingType !== \"ImportDefaultSpecifier\") {\n        this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);\n      }\n      if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);\n      }\n    }\n  }\n  checkJSONModuleImport(node) {\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      const {\n        specifiers\n      } = node;\n      if (specifiers != null) {\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\" ? imported.name !== \"default\" : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);\n        }\n      }\n    }\n  }\n  isPotentialImportPhase(isExport) {\n    if (isExport) return false;\n    return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);\n  }\n  applyImportPhase(node, isExport, phase, loc) {\n    if (isExport) {\n      return;\n    }\n    if (phase === \"module\") {\n      this.expectPlugin(\"importReflection\", loc);\n      node.module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      node.module = false;\n    }\n    if (phase === \"source\") {\n      this.expectPlugin(\"sourcePhaseImports\", loc);\n      node.phase = \"source\";\n    } else if (phase === \"defer\") {\n      this.expectPlugin(\"deferredImportEvaluation\", loc);\n      node.phase = \"defer\";\n    } else if (this.hasPlugin(\"sourcePhaseImports\")) {\n      node.phase = null;\n    }\n  }\n  parseMaybeImportPhase(node, isExport) {\n    if (!this.isPotentialImportPhase(isExport)) {\n      this.applyImportPhase(node, isExport, null);\n      return null;\n    }\n    const phaseIdentifier = this.startNode();\n    const phaseIdentifierName = this.parseIdentifierName(true);\n    const {\n      type\n    } = this.state;\n    const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n    if (isImportPhase) {\n      this.applyImportPhase(node, isExport, phaseIdentifierName, phaseIdentifier.loc.start);\n      return null;\n    } else {\n      this.applyImportPhase(node, isExport, null);\n      return this.createIdentifier(phaseIdentifier, phaseIdentifierName);\n    }\n  }\n  isPrecedingIdImportPhase(phase) {\n    const {\n      type\n    } = this.state;\n    return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;\n  }\n  parseImport(node) {\n    if (this.match(134)) {\n      return this.parseImportSourceAndAttributes(node);\n    }\n    return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));\n  }\n  parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {\n    node.specifiers = [];\n    const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);\n    const parseNext = !hasDefault || this.eat(12);\n    const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n    if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n    this.expectContextual(98);\n    return this.parseImportSourceAndAttributes(node);\n  }\n  parseImportSourceAndAttributes(node) {\n    var _node$specifiers2;\n    (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];\n    node.source = this.parseImportSource();\n    this.maybeParseImportAttributes(node);\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n    this.semicolon();\n    this.sawUnambiguousESM = true;\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n  parseImportSource() {\n    if (!this.match(134)) this.unexpected();\n    return this.parseExprAtom();\n  }\n  parseImportSpecifierLocal(node, specifier, type) {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n  finishImportSpecifier(specifier, type, bindingType = 8201) {\n    this.checkLVal(specifier.local, {\n      type\n    }, bindingType);\n    return this.finishNode(specifier, type);\n  }\n  parseImportAttributes() {\n    this.expect(5);\n    const attrs = [];\n    const attrNames = new Set();\n    do {\n      if (this.match(8)) {\n        break;\n      }\n      const node = this.startNode();\n      const keyName = this.state.value;\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {\n          key: keyName\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(134)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(14);\n      if (!this.match(134)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    this.expect(8);\n    return attrs;\n  }\n  parseModuleAttributes() {\n    const attrs = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, node.key);\n      }\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {\n          key: node.key.name\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(14);\n      if (!this.match(134)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(12));\n    return attrs;\n  }\n  maybeParseImportAttributes(node) {\n    let attributes;\n    var useWith = false;\n    if (this.match(76)) {\n      if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {\n        return;\n      }\n      this.next();\n      if (this.hasPlugin(\"moduleAttributes\")) {\n        attributes = this.parseModuleAttributes();\n        this.addExtra(node, \"deprecatedWithLegacySyntax\", true);\n      } else {\n        attributes = this.parseImportAttributes();\n      }\n      useWith = true;\n    } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {\n      if (!this.hasPlugin(\"deprecatedImportAssert\") && !this.hasPlugin(\"importAssertions\")) {\n        this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);\n      }\n      if (!this.hasPlugin(\"importAssertions\")) {\n        this.addExtra(node, \"deprecatedAssertSyntax\", true);\n      }\n      this.next();\n      attributes = this.parseImportAttributes();\n    } else {\n      attributes = [];\n    }\n    if (!useWith && this.hasPlugin(\"importAssertions\")) {\n      node.assertions = attributes;\n    } else {\n      node.attributes = attributes;\n    }\n  }\n  maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {\n    if (maybeDefaultIdentifier) {\n      const specifier = this.startNodeAtNode(maybeDefaultIdentifier);\n      specifier.local = maybeDefaultIdentifier;\n      node.specifiers.push(this.finishImportSpecifier(specifier, \"ImportDefaultSpecifier\"));\n      return true;\n    } else if (tokenIsKeywordOrIdentifier(this.state.type)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(55)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(93);\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\");\n      return true;\n    }\n    return false;\n  }\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(5);\n    while (!this.eat(8)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(14)) {\n          throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);\n        }\n        this.expect(12);\n        if (this.eat(8)) break;\n      }\n      const specifier = this.startNode();\n      const importedIsString = this.match(134);\n      const isMaybeTypeOnly = this.isContextual(130);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === \"type\" || node.importKind === \"typeof\", isMaybeTypeOnly, undefined);\n      node.specifiers.push(importSpecifier);\n    }\n  }\n  parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {\n    if (this.eatContextual(93)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const {\n        imported\n      } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, specifier, {\n          importName: imported.value\n        });\n      }\n      this.checkReservedWord(imported.name, specifier.loc.start, true, true);\n      if (!specifier.local) {\n        specifier.local = this.cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(specifier, \"ImportSpecifier\", bindingType);\n  }\n  isThisParam(param) {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\nclass Parser extends StatementParser {\n  constructor(options, input, pluginsMap) {\n    const normalizedOptions = getOptions(options);\n    super(normalizedOptions, input);\n    this.options = normalizedOptions;\n    this.initializeScopes();\n    this.plugins = pluginsMap;\n    this.filename = normalizedOptions.sourceFilename;\n    this.startIndex = normalizedOptions.startIndex;\n    let optionFlags = 0;\n    if (normalizedOptions.allowAwaitOutsideFunction) {\n      optionFlags |= 1;\n    }\n    if (normalizedOptions.allowReturnOutsideFunction) {\n      optionFlags |= 2;\n    }\n    if (normalizedOptions.allowImportExportEverywhere) {\n      optionFlags |= 8;\n    }\n    if (normalizedOptions.allowSuperOutsideMethod) {\n      optionFlags |= 16;\n    }\n    if (normalizedOptions.allowUndeclaredExports) {\n      optionFlags |= 64;\n    }\n    if (normalizedOptions.allowNewTargetOutsideFunction) {\n      optionFlags |= 4;\n    }\n    if (normalizedOptions.allowYieldOutsideFunction) {\n      optionFlags |= 32;\n    }\n    if (normalizedOptions.ranges) {\n      optionFlags |= 128;\n    }\n    if (normalizedOptions.tokens) {\n      optionFlags |= 256;\n    }\n    if (normalizedOptions.createImportExpressions) {\n      optionFlags |= 512;\n    }\n    if (normalizedOptions.createParenthesizedExpressions) {\n      optionFlags |= 1024;\n    }\n    if (normalizedOptions.errorRecovery) {\n      optionFlags |= 2048;\n    }\n    if (normalizedOptions.attachComment) {\n      optionFlags |= 4096;\n    }\n    if (normalizedOptions.annexB) {\n      optionFlags |= 8192;\n    }\n    this.optionFlags = optionFlags;\n  }\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n  parse() {\n    this.enterInitialScopes();\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    const result = this.parseTopLevel(file, program);\n    result.errors = this.state.errors;\n    result.comments.length = this.state.commentsLen;\n    return result;\n  }\n}\nfunction parse(input, options) {\n  var _options;\n  if (((_options = options) == null ? void 0 : _options.sourceType) === \"unambiguous\") {\n    options = Object.assign({}, options);\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n  return parser.getExpression();\n}\nfunction generateExportedTokenTypes(internalTokenTypes) {\n  const tokenTypes = {};\n  for (const typeName of Object.keys(internalTokenTypes)) {\n    tokenTypes[typeName] = getExportedToken(internalTokenTypes[typeName]);\n  }\n  return tokenTypes;\n}\nconst tokTypes = generateExportedTokenTypes(tt);\nfunction getParser(options, input) {\n  let cls = Parser;\n  const pluginsMap = new Map();\n  if (options != null && options.plugins) {\n    for (const plugin of options.plugins) {\n      let name, opts;\n      if (typeof plugin === \"string\") {\n        name = plugin;\n      } else {\n        [name, opts] = plugin;\n      }\n      if (!pluginsMap.has(name)) {\n        pluginsMap.set(name, opts || {});\n      }\n    }\n    validatePlugins(pluginsMap);\n    cls = getParserClass(pluginsMap);\n  }\n  return new cls(options, input, pluginsMap);\n}\nconst parserClassCache = new Map();\nfunction getParserClass(pluginsMap) {\n  const pluginList = [];\n  for (const name of mixinPluginNames) {\n    if (pluginsMap.has(name)) {\n      pluginList.push(name);\n    }\n  }\n  const key = pluginList.join(\"|\");\n  let cls = parserClassCache.get(key);\n  if (!cls) {\n    cls = Parser;\n    for (const plugin of pluginList) {\n      cls = mixinPlugins[plugin](cls);\n    }\n    parserClassCache.set(key, cls);\n  }\n  return cls;\n}\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = tokTypes;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BiYWJlbCtwYXJzZXJANy4yOC42L25vZGVfbW9kdWxlcy9AYmFiZWwvcGFyc2VyL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLFlBQVk7QUFDdEg7QUFDQTtBQUNBO0FBQ0EsR0FBRyxVQUFVLEtBQUs7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsK0JBQStCLE1BQU07QUFDeEM7QUFDQSwwS0FBMEs7QUFDMUs7QUFDQSxpR0FBaUcsS0FBSztBQUN0Ryx5S0FBeUs7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxVQUFVLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBHQUEwRyxHQUFHLFVBQVUsUUFBUSxXQUFXLElBQUk7QUFDako7QUFDQTtBQUNBO0FBQ0EsR0FBRyxTQUFTLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixpREFBaUQ7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcseUZBQXlGLEdBQUcsV0FBVyxVQUFVO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlDQUFpQyxNQUFNO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxtQ0FBbUMsYUFBYTtBQUNuRDtBQUNBO0FBQ0EsR0FBRywyQkFBMkIsZUFBZTtBQUM3QztBQUNBO0FBQ0EsR0FBRyxrQ0FBa0MsNEJBQTRCO0FBQ2pFO0FBQ0E7QUFDQSxHQUFHLDBDQUEwQyw0QkFBNEI7QUFDekU7QUFDQTtBQUNBLEdBQUcsMkRBQTJELDRCQUE0QjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOEJBQThCLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzQkFBc0IsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGVBQWUsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzRUFBc0UsMkRBQTJEO0FBQ3BJO0FBQ0E7QUFDQSxHQUFHLDBGQUEwRiwyREFBMkQ7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx1QkFBdUIsSUFBSTtBQUM5QjtBQUNBO0FBQ0EsR0FBRyxrRUFBa0UsK0JBQStCO0FBQ3BHO0FBQ0E7QUFDQSxHQUFHLGdCQUFnQixVQUFVO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9FQUFvRSxlQUFlLG1DQUFtQyxnQkFBZ0I7QUFDekk7QUFDQTtBQUNBLEdBQUcsZ0NBQWdDLGVBQWU7QUFDbEQsZ0ZBQWdGO0FBQ2hGLG1GQUFtRjtBQUNuRixxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDRCQUE0QixRQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrQ0FBa0MsYUFBYTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsd0JBQXdCLGtCQUFrQixXQUFXLFNBQVMsRUFBRSwwQkFBMEIsU0FBUyxRQUFRO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx5Q0FBeUMsUUFBUSxLQUFLLE9BQU8sR0FBRyxzQkFBc0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0JBQW9CLGVBQWU7QUFDdEMsaUdBQWlHLE1BQU0sUUFBUSxLQUFLO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxzQkFBc0IsY0FBYztBQUN2QztBQUNBO0FBQ0EsR0FBRyxpQkFBaUIsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGdLQUFnSyxpQ0FBaUM7QUFDcE07QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSxHQUFHLDRCQUE0QixNQUFNLG9CQUFvQixPQUFPLDRFQUE0RSxxQ0FBcUMsTUFBTSxHQUFHO0FBQzFMLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EsR0FBRywwREFBMEQ7QUFDN0Q7QUFDQSxHQUFHLElBQUk7QUFDUCxDQUFDO0FBQ0QsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDRFQUE0RTtBQUM1RSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsb0JBQW9CLEdBQUcsU0FBUyxHQUFHLFdBQVc7QUFDekU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLEdBQUc7QUFDSCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSCx3QkFBd0I7QUFDeEIsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCO0FBQ3RCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUNBQXVDLGFBQWE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxrRUFBa0UsWUFBWSxpQkFBaUIsWUFBWSx1QkFBdUIsU0FBUztBQUM5STtBQUNBO0FBQ0E7QUFDQSxHQUFHLDREQUE0RCxXQUFXLDRDQUE0QyxTQUFTO0FBQy9IO0FBQ0E7QUFDQSxHQUFHLGVBQWUsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9CQUFvQixnQkFBZ0IsMkZBQTJGLFNBQVM7QUFDM0k7QUFDQTtBQUNBLEdBQUcsaUhBQWlILFNBQVM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGVBQWUsU0FBUyxnQkFBZ0IsYUFBYSw4QkFBOEIsV0FBVyxtQkFBbUIsY0FBYztBQUNsSTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHlEQUF5RCxXQUFXLGdCQUFnQixTQUFTO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMENBQTBDLFdBQVcsMkVBQTJFLFNBQVM7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBGQUEwRixXQUFXLHVCQUF1QixXQUFXLGdCQUFnQixTQUFTO0FBQ25LO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMkRBQTJELFlBQVksa0JBQWtCLFNBQVM7QUFDckc7QUFDQTtBQUNBLEdBQUcsZ0hBQWdILFNBQVM7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxpQ0FBaUMsYUFBYTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMElBQTBJLHlCQUF5QjtBQUNuSztBQUNBO0FBQ0E7QUFDQSxHQUFHLHlCQUF5QixzQkFBc0IsNkJBQTZCLFdBQVc7QUFDMUY7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxvREFBb0QsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRywyQkFBMkIsV0FBVyxxQkFBcUIsV0FBVyxTQUFTLEdBQUcsV0FBVyxFQUFFO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixhQUFhO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhEQUE4RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBLEtBQUs7QUFDTCxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxZQUFZO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnQkFBZ0IsV0FBVztBQUM5QjtBQUNBO0FBQ0EsR0FBRyxrQkFBa0IsYUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLG9DQUFvQyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyw4Q0FBOEMsU0FBUztBQUMxRDtBQUNBO0FBQ0EsR0FBRyw2QkFBNkIsU0FBUztBQUN6QztBQUNBO0FBQ0EsR0FBRyxTQUFTLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFNBQVMsYUFBYSxrQ0FBa0MsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxHQUFHLGlFQUFpRSxTQUFTO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsU0FBUyxNQUFNO0FBQ2xCLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7QUFDQSxHQUFHLFNBQVMsU0FBUztBQUNyQjtBQUNBO0FBQ0EsR0FBRyxTQUFTLFNBQVM7QUFDckI7QUFDQTtBQUNBLEdBQUcsU0FBUyxTQUFTO0FBQ3JCLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQSxHQUFHLFNBQVMsb0JBQW9CLDJCQUEyQixvQkFBb0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsaUVBQWlFLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsOEJBQThCLG1CQUFtQixnREFBZ0Qsa0JBQWtCO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDhGQUE4RixLQUFLO0FBQ3RHLGdEQUFnRCxLQUFLO0FBQ3JELENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxtRkFBbUYscUZBQXFGO0FBQ3hLLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxxRkFBcUYscUZBQXFGO0FBQzFLLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEVBQUU7QUFDN0QsbUdBQW1HLGFBQWE7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxFQUFFO0FBQ3RELHlJQUF5SSxVQUFVO0FBQ25KO0FBQ0E7QUFDQSwwRUFBMEUsbUNBQW1DLFlBQVkscUVBQXFFO0FBQzlMO0FBQ0EsTUFBTTtBQUNOLHdFQUF3RSxtQkFBbUIsWUFBWSxxRUFBcUU7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtJQUErSSxFQUFFO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RhbmdlbnQtcGxheWdyb3VuZC1uZXh0Ly4uL25vZGVfbW9kdWxlcy8ucG5wbS9AYmFiZWwrcGFyc2VyQDcuMjguNi9ub2RlX21vZHVsZXMvQGJhYmVsL3BhcnNlci9saWIvaW5kZXguanM/NmZkMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkge1xuICBpZiAobnVsbCA9PSByKSByZXR1cm4ge307XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHtcbiAgICBpZiAoLTEgIT09IGUuaW5kZXhPZihuKSkgY29udGludWU7XG4gICAgdFtuXSA9IHJbbl07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5jbGFzcyBQb3NpdGlvbiB7XG4gIGNvbnN0cnVjdG9yKGxpbmUsIGNvbCwgaW5kZXgpIHtcbiAgICB0aGlzLmxpbmUgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2x1bW4gPSB2b2lkIDA7XG4gICAgdGhpcy5pbmRleCA9IHZvaWQgMDtcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uID0gY29sO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgfVxufVxuY2xhc3MgU291cmNlTG9jYXRpb24ge1xuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kKSB7XG4gICAgdGhpcy5zdGFydCA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZCA9IHZvaWQgMDtcbiAgICB0aGlzLmZpbGVuYW1lID0gdm9pZCAwO1xuICAgIHRoaXMuaWRlbnRpZmllck5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIHRoaXMuZW5kID0gZW5kO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQocG9zaXRpb24sIGNvbHVtbk9mZnNldCkge1xuICBjb25zdCB7XG4gICAgbGluZSxcbiAgICBjb2x1bW4sXG4gICAgaW5kZXhcbiAgfSA9IHBvc2l0aW9uO1xuICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIGNvbHVtbiArIGNvbHVtbk9mZnNldCwgaW5kZXggKyBjb2x1bW5PZmZzZXQpO1xufVxuY29uc3QgY29kZSA9IFwiQkFCRUxfUEFSU0VSX1NPVVJDRVRZUEVfTU9EVUxFX1JFUVVJUkVEXCI7XG52YXIgTW9kdWxlRXJyb3JzID0ge1xuICBJbXBvcnRNZXRhT3V0c2lkZU1vZHVsZToge1xuICAgIG1lc3NhZ2U6IGBpbXBvcnQubWV0YSBtYXkgYXBwZWFyIG9ubHkgd2l0aCAnc291cmNlVHlwZTogXCJtb2R1bGVcIidgLFxuICAgIGNvZGVcbiAgfSxcbiAgSW1wb3J0T3V0c2lkZU1vZHVsZToge1xuICAgIG1lc3NhZ2U6IGAnaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IGFwcGVhciBvbmx5IHdpdGggJ3NvdXJjZVR5cGU6IFwibW9kdWxlXCInYCxcbiAgICBjb2RlXG4gIH1cbn07XG5jb25zdCBOb2RlRGVzY3JpcHRpb25zID0ge1xuICBBcnJheVBhdHRlcm46IFwiYXJyYXkgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIsXG4gIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBcImFzc2lnbm1lbnQgZXhwcmVzc2lvblwiLFxuICBBc3NpZ25tZW50UGF0dGVybjogXCJhc3NpZ25tZW50IGV4cHJlc3Npb25cIixcbiAgQXJyb3dGdW5jdGlvbkV4cHJlc3Npb246IFwiYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvblwiLFxuICBDb25kaXRpb25hbEV4cHJlc3Npb246IFwiY29uZGl0aW9uYWwgZXhwcmVzc2lvblwiLFxuICBDYXRjaENsYXVzZTogXCJjYXRjaCBjbGF1c2VcIixcbiAgRm9yT2ZTdGF0ZW1lbnQ6IFwiZm9yLW9mIHN0YXRlbWVudFwiLFxuICBGb3JJblN0YXRlbWVudDogXCJmb3ItaW4gc3RhdGVtZW50XCIsXG4gIEZvclN0YXRlbWVudDogXCJmb3ItbG9vcFwiLFxuICBGb3JtYWxQYXJhbWV0ZXJzOiBcImZ1bmN0aW9uIHBhcmFtZXRlciBsaXN0XCIsXG4gIElkZW50aWZpZXI6IFwiaWRlbnRpZmllclwiLFxuICBJbXBvcnRTcGVjaWZpZXI6IFwiaW1wb3J0IHNwZWNpZmllclwiLFxuICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyOiBcImltcG9ydCBkZWZhdWx0IHNwZWNpZmllclwiLFxuICBJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXI6IFwiaW1wb3J0IG5hbWVzcGFjZSBzcGVjaWZpZXJcIixcbiAgT2JqZWN0UGF0dGVybjogXCJvYmplY3QgZGVzdHJ1Y3R1cmluZyBwYXR0ZXJuXCIsXG4gIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uOiBcInBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvblwiLFxuICBSZXN0RWxlbWVudDogXCJyZXN0IGVsZW1lbnRcIixcbiAgVXBkYXRlRXhwcmVzc2lvbjoge1xuICAgIHRydWU6IFwicHJlZml4IG9wZXJhdGlvblwiLFxuICAgIGZhbHNlOiBcInBvc3RmaXggb3BlcmF0aW9uXCJcbiAgfSxcbiAgVmFyaWFibGVEZWNsYXJhdG9yOiBcInZhcmlhYmxlIGRlY2xhcmF0aW9uXCIsXG4gIFlpZWxkRXhwcmVzc2lvbjogXCJ5aWVsZCBleHByZXNzaW9uXCJcbn07XG5jb25zdCB0b05vZGVEZXNjcmlwdGlvbiA9IG5vZGUgPT4gbm9kZS50eXBlID09PSBcIlVwZGF0ZUV4cHJlc3Npb25cIiA/IE5vZGVEZXNjcmlwdGlvbnMuVXBkYXRlRXhwcmVzc2lvbltgJHtub2RlLnByZWZpeH1gXSA6IE5vZGVEZXNjcmlwdGlvbnNbbm9kZS50eXBlXTtcbnZhciBTdGFuZGFyZEVycm9ycyA9IHtcbiAgQWNjZXNzb3JJc0dlbmVyYXRvcjogKHtcbiAgICBraW5kXG4gIH0pID0+IGBBICR7a2luZH10ZXIgY2Fubm90IGJlIGEgZ2VuZXJhdG9yLmAsXG4gIEFyZ3VtZW50c0luQ2xhc3M6IFwiJ2FyZ3VtZW50cycgaXMgb25seSBhbGxvd2VkIGluIGZ1bmN0aW9ucyBhbmQgY2xhc3MgbWV0aG9kcy5cIixcbiAgQXN5bmNGdW5jdGlvbkluU2luZ2xlU3RhdGVtZW50Q29udGV4dDogXCJBc3luYyBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdGhlIHRvcCBsZXZlbCBvciBpbnNpZGUgYSBibG9jay5cIixcbiAgQXdhaXRCaW5kaW5nSWRlbnRpZmllcjogXCJDYW4gbm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGFuIGFzeW5jIGZ1bmN0aW9uLlwiLFxuICBBd2FpdEJpbmRpbmdJZGVudGlmaWVySW5TdGF0aWNCbG9jazogXCJDYW4gbm90IHVzZSAnYXdhaXQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgc3RhdGljIGJsb2NrLlwiLFxuICBBd2FpdEV4cHJlc3Npb25Gb3JtYWxQYXJhbWV0ZXI6IFwiJ2F3YWl0JyBpcyBub3QgYWxsb3dlZCBpbiBhc3luYyBmdW5jdGlvbiBwYXJhbWV0ZXJzLlwiLFxuICBBd2FpdFVzaW5nTm90SW5Bc3luY0NvbnRleHQ6IFwiJ2F3YWl0IHVzaW5nJyBpcyBvbmx5IGFsbG93ZWQgd2l0aGluIGFzeW5jIGZ1bmN0aW9ucyBhbmQgYXQgdGhlIHRvcCBsZXZlbHMgb2YgbW9kdWxlcy5cIixcbiAgQXdhaXROb3RJbkFzeW5jQ29udGV4dDogXCInYXdhaXQnIGlzIG9ubHkgYWxsb3dlZCB3aXRoaW4gYXN5bmMgZnVuY3Rpb25zIGFuZCBhdCB0aGUgdG9wIGxldmVscyBvZiBtb2R1bGVzLlwiLFxuICBCYWRHZXR0ZXJBcml0eTogXCJBICdnZXQnIGFjY2Vzc29yIG11c3Qgbm90IGhhdmUgYW55IGZvcm1hbCBwYXJhbWV0ZXJzLlwiLFxuICBCYWRTZXR0ZXJBcml0eTogXCJBICdzZXQnIGFjY2Vzc29yIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBmb3JtYWwgcGFyYW1ldGVyLlwiLFxuICBCYWRTZXR0ZXJSZXN0UGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNzb3IgZnVuY3Rpb24gYXJndW1lbnQgbXVzdCBub3QgYmUgYSByZXN0IHBhcmFtZXRlci5cIixcbiAgQ29uc3RydWN0b3JDbGFzc0ZpZWxkOiBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIGEgZmllbGQgbmFtZWQgJ2NvbnN0cnVjdG9yJy5cIixcbiAgQ29uc3RydWN0b3JDbGFzc1ByaXZhdGVGaWVsZDogXCJDbGFzc2VzIG1heSBub3QgaGF2ZSBhIHByaXZhdGUgZmllbGQgbmFtZWQgJyNjb25zdHJ1Y3RvcicuXCIsXG4gIENvbnN0cnVjdG9ySXNBY2Nlc3NvcjogXCJDbGFzcyBjb25zdHJ1Y3RvciBtYXkgbm90IGJlIGFuIGFjY2Vzc29yLlwiLFxuICBDb25zdHJ1Y3RvcklzQXN5bmM6IFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgZnVuY3Rpb24uXCIsXG4gIENvbnN0cnVjdG9ySXNHZW5lcmF0b3I6IFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYSBnZW5lcmF0b3IuXCIsXG4gIERlY2xhcmF0aW9uTWlzc2luZ0luaXRpYWxpemVyOiAoe1xuICAgIGtpbmRcbiAgfSkgPT4gYE1pc3NpbmcgaW5pdGlhbGl6ZXIgaW4gJHtraW5kfSBkZWNsYXJhdGlvbi5gLFxuICBEZWNvcmF0b3JBcmd1bWVudHNPdXRzaWRlUGFyZW50aGVzZXM6IFwiRGVjb3JhdG9yIGFyZ3VtZW50cyBtdXN0IGJlIG1vdmVkIGluc2lkZSBwYXJlbnRoZXNlczogdXNlICdAKGRlY29yYXRvcihhcmdzKSknIGluc3RlYWQgb2YgJ0AoZGVjb3JhdG9yKShhcmdzKScuXCIsXG4gIERlY29yYXRvckJlZm9yZUV4cG9ydDogXCJEZWNvcmF0b3JzIG11c3QgYmUgcGxhY2VkICpiZWZvcmUqIHRoZSAnZXhwb3J0JyBrZXl3b3JkLiBSZW1vdmUgdGhlICdkZWNvcmF0b3JzQmVmb3JlRXhwb3J0OiB0cnVlJyBvcHRpb24gdG8gdXNlIHRoZSAnZXhwb3J0IEBkZWNvcmF0b3IgY2xhc3Mge30nIHN5bnRheC5cIixcbiAgRGVjb3JhdG9yc0JlZm9yZUFmdGVyRXhwb3J0OiBcIkRlY29yYXRvcnMgY2FuIGJlIHBsYWNlZCAqZWl0aGVyKiBiZWZvcmUgb3IgYWZ0ZXIgdGhlICdleHBvcnQnIGtleXdvcmQsIGJ1dCBub3QgaW4gYm90aCBsb2NhdGlvbnMgYXQgdGhlIHNhbWUgdGltZS5cIixcbiAgRGVjb3JhdG9yQ29uc3RydWN0b3I6IFwiRGVjb3JhdG9ycyBjYW4ndCBiZSB1c2VkIHdpdGggYSBjb25zdHJ1Y3Rvci4gRGlkIHlvdSBtZWFuICdAZGVjIGNsYXNzIHsgLi4uIH0nP1wiLFxuICBEZWNvcmF0b3JFeHBvcnRDbGFzczogXCJEZWNvcmF0b3JzIG11c3QgYmUgcGxhY2VkICphZnRlciogdGhlICdleHBvcnQnIGtleXdvcmQuIFJlbW92ZSB0aGUgJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQ6IGZhbHNlJyBvcHRpb24gdG8gdXNlIHRoZSAnQGRlY29yYXRvciBleHBvcnQgY2xhc3Mge30nIHN5bnRheC5cIixcbiAgRGVjb3JhdG9yU2VtaWNvbG9uOiBcIkRlY29yYXRvcnMgbXVzdCBub3QgYmUgZm9sbG93ZWQgYnkgYSBzZW1pY29sb24uXCIsXG4gIERlY29yYXRvclN0YXRpY0Jsb2NrOiBcIkRlY29yYXRvcnMgY2FuJ3QgYmUgdXNlZCB3aXRoIGEgc3RhdGljIGJsb2NrLlwiLFxuICBEZWZlckltcG9ydFJlcXVpcmVzTmFtZXNwYWNlOiAnT25seSBgaW1wb3J0IGRlZmVyICogYXMgeCBmcm9tIFwiLi9tb2R1bGVcImAgaXMgdmFsaWQuJyxcbiAgRGVsZXRlUHJpdmF0ZUZpZWxkOiBcIkRlbGV0aW5nIGEgcHJpdmF0ZSBmaWVsZCBpcyBub3QgYWxsb3dlZC5cIixcbiAgRGVzdHJ1Y3R1cmVOYW1lZEltcG9ydDogXCJFUzIwMTUgbmFtZWQgaW1wb3J0cyBkbyBub3QgZGVzdHJ1Y3R1cmUuIFVzZSBhbm90aGVyIHN0YXRlbWVudCBmb3IgZGVzdHJ1Y3R1cmluZyBhZnRlciB0aGUgaW1wb3J0LlwiLFxuICBEdXBsaWNhdGVDb25zdHJ1Y3RvcjogXCJEdXBsaWNhdGUgY29uc3RydWN0b3IgaW4gdGhlIHNhbWUgY2xhc3MuXCIsXG4gIER1cGxpY2F0ZURlZmF1bHRFeHBvcnQ6IFwiT25seSBvbmUgZGVmYXVsdCBleHBvcnQgYWxsb3dlZCBwZXIgbW9kdWxlLlwiLFxuICBEdXBsaWNhdGVFeHBvcnQ6ICh7XG4gICAgZXhwb3J0TmFtZVxuICB9KSA9PiBgXFxgJHtleHBvcnROYW1lfVxcYCBoYXMgYWxyZWFkeSBiZWVuIGV4cG9ydGVkLiBFeHBvcnRlZCBpZGVudGlmaWVycyBtdXN0IGJlIHVuaXF1ZS5gLFxuICBEdXBsaWNhdGVQcm90bzogXCJSZWRlZmluaXRpb24gb2YgX19wcm90b19fIHByb3BlcnR5LlwiLFxuICBEdXBsaWNhdGVSZWdFeHBGbGFnczogXCJEdXBsaWNhdGUgcmVndWxhciBleHByZXNzaW9uIGZsYWcuXCIsXG4gIEVsZW1lbnRBZnRlclJlc3Q6IFwiUmVzdCBlbGVtZW50IG11c3QgYmUgbGFzdCBlbGVtZW50LlwiLFxuICBFc2NhcGVkQ2hhck5vdEFuSWRlbnRpZmllcjogXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlLlwiLFxuICBFeHBvcnRCaW5kaW5nSXNTdHJpbmc6ICh7XG4gICAgbG9jYWxOYW1lLFxuICAgIGV4cG9ydE5hbWVcbiAgfSkgPT4gYEEgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHVzZWQgYXMgYW4gZXhwb3J0ZWQgYmluZGluZyB3aXRob3V0IFxcYGZyb21cXGAuXFxuLSBEaWQgeW91IG1lYW4gXFxgZXhwb3J0IHsgJyR7bG9jYWxOYW1lfScgYXMgJyR7ZXhwb3J0TmFtZX0nIH0gZnJvbSAnc29tZS1tb2R1bGUnXFxgP2AsXG4gIEV4cG9ydERlZmF1bHRGcm9tQXNJZGVudGlmaWVyOiBcIidmcm9tJyBpcyBub3QgYWxsb3dlZCBhcyBhbiBpZGVudGlmaWVyIGFmdGVyICdleHBvcnQgZGVmYXVsdCcuXCIsXG4gIEZvckluT2ZMb29wSW5pdGlhbGl6ZXI6ICh7XG4gICAgdHlwZVxuICB9KSA9PiBgJyR7dHlwZSA9PT0gXCJGb3JJblN0YXRlbWVudFwiID8gXCJmb3ItaW5cIiA6IFwiZm9yLW9mXCJ9JyBsb29wIHZhcmlhYmxlIGRlY2xhcmF0aW9uIG1heSBub3QgaGF2ZSBhbiBpbml0aWFsaXplci5gLFxuICBGb3JJblVzaW5nOiBcIkZvci1pbiBsb29wIG1heSBub3Qgc3RhcnQgd2l0aCAndXNpbmcnIGRlY2xhcmF0aW9uLlwiLFxuICBGb3JPZkFzeW5jOiBcIlRoZSBsZWZ0LWhhbmQgc2lkZSBvZiBhIGZvci1vZiBsb29wIG1heSBub3QgYmUgJ2FzeW5jJy5cIixcbiAgRm9yT2ZMZXQ6IFwiVGhlIGxlZnQtaGFuZCBzaWRlIG9mIGEgZm9yLW9mIGxvb3AgbWF5IG5vdCBzdGFydCB3aXRoICdsZXQnLlwiLFxuICBHZW5lcmF0b3JJblNpbmdsZVN0YXRlbWVudENvbnRleHQ6IFwiR2VuZXJhdG9ycyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0aGUgdG9wIGxldmVsIG9yIGluc2lkZSBhIGJsb2NrLlwiLFxuICBJbGxlZ2FsQnJlYWtDb250aW51ZTogKHtcbiAgICB0eXBlXG4gIH0pID0+IGBVbnN5bnRhY3RpYyAke3R5cGUgPT09IFwiQnJlYWtTdGF0ZW1lbnRcIiA/IFwiYnJlYWtcIiA6IFwiY29udGludWVcIn0uYCxcbiAgSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZTogXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0LlwiLFxuICBJbGxlZ2FsUmV0dXJuOiBcIidyZXR1cm4nIG91dHNpZGUgb2YgZnVuY3Rpb24uXCIsXG4gIEltcG9ydEF0dHJpYnV0ZXNVc2VBc3NlcnQ6IFwiVGhlIGBhc3NlcnRgIGtleXdvcmQgaW4gaW1wb3J0IGF0dHJpYnV0ZXMgaXMgZGVwcmVjYXRlZCBhbmQgaXQgaGFzIGJlZW4gcmVwbGFjZWQgYnkgdGhlIGB3aXRoYCBrZXl3b3JkLiBZb3UgY2FuIGVuYWJsZSB0aGUgYGRlcHJlY2F0ZWRJbXBvcnRBc3NlcnRgIHBhcnNlciBwbHVnaW4gdG8gc3VwcHJlc3MgdGhpcyBlcnJvci5cIixcbiAgSW1wb3J0QmluZGluZ0lzU3RyaW5nOiAoe1xuICAgIGltcG9ydE5hbWVcbiAgfSkgPT4gYEEgc3RyaW5nIGxpdGVyYWwgY2Fubm90IGJlIHVzZWQgYXMgYW4gaW1wb3J0ZWQgYmluZGluZy5cXG4tIERpZCB5b3UgbWVhbiBcXGBpbXBvcnQgeyBcIiR7aW1wb3J0TmFtZX1cIiBhcyBmb28gfVxcYD9gLFxuICBJbXBvcnRDYWxsQXJpdHk6IGBcXGBpbXBvcnQoKVxcYCByZXF1aXJlcyBleGFjdGx5IG9uZSBvciB0d28gYXJndW1lbnRzLmAsXG4gIEltcG9ydENhbGxOb3ROZXdFeHByZXNzaW9uOiBcIkNhbm5vdCB1c2UgbmV3IHdpdGggaW1wb3J0KC4uLikuXCIsXG4gIEltcG9ydENhbGxTcHJlYWRBcmd1bWVudDogXCJgLi4uYCBpcyBub3QgYWxsb3dlZCBpbiBgaW1wb3J0KClgLlwiLFxuICBJbXBvcnRKU09OQmluZGluZ05vdERlZmF1bHQ6IFwiQSBKU09OIG1vZHVsZSBjYW4gb25seSBiZSBpbXBvcnRlZCB3aXRoIGBkZWZhdWx0YC5cIixcbiAgSW1wb3J0UmVmbGVjdGlvbkhhc0Fzc2VydGlvbjogXCJgaW1wb3J0IG1vZHVsZSB4YCBjYW5ub3QgaGF2ZSBhc3NlcnRpb25zLlwiLFxuICBJbXBvcnRSZWZsZWN0aW9uTm90QmluZGluZzogJ09ubHkgYGltcG9ydCBtb2R1bGUgeCBmcm9tIFwiLi9tb2R1bGVcImAgaXMgdmFsaWQuJyxcbiAgSW5jb21wYXRpYmxlUmVnRXhwVVZGbGFnczogXCJUaGUgJ3UnIGFuZCAndicgcmVndWxhciBleHByZXNzaW9uIGZsYWdzIGNhbm5vdCBiZSBlbmFibGVkIGF0IHRoZSBzYW1lIHRpbWUuXCIsXG4gIEludmFsaWRCaWdJbnRMaXRlcmFsOiBcIkludmFsaWQgQmlnSW50TGl0ZXJhbC5cIixcbiAgSW52YWxpZENvZGVQb2ludDogXCJDb2RlIHBvaW50IG91dCBvZiBib3VuZHMuXCIsXG4gIEludmFsaWRDb3ZlckRpc2NhcmRFbGVtZW50OiBcIid2b2lkJyBtdXN0IGJlIGZvbGxvd2VkIGJ5IGFuIGV4cHJlc3Npb24gd2hlbiBub3QgdXNlZCBpbiBhIGJpbmRpbmcgcG9zaXRpb24uXCIsXG4gIEludmFsaWRDb3ZlckluaXRpYWxpemVkTmFtZTogXCJJbnZhbGlkIHNob3J0aGFuZCBwcm9wZXJ0eSBpbml0aWFsaXplci5cIixcbiAgSW52YWxpZERlY2ltYWw6IFwiSW52YWxpZCBkZWNpbWFsLlwiLFxuICBJbnZhbGlkRGlnaXQ6ICh7XG4gICAgcmFkaXhcbiAgfSkgPT4gYEV4cGVjdGVkIG51bWJlciBpbiByYWRpeCAke3JhZGl4fS5gLFxuICBJbnZhbGlkRXNjYXBlU2VxdWVuY2U6IFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2UuXCIsXG4gIEludmFsaWRFc2NhcGVTZXF1ZW5jZVRlbXBsYXRlOiBcIkludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHRlbXBsYXRlLlwiLFxuICBJbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZDogKHtcbiAgICByZXNlcnZlZFdvcmRcbiAgfSkgPT4gYEVzY2FwZSBzZXF1ZW5jZSBpbiBrZXl3b3JkICR7cmVzZXJ2ZWRXb3JkfS5gLFxuICBJbnZhbGlkSWRlbnRpZmllcjogKHtcbiAgICBpZGVudGlmaWVyTmFtZVxuICB9KSA9PiBgSW52YWxpZCBpZGVudGlmaWVyICR7aWRlbnRpZmllck5hbWV9LmAsXG4gIEludmFsaWRMaHM6ICh7XG4gICAgYW5jZXN0b3JcbiAgfSkgPT4gYEludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gJHt0b05vZGVEZXNjcmlwdGlvbihhbmNlc3Rvcil9LmAsXG4gIEludmFsaWRMaHNCaW5kaW5nOiAoe1xuICAgIGFuY2VzdG9yXG4gIH0pID0+IGBCaW5kaW5nIGludmFsaWQgbGVmdC1oYW5kIHNpZGUgaW4gJHt0b05vZGVEZXNjcmlwdGlvbihhbmNlc3Rvcil9LmAsXG4gIEludmFsaWRMaHNPcHRpb25hbENoYWluaW5nOiAoe1xuICAgIGFuY2VzdG9yXG4gIH0pID0+IGBJbnZhbGlkIG9wdGlvbmFsIGNoYWluaW5nIGluIHRoZSBsZWZ0LWhhbmQgc2lkZSBvZiAke3RvTm9kZURlc2NyaXB0aW9uKGFuY2VzdG9yKX0uYCxcbiAgSW52YWxpZE51bWJlcjogXCJJbnZhbGlkIG51bWJlci5cIixcbiAgSW52YWxpZE9yTWlzc2luZ0V4cG9uZW50OiBcIkZsb2F0aW5nLXBvaW50IG51bWJlcnMgcmVxdWlyZSBhIHZhbGlkIGV4cG9uZW50IGFmdGVyIHRoZSAnZScuXCIsXG4gIEludmFsaWRPclVuZXhwZWN0ZWRUb2tlbjogKHtcbiAgICB1bmV4cGVjdGVkXG4gIH0pID0+IGBVbmV4cGVjdGVkIGNoYXJhY3RlciAnJHt1bmV4cGVjdGVkfScuYCxcbiAgSW52YWxpZFBhcmVudGhlc2l6ZWRBc3NpZ25tZW50OiBcIkludmFsaWQgcGFyZW50aGVzaXplZCBhc3NpZ25tZW50IHBhdHRlcm4uXCIsXG4gIEludmFsaWRQcml2YXRlRmllbGRSZXNvbHV0aW9uOiAoe1xuICAgIGlkZW50aWZpZXJOYW1lXG4gIH0pID0+IGBQcml2YXRlIG5hbWUgIyR7aWRlbnRpZmllck5hbWV9IGlzIG5vdCBkZWZpbmVkLmAsXG4gIEludmFsaWRQcm9wZXJ0eUJpbmRpbmdQYXR0ZXJuOiBcIkJpbmRpbmcgbWVtYmVyIGV4cHJlc3Npb24uXCIsXG4gIEludmFsaWRSZWNvcmRQcm9wZXJ0eTogXCJPbmx5IHByb3BlcnRpZXMgYW5kIHNwcmVhZCBlbGVtZW50cyBhcmUgYWxsb3dlZCBpbiByZWNvcmQgZGVmaW5pdGlvbnMuXCIsXG4gIEludmFsaWRSZXN0QXNzaWdubWVudFBhdHRlcm46IFwiSW52YWxpZCByZXN0IG9wZXJhdG9yJ3MgYXJndW1lbnQuXCIsXG4gIExhYmVsUmVkZWNsYXJhdGlvbjogKHtcbiAgICBsYWJlbE5hbWVcbiAgfSkgPT4gYExhYmVsICcke2xhYmVsTmFtZX0nIGlzIGFscmVhZHkgZGVjbGFyZWQuYCxcbiAgTGV0SW5MZXhpY2FsQmluZGluZzogXCInbGV0JyBpcyBkaXNhbGxvd2VkIGFzIGEgbGV4aWNhbGx5IGJvdW5kIG5hbWUuXCIsXG4gIExpbmVUZXJtaW5hdG9yQmVmb3JlQXJyb3c6IFwiTm8gbGluZSBicmVhayBpcyBhbGxvd2VkIGJlZm9yZSAnPT4nLlwiLFxuICBNYWxmb3JtZWRSZWdFeHBGbGFnczogXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnLlwiLFxuICBNaXNzaW5nQ2xhc3NOYW1lOiBcIkEgY2xhc3MgbmFtZSBpcyByZXF1aXJlZC5cIixcbiAgTWlzc2luZ0VxSW5Bc3NpZ25tZW50OiBcIk9ubHkgJz0nIG9wZXJhdG9yIGNhbiBiZSB1c2VkIGZvciBzcGVjaWZ5aW5nIGRlZmF1bHQgdmFsdWUuXCIsXG4gIE1pc3NpbmdTZW1pY29sb246IFwiTWlzc2luZyBzZW1pY29sb24uXCIsXG4gIE1pc3NpbmdQbHVnaW46ICh7XG4gICAgbWlzc2luZ1BsdWdpblxuICB9KSA9PiBgVGhpcyBleHBlcmltZW50YWwgc3ludGF4IHJlcXVpcmVzIGVuYWJsaW5nIHRoZSBwYXJzZXIgcGx1Z2luOiAke21pc3NpbmdQbHVnaW4ubWFwKG5hbWUgPT4gSlNPTi5zdHJpbmdpZnkobmFtZSkpLmpvaW4oXCIsIFwiKX0uYCxcbiAgTWlzc2luZ09uZU9mUGx1Z2luczogKHtcbiAgICBtaXNzaW5nUGx1Z2luXG4gIH0pID0+IGBUaGlzIGV4cGVyaW1lbnRhbCBzeW50YXggcmVxdWlyZXMgZW5hYmxpbmcgb25lIG9mIHRoZSBmb2xsb3dpbmcgcGFyc2VyIHBsdWdpbihzKTogJHttaXNzaW5nUGx1Z2luLm1hcChuYW1lID0+IEpTT04uc3RyaW5naWZ5KG5hbWUpKS5qb2luKFwiLCBcIil9LmAsXG4gIE1pc3NpbmdVbmljb2RlRXNjYXBlOiBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFguXCIsXG4gIE1peGluZ0NvYWxlc2NlV2l0aExvZ2ljYWw6IFwiTnVsbGlzaCBjb2FsZXNjaW5nIG9wZXJhdG9yKD8/KSByZXF1aXJlcyBwYXJlbnMgd2hlbiBtaXhpbmcgd2l0aCBsb2dpY2FsIG9wZXJhdG9ycy5cIixcbiAgTW9kdWxlQXR0cmlidXRlRGlmZmVyZW50RnJvbVR5cGU6IFwiVGhlIG9ubHkgYWNjZXB0ZWQgbW9kdWxlIGF0dHJpYnV0ZSBpcyBgdHlwZWAuXCIsXG4gIE1vZHVsZUF0dHJpYnV0ZUludmFsaWRWYWx1ZTogXCJPbmx5IHN0cmluZyBsaXRlcmFscyBhcmUgYWxsb3dlZCBhcyBtb2R1bGUgYXR0cmlidXRlIHZhbHVlcy5cIixcbiAgTW9kdWxlQXR0cmlidXRlc1dpdGhEdXBsaWNhdGVLZXlzOiAoe1xuICAgIGtleVxuICB9KSA9PiBgRHVwbGljYXRlIGtleSBcIiR7a2V5fVwiIGlzIG5vdCBhbGxvd2VkIGluIG1vZHVsZSBhdHRyaWJ1dGVzLmAsXG4gIE1vZHVsZUV4cG9ydE5hbWVIYXNMb25lU3Vycm9nYXRlOiAoe1xuICAgIHN1cnJvZ2F0ZUNoYXJDb2RlXG4gIH0pID0+IGBBbiBleHBvcnQgbmFtZSBjYW5ub3QgaW5jbHVkZSBhIGxvbmUgc3Vycm9nYXRlLCBmb3VuZCAnXFxcXHUke3N1cnJvZ2F0ZUNoYXJDb2RlLnRvU3RyaW5nKDE2KX0nLmAsXG4gIE1vZHVsZUV4cG9ydFVuZGVmaW5lZDogKHtcbiAgICBsb2NhbE5hbWVcbiAgfSkgPT4gYEV4cG9ydCAnJHtsb2NhbE5hbWV9JyBpcyBub3QgZGVmaW5lZC5gLFxuICBNdWx0aXBsZURlZmF1bHRzSW5Td2l0Y2g6IFwiTXVsdGlwbGUgZGVmYXVsdCBjbGF1c2VzLlwiLFxuICBOZXdsaW5lQWZ0ZXJUaHJvdzogXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3cuXCIsXG4gIE5vQ2F0Y2hPckZpbmFsbHk6IFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZS5cIixcbiAgTnVtYmVySWRlbnRpZmllcjogXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlci5cIixcbiAgTnVtZXJpY1NlcGFyYXRvckluRXNjYXBlU2VxdWVuY2U6IFwiTnVtZXJpYyBzZXBhcmF0b3JzIGFyZSBub3QgYWxsb3dlZCBpbnNpZGUgdW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzIG9yIGhleCBlc2NhcGUgc2VxdWVuY2VzLlwiLFxuICBPYnNvbGV0ZUF3YWl0U3RhcjogXCInYXdhaXQqJyBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGFzeW5jIGZ1bmN0aW9ucyBwcm9wb3NhbC4gVXNlIFByb21pc2UuYWxsKCkgaW5zdGVhZC5cIixcbiAgT3B0aW9uYWxDaGFpbmluZ05vTmV3OiBcIkNvbnN0cnVjdG9ycyBpbi9hZnRlciBhbiBPcHRpb25hbCBDaGFpbiBhcmUgbm90IGFsbG93ZWQuXCIsXG4gIE9wdGlvbmFsQ2hhaW5pbmdOb1RlbXBsYXRlOiBcIlRhZ2dlZCBUZW1wbGF0ZSBMaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gb3B0aW9uYWxDaGFpbi5cIixcbiAgT3ZlcnJpZGVPbkNvbnN0cnVjdG9yOiBcIidvdmVycmlkZScgbW9kaWZpZXIgY2Fubm90IGFwcGVhciBvbiBhIGNvbnN0cnVjdG9yIGRlY2xhcmF0aW9uLlwiLFxuICBQYXJhbUR1cGU6IFwiQXJndW1lbnQgbmFtZSBjbGFzaC5cIixcbiAgUGF0dGVybkhhc0FjY2Vzc29yOiBcIk9iamVjdCBwYXR0ZXJuIGNhbid0IGNvbnRhaW4gZ2V0dGVyIG9yIHNldHRlci5cIixcbiAgUGF0dGVybkhhc01ldGhvZDogXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIG1ldGhvZHMuXCIsXG4gIFByaXZhdGVJbkV4cGVjdGVkSW46ICh7XG4gICAgaWRlbnRpZmllck5hbWVcbiAgfSkgPT4gYFByaXZhdGUgbmFtZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBwcm9wZXJ0eSBhY2Nlc3NlcyAoXFxgb2JqLiMke2lkZW50aWZpZXJOYW1lfVxcYCkgb3IgaW4gXFxgaW5cXGAgZXhwcmVzc2lvbnMgKFxcYCMke2lkZW50aWZpZXJOYW1lfSBpbiBvYmpcXGApLmAsXG4gIFByaXZhdGVOYW1lUmVkZWNsYXJhdGlvbjogKHtcbiAgICBpZGVudGlmaWVyTmFtZVxuICB9KSA9PiBgRHVwbGljYXRlIHByaXZhdGUgbmFtZSAjJHtpZGVudGlmaWVyTmFtZX0uYCxcbiAgUmVjb3JkRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGU6IFwiUmVjb3JkIGV4cHJlc3Npb25zIGVuZGluZyB3aXRoICd8fScgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcicuXCIsXG4gIFJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiUmVjb3JkIGV4cHJlc3Npb25zIHN0YXJ0aW5nIHdpdGggJ3t8JyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnYmFyJy5cIixcbiAgUmVjb3JkRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiUmVjb3JkIGV4cHJlc3Npb25zIHN0YXJ0aW5nIHdpdGggJyN7JyBhcmUgb25seSBhbGxvd2VkIHdoZW4gdGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIGlzIHNldCB0byAnaGFzaCcuXCIsXG4gIFJlY29yZE5vUHJvdG86IFwiJ19fcHJvdG9fXycgaXMgbm90IGFsbG93ZWQgaW4gUmVjb3JkIGV4cHJlc3Npb25zLlwiLFxuICBSZXN0VHJhaWxpbmdDb21tYTogXCJVbmV4cGVjdGVkIHRyYWlsaW5nIGNvbW1hIGFmdGVyIHJlc3QgZWxlbWVudC5cIixcbiAgU2xvcHB5RnVuY3Rpb246IFwiSW4gbm9uLXN0cmljdCBtb2RlIGNvZGUsIGZ1bmN0aW9ucyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2suXCIsXG4gIFNsb3BweUZ1bmN0aW9uQW5uZXhCOiBcIkluIG5vbi1zdHJpY3QgbW9kZSBjb2RlLCBmdW5jdGlvbnMgY2FuIG9ubHkgYmUgZGVjbGFyZWQgYXQgdG9wIGxldmVsLCBpbnNpZGUgYSBibG9jaywgb3IgYXMgdGhlIGJvZHkgb2YgYW4gaWYgc3RhdGVtZW50LlwiLFxuICBTb3VyY2VQaGFzZUltcG9ydFJlcXVpcmVzRGVmYXVsdDogJ09ubHkgYGltcG9ydCBzb3VyY2UgeCBmcm9tIFwiLi9tb2R1bGVcImAgaXMgdmFsaWQuJyxcbiAgU3RhdGljUHJvdG90eXBlOiBcIkNsYXNzZXMgbWF5IG5vdCBoYXZlIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBwcm90b3R5cGUuXCIsXG4gIFN1cGVyTm90QWxsb3dlZDogXCJgc3VwZXIoKWAgaXMgb25seSB2YWxpZCBpbnNpZGUgYSBjbGFzcyBjb25zdHJ1Y3RvciBvZiBhIHN1YmNsYXNzLiBNYXliZSBhIHR5cG8gaW4gdGhlIG1ldGhvZCBuYW1lICgnY29uc3RydWN0b3InKSBvciBub3QgZXh0ZW5kaW5nIGFub3RoZXIgY2xhc3M/XCIsXG4gIFN1cGVyUHJpdmF0ZUZpZWxkOiBcIlByaXZhdGUgZmllbGRzIGNhbid0IGJlIGFjY2Vzc2VkIG9uIHN1cGVyLlwiLFxuICBUcmFpbGluZ0RlY29yYXRvcjogXCJEZWNvcmF0b3JzIG11c3QgYmUgYXR0YWNoZWQgdG8gYSBjbGFzcyBlbGVtZW50LlwiLFxuICBUdXBsZUV4cHJlc3Npb25CYXJJbmNvcnJlY3RFbmRTeW50YXhUeXBlOiBcIlR1cGxlIGV4cHJlc3Npb25zIGVuZGluZyB3aXRoICd8XScgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcicuXCIsXG4gIFR1cGxlRXhwcmVzc2lvbkJhckluY29ycmVjdFN0YXJ0U3ludGF4VHlwZTogXCJUdXBsZSBleHByZXNzaW9ucyBzdGFydGluZyB3aXRoICdbfCcgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSAnc3ludGF4VHlwZScgb3B0aW9uIG9mIHRoZSAncmVjb3JkQW5kVHVwbGUnIHBsdWdpbiBpcyBzZXQgdG8gJ2JhcicuXCIsXG4gIFR1cGxlRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGU6IFwiVHVwbGUgZXhwcmVzc2lvbnMgc3RhcnRpbmcgd2l0aCAnI1snIGFyZSBvbmx5IGFsbG93ZWQgd2hlbiB0aGUgJ3N5bnRheFR5cGUnIG9wdGlvbiBvZiB0aGUgJ3JlY29yZEFuZFR1cGxlJyBwbHVnaW4gaXMgc2V0IHRvICdoYXNoJy5cIixcbiAgVW5leHBlY3RlZEFyZ3VtZW50UGxhY2Vob2xkZXI6IFwiVW5leHBlY3RlZCBhcmd1bWVudCBwbGFjZWhvbGRlci5cIixcbiAgVW5leHBlY3RlZEF3YWl0QWZ0ZXJQaXBlbGluZUJvZHk6ICdVbmV4cGVjdGVkIFwiYXdhaXRcIiBhZnRlciBwaXBlbGluZSBib2R5OyBhd2FpdCBtdXN0IGhhdmUgcGFyZW50aGVzZXMgaW4gbWluaW1hbCBwcm9wb3NhbC4nLFxuICBVbmV4cGVjdGVkRGlnaXRBZnRlckhhc2g6IFwiVW5leHBlY3RlZCBkaWdpdCBhZnRlciBoYXNoIHRva2VuLlwiLFxuICBVbmV4cGVjdGVkSW1wb3J0RXhwb3J0OiBcIidpbXBvcnQnIGFuZCAnZXhwb3J0JyBtYXkgb25seSBhcHBlYXIgYXQgdGhlIHRvcCBsZXZlbC5cIixcbiAgVW5leHBlY3RlZEtleXdvcmQ6ICh7XG4gICAga2V5d29yZFxuICB9KSA9PiBgVW5leHBlY3RlZCBrZXl3b3JkICcke2tleXdvcmR9Jy5gLFxuICBVbmV4cGVjdGVkTGVhZGluZ0RlY29yYXRvcjogXCJMZWFkaW5nIGRlY29yYXRvcnMgbXVzdCBiZSBhdHRhY2hlZCB0byBhIGNsYXNzIGRlY2xhcmF0aW9uLlwiLFxuICBVbmV4cGVjdGVkTGV4aWNhbERlY2xhcmF0aW9uOiBcIkxleGljYWwgZGVjbGFyYXRpb24gY2Fubm90IGFwcGVhciBpbiBhIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dC5cIixcbiAgVW5leHBlY3RlZE5ld1RhcmdldDogXCJgbmV3LnRhcmdldGAgY2FuIG9ubHkgYmUgdXNlZCBpbiBmdW5jdGlvbnMgb3IgY2xhc3MgcHJvcGVydGllcy5cIixcbiAgVW5leHBlY3RlZE51bWVyaWNTZXBhcmF0b3I6IFwiQSBudW1lcmljIHNlcGFyYXRvciBpcyBvbmx5IGFsbG93ZWQgYmV0d2VlbiB0d28gZGlnaXRzLlwiLFxuICBVbmV4cGVjdGVkUHJpdmF0ZUZpZWxkOiBcIlVuZXhwZWN0ZWQgcHJpdmF0ZSBuYW1lLlwiLFxuICBVbmV4cGVjdGVkUmVzZXJ2ZWRXb3JkOiAoe1xuICAgIHJlc2VydmVkV29yZFxuICB9KSA9PiBgVW5leHBlY3RlZCByZXNlcnZlZCB3b3JkICcke3Jlc2VydmVkV29yZH0nLmAsXG4gIFVuZXhwZWN0ZWRTdXBlcjogXCInc3VwZXInIGlzIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbWV0aG9kcyBhbmQgY2xhc3Nlcy5cIixcbiAgVW5leHBlY3RlZFRva2VuOiAoe1xuICAgIGV4cGVjdGVkLFxuICAgIHVuZXhwZWN0ZWRcbiAgfSkgPT4gYFVuZXhwZWN0ZWQgdG9rZW4ke3VuZXhwZWN0ZWQgPyBgICcke3VuZXhwZWN0ZWR9Jy5gIDogXCJcIn0ke2V4cGVjdGVkID8gYCwgZXhwZWN0ZWQgXCIke2V4cGVjdGVkfVwiYCA6IFwiXCJ9YCxcbiAgVW5leHBlY3RlZFRva2VuVW5hcnlFeHBvbmVudGlhdGlvbjogXCJJbGxlZ2FsIGV4cHJlc3Npb24uIFdyYXAgbGVmdCBoYW5kIHNpZGUgb3IgZW50aXJlIGV4cG9uZW50aWF0aW9uIGluIHBhcmVudGhlc2VzLlwiLFxuICBVbmV4cGVjdGVkVXNpbmdEZWNsYXJhdGlvbjogXCJVc2luZyBkZWNsYXJhdGlvbiBjYW5ub3QgYXBwZWFyIGluIHRoZSB0b3AgbGV2ZWwgd2hlbiBzb3VyY2UgdHlwZSBpcyBgc2NyaXB0YCBvciBpbiB0aGUgYmFyZSBjYXNlIHN0YXRlbWVudC5cIixcbiAgVW5leHBlY3RlZFZvaWRQYXR0ZXJuOiBcIlVuZXhwZWN0ZWQgdm9pZCBiaW5kaW5nLlwiLFxuICBVbnN1cHBvcnRlZEJpbmQ6IFwiQmluZGluZyBzaG91bGQgYmUgcGVyZm9ybWVkIG9uIG9iamVjdCBwcm9wZXJ0eS5cIixcbiAgVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQ6IFwiQSBkZWNvcmF0ZWQgZXhwb3J0IG11c3QgZXhwb3J0IGEgY2xhc3MgZGVjbGFyYXRpb24uXCIsXG4gIFVuc3VwcG9ydGVkRGVmYXVsdEV4cG9ydDogXCJPbmx5IGV4cHJlc3Npb25zLCBmdW5jdGlvbnMgb3IgY2xhc3NlcyBhcmUgYWxsb3dlZCBhcyB0aGUgYGRlZmF1bHRgIGV4cG9ydC5cIixcbiAgVW5zdXBwb3J0ZWRJbXBvcnQ6IFwiYGltcG9ydGAgY2FuIG9ubHkgYmUgdXNlZCBpbiBgaW1wb3J0KClgIG9yIGBpbXBvcnQubWV0YWAuXCIsXG4gIFVuc3VwcG9ydGVkTWV0YVByb3BlcnR5OiAoe1xuICAgIHRhcmdldCxcbiAgICBvbmx5VmFsaWRQcm9wZXJ0eU5hbWVcbiAgfSkgPT4gYFRoZSBvbmx5IHZhbGlkIG1ldGEgcHJvcGVydHkgZm9yICR7dGFyZ2V0fSBpcyAke3RhcmdldH0uJHtvbmx5VmFsaWRQcm9wZXJ0eU5hbWV9LmAsXG4gIFVuc3VwcG9ydGVkUGFyYW1ldGVyRGVjb3JhdG9yOiBcIkRlY29yYXRvcnMgY2Fubm90IGJlIHVzZWQgdG8gZGVjb3JhdGUgcGFyYW1ldGVycy5cIixcbiAgVW5zdXBwb3J0ZWRQcm9wZXJ0eURlY29yYXRvcjogXCJEZWNvcmF0b3JzIGNhbm5vdCBiZSB1c2VkIHRvIGRlY29yYXRlIG9iamVjdCBsaXRlcmFsIHByb3BlcnRpZXMuXCIsXG4gIFVuc3VwcG9ydGVkU3VwZXI6IFwiJ3N1cGVyJyBjYW4gb25seSBiZSB1c2VkIHdpdGggZnVuY3Rpb24gY2FsbHMgKGkuZS4gc3VwZXIoKSkgb3IgaW4gcHJvcGVydHkgYWNjZXNzZXMgKGkuZS4gc3VwZXIucHJvcCBvciBzdXBlcltwcm9wXSkuXCIsXG4gIFVudGVybWluYXRlZENvbW1lbnQ6IFwiVW50ZXJtaW5hdGVkIGNvbW1lbnQuXCIsXG4gIFVudGVybWluYXRlZFJlZ0V4cDogXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uLlwiLFxuICBVbnRlcm1pbmF0ZWRTdHJpbmc6IFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudC5cIixcbiAgVW50ZXJtaW5hdGVkVGVtcGxhdGU6IFwiVW50ZXJtaW5hdGVkIHRlbXBsYXRlLlwiLFxuICBVc2luZ0RlY2xhcmF0aW9uRXhwb3J0OiBcIlVzaW5nIGRlY2xhcmF0aW9uIGNhbm5vdCBiZSBleHBvcnRlZC5cIixcbiAgVXNpbmdEZWNsYXJhdGlvbkhhc0JpbmRpbmdQYXR0ZXJuOiBcIlVzaW5nIGRlY2xhcmF0aW9uIGNhbm5vdCBoYXZlIGRlc3RydWN0dXJpbmcgcGF0dGVybnMuXCIsXG4gIFZhclJlZGVjbGFyYXRpb246ICh7XG4gICAgaWRlbnRpZmllck5hbWVcbiAgfSkgPT4gYElkZW50aWZpZXIgJyR7aWRlbnRpZmllck5hbWV9JyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkLmAsXG4gIFZvaWRQYXR0ZXJuQ2F0Y2hDbGF1c2VQYXJhbTogXCJBIHZvaWQgYmluZGluZyBjYW4gbm90IGJlIHRoZSBjYXRjaCBjbGF1c2UgcGFyYW1ldGVyLiBVc2UgYHRyeSB7IC4uLiB9IGNhdGNoIHsgLi4uIH1gIGlmIHlvdSB3YW50IHRvIGRpc2NhcmQgdGhlIGNhdWdodCBlcnJvci5cIixcbiAgVm9pZFBhdHRlcm5Jbml0aWFsaXplcjogXCJBIHZvaWQgYmluZGluZyBtYXkgbm90IGhhdmUgYW4gaW5pdGlhbGl6ZXIuXCIsXG4gIFlpZWxkQmluZGluZ0lkZW50aWZpZXI6IFwiQ2FuIG5vdCB1c2UgJ3lpZWxkJyBhcyBpZGVudGlmaWVyIGluc2lkZSBhIGdlbmVyYXRvci5cIixcbiAgWWllbGRJblBhcmFtZXRlcjogXCJZaWVsZCBleHByZXNzaW9uIGlzIG5vdCBhbGxvd2VkIGluIGZvcm1hbCBwYXJhbWV0ZXJzLlwiLFxuICBZaWVsZE5vdEluR2VuZXJhdG9yRnVuY3Rpb246IFwiJ3lpZWxkJyBpcyBvbmx5IGFsbG93ZWQgd2l0aGluIGdlbmVyYXRvciBmdW5jdGlvbnMuXCIsXG4gIFplcm9EaWdpdE51bWVyaWNTZXBhcmF0b3I6IFwiTnVtZXJpYyBzZXBhcmF0b3IgY2FuIG5vdCBiZSB1c2VkIGFmdGVyIGxlYWRpbmcgMC5cIlxufTtcbnZhciBTdHJpY3RNb2RlRXJyb3JzID0ge1xuICBTdHJpY3REZWxldGU6IFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGUuXCIsXG4gIFN0cmljdEV2YWxBcmd1bWVudHM6ICh7XG4gICAgcmVmZXJlbmNlTmFtZVxuICB9KSA9PiBgQXNzaWduaW5nIHRvICcke3JlZmVyZW5jZU5hbWV9JyBpbiBzdHJpY3QgbW9kZS5gLFxuICBTdHJpY3RFdmFsQXJndW1lbnRzQmluZGluZzogKHtcbiAgICBiaW5kaW5nTmFtZVxuICB9KSA9PiBgQmluZGluZyAnJHtiaW5kaW5nTmFtZX0nIGluIHN0cmljdCBtb2RlLmAsXG4gIFN0cmljdEZ1bmN0aW9uOiBcIkluIHN0cmljdCBtb2RlIGNvZGUsIGZ1bmN0aW9ucyBjYW4gb25seSBiZSBkZWNsYXJlZCBhdCB0b3AgbGV2ZWwgb3IgaW5zaWRlIGEgYmxvY2suXCIsXG4gIFN0cmljdE51bWVyaWNFc2NhcGU6IFwiVGhlIG9ubHkgdmFsaWQgbnVtZXJpYyBlc2NhcGUgaW4gc3RyaWN0IG1vZGUgaXMgJ1xcXFwwJy5cIixcbiAgU3RyaWN0T2N0YWxMaXRlcmFsOiBcIkxlZ2FjeSBvY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuXCIsXG4gIFN0cmljdFdpdGg6IFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlLlwiXG59O1xudmFyIFBhcnNlRXhwcmVzc2lvbkVycm9ycyA9IHtcbiAgUGFyc2VFeHByZXNzaW9uRW1wdHlJbnB1dDogXCJVbmV4cGVjdGVkIHBhcnNlRXhwcmVzc2lvbigpIGlucHV0OiBUaGUgaW5wdXQgaXMgZW1wdHkgb3IgY29udGFpbnMgb25seSBjb21tZW50cy5cIixcbiAgUGFyc2VFeHByZXNzaW9uRXhwZWN0c0VPRjogKHtcbiAgICB1bmV4cGVjdGVkXG4gIH0pID0+IGBVbmV4cGVjdGVkIHBhcnNlRXhwcmVzc2lvbigpIGlucHV0OiBUaGUgaW5wdXQgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgZXhwcmVzc2lvbiwgYnV0IHRoZSBmaXJzdCBleHByZXNzaW9uIGlzIGZvbGxvd2VkIGJ5IHRoZSB1bmV4cGVjdGVkIGNoYXJhY3RlciBcXGAke1N0cmluZy5mcm9tQ29kZVBvaW50KHVuZXhwZWN0ZWQpfVxcYC5gXG59O1xuY29uc3QgVW5wYXJlbnRoZXNpemVkUGlwZUJvZHlEZXNjcmlwdGlvbnMgPSBuZXcgU2V0KFtcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiwgXCJZaWVsZEV4cHJlc3Npb25cIl0pO1xudmFyIFBpcGVsaW5lT3BlcmF0b3JFcnJvcnMgPSBPYmplY3QuYXNzaWduKHtcbiAgUGlwZUJvZHlJc1RpZ2h0ZXI6IFwiVW5leHBlY3RlZCB5aWVsZCBhZnRlciBwaXBlbGluZSBib2R5OyBhbnkgeWllbGQgZXhwcmVzc2lvbiBhY3RpbmcgYXMgSGFjay1zdHlsZSBwaXBlIGJvZHkgbXVzdCBiZSBwYXJlbnRoZXNpemVkIGR1ZSB0byBpdHMgbG9vc2Ugb3BlcmF0b3IgcHJlY2VkZW5jZS5cIixcbiAgUGlwZVRvcGljUmVxdWlyZXNIYWNrUGlwZXM6ICdUb3BpYyByZWZlcmVuY2UgaXMgdXNlZCwgYnV0IHRoZSBwaXBlbGluZU9wZXJhdG9yIHBsdWdpbiB3YXMgbm90IHBhc3NlZCBhIFwicHJvcG9zYWxcIjogXCJoYWNrXCIgb3IgXCJzbWFydFwiIG9wdGlvbi4nLFxuICBQaXBlVG9waWNVbmJvdW5kOiBcIlRvcGljIHJlZmVyZW5jZSBpcyB1bmJvdW5kOyBpdCBtdXN0IGJlIGluc2lkZSBhIHBpcGUgYm9keS5cIixcbiAgUGlwZVRvcGljVW5jb25maWd1cmVkVG9rZW46ICh7XG4gICAgdG9rZW5cbiAgfSkgPT4gYEludmFsaWQgdG9waWMgdG9rZW4gJHt0b2tlbn0uIEluIG9yZGVyIHRvIHVzZSAke3Rva2VufSBhcyBhIHRvcGljIHJlZmVyZW5jZSwgdGhlIHBpcGVsaW5lT3BlcmF0b3IgcGx1Z2luIG11c3QgYmUgY29uZmlndXJlZCB3aXRoIHsgXCJwcm9wb3NhbFwiOiBcImhhY2tcIiwgXCJ0b3BpY1Rva2VuXCI6IFwiJHt0b2tlbn1cIiB9LmAsXG4gIFBpcGVUb3BpY1VudXNlZDogXCJIYWNrLXN0eWxlIHBpcGUgYm9keSBkb2VzIG5vdCBjb250YWluIGEgdG9waWMgcmVmZXJlbmNlOyBIYWNrLXN0eWxlIHBpcGVzIG11c3QgdXNlIHRvcGljIGF0IGxlYXN0IG9uY2UuXCIsXG4gIFBpcGVVbnBhcmVudGhlc2l6ZWRCb2R5OiAoe1xuICAgIHR5cGVcbiAgfSkgPT4gYEhhY2stc3R5bGUgcGlwZSBib2R5IGNhbm5vdCBiZSBhbiB1bnBhcmVudGhlc2l6ZWQgJHt0b05vZGVEZXNjcmlwdGlvbih7XG4gICAgdHlwZVxuICB9KX07IHBsZWFzZSB3cmFwIGl0IGluIHBhcmVudGhlc2VzLmBcbn0sIHtcbiAgUGlwZWxpbmVCb2R5Tm9BcnJvdzogJ1VuZXhwZWN0ZWQgYXJyb3cgXCI9PlwiIGFmdGVyIHBpcGVsaW5lIGJvZHk7IGFycm93IGZ1bmN0aW9uIGluIHBpcGVsaW5lIGJvZHkgbXVzdCBiZSBwYXJlbnRoZXNpemVkLicsXG4gIFBpcGVsaW5lQm9keVNlcXVlbmNlRXhwcmVzc2lvbjogXCJQaXBlbGluZSBib2R5IG1heSBub3QgYmUgYSBjb21tYS1zZXBhcmF0ZWQgc2VxdWVuY2UgZXhwcmVzc2lvbi5cIixcbiAgUGlwZWxpbmVIZWFkU2VxdWVuY2VFeHByZXNzaW9uOiBcIlBpcGVsaW5lIGhlYWQgc2hvdWxkIG5vdCBiZSBhIGNvbW1hLXNlcGFyYXRlZCBzZXF1ZW5jZSBleHByZXNzaW9uLlwiLFxuICBQaXBlbGluZVRvcGljVW51c2VkOiBcIlBpcGVsaW5lIGlzIGluIHRvcGljIHN0eWxlIGJ1dCBkb2VzIG5vdCB1c2UgdG9waWMgcmVmZXJlbmNlLlwiLFxuICBQcmltYXJ5VG9waWNOb3RBbGxvd2VkOiBcIlRvcGljIHJlZmVyZW5jZSB3YXMgdXNlZCBpbiBhIGxleGljYWwgY29udGV4dCB3aXRob3V0IHRvcGljIGJpbmRpbmcuXCIsXG4gIFByaW1hcnlUb3BpY1JlcXVpcmVzU21hcnRQaXBlbGluZTogJ1RvcGljIHJlZmVyZW5jZSBpcyB1c2VkLCBidXQgdGhlIHBpcGVsaW5lT3BlcmF0b3IgcGx1Z2luIHdhcyBub3QgcGFzc2VkIGEgXCJwcm9wb3NhbFwiOiBcImhhY2tcIiBvciBcInNtYXJ0XCIgb3B0aW9uLidcbn0pO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wibWVzc2FnZVwiXTtcbmZ1bmN0aW9uIGRlZmluZUhpZGRlbihvYmosIGtleSwgdmFsdWUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuZnVuY3Rpb24gdG9QYXJzZUVycm9yQ29uc3RydWN0b3Ioe1xuICB0b01lc3NhZ2UsXG4gIGNvZGUsXG4gIHJlYXNvbkNvZGUsXG4gIHN5bnRheFBsdWdpblxufSkge1xuICBjb25zdCBoYXNNaXNzaW5nUGx1Z2luID0gcmVhc29uQ29kZSA9PT0gXCJNaXNzaW5nUGx1Z2luXCIgfHwgcmVhc29uQ29kZSA9PT0gXCJNaXNzaW5nT25lT2ZQbHVnaW5zXCI7XG4gIGNvbnN0IG9sZFJlYXNvbkNvZGVzID0ge1xuICAgIEFjY2Vzc29yQ2Fubm90RGVjbGFyZVRoaXNQYXJhbWV0ZXI6IFwiQWNjZXNvckNhbm5vdERlY2xhcmVUaGlzUGFyYW1ldGVyXCIsXG4gICAgQWNjZXNzb3JDYW5ub3RIYXZlVHlwZVBhcmFtZXRlcnM6IFwiQWNjZXNvckNhbm5vdEhhdmVUeXBlUGFyYW1ldGVyc1wiLFxuICAgIENvbnN0SW5pdGlhbGl6ZXJNdXN0QmVTdHJpbmdPck51bWVyaWNMaXRlcmFsT3JMaXRlcmFsRW51bVJlZmVyZW5jZTogXCJDb25zdEluaXRpYWlsaXplck11c3RCZVN0cmluZ09yTnVtZXJpY0xpdGVyYWxPckxpdGVyYWxFbnVtUmVmZXJlbmNlXCIsXG4gICAgU2V0QWNjZXNzb3JDYW5ub3RIYXZlT3B0aW9uYWxQYXJhbWV0ZXI6IFwiU2V0QWNjZXNvckNhbm5vdEhhdmVPcHRpb25hbFBhcmFtZXRlclwiLFxuICAgIFNldEFjY2Vzc29yQ2Fubm90SGF2ZVJlc3RQYXJhbWV0ZXI6IFwiU2V0QWNjZXNvckNhbm5vdEhhdmVSZXN0UGFyYW1ldGVyXCIsXG4gICAgU2V0QWNjZXNzb3JDYW5ub3RIYXZlUmV0dXJuVHlwZTogXCJTZXRBY2Nlc29yQ2Fubm90SGF2ZVJldHVyblR5cGVcIlxuICB9O1xuICBpZiAob2xkUmVhc29uQ29kZXNbcmVhc29uQ29kZV0pIHtcbiAgICByZWFzb25Db2RlID0gb2xkUmVhc29uQ29kZXNbcmVhc29uQ29kZV07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdG9yKGxvYywgZGV0YWlscykge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFN5bnRheEVycm9yKCk7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gICAgZXJyb3IucmVhc29uQ29kZSA9IHJlYXNvbkNvZGU7XG4gICAgZXJyb3IubG9jID0gbG9jO1xuICAgIGVycm9yLnBvcyA9IGxvYy5pbmRleDtcbiAgICBlcnJvci5zeW50YXhQbHVnaW4gPSBzeW50YXhQbHVnaW47XG4gICAgaWYgKGhhc01pc3NpbmdQbHVnaW4pIHtcbiAgICAgIGVycm9yLm1pc3NpbmdQbHVnaW4gPSBkZXRhaWxzLm1pc3NpbmdQbHVnaW47XG4gICAgfVxuICAgIGRlZmluZUhpZGRlbihlcnJvciwgXCJjbG9uZVwiLCBmdW5jdGlvbiBjbG9uZShvdmVycmlkZXMgPSB7fSkge1xuICAgICAgdmFyIF9vdmVycmlkZXMkbG9jO1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lLFxuICAgICAgICBjb2x1bW4sXG4gICAgICAgIGluZGV4XG4gICAgICB9ID0gKF9vdmVycmlkZXMkbG9jID0gb3ZlcnJpZGVzLmxvYykgIT0gbnVsbCA/IF9vdmVycmlkZXMkbG9jIDogbG9jO1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yKG5ldyBQb3NpdGlvbihsaW5lLCBjb2x1bW4sIGluZGV4KSwgT2JqZWN0LmFzc2lnbih7fSwgZGV0YWlscywgb3ZlcnJpZGVzLmRldGFpbHMpKTtcbiAgICB9KTtcbiAgICBkZWZpbmVIaWRkZW4oZXJyb3IsIFwiZGV0YWlsc1wiLCBkZXRhaWxzKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3IsIFwibWVzc2FnZVwiLCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgJHt0b01lc3NhZ2UoZGV0YWlscyl9ICgke2xvYy5saW5lfToke2xvYy5jb2x1bW59KWA7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgfSxcbiAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJtZXNzYWdlXCIsIHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3I7XG4gIH07XG59XG5mdW5jdGlvbiBQYXJzZUVycm9yRW51bShhcmd1bWVudCwgc3ludGF4UGx1Z2luKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50KSkge1xuICAgIHJldHVybiBwYXJzZUVycm9yVGVtcGxhdGVzID0+IFBhcnNlRXJyb3JFbnVtKHBhcnNlRXJyb3JUZW1wbGF0ZXMsIGFyZ3VtZW50WzBdKTtcbiAgfVxuICBjb25zdCBQYXJzZUVycm9yQ29uc3RydWN0b3JzID0ge307XG4gIGZvciAoY29uc3QgcmVhc29uQ29kZSBvZiBPYmplY3Qua2V5cyhhcmd1bWVudCkpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGFyZ3VtZW50W3JlYXNvbkNvZGVdO1xuICAgIGNvbnN0IF9yZWYgPSB0eXBlb2YgdGVtcGxhdGUgPT09IFwic3RyaW5nXCIgPyB7XG4gICAgICAgIG1lc3NhZ2U6ICgpID0+IHRlbXBsYXRlXG4gICAgICB9IDogdHlwZW9mIHRlbXBsYXRlID09PSBcImZ1bmN0aW9uXCIgPyB7XG4gICAgICAgIG1lc3NhZ2U6IHRlbXBsYXRlXG4gICAgICB9IDogdGVtcGxhdGUsXG4gICAgICB7XG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIH0gPSBfcmVmLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIF9leGNsdWRlZCk7XG4gICAgY29uc3QgdG9NZXNzYWdlID0gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyAoKSA9PiBtZXNzYWdlIDogbWVzc2FnZTtcbiAgICBQYXJzZUVycm9yQ29uc3RydWN0b3JzW3JlYXNvbkNvZGVdID0gdG9QYXJzZUVycm9yQ29uc3RydWN0b3IoT2JqZWN0LmFzc2lnbih7XG4gICAgICBjb2RlOiBcIkJBQkVMX1BBUlNFUl9TWU5UQVhfRVJST1JcIixcbiAgICAgIHJlYXNvbkNvZGUsXG4gICAgICB0b01lc3NhZ2VcbiAgICB9LCBzeW50YXhQbHVnaW4gPyB7XG4gICAgICBzeW50YXhQbHVnaW5cbiAgICB9IDoge30sIHJlc3QpKTtcbiAgfVxuICByZXR1cm4gUGFyc2VFcnJvckNvbnN0cnVjdG9ycztcbn1cbmNvbnN0IEVycm9ycyA9IE9iamVjdC5hc3NpZ24oe30sIFBhcnNlRXJyb3JFbnVtKE1vZHVsZUVycm9ycyksIFBhcnNlRXJyb3JFbnVtKFN0YW5kYXJkRXJyb3JzKSwgUGFyc2VFcnJvckVudW0oU3RyaWN0TW9kZUVycm9ycyksIFBhcnNlRXJyb3JFbnVtKFBhcnNlRXhwcmVzc2lvbkVycm9ycyksIFBhcnNlRXJyb3JFbnVtYHBpcGVsaW5lT3BlcmF0b3JgKFBpcGVsaW5lT3BlcmF0b3JFcnJvcnMpKTtcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRPcHRpb25zKCkge1xuICByZXR1cm4ge1xuICAgIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gICAgc291cmNlRmlsZW5hbWU6IHVuZGVmaW5lZCxcbiAgICBzdGFydEluZGV4OiAwLFxuICAgIHN0YXJ0Q29sdW1uOiAwLFxuICAgIHN0YXJ0TGluZTogMSxcbiAgICBhbGxvd0F3YWl0T3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgICBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogZmFsc2UsXG4gICAgYWxsb3dOZXdUYXJnZXRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIGFsbG93SW1wb3J0RXhwb3J0RXZlcnl3aGVyZTogZmFsc2UsXG4gICAgYWxsb3dTdXBlck91dHNpZGVNZXRob2Q6IGZhbHNlLFxuICAgIGFsbG93VW5kZWNsYXJlZEV4cG9ydHM6IGZhbHNlLFxuICAgIGFsbG93WWllbGRPdXRzaWRlRnVuY3Rpb246IGZhbHNlLFxuICAgIHBsdWdpbnM6IFtdLFxuICAgIHN0cmljdE1vZGU6IHVuZGVmaW5lZCxcbiAgICByYW5nZXM6IGZhbHNlLFxuICAgIHRva2VuczogZmFsc2UsXG4gICAgY3JlYXRlSW1wb3J0RXhwcmVzc2lvbnM6IGZhbHNlLFxuICAgIGNyZWF0ZVBhcmVudGhlc2l6ZWRFeHByZXNzaW9uczogZmFsc2UsXG4gICAgZXJyb3JSZWNvdmVyeTogZmFsc2UsXG4gICAgYXR0YWNoQ29tbWVudDogdHJ1ZSxcbiAgICBhbm5leEI6IHRydWVcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9wdGlvbnMob3B0cykge1xuICBjb25zdCBvcHRpb25zID0gY3JlYXRlRGVmYXVsdE9wdGlvbnMoKTtcbiAgaWYgKG9wdHMgPT0gbnVsbCkge1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGlmIChvcHRzLmFubmV4QiAhPSBudWxsICYmIG9wdHMuYW5uZXhCICE9PSBmYWxzZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgYW5uZXhCYCBvcHRpb24gY2FuIG9ubHkgYmUgc2V0IHRvIGBmYWxzZWAuXCIpO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9wdGlvbnMpKSB7XG4gICAgaWYgKG9wdHNba2V5XSAhPSBudWxsKSBvcHRpb25zW2tleV0gPSBvcHRzW2tleV07XG4gIH1cbiAgaWYgKG9wdGlvbnMuc3RhcnRMaW5lID09PSAxKSB7XG4gICAgaWYgKG9wdHMuc3RhcnRJbmRleCA9PSBudWxsICYmIG9wdGlvbnMuc3RhcnRDb2x1bW4gPiAwKSB7XG4gICAgICBvcHRpb25zLnN0YXJ0SW5kZXggPSBvcHRpb25zLnN0YXJ0Q29sdW1uO1xuICAgIH0gZWxzZSBpZiAob3B0cy5zdGFydENvbHVtbiA9PSBudWxsICYmIG9wdGlvbnMuc3RhcnRJbmRleCA+IDApIHtcbiAgICAgIG9wdGlvbnMuc3RhcnRDb2x1bW4gPSBvcHRpb25zLnN0YXJ0SW5kZXg7XG4gICAgfVxuICB9IGVsc2UgaWYgKG9wdHMuc3RhcnRDb2x1bW4gPT0gbnVsbCB8fCBvcHRzLnN0YXJ0SW5kZXggPT0gbnVsbCkge1xuICAgIGlmIChvcHRzLnN0YXJ0SW5kZXggIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2l0aCBhIGBzdGFydExpbmUgPiAxYCB5b3UgbXVzdCBhbHNvIHNwZWNpZnkgYHN0YXJ0SW5kZXhgIGFuZCBgc3RhcnRDb2x1bW5gLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJjb21tb25qc1wiKSB7XG4gICAgaWYgKG9wdHMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYGFsbG93QXdhaXRPdXRzaWRlRnVuY3Rpb25gIG9wdGlvbiBjYW5ub3QgYmUgdXNlZCB3aXRoIGBzb3VyY2VUeXBlOiAnY29tbW9uanMnYC5cIik7XG4gICAgfVxuICAgIGlmIChvcHRzLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImBzb3VyY2VUeXBlOiAnY29tbW9uanMnYCBpbXBsaWVzIGBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbjogdHJ1ZWAsIHBsZWFzZSByZW1vdmUgdGhlIGBhbGxvd1JldHVybk91dHNpZGVGdW5jdGlvbmAgb3B0aW9uIG9yIHVzZSBgc291cmNlVHlwZTogJ3NjcmlwdCdgLlwiKTtcbiAgICB9XG4gICAgaWYgKG9wdHMuYWxsb3dOZXdUYXJnZXRPdXRzaWRlRnVuY3Rpb24gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHNvdXJjZVR5cGU6ICdjb21tb25qcydgIGltcGxpZXMgYGFsbG93TmV3VGFyZ2V0T3V0c2lkZUZ1bmN0aW9uOiB0cnVlYCwgcGxlYXNlIHJlbW92ZSB0aGUgYGFsbG93TmV3VGFyZ2V0T3V0c2lkZUZ1bmN0aW9uYCBvcHRpb24gb3IgdXNlIGBzb3VyY2VUeXBlOiAnc2NyaXB0J2AuXCIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cbmNvbnN0IHtcbiAgZGVmaW5lUHJvcGVydHlcbn0gPSBPYmplY3Q7XG5jb25zdCB0b1VuZW51bWVyYWJsZSA9IChvYmplY3QsIGtleSkgPT4ge1xuICBpZiAob2JqZWN0KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IG9iamVjdFtrZXldXG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiB0b0VTVHJlZUxvY2F0aW9uKG5vZGUpIHtcbiAgdG9VbmVudW1lcmFibGUobm9kZS5sb2Muc3RhcnQsIFwiaW5kZXhcIik7XG4gIHRvVW5lbnVtZXJhYmxlKG5vZGUubG9jLmVuZCwgXCJpbmRleFwiKTtcbiAgcmV0dXJuIG5vZGU7XG59XG52YXIgZXN0cmVlID0gc3VwZXJDbGFzcyA9PiBjbGFzcyBFU1RyZWVQYXJzZXJNaXhpbiBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICBwYXJzZSgpIHtcbiAgICBjb25zdCBmaWxlID0gdG9FU1RyZWVMb2NhdGlvbihzdXBlci5wYXJzZSgpKTtcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDI1Nikge1xuICAgICAgZmlsZS50b2tlbnMgPSBmaWxlLnRva2Vucy5tYXAodG9FU1RyZWVMb2NhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBmaWxlO1xuICB9XG4gIHBhcnNlUmVnRXhwTGl0ZXJhbCh7XG4gICAgcGF0dGVybixcbiAgICBmbGFnc1xuICB9KSB7XG4gICAgbGV0IHJlZ2V4ID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgICB9IGNhdGNoIChfKSB7fVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmVzdHJlZVBhcnNlTGl0ZXJhbChyZWdleCk7XG4gICAgbm9kZS5yZWdleCA9IHtcbiAgICAgIHBhdHRlcm4sXG4gICAgICBmbGFnc1xuICAgIH07XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VCaWdJbnRMaXRlcmFsKHZhbHVlKSB7XG4gICAgbGV0IGJpZ0ludDtcbiAgICB0cnkge1xuICAgICAgYmlnSW50ID0gQmlnSW50KHZhbHVlKTtcbiAgICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgICBiaWdJbnQgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwoYmlnSW50KTtcbiAgICBub2RlLmJpZ2ludCA9IFN0cmluZyhub2RlLnZhbHVlIHx8IHZhbHVlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZURlY2ltYWxMaXRlcmFsKHZhbHVlKSB7XG4gICAgY29uc3QgZGVjaW1hbCA9IG51bGw7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKGRlY2ltYWwpO1xuICAgIG5vZGUuZGVjaW1hbCA9IFN0cmluZyhub2RlLnZhbHVlIHx8IHZhbHVlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBlc3RyZWVQYXJzZUxpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiTGl0ZXJhbFwiKTtcbiAgfVxuICBwYXJzZVN0cmluZ0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwodmFsdWUpO1xuICB9XG4gIHBhcnNlTnVtZXJpY0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwodmFsdWUpO1xuICB9XG4gIHBhcnNlTnVsbExpdGVyYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXN0cmVlUGFyc2VMaXRlcmFsKG51bGwpO1xuICB9XG4gIHBhcnNlQm9vbGVhbkxpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUxpdGVyYWwodmFsdWUpO1xuICB9XG4gIGVzdHJlZVBhcnNlQ2hhaW5FeHByZXNzaW9uKG5vZGUsIGVuZExvYykge1xuICAgIGNvbnN0IGNoYWluID0gdGhpcy5zdGFydE5vZGVBdE5vZGUobm9kZSk7XG4gICAgY2hhaW4uZXhwcmVzc2lvbiA9IG5vZGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KGNoYWluLCBcIkNoYWluRXhwcmVzc2lvblwiLCBlbmRMb2MpO1xuICB9XG4gIGRpcmVjdGl2ZVRvU3RtdChkaXJlY3RpdmUpIHtcbiAgICBjb25zdCBleHByZXNzaW9uID0gZGlyZWN0aXZlLnZhbHVlO1xuICAgIGRlbGV0ZSBkaXJlY3RpdmUudmFsdWU7XG4gICAgdGhpcy5jYXN0Tm9kZVRvKGV4cHJlc3Npb24sIFwiTGl0ZXJhbFwiKTtcbiAgICBleHByZXNzaW9uLnJhdyA9IGV4cHJlc3Npb24uZXh0cmEucmF3O1xuICAgIGV4cHJlc3Npb24udmFsdWUgPSBleHByZXNzaW9uLmV4dHJhLmV4cHJlc3Npb25WYWx1ZTtcbiAgICBjb25zdCBzdG10ID0gdGhpcy5jYXN0Tm9kZVRvKGRpcmVjdGl2ZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpO1xuICAgIHN0bXQuZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgc3RtdC5kaXJlY3RpdmUgPSBleHByZXNzaW9uLmV4dHJhLnJhd1ZhbHVlO1xuICAgIGRlbGV0ZSBleHByZXNzaW9uLmV4dHJhO1xuICAgIHJldHVybiBzdG10O1xuICB9XG4gIGZpbGxPcHRpb25hbFByb3BlcnRpZXNGb3JUU0VTTGludChub2RlKSB7fVxuICBjbG9uZUVzdHJlZVN0cmluZ0xpdGVyYWwobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgbG9jLFxuICAgICAgcmFuZ2UsXG4gICAgICByYXcsXG4gICAgICB2YWx1ZVxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgIGNsb25lZC50eXBlID0gXCJMaXRlcmFsXCI7XG4gICAgY2xvbmVkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgY2xvbmVkLmVuZCA9IGVuZDtcbiAgICBjbG9uZWQubG9jID0gbG9jO1xuICAgIGNsb25lZC5yYW5nZSA9IHJhbmdlO1xuICAgIGNsb25lZC5yYXcgPSByYXc7XG4gICAgY2xvbmVkLnZhbHVlID0gdmFsdWU7XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBpbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYykge1xuICAgIHN1cGVyLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBmYWxzZTtcbiAgfVxuICBjaGVja0RlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZSAhPSBudWxsICYmIHRoaXMuaXNPYmplY3RQcm9wZXJ0eShub2RlKSkge1xuICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKG5vZGUudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5jaGVja0RlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cbiAgfVxuICBnZXRPYmplY3RPckNsYXNzTWV0aG9kUGFyYW1zKG1ldGhvZCkge1xuICAgIHJldHVybiBtZXRob2QudmFsdWUucGFyYW1zO1xuICB9XG4gIGlzVmFsaWREaXJlY3RpdmUoc3RtdCkge1xuICAgIHZhciBfc3RtdCRleHByZXNzaW9uJGV4dHI7XG4gICAgcmV0dXJuIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIHR5cGVvZiBzdG10LmV4cHJlc3Npb24udmFsdWUgPT09IFwic3RyaW5nXCIgJiYgISgoX3N0bXQkZXhwcmVzc2lvbiRleHRyID0gc3RtdC5leHByZXNzaW9uLmV4dHJhKSAhPSBudWxsICYmIF9zdG10JGV4cHJlc3Npb24kZXh0ci5wYXJlbnRoZXNpemVkKTtcbiAgfVxuICBwYXJzZUJsb2NrQm9keShub2RlLCBhbGxvd0RpcmVjdGl2ZXMsIHRvcExldmVsLCBlbmQsIGFmdGVyQmxvY2tQYXJzZSkge1xuICAgIHN1cGVyLnBhcnNlQmxvY2tCb2R5KG5vZGUsIGFsbG93RGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKTtcbiAgICBjb25zdCBkaXJlY3RpdmVTdGF0ZW1lbnRzID0gbm9kZS5kaXJlY3RpdmVzLm1hcChkID0+IHRoaXMuZGlyZWN0aXZlVG9TdG10KGQpKTtcbiAgICBub2RlLmJvZHkgPSBkaXJlY3RpdmVTdGF0ZW1lbnRzLmNvbmNhdChub2RlLmJvZHkpO1xuICAgIGRlbGV0ZSBub2RlLmRpcmVjdGl2ZXM7XG4gIH1cbiAgcGFyc2VQcml2YXRlTmFtZSgpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgIGlmICghdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJlc3RyZWVcIiwgXCJjbGFzc0ZlYXR1cmVzXCIpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udmVydFByaXZhdGVOYW1lVG9Qcml2YXRlSWRlbnRpZmllcihub2RlKTtcbiAgfVxuICBjb252ZXJ0UHJpdmF0ZU5hbWVUb1ByaXZhdGVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBuYW1lID0gc3VwZXIuZ2V0UHJpdmF0ZU5hbWVTVihub2RlKTtcbiAgICBkZWxldGUgbm9kZS5pZDtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIHJldHVybiB0aGlzLmNhc3ROb2RlVG8obm9kZSwgXCJQcml2YXRlSWRlbnRpZmllclwiKTtcbiAgfVxuICBpc1ByaXZhdGVOYW1lKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmlzUHJpdmF0ZU5hbWUobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJpdmF0ZUlkZW50aWZpZXJcIjtcbiAgfVxuICBnZXRQcml2YXRlTmFtZVNWKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZXN0cmVlXCIsIFwiY2xhc3NGZWF0dXJlc1wiKSkge1xuICAgICAgcmV0dXJuIHN1cGVyLmdldFByaXZhdGVOYW1lU1Yobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLm5hbWU7XG4gIH1cbiAgcGFyc2VMaXRlcmFsKHZhbHVlLCB0eXBlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlTGl0ZXJhbCh2YWx1ZSwgdHlwZSk7XG4gICAgbm9kZS5yYXcgPSBub2RlLmV4dHJhLnJhdztcbiAgICBkZWxldGUgbm9kZS5leHRyYTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb24sIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb24sIGlzTWV0aG9kKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBub2RlLmJvZHkudHlwZSAhPT0gXCJCbG9ja1N0YXRlbWVudFwiO1xuICB9XG4gIHBhcnNlTWV0aG9kKG5vZGUsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd0RpcmVjdFN1cGVyLCB0eXBlLCBpbkNsYXNzU2NvcGUgPSBmYWxzZSkge1xuICAgIGxldCBmdW5jTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgZnVuY05vZGUua2luZCA9IG5vZGUua2luZDtcbiAgICBmdW5jTm9kZSA9IHN1cGVyLnBhcnNlTWV0aG9kKGZ1bmNOb2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dEaXJlY3RTdXBlciwgdHlwZSwgaW5DbGFzc1Njb3BlKTtcbiAgICBkZWxldGUgZnVuY05vZGUua2luZDtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlUGFyYW1ldGVyc1xuICAgIH0gPSBub2RlO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykge1xuICAgICAgZGVsZXRlIG5vZGUudHlwZVBhcmFtZXRlcnM7XG4gICAgICBmdW5jTm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShmdW5jTm9kZSwgdHlwZVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZU5vZGUgPSB0aGlzLmNhc3ROb2RlVG8oZnVuY05vZGUsIFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpO1xuICAgIG5vZGUudmFsdWUgPSB2YWx1ZU5vZGU7XG4gICAgaWYgKHR5cGUgPT09IFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIpIHtcbiAgICAgIG5vZGUuY29tcHV0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiT2JqZWN0TWV0aG9kXCIpIHtcbiAgICAgIGlmIChub2RlLmtpbmQgPT09IFwibWV0aG9kXCIpIHtcbiAgICAgICAgbm9kZS5raW5kID0gXCJpbml0XCI7XG4gICAgICB9XG4gICAgICBub2RlLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb3BlcnR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTWV0aG9kRGVmaW5pdGlvblwiKTtcbiAgICB9XG4gIH1cbiAgbmFtZUlzQ29uc3RydWN0b3Ioa2V5KSB7XG4gICAgaWYgKGtleS50eXBlID09PSBcIkxpdGVyYWxcIikgcmV0dXJuIGtleS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiO1xuICAgIHJldHVybiBzdXBlci5uYW1lSXNDb25zdHJ1Y3RvcihrZXkpO1xuICB9XG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eSguLi5hcmdzKSB7XG4gICAgY29uc3QgcHJvcGVydHlOb2RlID0gc3VwZXIucGFyc2VDbGFzc1Byb3BlcnR5KC4uLmFyZ3MpO1xuICAgIGlmICghdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJlc3RyZWVcIiwgXCJjbGFzc0ZlYXR1cmVzXCIpKSB7XG4gICAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xuICAgIH1cbiAgICB0aGlzLmNhc3ROb2RlVG8ocHJvcGVydHlOb2RlLCBcIlByb3BlcnR5RGVmaW5pdGlvblwiKTtcbiAgICByZXR1cm4gcHJvcGVydHlOb2RlO1xuICB9XG4gIHBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkoLi4uYXJncykge1xuICAgIGNvbnN0IHByb3BlcnR5Tm9kZSA9IHN1cGVyLnBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkoLi4uYXJncyk7XG4gICAgaWYgKCF0aGlzLmdldFBsdWdpbk9wdGlvbihcImVzdHJlZVwiLCBcImNsYXNzRmVhdHVyZXNcIikpIHtcbiAgICAgIHJldHVybiBwcm9wZXJ0eU5vZGU7XG4gICAgfVxuICAgIHRoaXMuY2FzdE5vZGVUbyhwcm9wZXJ0eU5vZGUsIFwiUHJvcGVydHlEZWZpbml0aW9uXCIpO1xuICAgIHByb3BlcnR5Tm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuICAgIHJldHVybiBwcm9wZXJ0eU5vZGU7XG4gIH1cbiAgcGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSkge1xuICAgIGNvbnN0IGFjY2Vzc29yUHJvcGVydHlOb2RlID0gc3VwZXIucGFyc2VDbGFzc0FjY2Vzc29yUHJvcGVydHkobm9kZSk7XG4gICAgaWYgKCF0aGlzLmdldFBsdWdpbk9wdGlvbihcImVzdHJlZVwiLCBcImNsYXNzRmVhdHVyZXNcIikpIHtcbiAgICAgIHJldHVybiBhY2Nlc3NvclByb3BlcnR5Tm9kZTtcbiAgICB9XG4gICAgaWYgKGFjY2Vzc29yUHJvcGVydHlOb2RlLmFic3RyYWN0ICYmIHRoaXMuaGFzUGx1Z2luKFwidHlwZXNjcmlwdFwiKSkge1xuICAgICAgZGVsZXRlIGFjY2Vzc29yUHJvcGVydHlOb2RlLmFic3RyYWN0O1xuICAgICAgdGhpcy5jYXN0Tm9kZVRvKGFjY2Vzc29yUHJvcGVydHlOb2RlLCBcIlRTQWJzdHJhY3RBY2Nlc3NvclByb3BlcnR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNhc3ROb2RlVG8oYWNjZXNzb3JQcm9wZXJ0eU5vZGUsIFwiQWNjZXNzb3JQcm9wZXJ0eVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY2Vzc29yUHJvcGVydHlOb2RlO1xuICB9XG4gIHBhcnNlT2JqZWN0UHJvcGVydHkocHJvcCwgc3RhcnRMb2MsIGlzUGF0dGVybiwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZU9iamVjdFByb3BlcnR5KHByb3AsIHN0YXJ0TG9jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlLmtpbmQgPSBcImluaXRcIjtcbiAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIlByb3BlcnR5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBmaW5pc2hPYmplY3RQcm9wZXJ0eShub2RlKSB7XG4gICAgbm9kZS5raW5kID0gXCJpbml0XCI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlByb3BlcnR5XCIpO1xuICB9XG4gIGlzVmFsaWRMVmFsKHR5cGUsIGRpc2FsbG93Q2FsbEV4cHJlc3Npb24sIGlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24sIGJpbmRpbmcpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJQcm9wZXJ0eVwiID8gXCJ2YWx1ZVwiIDogc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiwgaXNVbnBhcmVudGhlc2l6ZWRJbkFzc2lnbiwgYmluZGluZyk7XG4gIH1cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIGlmIChub2RlICE9IG51bGwgJiYgdGhpcy5pc09iamVjdFByb3BlcnR5KG5vZGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0Fzc2lnbmFibGUobm9kZS52YWx1ZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpO1xuICB9XG4gIHRvQXNzaWduYWJsZShub2RlLCBpc0xIUyA9IGZhbHNlKSB7XG4gICAgaWYgKG5vZGUgIT0gbnVsbCAmJiB0aGlzLmlzT2JqZWN0UHJvcGVydHkobm9kZSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IG5vZGU7XG4gICAgICBpZiAodGhpcy5pc1ByaXZhdGVOYW1lKGtleSkpIHtcbiAgICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihrZXkpLCBrZXkubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHZhbHVlLCBpc0xIUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpIHtcbiAgICBpZiAocHJvcC50eXBlID09PSBcIlByb3BlcnR5XCIgJiYgKHByb3Aua2luZCA9PT0gXCJnZXRcIiB8fCBwcm9wLmtpbmQgPT09IFwic2V0XCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QYXR0ZXJuSGFzQWNjZXNzb3IsIHByb3Aua2V5KTtcbiAgICB9IGVsc2UgaWYgKHByb3AudHlwZSA9PT0gXCJQcm9wZXJ0eVwiICYmIHByb3AubWV0aG9kKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QYXR0ZXJuSGFzTWV0aG9kLCBwcm9wLmtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpO1xuICAgIH1cbiAgfVxuICBmaW5pc2hDYWxsRXhwcmVzc2lvbih1bmZpbmlzaGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5maW5pc2hDYWxsRXhwcmVzc2lvbih1bmZpbmlzaGVkLCBvcHRpb25hbCk7XG4gICAgaWYgKG5vZGUuY2FsbGVlLnR5cGUgPT09IFwiSW1wb3J0XCIpIHtcbiAgICAgIHZhciBfcmVmLCBfcmVmMjtcbiAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIkltcG9ydEV4cHJlc3Npb25cIik7XG4gICAgICBub2RlLnNvdXJjZSA9IG5vZGUuYXJndW1lbnRzWzBdO1xuICAgICAgbm9kZS5vcHRpb25zID0gKF9yZWYgPSBub2RlLmFyZ3VtZW50c1sxXSkgIT0gbnVsbCA/IF9yZWYgOiBudWxsO1xuICAgICAgbm9kZS5hdHRyaWJ1dGVzID0gKF9yZWYyID0gbm9kZS5hcmd1bWVudHNbMV0pICE9IG51bGwgPyBfcmVmMiA6IG51bGw7XG4gICAgICBkZWxldGUgbm9kZS5hcmd1bWVudHM7XG4gICAgICBkZWxldGUgbm9kZS5jYWxsZWU7XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiKSB7XG4gICAgICB0aGlzLmNhc3ROb2RlVG8obm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICB0b1JlZmVyZW5jZWRBcmd1bWVudHMobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSW1wb3J0RXhwcmVzc2lvblwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnRvUmVmZXJlbmNlZEFyZ3VtZW50cyhub2RlKTtcbiAgfVxuICBwYXJzZUV4cG9ydCh1bmZpbmlzaGVkLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgZXhwb3J0U3RhcnRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYztcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VFeHBvcnQodW5maW5pc2hlZCwgZGVjb3JhdG9ycyk7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiOlxuICAgICAgICBub2RlLmV4cG9ydGVkID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiOlxuICAgICAgICBpZiAobm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA9PT0gMSAmJiBub2RlLnNwZWNpZmllcnNbMF0udHlwZSA9PT0gXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikge1xuICAgICAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpO1xuICAgICAgICAgIG5vZGUuZXhwb3J0ZWQgPSBub2RlLnNwZWNpZmllcnNbMF0uZXhwb3J0ZWQ7XG4gICAgICAgICAgZGVsZXRlIG5vZGUuc3BlY2lmaWVycztcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9kZWNsYXJhdGlvbiRkZWNvcmF0bztcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvblxuICAgICAgICAgIH0gPSBub2RlO1xuICAgICAgICAgIGlmICgoZGVjbGFyYXRpb24gPT0gbnVsbCA/IHZvaWQgMCA6IGRlY2xhcmF0aW9uLnR5cGUpID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIiAmJiAoKF9kZWNsYXJhdGlvbiRkZWNvcmF0byA9IGRlY2xhcmF0aW9uLmRlY29yYXRvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfZGVjbGFyYXRpb24kZGVjb3JhdG8ubGVuZ3RoKSA+IDAgJiYgZGVjbGFyYXRpb24uc3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uKG5vZGUsIGV4cG9ydFN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHN0b3BQYXJzZVN1YnNjcmlwdChiYXNlLCBzdGF0ZSkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5zdG9wUGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5lc3RyZWVQYXJzZUNoYWluRXhwcmVzc2lvbihub2RlLCBiYXNlLmxvYy5lbmQpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZU1lbWJlcihiYXNlLCBzdGFydExvYywgc3RhdGUsIGNvbXB1dGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSBzdXBlci5wYXJzZU1lbWJlcihiYXNlLCBzdGFydExvYywgc3RhdGUsIGNvbXB1dGVkLCBvcHRpb25hbCk7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIikge1xuICAgICAgdGhpcy5jYXN0Tm9kZVRvKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbihub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDaGFpbkV4cHJlc3Npb25cIikge1xuICAgICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIjtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uKG5vZGUpO1xuICB9XG4gIGhhc1Byb3BlcnR5QXNQcml2YXRlTmFtZShub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJDaGFpbkV4cHJlc3Npb25cIikge1xuICAgICAgbm9kZSA9IG5vZGUuZXhwcmVzc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmhhc1Byb3BlcnR5QXNQcml2YXRlTmFtZShub2RlKTtcbiAgfVxuICBpc09iamVjdFByb3BlcnR5KG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIlByb3BlcnR5XCIgJiYgbm9kZS5raW5kID09PSBcImluaXRcIiAmJiAhbm9kZS5tZXRob2Q7XG4gIH1cbiAgaXNPYmplY3RNZXRob2Qobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiUHJvcGVydHlcIiAmJiAobm9kZS5tZXRob2QgfHwgbm9kZS5raW5kID09PSBcImdldFwiIHx8IG5vZGUua2luZCA9PT0gXCJzZXRcIik7XG4gIH1cbiAgY2FzdE5vZGVUbyhub2RlLCB0eXBlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3VwZXIuY2FzdE5vZGVUbyhub2RlLCB0eXBlKTtcbiAgICB0aGlzLmZpbGxPcHRpb25hbFByb3BlcnRpZXNGb3JUU0VTTGludChyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY2xvbmVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBzdXBlci5jbG9uZUlkZW50aWZpZXIobm9kZSk7XG4gICAgdGhpcy5maWxsT3B0aW9uYWxQcm9wZXJ0aWVzRm9yVFNFU0xpbnQoY2xvbmVkKTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGNsb25lU3RyaW5nTGl0ZXJhbChub2RlKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJMaXRlcmFsXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsb25lRXN0cmVlU3RyaW5nTGl0ZXJhbChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmNsb25lU3RyaW5nTGl0ZXJhbChub2RlKTtcbiAgfVxuICBmaW5pc2hOb2RlQXQobm9kZSwgdHlwZSwgZW5kTG9jKSB7XG4gICAgcmV0dXJuIHRvRVNUcmVlTG9jYXRpb24oc3VwZXIuZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIGVuZExvYykpO1xuICB9XG4gIGZpbmlzaE5vZGUobm9kZSwgdHlwZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gICAgdGhpcy5maWxsT3B0aW9uYWxQcm9wZXJ0aWVzRm9yVFNFU0xpbnQocmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBzdGFydExvYykge1xuICAgIHN1cGVyLnJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBzdGFydExvYyk7XG4gICAgdG9FU1RyZWVMb2NhdGlvbihub2RlKTtcbiAgfVxuICByZXNldEVuZExvY2F0aW9uKG5vZGUsIGVuZExvYyA9IHRoaXMuc3RhdGUubGFzdFRva0VuZExvYykge1xuICAgIHN1cGVyLnJlc2V0RW5kTG9jYXRpb24obm9kZSwgZW5kTG9jKTtcbiAgICB0b0VTVHJlZUxvY2F0aW9uKG5vZGUpO1xuICB9XG59O1xuY2xhc3MgVG9rQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKHRva2VuLCBwcmVzZXJ2ZVNwYWNlKSB7XG4gICAgdGhpcy50b2tlbiA9IHZvaWQgMDtcbiAgICB0aGlzLnByZXNlcnZlU3BhY2UgPSB2b2lkIDA7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIHRoaXMucHJlc2VydmVTcGFjZSA9ICEhcHJlc2VydmVTcGFjZTtcbiAgfVxufVxuY29uc3QgdHlwZXMgPSB7XG4gIGJyYWNlOiBuZXcgVG9rQ29udGV4dChcIntcIiksXG4gIGpfb1RhZzogbmV3IFRva0NvbnRleHQoXCI8dGFnXCIpLFxuICBqX2NUYWc6IG5ldyBUb2tDb250ZXh0KFwiPC90YWdcIiksXG4gIGpfZXhwcjogbmV3IFRva0NvbnRleHQoXCI8dGFnPi4uLjwvdGFnPlwiLCB0cnVlKVxufTtcbnR5cGVzLnRlbXBsYXRlID0gbmV3IFRva0NvbnRleHQoXCJgXCIsIHRydWUpO1xuY29uc3QgYmVmb3JlRXhwciA9IHRydWU7XG5jb25zdCBzdGFydHNFeHByID0gdHJ1ZTtcbmNvbnN0IGlzTG9vcCA9IHRydWU7XG5jb25zdCBpc0Fzc2lnbiA9IHRydWU7XG5jb25zdCBwcmVmaXggPSB0cnVlO1xuY29uc3QgcG9zdGZpeCA9IHRydWU7XG5jbGFzcyBFeHBvcnRlZFRva2VuVHlwZSB7XG4gIGNvbnN0cnVjdG9yKGxhYmVsLCBjb25mID0ge30pIHtcbiAgICB0aGlzLmxhYmVsID0gdm9pZCAwO1xuICAgIHRoaXMua2V5d29yZCA9IHZvaWQgMDtcbiAgICB0aGlzLmJlZm9yZUV4cHIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydHNFeHByID0gdm9pZCAwO1xuICAgIHRoaXMucmlnaHRBc3NvY2lhdGl2ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzTG9vcCA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQXNzaWduID0gdm9pZCAwO1xuICAgIHRoaXMucHJlZml4ID0gdm9pZCAwO1xuICAgIHRoaXMucG9zdGZpeCA9IHZvaWQgMDtcbiAgICB0aGlzLmJpbm9wID0gdm9pZCAwO1xuICAgIHRoaXMubGFiZWwgPSBsYWJlbDtcbiAgICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gICAgdGhpcy5iZWZvcmVFeHByID0gISFjb25mLmJlZm9yZUV4cHI7XG4gICAgdGhpcy5zdGFydHNFeHByID0gISFjb25mLnN0YXJ0c0V4cHI7XG4gICAgdGhpcy5yaWdodEFzc29jaWF0aXZlID0gISFjb25mLnJpZ2h0QXNzb2NpYXRpdmU7XG4gICAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICAgIHRoaXMuaXNBc3NpZ24gPSAhIWNvbmYuaXNBc3NpZ247XG4gICAgdGhpcy5wcmVmaXggPSAhIWNvbmYucHJlZml4O1xuICAgIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICAgIHRoaXMuYmlub3AgPSBjb25mLmJpbm9wICE9IG51bGwgPyBjb25mLmJpbm9wIDogbnVsbDtcbiAgICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xuICB9XG59XG5jb25zdCBrZXl3b3JkcyQxID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gY3JlYXRlS2V5d29yZChuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgY29uc3QgdG9rZW4gPSBjcmVhdGVUb2tlbihuYW1lLCBvcHRpb25zKTtcbiAga2V5d29yZHMkMS5zZXQobmFtZSwgdG9rZW4pO1xuICByZXR1cm4gdG9rZW47XG59XG5mdW5jdGlvbiBjcmVhdGVCaW5vcChuYW1lLCBiaW5vcCkge1xuICByZXR1cm4gY3JlYXRlVG9rZW4obmFtZSwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgYmlub3BcbiAgfSk7XG59XG5sZXQgdG9rZW5UeXBlQ291bnRlciA9IC0xO1xuY29uc3QgdG9rZW5UeXBlcyA9IFtdO1xuY29uc3QgdG9rZW5MYWJlbHMgPSBbXTtcbmNvbnN0IHRva2VuQmlub3BzID0gW107XG5jb25zdCB0b2tlbkJlZm9yZUV4cHJzID0gW107XG5jb25zdCB0b2tlblN0YXJ0c0V4cHJzID0gW107XG5jb25zdCB0b2tlblByZWZpeGVzID0gW107XG5mdW5jdGlvbiBjcmVhdGVUb2tlbihuYW1lLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9vcHRpb25zJGJpbm9wLCBfb3B0aW9ucyRiZWZvcmVFeHByLCBfb3B0aW9ucyRzdGFydHNFeHByLCBfb3B0aW9ucyRwcmVmaXg7XG4gICsrdG9rZW5UeXBlQ291bnRlcjtcbiAgdG9rZW5MYWJlbHMucHVzaChuYW1lKTtcbiAgdG9rZW5CaW5vcHMucHVzaCgoX29wdGlvbnMkYmlub3AgPSBvcHRpb25zLmJpbm9wKSAhPSBudWxsID8gX29wdGlvbnMkYmlub3AgOiAtMSk7XG4gIHRva2VuQmVmb3JlRXhwcnMucHVzaCgoX29wdGlvbnMkYmVmb3JlRXhwciA9IG9wdGlvbnMuYmVmb3JlRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJGJlZm9yZUV4cHIgOiBmYWxzZSk7XG4gIHRva2VuU3RhcnRzRXhwcnMucHVzaCgoX29wdGlvbnMkc3RhcnRzRXhwciA9IG9wdGlvbnMuc3RhcnRzRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJHN0YXJ0c0V4cHIgOiBmYWxzZSk7XG4gIHRva2VuUHJlZml4ZXMucHVzaCgoX29wdGlvbnMkcHJlZml4ID0gb3B0aW9ucy5wcmVmaXgpICE9IG51bGwgPyBfb3B0aW9ucyRwcmVmaXggOiBmYWxzZSk7XG4gIHRva2VuVHlwZXMucHVzaChuZXcgRXhwb3J0ZWRUb2tlblR5cGUobmFtZSwgb3B0aW9ucykpO1xuICByZXR1cm4gdG9rZW5UeXBlQ291bnRlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleXdvcmRMaWtlKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xuICB2YXIgX29wdGlvbnMkYmlub3AyLCBfb3B0aW9ucyRiZWZvcmVFeHByMiwgX29wdGlvbnMkc3RhcnRzRXhwcjIsIF9vcHRpb25zJHByZWZpeDI7XG4gICsrdG9rZW5UeXBlQ291bnRlcjtcbiAga2V5d29yZHMkMS5zZXQobmFtZSwgdG9rZW5UeXBlQ291bnRlcik7XG4gIHRva2VuTGFiZWxzLnB1c2gobmFtZSk7XG4gIHRva2VuQmlub3BzLnB1c2goKF9vcHRpb25zJGJpbm9wMiA9IG9wdGlvbnMuYmlub3ApICE9IG51bGwgPyBfb3B0aW9ucyRiaW5vcDIgOiAtMSk7XG4gIHRva2VuQmVmb3JlRXhwcnMucHVzaCgoX29wdGlvbnMkYmVmb3JlRXhwcjIgPSBvcHRpb25zLmJlZm9yZUV4cHIpICE9IG51bGwgPyBfb3B0aW9ucyRiZWZvcmVFeHByMiA6IGZhbHNlKTtcbiAgdG9rZW5TdGFydHNFeHBycy5wdXNoKChfb3B0aW9ucyRzdGFydHNFeHByMiA9IG9wdGlvbnMuc3RhcnRzRXhwcikgIT0gbnVsbCA/IF9vcHRpb25zJHN0YXJ0c0V4cHIyIDogZmFsc2UpO1xuICB0b2tlblByZWZpeGVzLnB1c2goKF9vcHRpb25zJHByZWZpeDIgPSBvcHRpb25zLnByZWZpeCkgIT0gbnVsbCA/IF9vcHRpb25zJHByZWZpeDIgOiBmYWxzZSk7XG4gIHRva2VuVHlwZXMucHVzaChuZXcgRXhwb3J0ZWRUb2tlblR5cGUoXCJuYW1lXCIsIG9wdGlvbnMpKTtcbiAgcmV0dXJuIHRva2VuVHlwZUNvdW50ZXI7XG59XG5jb25zdCB0dCA9IHtcbiAgYnJhY2tldEw6IGNyZWF0ZVRva2VuKFwiW1wiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFja2V0SGFzaEw6IGNyZWF0ZVRva2VuKFwiI1tcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2tldEJhckw6IGNyZWF0ZVRva2VuKFwiW3xcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYnJhY2tldFI6IGNyZWF0ZVRva2VuKFwiXVwiKSxcbiAgYnJhY2tldEJhclI6IGNyZWF0ZVRva2VuKFwifF1cIiksXG4gIGJyYWNlTDogY3JlYXRlVG9rZW4oXCJ7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNlQmFyTDogY3JlYXRlVG9rZW4oXCJ7fFwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBicmFjZUhhc2hMOiBjcmVhdGVUb2tlbihcIiN7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIGJyYWNlUjogY3JlYXRlVG9rZW4oXCJ9XCIpLFxuICBicmFjZUJhclI6IGNyZWF0ZVRva2VuKFwifH1cIiksXG4gIHBhcmVuTDogY3JlYXRlVG9rZW4oXCIoXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHBhcmVuUjogY3JlYXRlVG9rZW4oXCIpXCIpLFxuICBjb21tYTogY3JlYXRlVG9rZW4oXCIsXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBzZW1pOiBjcmVhdGVUb2tlbihcIjtcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGNvbG9uOiBjcmVhdGVUb2tlbihcIjpcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGRvdWJsZUNvbG9uOiBjcmVhdGVUb2tlbihcIjo6XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBkb3Q6IGNyZWF0ZVRva2VuKFwiLlwiKSxcbiAgcXVlc3Rpb246IGNyZWF0ZVRva2VuKFwiP1wiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgcXVlc3Rpb25Eb3Q6IGNyZWF0ZVRva2VuKFwiPy5cIiksXG4gIGFycm93OiBjcmVhdGVUb2tlbihcIj0+XCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICB0ZW1wbGF0ZTogY3JlYXRlVG9rZW4oXCJ0ZW1wbGF0ZVwiKSxcbiAgZWxsaXBzaXM6IGNyZWF0ZVRva2VuKFwiLi4uXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBiYWNrUXVvdGU6IGNyZWF0ZVRva2VuKFwiYFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZG9sbGFyQnJhY2VMOiBjcmVhdGVUb2tlbihcIiR7XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHRlbXBsYXRlVGFpbDogY3JlYXRlVG9rZW4oXCIuLi5gXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICB0ZW1wbGF0ZU5vblRhaWw6IGNyZWF0ZVRva2VuKFwiLi4uJHtcIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYXQ6IGNyZWF0ZVRva2VuKFwiQFwiKSxcbiAgaGFzaDogY3JlYXRlVG9rZW4oXCIjXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBpbnRlcnByZXRlckRpcmVjdGl2ZTogY3JlYXRlVG9rZW4oXCIjIS4uLlwiKSxcbiAgZXE6IGNyZWF0ZVRva2VuKFwiPVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBpc0Fzc2lnblxuICB9KSxcbiAgYXNzaWduOiBjcmVhdGVUb2tlbihcIl89XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICBzbGFzaEFzc2lnbjogY3JlYXRlVG9rZW4oXCJfPVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBpc0Fzc2lnblxuICB9KSxcbiAgeG9yQXNzaWduOiBjcmVhdGVUb2tlbihcIl89XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGlzQXNzaWduXG4gIH0pLFxuICBtb2R1bG9Bc3NpZ246IGNyZWF0ZVRva2VuKFwiXz1cIiwge1xuICAgIGJlZm9yZUV4cHIsXG4gICAgaXNBc3NpZ25cbiAgfSksXG4gIGluY0RlYzogY3JlYXRlVG9rZW4oXCIrKy8tLVwiLCB7XG4gICAgcHJlZml4LFxuICAgIHBvc3RmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYmFuZzogY3JlYXRlVG9rZW4oXCIhXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICB0aWxkZTogY3JlYXRlVG9rZW4oXCJ+XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBkb3VibGVDYXJldDogY3JlYXRlVG9rZW4oXCJeXlwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZG91YmxlQXQ6IGNyZWF0ZVRva2VuKFwiQEBcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIHBpcGVsaW5lOiBjcmVhdGVCaW5vcChcInw+XCIsIDApLFxuICBudWxsaXNoQ29hbGVzY2luZzogY3JlYXRlQmlub3AoXCI/P1wiLCAxKSxcbiAgbG9naWNhbE9SOiBjcmVhdGVCaW5vcChcInx8XCIsIDEpLFxuICBsb2dpY2FsQU5EOiBjcmVhdGVCaW5vcChcIiYmXCIsIDIpLFxuICBiaXR3aXNlT1I6IGNyZWF0ZUJpbm9wKFwifFwiLCAzKSxcbiAgYml0d2lzZVhPUjogY3JlYXRlQmlub3AoXCJeXCIsIDQpLFxuICBiaXR3aXNlQU5EOiBjcmVhdGVCaW5vcChcIiZcIiwgNSksXG4gIGVxdWFsaXR5OiBjcmVhdGVCaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gIGx0OiBjcmVhdGVCaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgZ3Q6IGNyZWF0ZUJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICByZWxhdGlvbmFsOiBjcmVhdGVCaW5vcChcIjwvPi88PS8+PVwiLCA3KSxcbiAgYml0U2hpZnQ6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBiaXRTaGlmdEw6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBiaXRTaGlmdFI6IGNyZWF0ZUJpbm9wKFwiPDwvPj4vPj4+XCIsIDgpLFxuICBwbHVzTWluOiBjcmVhdGVUb2tlbihcIisvLVwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogOSxcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbW9kdWxvOiBjcmVhdGVUb2tlbihcIiVcIiwge1xuICAgIGJpbm9wOiAxMCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBzdGFyOiBjcmVhdGVUb2tlbihcIipcIiwge1xuICAgIGJpbm9wOiAxMFxuICB9KSxcbiAgc2xhc2g6IGNyZWF0ZUJpbm9wKFwiL1wiLCAxMCksXG4gIGV4cG9uZW50OiBjcmVhdGVUb2tlbihcIioqXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGJpbm9wOiAxMSxcbiAgICByaWdodEFzc29jaWF0aXZlOiB0cnVlXG4gIH0pLFxuICBfaW46IGNyZWF0ZUtleXdvcmQoXCJpblwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBiaW5vcDogN1xuICB9KSxcbiAgX2luc3RhbmNlb2Y6IGNyZWF0ZUtleXdvcmQoXCJpbnN0YW5jZW9mXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIGJpbm9wOiA3XG4gIH0pLFxuICBfYnJlYWs6IGNyZWF0ZUtleXdvcmQoXCJicmVha1wiKSxcbiAgX2Nhc2U6IGNyZWF0ZUtleXdvcmQoXCJjYXNlXCIsIHtcbiAgICBiZWZvcmVFeHByXG4gIH0pLFxuICBfY2F0Y2g6IGNyZWF0ZUtleXdvcmQoXCJjYXRjaFwiKSxcbiAgX2NvbnRpbnVlOiBjcmVhdGVLZXl3b3JkKFwiY29udGludWVcIiksXG4gIF9kZWJ1Z2dlcjogY3JlYXRlS2V5d29yZChcImRlYnVnZ2VyXCIpLFxuICBfZGVmYXVsdDogY3JlYXRlS2V5d29yZChcImRlZmF1bHRcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9lbHNlOiBjcmVhdGVLZXl3b3JkKFwiZWxzZVwiLCB7XG4gICAgYmVmb3JlRXhwclxuICB9KSxcbiAgX2ZpbmFsbHk6IGNyZWF0ZUtleXdvcmQoXCJmaW5hbGx5XCIpLFxuICBfZnVuY3Rpb246IGNyZWF0ZUtleXdvcmQoXCJmdW5jdGlvblwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2lmOiBjcmVhdGVLZXl3b3JkKFwiaWZcIiksXG4gIF9yZXR1cm46IGNyZWF0ZUtleXdvcmQoXCJyZXR1cm5cIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9zd2l0Y2g6IGNyZWF0ZUtleXdvcmQoXCJzd2l0Y2hcIiksXG4gIF90aHJvdzogY3JlYXRlS2V5d29yZChcInRocm93XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHJ5OiBjcmVhdGVLZXl3b3JkKFwidHJ5XCIpLFxuICBfdmFyOiBjcmVhdGVLZXl3b3JkKFwidmFyXCIpLFxuICBfY29uc3Q6IGNyZWF0ZUtleXdvcmQoXCJjb25zdFwiKSxcbiAgX3dpdGg6IGNyZWF0ZUtleXdvcmQoXCJ3aXRoXCIpLFxuICBfbmV3OiBjcmVhdGVLZXl3b3JkKFwibmV3XCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF90aGlzOiBjcmVhdGVLZXl3b3JkKFwidGhpc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3N1cGVyOiBjcmVhdGVLZXl3b3JkKFwic3VwZXJcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9jbGFzczogY3JlYXRlS2V5d29yZChcImNsYXNzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZXh0ZW5kczogY3JlYXRlS2V5d29yZChcImV4dGVuZHNcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9leHBvcnQ6IGNyZWF0ZUtleXdvcmQoXCJleHBvcnRcIiksXG4gIF9pbXBvcnQ6IGNyZWF0ZUtleXdvcmQoXCJpbXBvcnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9udWxsOiBjcmVhdGVLZXl3b3JkKFwibnVsbFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3RydWU6IGNyZWF0ZUtleXdvcmQoXCJ0cnVlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZmFsc2U6IGNyZWF0ZUtleXdvcmQoXCJmYWxzZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3R5cGVvZjogY3JlYXRlS2V5d29yZChcInR5cGVvZlwiLCB7XG4gICAgYmVmb3JlRXhwcixcbiAgICBwcmVmaXgsXG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3ZvaWQ6IGNyZWF0ZUtleXdvcmQoXCJ2b2lkXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZGVsZXRlOiBjcmVhdGVLZXl3b3JkKFwiZGVsZXRlXCIsIHtcbiAgICBiZWZvcmVFeHByLFxuICAgIHByZWZpeCxcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZG86IGNyZWF0ZUtleXdvcmQoXCJkb1wiLCB7XG4gICAgaXNMb29wLFxuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIF9mb3I6IGNyZWF0ZUtleXdvcmQoXCJmb3JcIiwge1xuICAgIGlzTG9vcFxuICB9KSxcbiAgX3doaWxlOiBjcmVhdGVLZXl3b3JkKFwid2hpbGVcIiwge1xuICAgIGlzTG9vcFxuICB9KSxcbiAgX2FzOiBjcmVhdGVLZXl3b3JkTGlrZShcImFzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXNzZXJ0OiBjcmVhdGVLZXl3b3JkTGlrZShcImFzc2VydFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2FzeW5jOiBjcmVhdGVLZXl3b3JkTGlrZShcImFzeW5jXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXdhaXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwiYXdhaXRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9kZWZlcjogY3JlYXRlS2V5d29yZExpa2UoXCJkZWZlclwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2Zyb206IGNyZWF0ZUtleXdvcmRMaWtlKFwiZnJvbVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2dldDogY3JlYXRlS2V5d29yZExpa2UoXCJnZXRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9sZXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwibGV0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfbWV0YTogY3JlYXRlS2V5d29yZExpa2UoXCJtZXRhXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfb2Y6IGNyZWF0ZUtleXdvcmRMaWtlKFwib2ZcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9zZW50OiBjcmVhdGVLZXl3b3JkTGlrZShcInNlbnRcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9zZXQ6IGNyZWF0ZUtleXdvcmRMaWtlKFwic2V0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfc291cmNlOiBjcmVhdGVLZXl3b3JkTGlrZShcInNvdXJjZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3N0YXRpYzogY3JlYXRlS2V5d29yZExpa2UoXCJzdGF0aWNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF91c2luZzogY3JlYXRlS2V5d29yZExpa2UoXCJ1c2luZ1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3lpZWxkOiBjcmVhdGVLZXl3b3JkTGlrZShcInlpZWxkXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfYXNzZXJ0czogY3JlYXRlS2V5d29yZExpa2UoXCJhc3NlcnRzXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfY2hlY2tzOiBjcmVhdGVLZXl3b3JkTGlrZShcImNoZWNrc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2V4cG9ydHM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiZXhwb3J0c1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2dsb2JhbDogY3JlYXRlS2V5d29yZExpa2UoXCJnbG9iYWxcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbXBsZW1lbnRzOiBjcmVhdGVLZXl3b3JkTGlrZShcImltcGxlbWVudHNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbnRyaW5zaWM6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW50cmluc2ljXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfaW5mZXI6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW5mZXJcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pczogY3JlYXRlS2V5d29yZExpa2UoXCJpc1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX21peGluczogY3JlYXRlS2V5d29yZExpa2UoXCJtaXhpbnNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9wcm90bzogY3JlYXRlS2V5d29yZExpa2UoXCJwcm90b1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3JlcXVpcmU6IGNyZWF0ZUtleXdvcmRMaWtlKFwicmVxdWlyZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3NhdGlzZmllczogY3JlYXRlS2V5d29yZExpa2UoXCJzYXRpc2ZpZXNcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9rZXlvZjogY3JlYXRlS2V5d29yZExpa2UoXCJrZXlvZlwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX3JlYWRvbmx5OiBjcmVhdGVLZXl3b3JkTGlrZShcInJlYWRvbmx5XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdW5pcXVlOiBjcmVhdGVLZXl3b3JkTGlrZShcInVuaXF1ZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX2Fic3RyYWN0OiBjcmVhdGVLZXl3b3JkTGlrZShcImFic3RyYWN0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZGVjbGFyZTogY3JlYXRlS2V5d29yZExpa2UoXCJkZWNsYXJlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfZW51bTogY3JlYXRlS2V5d29yZExpa2UoXCJlbnVtXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfbW9kdWxlOiBjcmVhdGVLZXl3b3JkTGlrZShcIm1vZHVsZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgX25hbWVzcGFjZTogY3JlYXRlS2V5d29yZExpa2UoXCJuYW1lc3BhY2VcIiwge1xuICAgIHN0YXJ0c0V4cHJcbiAgfSksXG4gIF9pbnRlcmZhY2U6IGNyZWF0ZUtleXdvcmRMaWtlKFwiaW50ZXJmYWNlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfdHlwZTogY3JlYXRlS2V5d29yZExpa2UoXCJ0eXBlXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBfb3BhcXVlOiBjcmVhdGVLZXl3b3JkTGlrZShcIm9wYXF1ZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbmFtZTogY3JlYXRlVG9rZW4oXCJuYW1lXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBwbGFjZWhvbGRlcjogY3JlYXRlVG9rZW4oXCIlJVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgc3RyaW5nOiBjcmVhdGVUb2tlbihcInN0cmluZ1wiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgbnVtOiBjcmVhdGVUb2tlbihcIm51bVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgYmlnaW50OiBjcmVhdGVUb2tlbihcImJpZ2ludFwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZGVjaW1hbDogY3JlYXRlVG9rZW4oXCJkZWNpbWFsXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICByZWdleHA6IGNyZWF0ZVRva2VuKFwicmVnZXhwXCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBwcml2YXRlTmFtZTogY3JlYXRlVG9rZW4oXCIjbmFtZVwiLCB7XG4gICAgc3RhcnRzRXhwclxuICB9KSxcbiAgZW9mOiBjcmVhdGVUb2tlbihcImVvZlwiKSxcbiAganN4TmFtZTogY3JlYXRlVG9rZW4oXCJqc3hOYW1lXCIpLFxuICBqc3hUZXh0OiBjcmVhdGVUb2tlbihcImpzeFRleHRcIiwge1xuICAgIGJlZm9yZUV4cHJcbiAgfSksXG4gIGpzeFRhZ1N0YXJ0OiBjcmVhdGVUb2tlbihcImpzeFRhZ1N0YXJ0XCIsIHtcbiAgICBzdGFydHNFeHByXG4gIH0pLFxuICBqc3hUYWdFbmQ6IGNyZWF0ZVRva2VuKFwianN4VGFnRW5kXCIpXG59O1xuZnVuY3Rpb24gdG9rZW5Jc0lkZW50aWZpZXIodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDkzICYmIHRva2VuIDw9IDEzMztcbn1cbmZ1bmN0aW9uIHRva2VuS2V5d29yZE9ySWRlbnRpZmllcklzS2V5d29yZCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gNTggJiYgdG9rZW4gPD0gMTMzO1xufVxuZnVuY3Rpb24gdG9rZW5Jc0xpdGVyYWxQcm9wZXJ0eU5hbWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDU4ICYmIHRva2VuIDw9IDEzNztcbn1cbmZ1bmN0aW9uIHRva2VuQ29tZXNCZWZvcmVFeHByZXNzaW9uKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbkJlZm9yZUV4cHJzW3Rva2VuXTtcbn1cbmZ1bmN0aW9uIHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblN0YXJ0c0V4cHJzW3Rva2VuXTtcbn1cbmZ1bmN0aW9uIHRva2VuSXNBc3NpZ25tZW50KHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSAyOSAmJiB0b2tlbiA8PSAzMztcbn1cbmZ1bmN0aW9uIHRva2VuSXNGbG93SW50ZXJmYWNlT3JUeXBlT3JPcGFxdWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDEyOSAmJiB0b2tlbiA8PSAxMzE7XG59XG5mdW5jdGlvbiB0b2tlbklzTG9vcCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gOTAgJiYgdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzS2V5d29yZCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gNTggJiYgdG9rZW4gPD0gOTI7XG59XG5mdW5jdGlvbiB0b2tlbklzT3BlcmF0b3IodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID49IDM5ICYmIHRva2VuIDw9IDU5O1xufVxuZnVuY3Rpb24gdG9rZW5Jc1Bvc3RmaXgodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID09PSAzNDtcbn1cbmZ1bmN0aW9uIHRva2VuSXNQcmVmaXgodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuUHJlZml4ZXNbdG9rZW5dO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1RTVHlwZU9wZXJhdG9yKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbiA+PSAxMjEgJiYgdG9rZW4gPD0gMTIzO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1RTRGVjbGFyYXRpb25TdGFydCh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gMTI0ICYmIHRva2VuIDw9IDEzMDtcbn1cbmZ1bmN0aW9uIHRva2VuTGFiZWxOYW1lKHRva2VuKSB7XG4gIHJldHVybiB0b2tlbkxhYmVsc1t0b2tlbl07XG59XG5mdW5jdGlvbiB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW5CaW5vcHNbdG9rZW5dO1xufVxuZnVuY3Rpb24gdG9rZW5Jc1JpZ2h0QXNzb2NpYXRpdmUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuID09PSA1Nztcbn1cbmZ1bmN0aW9uIHRva2VuSXNUZW1wbGF0ZSh0b2tlbikge1xuICByZXR1cm4gdG9rZW4gPj0gMjQgJiYgdG9rZW4gPD0gMjU7XG59XG5mdW5jdGlvbiBnZXRFeHBvcnRlZFRva2VuKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblR5cGVzW3Rva2VuXTtcbn1cbnRva2VuVHlwZXNbOF0udXBkYXRlQ29udGV4dCA9IGNvbnRleHQgPT4ge1xuICBjb250ZXh0LnBvcCgpO1xufTtcbnRva2VuVHlwZXNbNV0udXBkYXRlQ29udGV4dCA9IHRva2VuVHlwZXNbN10udXBkYXRlQ29udGV4dCA9IHRva2VuVHlwZXNbMjNdLnVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgY29udGV4dC5wdXNoKHR5cGVzLmJyYWNlKTtcbn07XG50b2tlblR5cGVzWzIyXS51cGRhdGVDb250ZXh0ID0gY29udGV4dCA9PiB7XG4gIGlmIChjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV0gPT09IHR5cGVzLnRlbXBsYXRlKSB7XG4gICAgY29udGV4dC5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LnB1c2godHlwZXMudGVtcGxhdGUpO1xuICB9XG59O1xudG9rZW5UeXBlc1sxNDNdLnVwZGF0ZUNvbnRleHQgPSBjb250ZXh0ID0+IHtcbiAgY29udGV4dC5wdXNoKHR5cGVzLmpfZXhwciwgdHlwZXMual9vVGFnKTtcbn07XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IFwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM3ZlxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTJmXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjAtXFx1MDU4OFxcdTA1ZDAtXFx1MDVlYVxcdTA1ZWYtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwODYwLVxcdTA4NmFcXHUwODcwLVxcdTA4ODdcXHUwODg5LVxcdTA4OGZcXHUwOGEwLVxcdTA4YzlcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTA5ZmNcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYWY5XFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzlcXHUwYzNkXFx1MGM1OC1cXHUwYzVhXFx1MGM1Y1xcdTBjNWRcXHUwYzYwXFx1MGM2MVxcdTBjODBcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkYy1cXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDQtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4Ni1cXHUwZThhXFx1MGU4Yy1cXHUwZWEzXFx1MGVhNVxcdTBlYTctXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y1XFx1MTNmOC1cXHUxM2ZkXFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmY4XFx1MTcwMC1cXHUxNzExXFx1MTcxZi1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzhcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFlXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTliMC1cXHUxOWM5XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0Y1xcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWM4MC1cXHUxYzhhXFx1MWM5MC1cXHUxY2JhXFx1MWNiZC1cXHUxY2JmXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YzXFx1MWNmNVxcdTFjZjZcXHUxY2ZhXFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJmXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJmXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGJmXFx1NGUwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3ZGNcXHVhN2YxLVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE4ZmVcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YTllMC1cXHVhOWU0XFx1YTllNi1cXHVhOWVmXFx1YTlmYS1cXHVhOWZlXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhN2UtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWIzMC1cXHVhYjVhXFx1YWI1Yy1cXHVhYjY5XFx1YWI3MC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCI7XG5sZXQgbm9uQVNDSUlpZGVudGlmaWVyQ2hhcnMgPSBcIlxceGI3XFx1MDMwMC1cXHUwMzZmXFx1MDM4N1xcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2NGItXFx1MDY2OVxcdTA2NzBcXHUwNmQ2LVxcdTA2ZGNcXHUwNmRmLVxcdTA2ZTRcXHUwNmU3XFx1MDZlOFxcdTA2ZWEtXFx1MDZlZFxcdTA2ZjAtXFx1MDZmOVxcdTA3MTFcXHUwNzMwLVxcdTA3NGFcXHUwN2E2LVxcdTA3YjBcXHUwN2MwLVxcdTA3YzlcXHUwN2ViLVxcdTA3ZjNcXHUwN2ZkXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDg5Ny1cXHUwODlmXFx1MDhjYS1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwOWZlXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMlxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYWZhLVxcdTBhZmZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU1LVxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMC1cXHUwYzA0XFx1MGMzY1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBjZjNcXHUwZDAwLVxcdTBkMDNcXHUwZDNiXFx1MGQzY1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODEtXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRlNi1cXHUwZGVmXFx1MGRmMlxcdTBkZjNcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGU1MC1cXHUwZTU5XFx1MGViMVxcdTBlYjQtXFx1MGViY1xcdTBlYzgtXFx1MGVjZVxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGYzZVxcdTBmM2ZcXHUwZjcxLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJiLVxcdTEwM2VcXHUxMDQwLVxcdTEwNDlcXHUxMDU2LVxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDYyLVxcdTEwNjRcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxMzY5LVxcdTEzNzFcXHUxNzEyLVxcdTE3MTVcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNC1cXHUxN2QzXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MGYtXFx1MTgxOVxcdTE4YTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTQ2LVxcdTE5NGZcXHUxOWQwLVxcdTE5ZGFcXHUxYTE3LVxcdTFhMWJcXHUxYTU1LVxcdTFhNWVcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYWIwLVxcdTFhYmRcXHUxYWJmLVxcdTFhZGRcXHUxYWUwLVxcdTFhZWJcXHUxYjAwLVxcdTFiMDRcXHUxYjM0LVxcdTFiNDRcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYjgwLVxcdTFiODJcXHUxYmExLVxcdTFiYWRcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzI0LVxcdTFjMzdcXHUxYzQwLVxcdTFjNDlcXHUxYzUwLVxcdTFjNTlcXHUxY2QwLVxcdTFjZDJcXHUxY2Q0LVxcdTFjZThcXHUxY2VkXFx1MWNmNFxcdTFjZjctXFx1MWNmOVxcdTFkYzAtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdTMwZmJcXHVhNjIwLVxcdWE2MjlcXHVhNjZmXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZVxcdWE2OWZcXHVhNmYwXFx1YTZmMVxcdWE4MDJcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4MmNcXHVhODgwXFx1YTg4MVxcdWE4YjQtXFx1YThjNVxcdWE4ZDAtXFx1YThkOVxcdWE4ZTAtXFx1YThmMVxcdWE4ZmYtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5NDctXFx1YTk1M1xcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWE5ZDAtXFx1YTlkOVxcdWE5ZTVcXHVhOWYwLVxcdWE5ZjlcXHVhYTI5LVxcdWFhMzZcXHVhYTQzXFx1YWE0Y1xcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiLVxcdWFhN2RcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYWViLVxcdWFhZWZcXHVhYWY1XFx1YWFmNlxcdWFiZTMtXFx1YWJlYVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIxZVxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyZlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlxcdWZmNjVcIjtcbmNvbnN0IG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG5jb25zdCBub25BU0NJSWlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKFwiW1wiICsgbm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyArIG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzICsgXCJdXCIpO1xubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcbmNvbnN0IGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzID0gWzAsIDExLCAyLCAyNSwgMiwgMTgsIDIsIDEsIDIsIDE0LCAzLCAxMywgMzUsIDEyMiwgNzAsIDUyLCAyNjgsIDI4LCA0LCA0OCwgNDgsIDMxLCAxNCwgMjksIDYsIDM3LCAxMSwgMjksIDMsIDM1LCA1LCA3LCAyLCA0LCA0MywgMTU3LCAxOSwgMzUsIDUsIDM1LCA1LCAzOSwgOSwgNTEsIDEzLCAxMCwgMiwgMTQsIDIsIDYsIDIsIDEsIDIsIDEwLCAyLCAxNCwgMiwgNiwgMiwgMSwgNCwgNTEsIDEzLCAzMTAsIDEwLCAyMSwgMTEsIDcsIDI1LCA1LCAyLCA0MSwgMiwgOCwgNzAsIDUsIDMsIDAsIDIsIDQzLCAyLCAxLCA0LCAwLCAzLCAyMiwgMTEsIDIyLCAxMCwgMzAsIDY2LCAxOCwgMiwgMSwgMTEsIDIxLCAxMSwgMjUsIDcsIDI1LCAzOSwgNTUsIDcsIDEsIDY1LCAwLCAxNiwgMywgMiwgMiwgMiwgMjgsIDQzLCAyOCwgNCwgMjgsIDM2LCA3LCAyLCAyNywgMjgsIDUzLCAxMSwgMjEsIDExLCAxOCwgMTQsIDE3LCAxMTEsIDcyLCA1NiwgNTAsIDE0LCA1MCwgMTQsIDM1LCAzOSwgMjcsIDEwLCAyMiwgMjUxLCA0MSwgNywgMSwgMTcsIDUsIDU3LCAyOCwgMTEsIDAsIDksIDIxLCA0MywgMTcsIDQ3LCAyMCwgMjgsIDIyLCAxMywgNTIsIDU4LCAxLCAzLCAwLCAxNCwgNDQsIDMzLCAyNCwgMjcsIDM1LCAzMCwgMCwgMywgMCwgOSwgMzQsIDQsIDAsIDEzLCA0NywgMTUsIDMsIDIyLCAwLCAyLCAwLCAzNiwgMTcsIDIsIDI0LCAyMCwgMSwgNjQsIDYsIDIsIDAsIDIsIDMsIDIsIDE0LCAyLCA5LCA4LCA0NiwgMzksIDcsIDMsIDEsIDMsIDIxLCAyLCA2LCAyLCAxLCAyLCA0LCA0LCAwLCAxOSwgMCwgMTMsIDQsIDMxLCA5LCAyLCAwLCAzLCAwLCAyLCAzNywgMiwgMCwgMjYsIDAsIDIsIDAsIDQ1LCA1MiwgMTksIDMsIDIxLCAyLCAzMSwgNDcsIDIxLCAxLCAyLCAwLCAxODUsIDQ2LCA0MiwgMywgMzcsIDQ3LCAyMSwgMCwgNjAsIDQyLCAxNCwgMCwgNzIsIDI2LCAzOCwgNiwgMTg2LCA0MywgMTE3LCA2MywgMzIsIDcsIDMsIDAsIDMsIDcsIDIsIDEsIDIsIDIzLCAxNiwgMCwgMiwgMCwgOTUsIDcsIDMsIDM4LCAxNywgMCwgMiwgMCwgMjksIDAsIDExLCAzOSwgOCwgMCwgMjIsIDAsIDEyLCA0NSwgMjAsIDAsIDE5LCA3MiwgMjAwLCAzMiwgMzIsIDgsIDIsIDM2LCAxOCwgMCwgNTAsIDI5LCAxMTMsIDYsIDIsIDEsIDIsIDM3LCAyMiwgMCwgMjYsIDUsIDIsIDEsIDIsIDMxLCAxNSwgMCwgMjQsIDQzLCAyNjEsIDE4LCAxNiwgMCwgMiwgMTIsIDIsIDMzLCAxMjUsIDAsIDgwLCA5MjEsIDEwMywgMTEwLCAxOCwgMTk1LCAyNjM3LCA5NiwgMTYsIDEwNzEsIDE4LCA1LCAyNiwgMzk5NCwgNiwgNTgyLCA2ODQyLCAyOSwgMTc2MywgNTY4LCA4LCAzMCwgMTgsIDc4LCAxOCwgMjksIDE5LCA0NywgMTcsIDMsIDMyLCAyMCwgNiwgMTgsIDQzMywgNDQsIDIxMiwgNjMsIDMzLCAyNCwgMywgMjQsIDQ1LCA3NCwgNiwgMCwgNjcsIDEyLCA2NSwgMSwgMiwgMCwgMTUsIDQsIDEwLCA3MzgxLCA0MiwgMzEsIDk4LCAxMTQsIDg3MDIsIDMsIDIsIDYsIDIsIDEsIDIsIDI5MCwgMTYsIDAsIDMwLCAyLCAzLCAwLCAxNSwgMywgOSwgMzk1LCAyMzA5LCAxMDYsIDYsIDEyLCA0LCA4LCA4LCA5LCA1OTkxLCA4NCwgMiwgNzAsIDIsIDEsIDMsIDAsIDMsIDEsIDMsIDMsIDIsIDExLCAyLCAwLCAyLCA2LCAyLCA2NCwgMiwgMywgMywgNywgMiwgNiwgMiwgMjcsIDIsIDMsIDIsIDQsIDIsIDAsIDQsIDYsIDIsIDMzOSwgMywgMjQsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDMwLCAyLCAyNCwgMiwgMzAsIDIsIDI0LCAyLCAzMCwgMiwgMjQsIDIsIDcsIDE4NDUsIDMwLCA3LCA1LCAyNjIsIDYxLCAxNDcsIDQ0LCAxMSwgNiwgMTcsIDAsIDMyMiwgMjksIDE5LCA0MywgNDg1LCAyNywgMjI5LCAyOSwgMywgMCwgMjA4LCAzMCwgMiwgMiwgMiwgMSwgMiwgNiwgMywgNCwgMTAsIDEsIDIyNSwgNiwgMiwgMywgMiwgMSwgMiwgMTQsIDIsIDE5NiwgNjAsIDY3LCA4LCAwLCAxMjA1LCAzLCAyLCAyNiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgOSwgMiwgMywgMiwgMCwgMiwgMCwgNywgMCwgNSwgMCwgMiwgMCwgMiwgMCwgMiwgMiwgMiwgMSwgMiwgMCwgMywgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMCwgMiwgMSwgMiwgMCwgMywgMywgMiwgNiwgMiwgMywgMiwgMywgMiwgMCwgMiwgOSwgMiwgMTYsIDYsIDIsIDIsIDQsIDIsIDE2LCA0NDIxLCA0MjcxOSwgMzMsIDQzODEsIDMsIDU3NzMsIDMsIDc0NzIsIDE2LCA2MjEsIDI0NjcsIDU0MSwgMTUwNywgNDkzOCwgNiwgODQ4OV07XG5jb25zdCBhc3RyYWxJZGVudGlmaWVyQ29kZXMgPSBbNTA5LCAwLCAyMjcsIDAsIDE1MCwgNCwgMjk0LCA5LCAxMzY4LCAyLCAyLCAxLCA2LCAzLCA0MSwgMiwgNSwgMCwgMTY2LCAxLCA1NzQsIDMsIDksIDksIDcsIDksIDMyLCA0LCAzMTgsIDEsIDc4LCA1LCA3MSwgMTAsIDUwLCAzLCAxMjMsIDIsIDU0LCAxNCwgMzIsIDEwLCAzLCAxLCAxMSwgMywgNDYsIDEwLCA4LCAwLCA0NiwgOSwgNywgMiwgMzcsIDEzLCAyLCA5LCA2LCAxLCA0NSwgMCwgMTMsIDIsIDQ5LCAxMywgOSwgMywgMiwgMTEsIDgzLCAxMSwgNywgMCwgMywgMCwgMTU4LCAxMSwgNiwgOSwgNywgMywgNTYsIDEsIDIsIDYsIDMsIDEsIDMsIDIsIDEwLCAwLCAxMSwgMSwgMywgNiwgNCwgNCwgNjgsIDgsIDIsIDAsIDMsIDAsIDIsIDMsIDIsIDQsIDIsIDAsIDE1LCAxLCA4MywgMTcsIDEwLCA5LCA1LCAwLCA4MiwgMTksIDEzLCA5LCAyMTQsIDYsIDMsIDgsIDI4LCAxLCA4MywgMTYsIDE2LCA5LCA4MiwgMTIsIDksIDksIDcsIDE5LCA1OCwgMTQsIDUsIDksIDI0MywgMTQsIDE2NiwgOSwgNzEsIDUsIDIsIDEsIDMsIDMsIDIsIDAsIDIsIDEsIDEzLCA5LCAxMjAsIDYsIDMsIDYsIDQsIDAsIDI5LCA5LCA0MSwgNiwgMiwgMywgOSwgMCwgMTAsIDEwLCA0NywgMTUsIDE5OSwgNywgMTM3LCA5LCA1NCwgNywgMiwgNywgMTcsIDksIDU3LCAyMSwgMiwgMTMsIDEyMywgNSwgNCwgMCwgMiwgMSwgMiwgNiwgMiwgMCwgOSwgOSwgNDksIDQsIDIsIDEsIDIsIDQsIDksIDksIDU1LCA5LCAyNjYsIDMsIDEwLCAxLCAyLCAwLCA0OSwgNiwgNCwgNCwgMTQsIDEwLCA1MzUwLCAwLCA3LCAxNCwgMTE0NjUsIDI3LCAyMzQzLCA5LCA4NywgOSwgMzksIDQsIDYwLCA2LCAyNiwgOSwgNTM1LCA5LCA0NzAsIDAsIDIsIDU0LCA4LCAzLCA4MiwgMCwgMTIsIDEsIDE5NjI4LCAxLCA0MTc4LCA5LCA1MTksIDQ1LCAzLCAyMiwgNTQzLCA0LCA0LCA1LCA5LCA3LCAzLCA2LCAzMSwgMywgMTQ5LCAyLCAxNDE4LCA0OSwgNTEzLCA1NCwgNSwgNDksIDksIDAsIDE1LCAwLCAyMywgNCwgMiwgMTQsIDEzNjEsIDYsIDIsIDE2LCAzLCA2LCAyLCAxLCAyLCA0LCAxMDEsIDAsIDE2MSwgNiwgMTAsIDksIDM1NywgMCwgNjIsIDEzLCA0OTksIDEzLCAyNDUsIDEsIDIsIDksIDIzMywgMCwgMywgMCwgOCwgMSwgNiwgMCwgNDc1LCA2LCAxMTAsIDYsIDYsIDksIDQ3NTksIDksIDc4NzcxOSwgMjM5XTtcbmZ1bmN0aW9uIGlzSW5Bc3RyYWxTZXQoY29kZSwgc2V0KSB7XG4gIGxldCBwb3MgPSAweDEwMDAwO1xuICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gc2V0Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAyKSB7XG4gICAgcG9zICs9IHNldFtpXTtcbiAgICBpZiAocG9zID4gY29kZSkgcmV0dXJuIGZhbHNlO1xuICAgIHBvcyArPSBzZXRbaSArIDFdO1xuICAgIGlmIChwb3MgPj0gY29kZSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSkge1xuICBpZiAoY29kZSA8IDY1KSByZXR1cm4gY29kZSA9PT0gMzY7XG4gIGlmIChjb2RlIDw9IDkwKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGNvZGUgPCA5NykgcmV0dXJuIGNvZGUgPT09IDk1O1xuICBpZiAoY29kZSA8PSAxMjIpIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8PSAweGZmZmYpIHtcbiAgICByZXR1cm4gY29kZSA+PSAweGFhICYmIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpO1xufVxuZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjb2RlKSB7XG4gIGlmIChjb2RlIDwgNDgpIHJldHVybiBjb2RlID09PSAzNjtcbiAgaWYgKGNvZGUgPCA1OCkgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDwgNjUpIHJldHVybiBmYWxzZTtcbiAgaWYgKGNvZGUgPD0gOTApIHJldHVybiB0cnVlO1xuICBpZiAoY29kZSA8IDk3KSByZXR1cm4gY29kZSA9PT0gOTU7XG4gIGlmIChjb2RlIDw9IDEyMikgcmV0dXJuIHRydWU7XG4gIGlmIChjb2RlIDw9IDB4ZmZmZikge1xuICAgIHJldHVybiBjb2RlID49IDB4YWEgJiYgbm9uQVNDSUlpZGVudGlmaWVyLnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSk7XG4gIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpIHx8IGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllckNvZGVzKTtcbn1cbmNvbnN0IHJlc2VydmVkV29yZHMgPSB7XG4gIGtleXdvcmQ6IFtcImJyZWFrXCIsIFwiY2FzZVwiLCBcImNhdGNoXCIsIFwiY29udGludWVcIiwgXCJkZWJ1Z2dlclwiLCBcImRlZmF1bHRcIiwgXCJkb1wiLCBcImVsc2VcIiwgXCJmaW5hbGx5XCIsIFwiZm9yXCIsIFwiZnVuY3Rpb25cIiwgXCJpZlwiLCBcInJldHVyblwiLCBcInN3aXRjaFwiLCBcInRocm93XCIsIFwidHJ5XCIsIFwidmFyXCIsIFwiY29uc3RcIiwgXCJ3aGlsZVwiLCBcIndpdGhcIiwgXCJuZXdcIiwgXCJ0aGlzXCIsIFwic3VwZXJcIiwgXCJjbGFzc1wiLCBcImV4dGVuZHNcIiwgXCJleHBvcnRcIiwgXCJpbXBvcnRcIiwgXCJudWxsXCIsIFwidHJ1ZVwiLCBcImZhbHNlXCIsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIFwidHlwZW9mXCIsIFwidm9pZFwiLCBcImRlbGV0ZVwiXSxcbiAgc3RyaWN0OiBbXCJpbXBsZW1lbnRzXCIsIFwiaW50ZXJmYWNlXCIsIFwibGV0XCIsIFwicGFja2FnZVwiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwdWJsaWNcIiwgXCJzdGF0aWNcIiwgXCJ5aWVsZFwiXSxcbiAgc3RyaWN0QmluZDogW1wiZXZhbFwiLCBcImFyZ3VtZW50c1wiXVxufTtcbmNvbnN0IGtleXdvcmRzID0gbmV3IFNldChyZXNlcnZlZFdvcmRzLmtleXdvcmQpO1xuY29uc3QgcmVzZXJ2ZWRXb3Jkc1N0cmljdFNldCA9IG5ldyBTZXQocmVzZXJ2ZWRXb3Jkcy5zdHJpY3QpO1xuY29uc3QgcmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmRTZXQgPSBuZXcgU2V0KHJlc2VydmVkV29yZHMuc3RyaWN0QmluZCk7XG5mdW5jdGlvbiBpc1Jlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkge1xuICByZXR1cm4gaW5Nb2R1bGUgJiYgd29yZCA9PT0gXCJhd2FpdFwiIHx8IHdvcmQgPT09IFwiZW51bVwiO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RSZXNlcnZlZFdvcmQod29yZCwgaW5Nb2R1bGUpIHtcbiAgcmV0dXJuIGlzUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB8fCByZXNlcnZlZFdvcmRzU3RyaWN0U2V0Lmhhcyh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0QmluZE9ubHlSZXNlcnZlZFdvcmQod29yZCkge1xuICByZXR1cm4gcmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmRTZXQuaGFzKHdvcmQpO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkKHdvcmQsIGluTW9kdWxlKSB7XG4gIHJldHVybiBpc1N0cmljdFJlc2VydmVkV29yZCh3b3JkLCBpbk1vZHVsZSkgfHwgaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZCh3b3JkKTtcbn1cbmZ1bmN0aW9uIGlzS2V5d29yZCh3b3JkKSB7XG4gIHJldHVybiBrZXl3b3Jkcy5oYXMod29yZCk7XG59XG5mdW5jdGlvbiBpc0l0ZXJhdG9yU3RhcnQoY3VycmVudCwgbmV4dCwgbmV4dDIpIHtcbiAgcmV0dXJuIGN1cnJlbnQgPT09IDY0ICYmIG5leHQgPT09IDY0ICYmIGlzSWRlbnRpZmllclN0YXJ0KG5leHQyKTtcbn1cbmNvbnN0IHJlc2VydmVkV29yZExpa2VTZXQgPSBuZXcgU2V0KFtcImJyZWFrXCIsIFwiY2FzZVwiLCBcImNhdGNoXCIsIFwiY29udGludWVcIiwgXCJkZWJ1Z2dlclwiLCBcImRlZmF1bHRcIiwgXCJkb1wiLCBcImVsc2VcIiwgXCJmaW5hbGx5XCIsIFwiZm9yXCIsIFwiZnVuY3Rpb25cIiwgXCJpZlwiLCBcInJldHVyblwiLCBcInN3aXRjaFwiLCBcInRocm93XCIsIFwidHJ5XCIsIFwidmFyXCIsIFwiY29uc3RcIiwgXCJ3aGlsZVwiLCBcIndpdGhcIiwgXCJuZXdcIiwgXCJ0aGlzXCIsIFwic3VwZXJcIiwgXCJjbGFzc1wiLCBcImV4dGVuZHNcIiwgXCJleHBvcnRcIiwgXCJpbXBvcnRcIiwgXCJudWxsXCIsIFwidHJ1ZVwiLCBcImZhbHNlXCIsIFwiaW5cIiwgXCJpbnN0YW5jZW9mXCIsIFwidHlwZW9mXCIsIFwidm9pZFwiLCBcImRlbGV0ZVwiLCBcImltcGxlbWVudHNcIiwgXCJpbnRlcmZhY2VcIiwgXCJsZXRcIiwgXCJwYWNrYWdlXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiLCBcInN0YXRpY1wiLCBcInlpZWxkXCIsIFwiZXZhbFwiLCBcImFyZ3VtZW50c1wiLCBcImVudW1cIiwgXCJhd2FpdFwiXSk7XG5mdW5jdGlvbiBjYW5CZVJlc2VydmVkV29yZCh3b3JkKSB7XG4gIHJldHVybiByZXNlcnZlZFdvcmRMaWtlU2V0Lmhhcyh3b3JkKTtcbn1cbmNsYXNzIFNjb3BlIHtcbiAgY29uc3RydWN0b3IoZmxhZ3MpIHtcbiAgICB0aGlzLmZsYWdzID0gMDtcbiAgICB0aGlzLm5hbWVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZmlyc3RMZXhpY2FsTmFtZSA9IFwiXCI7XG4gICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICB9XG59XG5jbGFzcyBTY29wZUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihwYXJzZXIsIGluTW9kdWxlKSB7XG4gICAgdGhpcy5wYXJzZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zY29wZVN0YWNrID0gW107XG4gICAgdGhpcy5pbk1vZHVsZSA9IHZvaWQgMDtcbiAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgdGhpcy5pbk1vZHVsZSA9IGluTW9kdWxlO1xuICB9XG4gIGdldCBpblRvcExldmVsKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50U2NvcGUoKS5mbGFncyAmIDEpID4gMDtcbiAgfVxuICBnZXQgaW5GdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFZhclNjb3BlRmxhZ3MoKSAmIDIpID4gMDtcbiAgfVxuICBnZXQgYWxsb3dTdXBlcigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZUZsYWdzKCkgJiAxNikgPiAwO1xuICB9XG4gIGdldCBhbGxvd0RpcmVjdFN1cGVyKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSAmIDMyKSA+IDA7XG4gIH1cbiAgZ2V0IGFsbG93TmV3VGFyZ2V0KCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSAmIDUxMikgPiAwO1xuICB9XG4gIGdldCBpbkNsYXNzKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50VGhpc1Njb3BlRmxhZ3MoKSAmIDY0KSA+IDA7XG4gIH1cbiAgZ2V0IGluQ2xhc3NBbmROb3RJbk5vbkFycm93RnVuY3Rpb24oKSB7XG4gICAgY29uc3QgZmxhZ3MgPSB0aGlzLmN1cnJlbnRUaGlzU2NvcGVGbGFncygpO1xuICAgIHJldHVybiAoZmxhZ3MgJiA2NCkgPiAwICYmIChmbGFncyAmIDIpID09PSAwO1xuICB9XG4gIGdldCBpblN0YXRpY0Jsb2NrKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmbGFnc1xuICAgICAgfSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChmbGFncyAmIDEyOCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChmbGFncyAmICgxNjY3IHwgNjQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGluTm9uQXJyb3dGdW5jdGlvbigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFRoaXNTY29wZUZsYWdzKCkgJiAyKSA+IDA7XG4gIH1cbiAgZ2V0IGluQmFyZUNhc2VTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRTY29wZSgpLmZsYWdzICYgMjU2KSA+IDA7XG4gIH1cbiAgZ2V0IHRyZWF0RnVuY3Rpb25zQXNWYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJlYXRGdW5jdGlvbnNBc1ZhckluU2NvcGUodGhpcy5jdXJyZW50U2NvcGUoKSk7XG4gIH1cbiAgY3JlYXRlU2NvcGUoZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFNjb3BlKGZsYWdzKTtcbiAgfVxuICBlbnRlcihmbGFncykge1xuICAgIHRoaXMuc2NvcGVTdGFjay5wdXNoKHRoaXMuY3JlYXRlU2NvcGUoZmxhZ3MpKTtcbiAgfVxuICBleGl0KCkge1xuICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZVN0YWNrLnBvcCgpO1xuICAgIHJldHVybiBzY29wZS5mbGFncztcbiAgfVxuICB0cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkge1xuICAgIHJldHVybiAhIShzY29wZS5mbGFncyAmICgyIHwgMTI4KSB8fCAhdGhpcy5wYXJzZXIuaW5Nb2R1bGUgJiYgc2NvcGUuZmxhZ3MgJiAxKTtcbiAgfVxuICBkZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKSB7XG4gICAgbGV0IHNjb3BlID0gdGhpcy5jdXJyZW50U2NvcGUoKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiA4IHx8IGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICBsZXQgdHlwZSA9IHNjb3BlLm5hbWVzLmdldChuYW1lKSB8fCAwO1xuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgICAgdHlwZSA9IHR5cGUgfCA0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFzY29wZS5maXJzdExleGljYWxOYW1lKSB7XG4gICAgICAgICAgc2NvcGUuZmlyc3RMZXhpY2FsTmFtZSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdHlwZSA9IHR5cGUgfCAyO1xuICAgICAgfVxuICAgICAgc2NvcGUubmFtZXMuc2V0KG5hbWUsIHR5cGUpO1xuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgOCkge1xuICAgICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChiaW5kaW5nVHlwZSAmIDQpIHtcbiAgICAgIGZvciAobGV0IGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICAgIHNjb3BlLm5hbWVzLnNldChuYW1lLCAoc2NvcGUubmFtZXMuZ2V0KG5hbWUpIHx8IDApIHwgMSk7XG4gICAgICAgIHRoaXMubWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKTtcbiAgICAgICAgaWYgKHNjb3BlLmZsYWdzICYgMTY2NykgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcnNlci5pbk1vZHVsZSAmJiBzY29wZS5mbGFncyAmIDEpIHtcbiAgICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cy5kZWxldGUobmFtZSk7XG4gICAgfVxuICB9XG4gIG1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSkge1xuICAgIGlmICh0aGlzLnBhcnNlci5pbk1vZHVsZSAmJiBzY29wZS5mbGFncyAmIDEpIHtcbiAgICAgIHRoaXMudW5kZWZpbmVkRXhwb3J0cy5kZWxldGUobmFtZSk7XG4gICAgfVxuICB9XG4gIGNoZWNrUmVkZWNsYXJhdGlvbkluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlLCBsb2MpIHtcbiAgICBpZiAodGhpcy5pc1JlZGVjbGFyZWRJblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSkpIHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5WYXJSZWRlY2xhcmF0aW9uLCBsb2MsIHtcbiAgICAgICAgaWRlbnRpZmllck5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpc1JlZGVjbGFyZWRJblNjb3BlKHNjb3BlLCBuYW1lLCBiaW5kaW5nVHlwZSkge1xuICAgIGlmICghKGJpbmRpbmdUeXBlICYgMSkpIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiA4KSB7XG4gICAgICByZXR1cm4gc2NvcGUubmFtZXMuaGFzKG5hbWUpO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gc2NvcGUubmFtZXMuZ2V0KG5hbWUpIHx8IDA7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMTYpIHtcbiAgICAgIHJldHVybiAodHlwZSAmIDIpID4gMCB8fCAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkgJiYgKHR5cGUgJiAxKSA+IDA7XG4gICAgfVxuICAgIHJldHVybiAodHlwZSAmIDIpID4gMCAmJiAhKHNjb3BlLmZsYWdzICYgOCAmJiBzY29wZS5maXJzdExleGljYWxOYW1lID09PSBuYW1lKSB8fCAhdGhpcy50cmVhdEZ1bmN0aW9uc0FzVmFySW5TY29wZShzY29wZSkgJiYgKHR5cGUgJiA0KSA+IDA7XG4gIH1cbiAgY2hlY2tMb2NhbEV4cG9ydChpZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9ID0gaWQ7XG4gICAgY29uc3QgdG9wTGV2ZWxTY29wZSA9IHRoaXMuc2NvcGVTdGFja1swXTtcbiAgICBpZiAoIXRvcExldmVsU2NvcGUubmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLnVuZGVmaW5lZEV4cG9ydHMuc2V0KG5hbWUsIGlkLmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG4gIGN1cnJlbnRTY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcbiAgfVxuICBjdXJyZW50VmFyU2NvcGVGbGFncygpIHtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDE7OyBpLS0pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmxhZ3NcbiAgICAgIH0gPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBpZiAoZmxhZ3MgJiAxNjY3KSB7XG4gICAgICAgIHJldHVybiBmbGFncztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY3VycmVudFRoaXNTY29wZUZsYWdzKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMTs7IGktLSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmbGFnc1xuICAgICAgfSA9IHRoaXMuc2NvcGVTdGFja1tpXTtcbiAgICAgIGlmIChmbGFncyAmICgxNjY3IHwgNjQpICYmICEoZmxhZ3MgJiA0KSkge1xuICAgICAgICByZXR1cm4gZmxhZ3M7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBGbG93U2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmRlY2xhcmVGdW5jdGlvbnMgPSBuZXcgU2V0KCk7XG4gIH1cbn1cbmNsYXNzIEZsb3dTY29wZUhhbmRsZXIgZXh0ZW5kcyBTY29wZUhhbmRsZXIge1xuICBjcmVhdGVTY29wZShmbGFncykge1xuICAgIHJldHVybiBuZXcgRmxvd1Njb3BlKGZsYWdzKTtcbiAgfVxuICBkZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIGlmIChiaW5kaW5nVHlwZSAmIDIwNDgpIHtcbiAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICBzY29wZS5kZWNsYXJlRnVuY3Rpb25zLmFkZChuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZGVjbGFyZU5hbWUobmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gIH1cbiAgaXNSZWRlY2xhcmVkSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUpIHtcbiAgICBpZiAoc3VwZXIuaXNSZWRlY2xhcmVkSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiAyMDQ4ICYmICFzY29wZS5kZWNsYXJlRnVuY3Rpb25zLmhhcyhuYW1lKSkge1xuICAgICAgY29uc3QgdHlwZSA9IHNjb3BlLm5hbWVzLmdldChuYW1lKTtcbiAgICAgIHJldHVybiAodHlwZSAmIDQpID4gMCB8fCAodHlwZSAmIDIpID4gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNoZWNrTG9jYWxFeHBvcnQoaWQpIHtcbiAgICBpZiAoIXRoaXMuc2NvcGVTdGFja1swXS5kZWNsYXJlRnVuY3Rpb25zLmhhcyhpZC5uYW1lKSkge1xuICAgICAgc3VwZXIuY2hlY2tMb2NhbEV4cG9ydChpZCk7XG4gICAgfVxuICB9XG59XG5jb25zdCByZXNlcnZlZFR5cGVzID0gbmV3IFNldChbXCJfXCIsIFwiYW55XCIsIFwiYm9vbFwiLCBcImJvb2xlYW5cIiwgXCJlbXB0eVwiLCBcImV4dGVuZHNcIiwgXCJmYWxzZVwiLCBcImludGVyZmFjZVwiLCBcIm1peGVkXCIsIFwibnVsbFwiLCBcIm51bWJlclwiLCBcInN0YXRpY1wiLCBcInN0cmluZ1wiLCBcInRydWVcIiwgXCJ0eXBlb2ZcIiwgXCJ2b2lkXCJdKTtcbmNvbnN0IEZsb3dFcnJvcnMgPSBQYXJzZUVycm9yRW51bWBmbG93YCh7XG4gIEFtYmlndW91c0NvbmRpdGlvbmFsQXJyb3c6IFwiQW1iaWd1b3VzIGV4cHJlc3Npb246IHdyYXAgdGhlIGFycm93IGZ1bmN0aW9ucyBpbiBwYXJlbnRoZXNlcyB0byBkaXNhbWJpZ3VhdGUuXCIsXG4gIEFtYmlndW91c0RlY2xhcmVNb2R1bGVLaW5kOiBcIkZvdW5kIGJvdGggYGRlY2xhcmUgbW9kdWxlLmV4cG9ydHNgIGFuZCBgZGVjbGFyZSBleHBvcnRgIGluIHRoZSBzYW1lIG1vZHVsZS4gTW9kdWxlcyBjYW4gb25seSBoYXZlIDEgc2luY2UgdGhleSBhcmUgZWl0aGVyIGFuIEVTIG1vZHVsZSBvciB0aGV5IGFyZSBhIENvbW1vbkpTIG1vZHVsZS5cIixcbiAgQXNzaWduUmVzZXJ2ZWRUeXBlOiAoe1xuICAgIHJlc2VydmVkVHlwZVxuICB9KSA9PiBgQ2Fubm90IG92ZXJ3cml0ZSByZXNlcnZlZCB0eXBlICR7cmVzZXJ2ZWRUeXBlfS5gLFxuICBEZWNsYXJlQ2xhc3NFbGVtZW50OiBcIlRoZSBgZGVjbGFyZWAgbW9kaWZpZXIgY2FuIG9ubHkgYXBwZWFyIG9uIGNsYXNzIGZpZWxkcy5cIixcbiAgRGVjbGFyZUNsYXNzRmllbGRJbml0aWFsaXplcjogXCJJbml0aWFsaXplcnMgYXJlIG5vdCBhbGxvd2VkIGluIGZpZWxkcyB3aXRoIHRoZSBgZGVjbGFyZWAgbW9kaWZpZXIuXCIsXG4gIER1cGxpY2F0ZURlY2xhcmVNb2R1bGVFeHBvcnRzOiBcIkR1cGxpY2F0ZSBgZGVjbGFyZSBtb2R1bGUuZXhwb3J0c2Agc3RhdGVtZW50LlwiLFxuICBFbnVtQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkOiAoe1xuICAgIG1lbWJlck5hbWUsXG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYEJvb2xlYW4gZW51bSBtZW1iZXJzIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQuIFVzZSBlaXRoZXIgXFxgJHttZW1iZXJOYW1lfSA9IHRydWUsXFxgIG9yIFxcYCR7bWVtYmVyTmFtZX0gPSBmYWxzZSxcXGAgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtRHVwbGljYXRlTWVtYmVyTmFtZTogKHtcbiAgICBtZW1iZXJOYW1lLFxuICAgIGVudW1OYW1lXG4gIH0pID0+IGBFbnVtIG1lbWJlciBuYW1lcyBuZWVkIHRvIGJlIHVuaXF1ZSwgYnV0IHRoZSBuYW1lIFxcYCR7bWVtYmVyTmFtZX1cXGAgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGJlZm9yZSBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbmNvbnNpc3RlbnRNZW1iZXJWYWx1ZXM6ICh7XG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYEVudW0gXFxgJHtlbnVtTmFtZX1cXGAgaGFzIGluY29uc2lzdGVudCBtZW1iZXIgaW5pdGlhbGl6ZXJzLiBFaXRoZXIgdXNlIG5vIGluaXRpYWxpemVycywgb3IgY29uc2lzdGVudGx5IHVzZSBsaXRlcmFscyAoZWl0aGVyIGJvb2xlYW5zLCBudW1iZXJzLCBvciBzdHJpbmdzKSBmb3IgYWxsIG1lbWJlciBpbml0aWFsaXplcnMuYCxcbiAgRW51bUludmFsaWRFeHBsaWNpdFR5cGU6ICh7XG4gICAgaW52YWxpZEVudW1UeXBlLFxuICAgIGVudW1OYW1lXG4gIH0pID0+IGBFbnVtIHR5cGUgXFxgJHtpbnZhbGlkRW51bVR5cGV9XFxgIGlzIG5vdCB2YWxpZC4gVXNlIG9uZSBvZiBcXGBib29sZWFuXFxgLCBcXGBudW1iZXJcXGAsIFxcYHN0cmluZ1xcYCwgb3IgXFxgc3ltYm9sXFxgIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bUludmFsaWRFeHBsaWNpdFR5cGVVbmtub3duU3VwcGxpZWQ6ICh7XG4gICAgZW51bU5hbWVcbiAgfSkgPT4gYFN1cHBsaWVkIGVudW0gdHlwZSBpcyBub3QgdmFsaWQuIFVzZSBvbmUgb2YgXFxgYm9vbGVhblxcYCwgXFxgbnVtYmVyXFxgLCBcXGBzdHJpbmdcXGAsIG9yIFxcYHN5bWJvbFxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJQcmltYXJ5VHlwZTogKHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lLFxuICAgIGV4cGxpY2l0VHlwZVxuICB9KSA9PiBgRW51bSBcXGAke2VudW1OYW1lfVxcYCBoYXMgdHlwZSBcXGAke2V4cGxpY2l0VHlwZX1cXGAsIHNvIHRoZSBpbml0aWFsaXplciBvZiBcXGAke21lbWJlck5hbWV9XFxgIG5lZWRzIHRvIGJlIGEgJHtleHBsaWNpdFR5cGV9IGxpdGVyYWwuYCxcbiAgRW51bUludmFsaWRNZW1iZXJJbml0aWFsaXplclN5bWJvbFR5cGU6ICh7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZVxuICB9KSA9PiBgU3ltYm9sIGVudW0gbWVtYmVycyBjYW5ub3QgYmUgaW5pdGlhbGl6ZWQuIFVzZSBcXGAke21lbWJlck5hbWV9LFxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJVbmtub3duVHlwZTogKHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lXG4gIH0pID0+IGBUaGUgZW51bSBtZW1iZXIgaW5pdGlhbGl6ZXIgZm9yIFxcYCR7bWVtYmVyTmFtZX1cXGAgbmVlZHMgdG8gYmUgYSBsaXRlcmFsIChlaXRoZXIgYSBib29sZWFuLCBudW1iZXIsIG9yIHN0cmluZykgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBFbnVtSW52YWxpZE1lbWJlck5hbWU6ICh7XG4gICAgZW51bU5hbWUsXG4gICAgbWVtYmVyTmFtZSxcbiAgICBzdWdnZXN0aW9uXG4gIH0pID0+IGBFbnVtIG1lbWJlciBuYW1lcyBjYW5ub3Qgc3RhcnQgd2l0aCBsb3dlcmNhc2UgJ2EnIHRocm91Z2ggJ3onLiBJbnN0ZWFkIG9mIHVzaW5nIFxcYCR7bWVtYmVyTmFtZX1cXGAsIGNvbnNpZGVyIHVzaW5nIFxcYCR7c3VnZ2VzdGlvbn1cXGAsIGluIGVudW0gXFxgJHtlbnVtTmFtZX1cXGAuYCxcbiAgRW51bU51bWJlck1lbWJlck5vdEluaXRpYWxpemVkOiAoe1xuICAgIGVudW1OYW1lLFxuICAgIG1lbWJlck5hbWVcbiAgfSkgPT4gYE51bWJlciBlbnVtIG1lbWJlcnMgbmVlZCB0byBiZSBpbml0aWFsaXplZCwgZS5nLiBcXGAke21lbWJlck5hbWV9ID0gMVxcYCBpbiBlbnVtIFxcYCR7ZW51bU5hbWV9XFxgLmAsXG4gIEVudW1TdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRpYWxpemVkOiAoe1xuICAgIGVudW1OYW1lXG4gIH0pID0+IGBTdHJpbmcgZW51bSBtZW1iZXJzIG5lZWQgdG8gY29uc2lzdGVudGx5IGVpdGhlciBhbGwgdXNlIGluaXRpYWxpemVycywgb3IgdXNlIG5vIGluaXRpYWxpemVycywgaW4gZW51bSBcXGAke2VudW1OYW1lfVxcYC5gLFxuICBHZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtOiBcIkEgZ2V0dGVyIGNhbm5vdCBoYXZlIGEgYHRoaXNgIHBhcmFtZXRlci5cIixcbiAgSW1wb3J0UmVmbGVjdGlvbkhhc0ltcG9ydFR5cGU6IFwiQW4gYGltcG9ydCBtb2R1bGVgIGRlY2xhcmF0aW9uIGNhbiBub3QgdXNlIGB0eXBlYCBvciBgdHlwZW9mYCBrZXl3b3JkLlwiLFxuICBJbXBvcnRUeXBlU2hvcnRoYW5kT25seUluUHVyZUltcG9ydDogXCJUaGUgYHR5cGVgIGFuZCBgdHlwZW9mYCBrZXl3b3JkcyBvbiBuYW1lZCBpbXBvcnRzIGNhbiBvbmx5IGJlIHVzZWQgb24gcmVndWxhciBgaW1wb3J0YCBzdGF0ZW1lbnRzLiBJdCBjYW5ub3QgYmUgdXNlZCB3aXRoIGBpbXBvcnQgdHlwZWAgb3IgYGltcG9ydCB0eXBlb2ZgIHN0YXRlbWVudHMuXCIsXG4gIEluZXhhY3RJbnNpZGVFeGFjdDogXCJFeHBsaWNpdCBpbmV4YWN0IHN5bnRheCBjYW5ub3QgYXBwZWFyIGluc2lkZSBhbiBleHBsaWNpdCBleGFjdCBvYmplY3QgdHlwZS5cIixcbiAgSW5leGFjdEluc2lkZU5vbk9iamVjdDogXCJFeHBsaWNpdCBpbmV4YWN0IHN5bnRheCBjYW5ub3QgYXBwZWFyIGluIGNsYXNzIG9yIGludGVyZmFjZSBkZWZpbml0aW9ucy5cIixcbiAgSW5leGFjdFZhcmlhbmNlOiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IGNhbm5vdCBoYXZlIHZhcmlhbmNlLlwiLFxuICBJbnZhbGlkTm9uVHlwZUltcG9ydEluRGVjbGFyZU1vZHVsZTogXCJJbXBvcnRzIHdpdGhpbiBhIGBkZWNsYXJlIG1vZHVsZWAgYm9keSBtdXN0IGFsd2F5cyBiZSBgaW1wb3J0IHR5cGVgIG9yIGBpbXBvcnQgdHlwZW9mYC5cIixcbiAgTWlzc2luZ1R5cGVQYXJhbURlZmF1bHQ6IFwiVHlwZSBwYXJhbWV0ZXIgZGVjbGFyYXRpb24gbmVlZHMgYSBkZWZhdWx0LCBzaW5jZSBhIHByZWNlZGluZyB0eXBlIHBhcmFtZXRlciBkZWNsYXJhdGlvbiBoYXMgYSBkZWZhdWx0LlwiLFxuICBOZXN0ZWREZWNsYXJlTW9kdWxlOiBcImBkZWNsYXJlIG1vZHVsZWAgY2Fubm90IGJlIHVzZWQgaW5zaWRlIGFub3RoZXIgYGRlY2xhcmUgbW9kdWxlYC5cIixcbiAgTmVzdGVkRmxvd0NvbW1lbnQ6IFwiQ2Fubm90IGhhdmUgYSBmbG93IGNvbW1lbnQgaW5zaWRlIGFub3RoZXIgZmxvdyBjb21tZW50LlwiLFxuICBQYXR0ZXJuSXNPcHRpb25hbDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWVzc2FnZTogXCJBIGJpbmRpbmcgcGF0dGVybiBwYXJhbWV0ZXIgY2Fubm90IGJlIG9wdGlvbmFsIGluIGFuIGltcGxlbWVudGF0aW9uIHNpZ25hdHVyZS5cIlxuICB9LCB7XG4gICAgcmVhc29uQ29kZTogXCJPcHRpb25hbEJpbmRpbmdQYXR0ZXJuXCJcbiAgfSksXG4gIFNldHRlck1heU5vdEhhdmVUaGlzUGFyYW06IFwiQSBzZXR0ZXIgY2Fubm90IGhhdmUgYSBgdGhpc2AgcGFyYW1ldGVyLlwiLFxuICBTcHJlYWRWYXJpYW5jZTogXCJTcHJlYWQgcHJvcGVydGllcyBjYW5ub3QgaGF2ZSB2YXJpYW5jZS5cIixcbiAgVGhpc1BhcmFtQW5ub3RhdGlvblJlcXVpcmVkOiBcIkEgdHlwZSBhbm5vdGF0aW9uIGlzIHJlcXVpcmVkIGZvciB0aGUgYHRoaXNgIHBhcmFtZXRlci5cIixcbiAgVGhpc1BhcmFtQmFubmVkSW5Db25zdHJ1Y3RvcjogXCJDb25zdHJ1Y3RvcnMgY2Fubm90IGhhdmUgYSBgdGhpc2AgcGFyYW1ldGVyOyBjb25zdHJ1Y3RvcnMgZG9uJ3QgYmluZCBgdGhpc2AgbGlrZSBvdGhlciBmdW5jdGlvbnMuXCIsXG4gIFRoaXNQYXJhbU1heU5vdEJlT3B0aW9uYWw6IFwiVGhlIGB0aGlzYCBwYXJhbWV0ZXIgY2Fubm90IGJlIG9wdGlvbmFsLlwiLFxuICBUaGlzUGFyYW1NdXN0QmVGaXJzdDogXCJUaGUgYHRoaXNgIHBhcmFtZXRlciBtdXN0IGJlIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXJhbWV0ZXIuXCIsXG4gIFRoaXNQYXJhbU5vRGVmYXVsdDogXCJUaGUgYHRoaXNgIHBhcmFtZXRlciBtYXkgbm90IGhhdmUgYSBkZWZhdWx0IHZhbHVlLlwiLFxuICBUeXBlQmVmb3JlSW5pdGlhbGl6ZXI6IFwiVHlwZSBhbm5vdGF0aW9ucyBtdXN0IGNvbWUgYmVmb3JlIGRlZmF1bHQgYXNzaWdubWVudHMsIGUuZy4gaW5zdGVhZCBvZiBgYWdlID0gMjU6IG51bWJlcmAgdXNlIGBhZ2U6IG51bWJlciA9IDI1YC5cIixcbiAgVHlwZUNhc3RJblBhdHRlcm46IFwiVGhlIHR5cGUgY2FzdCBleHByZXNzaW9uIGlzIGV4cGVjdGVkIHRvIGJlIHdyYXBwZWQgd2l0aCBwYXJlbnRoZXNpcy5cIixcbiAgVW5leHBlY3RlZEV4cGxpY2l0SW5leGFjdEluT2JqZWN0OiBcIkV4cGxpY2l0IGluZXhhY3Qgc3ludGF4IG11c3QgYXBwZWFyIGF0IHRoZSBlbmQgb2YgYW4gaW5leGFjdCBvYmplY3QuXCIsXG4gIFVuZXhwZWN0ZWRSZXNlcnZlZFR5cGU6ICh7XG4gICAgcmVzZXJ2ZWRUeXBlXG4gIH0pID0+IGBVbmV4cGVjdGVkIHJlc2VydmVkIHR5cGUgJHtyZXNlcnZlZFR5cGV9LmAsXG4gIFVuZXhwZWN0ZWRSZXNlcnZlZFVuZGVyc2NvcmU6IFwiYF9gIGlzIG9ubHkgYWxsb3dlZCBhcyBhIHR5cGUgYXJndW1lbnQgdG8gY2FsbCBvciBuZXcuXCIsXG4gIFVuZXhwZWN0ZWRTcGFjZUJldHdlZW5Nb2R1bG9DaGVja3M6IFwiU3BhY2VzIGJldHdlZW4gYCVgIGFuZCBgY2hlY2tzYCBhcmUgbm90IGFsbG93ZWQgaGVyZS5cIixcbiAgVW5leHBlY3RlZFNwcmVhZFR5cGU6IFwiU3ByZWFkIG9wZXJhdG9yIGNhbm5vdCBhcHBlYXIgaW4gY2xhc3Mgb3IgaW50ZXJmYWNlIGRlZmluaXRpb25zLlwiLFxuICBVbmV4cGVjdGVkU3VidHJhY3Rpb25PcGVyYW5kOiAnVW5leHBlY3RlZCB0b2tlbiwgZXhwZWN0ZWQgXCJudW1iZXJcIiBvciBcImJpZ2ludFwiLicsXG4gIFVuZXhwZWN0ZWRUb2tlbkFmdGVyVHlwZVBhcmFtZXRlcjogXCJFeHBlY3RlZCBhbiBhcnJvdyBmdW5jdGlvbiBhZnRlciB0aGlzIHR5cGUgcGFyYW1ldGVyIGRlY2xhcmF0aW9uLlwiLFxuICBVbmV4cGVjdGVkVHlwZVBhcmFtZXRlckJlZm9yZUFzeW5jQXJyb3dGdW5jdGlvbjogXCJUeXBlIHBhcmFtZXRlcnMgbXVzdCBjb21lIGFmdGVyIHRoZSBhc3luYyBrZXl3b3JkLCBlLmcuIGluc3RlYWQgb2YgYDxUPiBhc3luYyAoKSA9PiB7fWAsIHVzZSBgYXN5bmMgPFQ+KCkgPT4ge31gLlwiLFxuICBVbnN1cHBvcnRlZERlY2xhcmVFeHBvcnRLaW5kOiAoe1xuICAgIHVuc3VwcG9ydGVkRXhwb3J0S2luZCxcbiAgICBzdWdnZXN0aW9uXG4gIH0pID0+IGBcXGBkZWNsYXJlIGV4cG9ydCAke3Vuc3VwcG9ydGVkRXhwb3J0S2luZH1cXGAgaXMgbm90IHN1cHBvcnRlZC4gVXNlIFxcYCR7c3VnZ2VzdGlvbn1cXGAgaW5zdGVhZC5gLFxuICBVbnN1cHBvcnRlZFN0YXRlbWVudEluRGVjbGFyZU1vZHVsZTogXCJPbmx5IGRlY2xhcmVzIGFuZCB0eXBlIGltcG9ydHMgYXJlIGFsbG93ZWQgaW5zaWRlIGRlY2xhcmUgbW9kdWxlLlwiLFxuICBVbnRlcm1pbmF0ZWRGbG93Q29tbWVudDogXCJVbnRlcm1pbmF0ZWQgZmxvdy1jb21tZW50LlwiXG59KTtcbmZ1bmN0aW9uIGlzRXNNb2R1bGVUeXBlKGJvZHlFbGVtZW50KSB7XG4gIHJldHVybiBib2R5RWxlbWVudC50eXBlID09PSBcIkRlY2xhcmVFeHBvcnRBbGxEZWNsYXJhdGlvblwiIHx8IGJvZHlFbGVtZW50LnR5cGUgPT09IFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIgJiYgKCFib2R5RWxlbWVudC5kZWNsYXJhdGlvbiB8fCBib2R5RWxlbWVudC5kZWNsYXJhdGlvbi50eXBlICE9PSBcIlR5cGVBbGlhc1wiICYmIGJvZHlFbGVtZW50LmRlY2xhcmF0aW9uLnR5cGUgIT09IFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG59XG5mdW5jdGlvbiBoYXNUeXBlSW1wb3J0S2luZChub2RlKSB7XG4gIHJldHVybiBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiIHx8IG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlb2ZcIjtcbn1cbmNvbnN0IGV4cG9ydFN1Z2dlc3Rpb25zID0ge1xuICBjb25zdDogXCJkZWNsYXJlIGV4cG9ydCB2YXJcIixcbiAgbGV0OiBcImRlY2xhcmUgZXhwb3J0IHZhclwiLFxuICB0eXBlOiBcImV4cG9ydCB0eXBlXCIsXG4gIGludGVyZmFjZTogXCJleHBvcnQgaW50ZXJmYWNlXCJcbn07XG5mdW5jdGlvbiBwYXJ0aXRpb24obGlzdCwgdGVzdCkge1xuICBjb25zdCBsaXN0MSA9IFtdO1xuICBjb25zdCBsaXN0MiA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAodGVzdChsaXN0W2ldLCBpLCBsaXN0KSA/IGxpc3QxIDogbGlzdDIpLnB1c2gobGlzdFtpXSk7XG4gIH1cbiAgcmV0dXJuIFtsaXN0MSwgbGlzdDJdO1xufVxuY29uc3QgRkxPV19QUkFHTUFfUkVHRVggPSAvXFwqP1xccypAKCg/Om5vKT9mbG93KVxcYi87XG52YXIgZmxvdyA9IHN1cGVyQ2xhc3MgPT4gY2xhc3MgRmxvd1BhcnNlck1peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcbiAgICB0aGlzLmZsb3dQcmFnbWEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0U2NvcGVIYW5kbGVyKCkge1xuICAgIHJldHVybiBGbG93U2NvcGVIYW5kbGVyO1xuICB9XG4gIHNob3VsZFBhcnNlVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZmxvd1wiLCBcImFsbFwiKSB8fCB0aGlzLmZsb3dQcmFnbWEgPT09IFwiZmxvd1wiO1xuICB9XG4gIGZpbmlzaFRva2VuKHR5cGUsIHZhbCkge1xuICAgIGlmICh0eXBlICE9PSAxMzQgJiYgdHlwZSAhPT0gMTMgJiYgdHlwZSAhPT0gMjgpIHtcbiAgICAgIGlmICh0aGlzLmZsb3dQcmFnbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5maW5pc2hUb2tlbih0eXBlLCB2YWwpO1xuICB9XG4gIGFkZENvbW1lbnQoY29tbWVudCkge1xuICAgIGlmICh0aGlzLmZsb3dQcmFnbWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IEZMT1dfUFJBR01BX1JFR0VYLmV4ZWMoY29tbWVudC52YWx1ZSk7XG4gICAgICBpZiAoIW1hdGNoZXMpIDtlbHNlIGlmIChtYXRjaGVzWzFdID09PSBcImZsb3dcIikge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBcImZsb3dcIjtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hlc1sxXSA9PT0gXCJub2Zsb3dcIikge1xuICAgICAgICB0aGlzLmZsb3dQcmFnbWEgPSBcIm5vZmxvd1wiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBmbG93IHByYWdtYVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIuYWRkQ29tbWVudChjb21tZW50KTtcbiAgfVxuICBmbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIodG9rKSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KHRvayB8fCAxNCk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGZsb3dQYXJzZVByZWRpY2F0ZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBtb2R1bG9Mb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMTApO1xuICAgIGlmICh0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYy5pbmRleCA+IG1vZHVsb0xvYy5pbmRleCArIDEpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3BhY2VCZXR3ZWVuTW9kdWxvQ2hlY2tzLCBtb2R1bG9Mb2MpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lYXQoMTApKSB7XG4gICAgICBub2RlLnZhbHVlID0gc3VwZXIucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZWRQcmVkaWNhdGVcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbmZlcnJlZFByZWRpY2F0ZVwiKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCkge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgbGV0IHR5cGUgPSBudWxsO1xuICAgIGxldCBwcmVkaWNhdGUgPSBudWxsO1xuICAgIGlmICh0aGlzLm1hdGNoKDU0KSkge1xuICAgICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgICBwcmVkaWNhdGUgPSB0aGlzLmZsb3dQYXJzZVByZWRpY2F0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICB0aGlzLnN0YXRlLmluVHlwZSA9IG9sZEluVHlwZTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDU0KSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB0aGlzLmZsb3dQYXJzZVByZWRpY2F0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW3R5cGUsIHByZWRpY2F0ZV07XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZUNsYXNzKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUNsYXNzXCIpO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3QgaWQgPSBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBjb25zdCB0eXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgdHlwZUNvbnRhaW5lciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICB0eXBlTm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVOb2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIGNvbnN0IHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgdHlwZU5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICB0eXBlTm9kZS5yZXN0ID0gdG1wLnJlc3Q7XG4gICAgdHlwZU5vZGUudGhpcyA9IHRtcC5fdGhpcztcbiAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgW3R5cGVOb2RlLnJldHVyblR5cGUsIG5vZGUucHJlZGljYXRlXSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG4gICAgdHlwZUNvbnRhaW5lci50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmluaXNoTm9kZSh0eXBlTm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIGlkLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKHR5cGVDb250YWluZXIsIFwiVHlwZUFubm90YXRpb25cIik7XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKGlkKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCAyMDQ4LCBub2RlLmlkLmxvYy5zdGFydCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVGdW5jdGlvblwiKTtcbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlKG5vZGUsIGluc2lkZU1vZHVsZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDgwKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUNsYXNzKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCg2OCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVGdW5jdGlvbihub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goNzQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlVmFyaWFibGUobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdENvbnRleHR1YWwoMTI3KSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTYpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVNb2R1bGVFeHBvcnRzKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGluc2lkZU1vZHVsZSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5OZXN0ZWREZWNsYXJlTW9kdWxlLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZU1vZHVsZShub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVUeXBlQWxpYXMobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VEZWNsYXJlT3BhcXVlVHlwZShub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZURlY2xhcmVJbnRlcmZhY2Uobm9kZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDgyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIGluc2lkZU1vZHVsZSk7XG4gICAgfVxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIGZsb3dQYXJzZURlY2xhcmVWYXJpYWJsZShub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcih0cnVlKTtcbiAgICB0aGlzLnNjb3BlLmRlY2xhcmVOYW1lKG5vZGUuaWQubmFtZSwgNSwgbm9kZS5pZC5sb2Muc3RhcnQpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVWYXJpYWJsZVwiKTtcbiAgfVxuICBmbG93UGFyc2VEZWNsYXJlTW9kdWxlKG5vZGUpIHtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDApO1xuICAgIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIG5vZGUuaWQgPSBzdXBlci5wYXJzZUV4cHJBdG9tKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIH1cbiAgICBjb25zdCBib2R5Tm9kZSA9IG5vZGUuYm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgYm9keSA9IGJvZHlOb2RlLmJvZHkgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goOCkpIHtcbiAgICAgIGNvbnN0IGJvZHlOb2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDgzKSkge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCgxMzApICYmICF0aGlzLm1hdGNoKDg3KSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbnZhbGlkTm9uVHlwZUltcG9ydEluRGVjbGFyZU1vZHVsZSwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIGJvZHkucHVzaChzdXBlci5wYXJzZUltcG9ydChib2R5Tm9kZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyNSwgRmxvd0Vycm9ycy5VbnN1cHBvcnRlZFN0YXRlbWVudEluRGVjbGFyZU1vZHVsZSk7XG4gICAgICAgIGJvZHkucHVzaCh0aGlzLmZsb3dQYXJzZURlY2xhcmUoYm9keU5vZGUsIHRydWUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgdGhpcy5maW5pc2hOb2RlKGJvZHlOb2RlLCBcIkJsb2NrU3RhdGVtZW50XCIpO1xuICAgIGxldCBraW5kID0gbnVsbDtcbiAgICBsZXQgaGFzTW9kdWxlRXhwb3J0ID0gZmFsc2U7XG4gICAgYm9keS5mb3JFYWNoKGJvZHlFbGVtZW50ID0+IHtcbiAgICAgIGlmIChpc0VzTW9kdWxlVHlwZShib2R5RWxlbWVudCkpIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiQ29tbW9uSlNcIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5BbWJpZ3VvdXNEZWNsYXJlTW9kdWxlS2luZCwgYm9keUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGtpbmQgPSBcIkVTXCI7XG4gICAgICB9IGVsc2UgaWYgKGJvZHlFbGVtZW50LnR5cGUgPT09IFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIikge1xuICAgICAgICBpZiAoaGFzTW9kdWxlRXhwb3J0KSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkR1cGxpY2F0ZURlY2xhcmVNb2R1bGVFeHBvcnRzLCBib2R5RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtpbmQgPT09IFwiRVNcIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5BbWJpZ3VvdXNEZWNsYXJlTW9kdWxlS2luZCwgYm9keUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGtpbmQgPSBcIkNvbW1vbkpTXCI7XG4gICAgICAgIGhhc01vZHVsZUV4cG9ydCA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbm9kZS5raW5kID0ga2luZCB8fCBcIkNvbW1vbkpTXCI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRlY2xhcmVNb2R1bGVcIik7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUsIGluc2lkZU1vZHVsZSkge1xuICAgIHRoaXMuZXhwZWN0KDgyKTtcbiAgICBpZiAodGhpcy5lYXQoNjUpKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg2OCkgfHwgdGhpcy5tYXRjaCg4MCkpIHtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMuZmxvd1BhcnNlRGVjbGFyZSh0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuZGVjbGFyYXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuZGVmYXVsdCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg3NSkgfHwgdGhpcy5pc0xldCgpIHx8ICh0aGlzLmlzQ29udGV4dHVhbCgxMzApIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpICYmICFpbnNpZGVNb2R1bGUpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5zdXBwb3J0ZWREZWNsYXJlRXhwb3J0S2luZCwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICAgIHVuc3VwcG9ydGVkRXhwb3J0S2luZDogbGFiZWwsXG4gICAgICAgICAgc3VnZ2VzdGlvbjogZXhwb3J0U3VnZ2VzdGlvbnNbbGFiZWxdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWF0Y2goNzQpIHx8IHRoaXMubWF0Y2goNjgpIHx8IHRoaXMubWF0Y2goODApIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEzMSkpIHtcbiAgICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMuZmxvd1BhcnNlRGVjbGFyZSh0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgbm9kZS5kZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIik7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goNTUpIHx8IHRoaXMubWF0Y2goNSkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTI5KSB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMzApIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEzMSkpIHtcbiAgICAgICAgbm9kZSA9IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgbnVsbCk7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKSB7XG4gICAgICAgICAgbm9kZS5kZWZhdWx0ID0gZmFsc2U7XG4gICAgICAgICAgZGVsZXRlIG5vZGUuZXhwb3J0S2luZDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jYXN0Tm9kZVRvKG5vZGUsIFwiRGVjbGFyZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNhc3ROb2RlVG8obm9kZSwgXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZU1vZHVsZUV4cG9ydHMobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMTEpO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVjbGFyZU1vZHVsZUV4cG9ydHNcIik7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZVR5cGVBbGlhcyhub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgY29uc3QgZmluaXNoZWQgPSB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhub2RlKTtcbiAgICB0aGlzLmNhc3ROb2RlVG8oZmluaXNoZWQsIFwiRGVjbGFyZVR5cGVBbGlhc1wiKTtcbiAgICByZXR1cm4gZmluaXNoZWQ7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZU9wYXF1ZVR5cGUobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IGZpbmlzaGVkID0gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKG5vZGUsIHRydWUpO1xuICAgIHRoaXMuY2FzdE5vZGVUbyhmaW5pc2hlZCwgXCJEZWNsYXJlT3BhcXVlVHlwZVwiKTtcbiAgICByZXR1cm4gZmluaXNoZWQ7XG4gIH1cbiAgZmxvd1BhcnNlRGVjbGFyZUludGVyZmFjZShub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Vpc2gobm9kZSwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNsYXJlSW50ZXJmYWNlXCIpO1xuICB9XG4gIGZsb3dQYXJzZUludGVyZmFjZWlzaChub2RlLCBpc0NsYXNzKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIoIWlzQ2xhc3MsIHRydWUpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCBpc0NsYXNzID8gMTcgOiA4MjAxLCBub2RlLmlkLmxvYy5zdGFydCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUuZXh0ZW5kcyA9IFtdO1xuICAgIGlmICh0aGlzLmVhdCg4MSkpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgbm9kZS5leHRlbmRzLnB1c2godGhpcy5mbG93UGFyc2VJbnRlcmZhY2VFeHRlbmRzKCkpO1xuICAgICAgfSB3aGlsZSAoIWlzQ2xhc3MgJiYgdGhpcy5lYXQoMTIpKTtcbiAgICB9XG4gICAgaWYgKGlzQ2xhc3MpIHtcbiAgICAgIG5vZGUuaW1wbGVtZW50cyA9IFtdO1xuICAgICAgbm9kZS5taXhpbnMgPSBbXTtcbiAgICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoMTE3KSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbm9kZS5taXhpbnMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSk7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDExMykpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIG5vZGUuaW1wbGVtZW50cy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlRXh0ZW5kcygpKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5lYXQoMTIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICAgIGFsbG93U3RhdGljOiBpc0NsYXNzLFxuICAgICAgYWxsb3dFeGFjdDogZmFsc2UsXG4gICAgICBhbGxvd1NwcmVhZDogZmFsc2UsXG4gICAgICBhbGxvd1Byb3RvOiBpc0NsYXNzLFxuICAgICAgYWxsb3dJbmV4YWN0OiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlUXVhbGlmaWVkVHlwZUlkZW50aWZpZXIoKTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJmYWNlRXh0ZW5kc1wiKTtcbiAgfVxuICBmbG93UGFyc2VJbnRlcmZhY2Uobm9kZSkge1xuICAgIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlaXNoKG5vZGUsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgY2hlY2tOb3RVbmRlcnNjb3JlKHdvcmQpIHtcbiAgICBpZiAod29yZCA9PT0gXCJfXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkUmVzZXJ2ZWRVbmRlcnNjb3JlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tSZXNlcnZlZFR5cGUod29yZCwgc3RhcnRMb2MsIGRlY2xhcmF0aW9uKSB7XG4gICAgaWYgKCFyZXNlcnZlZFR5cGVzLmhhcyh3b3JkKSkgcmV0dXJuO1xuICAgIHRoaXMucmFpc2UoZGVjbGFyYXRpb24gPyBGbG93RXJyb3JzLkFzc2lnblJlc2VydmVkVHlwZSA6IEZsb3dFcnJvcnMuVW5leHBlY3RlZFJlc2VydmVkVHlwZSwgc3RhcnRMb2MsIHtcbiAgICAgIHJlc2VydmVkVHlwZTogd29yZFxuICAgIH0pO1xuICB9XG4gIGZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKGxpYmVyYWwsIGRlY2xhcmF0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Jlc2VydmVkVHlwZSh0aGlzLnN0YXRlLnZhbHVlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCBkZWNsYXJhdGlvbik7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyKGxpYmVyYWwpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVBbGlhcyhub2RlKSB7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIoZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCA4MjAxLCBub2RlLmlkLmxvYy5zdGFydCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUucmlnaHQgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigyOSk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZUFsaWFzXCIpO1xuICB9XG4gIGZsb3dQYXJzZU9wYXF1ZVR5cGUobm9kZSwgZGVjbGFyZSkge1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMzApO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUsIHRydWUpO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCA4MjAxLCBub2RlLmlkLmxvYy5zdGFydCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgfVxuICAgIG5vZGUuc3VwZXJ0eXBlID0gbnVsbDtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIG5vZGUuc3VwZXJ0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlSW5pdGlhbGlzZXIoMTQpO1xuICAgIH1cbiAgICBub2RlLmltcGx0eXBlID0gbnVsbDtcbiAgICBpZiAoIWRlY2xhcmUpIHtcbiAgICAgIG5vZGUuaW1wbHR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigyOSk7XG4gICAgfVxuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9wYXF1ZVR5cGVcIik7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZVBhcmFtZXRlcihyZXF1aXJlRGVmYXVsdCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgbm9kZVN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCB2YXJpYW5jZSA9IHRoaXMuZmxvd1BhcnNlVmFyaWFuY2UoKTtcbiAgICBjb25zdCBpZGVudCA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRhYmxlSWRlbnRpZmllcigpO1xuICAgIG5vZGUubmFtZSA9IGlkZW50Lm5hbWU7XG4gICAgbm9kZS52YXJpYW5jZSA9IHZhcmlhbmNlO1xuICAgIG5vZGUuYm91bmQgPSBpZGVudC50eXBlQW5ub3RhdGlvbjtcbiAgICBpZiAodGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgIHRoaXMuZWF0KDI5KTtcbiAgICAgIG5vZGUuZGVmYXVsdCA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVxdWlyZURlZmF1bHQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLk1pc3NpbmdUeXBlUGFyYW1EZWZhdWx0LCBub2RlU3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlclwiKTtcbiAgfVxuICBmbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5wYXJhbXMgPSBbXTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goMTQzKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBsZXQgZGVmYXVsdFJlcXVpcmVkID0gZmFsc2U7XG4gICAgZG8ge1xuICAgICAgY29uc3QgdHlwZVBhcmFtZXRlciA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlcihkZWZhdWx0UmVxdWlyZWQpO1xuICAgICAgbm9kZS5wYXJhbXMucHVzaCh0eXBlUGFyYW1ldGVyKTtcbiAgICAgIGlmICh0eXBlUGFyYW1ldGVyLmRlZmF1bHQpIHtcbiAgICAgICAgZGVmYXVsdFJlcXVpcmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5tYXRjaCg0OCkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCF0aGlzLm1hdGNoKDQ4KSk7XG4gICAgdGhpcy5leHBlY3QoNDgpO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgZmxvd0luVG9wTGV2ZWxDb250ZXh0KGNiKSB7XG4gICAgaWYgKHRoaXMuY3VyQ29udGV4dCgpICE9PSB0eXBlcy5icmFjZSkge1xuICAgICAgY29uc3Qgb2xkQ29udGV4dCA9IHRoaXMuc3RhdGUuY29udGV4dDtcbiAgICAgIHRoaXMuc3RhdGUuY29udGV4dCA9IFtvbGRDb250ZXh0WzBdXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYigpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5zdGF0ZS5jb250ZXh0ID0gb2xkQ29udGV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfVxuICB9XG4gIGZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uSW5FeHByZXNzaW9uKCkge1xuICAgIGlmICh0aGlzLnJlU2Nhbl9sdCgpICE9PSA0NykgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uKCk7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb24oKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIG5vZGUucGFyYW1zID0gW107XG4gICAgdGhpcy5mbG93SW5Ub3BMZXZlbENvbnRleHQoKCkgPT4ge1xuICAgICAgdGhpcy5leHBlY3QoNDcpO1xuICAgICAgY29uc3Qgb2xkTm9Bbm9uRnVuY3Rpb25UeXBlID0gdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU7XG4gICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuICAgICAgd2hpbGUgKCF0aGlzLm1hdGNoKDQ4KSkge1xuICAgICAgICBub2RlLnBhcmFtcy5wdXNoKHRoaXMuZmxvd1BhcnNlVHlwZSgpKTtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoKDQ4KSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgaWYgKCF0aGlzLnN0YXRlLmluVHlwZSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMuYnJhY2UpIHtcbiAgICAgIHRoaXMucmVTY2FuX2x0X2d0KCk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDQ4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25DYWxsT3JOZXcoKSB7XG4gICAgaWYgKHRoaXMucmVTY2FuX2x0KCkgIT09IDQ3KSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0aGlzLmV4cGVjdCg0Nyk7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDQ4KSkge1xuICAgICAgbm9kZS5wYXJhbXMucHVzaCh0aGlzLmZsb3dQYXJzZVR5cGVPckltcGxpY2l0SW5zdGFudGlhdGlvbigpKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCg0OCkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZUludGVyZmFjZVR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyOSk7XG4gICAgbm9kZS5leHRlbmRzID0gW107XG4gICAgaWYgKHRoaXMuZWF0KDgxKSkge1xuICAgICAgZG8ge1xuICAgICAgICBub2RlLmV4dGVuZHMucHVzaCh0aGlzLmZsb3dQYXJzZUludGVyZmFjZUV4dGVuZHMoKSk7XG4gICAgICB9IHdoaWxlICh0aGlzLmVhdCgxMikpO1xuICAgIH1cbiAgICBub2RlLmJvZHkgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGUoe1xuICAgICAgYWxsb3dTdGF0aWM6IGZhbHNlLFxuICAgICAgYWxsb3dFeGFjdDogZmFsc2UsXG4gICAgICBhbGxvd1NwcmVhZDogZmFsc2UsXG4gICAgICBhbGxvd1Byb3RvOiBmYWxzZSxcbiAgICAgIGFsbG93SW5leGFjdDogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW50ZXJmYWNlVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTM1KSB8fCB0aGlzLm1hdGNoKDEzNCkgPyBzdXBlci5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RUeXBlSW5kZXhlcihub2RlLCBpc1N0YXRpYywgdmFyaWFuY2UpIHtcbiAgICBub2RlLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgIGlmICh0aGlzLmxvb2thaGVhZCgpLnR5cGUgPT09IDE0KSB7XG4gICAgICBub2RlLmlkID0gdGhpcy5mbG93UGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgICAgbm9kZS5rZXkgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgIG5vZGUua2V5ID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIG5vZGUudmFyaWFuY2UgPSB2YXJpYW5jZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZUluZGV4ZXJcIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZUludGVybmFsU2xvdChub2RlLCBpc1N0YXRpYykge1xuICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgbm9kZS5pZCA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIG5vZGUubWV0aG9kID0gdHJ1ZTtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVNZXRob2Rpc2godGhpcy5zdGFydE5vZGVBdChub2RlLmxvYy5zdGFydCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLm1ldGhvZCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiKTtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKG5vZGUpIHtcbiAgICBub2RlLnBhcmFtcyA9IFtdO1xuICAgIG5vZGUucmVzdCA9IG51bGw7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IG51bGw7XG4gICAgbm9kZS50aGlzID0gbnVsbDtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNzgpKSB7XG4gICAgICBub2RlLnRoaXMgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKHRydWUpO1xuICAgICAgbm9kZS50aGlzLm5hbWUgPSBudWxsO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIHdoaWxlICghdGhpcy5tYXRjaCgxMSkgJiYgIXRoaXMubWF0Y2goMjEpKSB7XG4gICAgICBub2RlLnBhcmFtcy5wdXNoKHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0oZmFsc2UpKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5lYXQoMjEpKSB7XG4gICAgICBub2RlLnJlc3QgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eShub2RlLCBpc1N0YXRpYykge1xuICAgIGNvbnN0IHZhbHVlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5zdGF0aWMgPSBpc1N0YXRpYztcbiAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHZhbHVlTm9kZSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdFR5cGVDYWxsUHJvcGVydHlcIik7XG4gIH1cbiAgZmxvd1BhcnNlT2JqZWN0VHlwZSh7XG4gICAgYWxsb3dTdGF0aWMsXG4gICAgYWxsb3dFeGFjdCxcbiAgICBhbGxvd1NwcmVhZCxcbiAgICBhbGxvd1Byb3RvLFxuICAgIGFsbG93SW5leGFjdFxuICB9KSB7XG4gICAgY29uc3Qgb2xkSW5UeXBlID0gdGhpcy5zdGF0ZS5pblR5cGU7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSB0cnVlO1xuICAgIGNvbnN0IG5vZGVTdGFydCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZVN0YXJ0LmNhbGxQcm9wZXJ0aWVzID0gW107XG4gICAgbm9kZVN0YXJ0LnByb3BlcnRpZXMgPSBbXTtcbiAgICBub2RlU3RhcnQuaW5kZXhlcnMgPSBbXTtcbiAgICBub2RlU3RhcnQuaW50ZXJuYWxTbG90cyA9IFtdO1xuICAgIGxldCBlbmREZWxpbTtcbiAgICBsZXQgZXhhY3Q7XG4gICAgbGV0IGluZXhhY3QgPSBmYWxzZTtcbiAgICBpZiAoYWxsb3dFeGFjdCAmJiB0aGlzLm1hdGNoKDYpKSB7XG4gICAgICB0aGlzLmV4cGVjdCg2KTtcbiAgICAgIGVuZERlbGltID0gOTtcbiAgICAgIGV4YWN0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBlY3QoNSk7XG4gICAgICBlbmREZWxpbSA9IDg7XG4gICAgICBleGFjdCA9IGZhbHNlO1xuICAgIH1cbiAgICBub2RlU3RhcnQuZXhhY3QgPSBleGFjdDtcbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goZW5kRGVsaW0pKSB7XG4gICAgICBsZXQgaXNTdGF0aWMgPSBmYWxzZTtcbiAgICAgIGxldCBwcm90b1N0YXJ0TG9jID0gbnVsbDtcbiAgICAgIGxldCBpbmV4YWN0U3RhcnRMb2MgPSBudWxsO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBpZiAoYWxsb3dQcm90byAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMTgpKSB7XG4gICAgICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgICAgIGlmIChsb29rYWhlYWQudHlwZSAhPT0gMTQgJiYgbG9va2FoZWFkLnR5cGUgIT09IDE3KSB7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcHJvdG9TdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgICAgYWxsb3dTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGFsbG93U3RhdGljICYmIHRoaXMuaXNDb250ZXh0dWFsKDEwNikpIHtcbiAgICAgICAgY29uc3QgbG9va2FoZWFkID0gdGhpcy5sb29rYWhlYWQoKTtcbiAgICAgICAgaWYgKGxvb2thaGVhZC50eXBlICE9PSAxNCAmJiBsb29rYWhlYWQudHlwZSAhPT0gMTcpIHtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBpc1N0YXRpYyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhcmlhbmNlID0gdGhpcy5mbG93UGFyc2VWYXJpYW5jZSgpO1xuICAgICAgaWYgKHRoaXMuZWF0KDApKSB7XG4gICAgICAgIGlmIChwcm90b1N0YXJ0TG9jICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQocHJvdG9TdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWF0KDApKSB7XG4gICAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQodmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZVN0YXJ0LmludGVybmFsU2xvdHMucHVzaCh0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVJbnRlcm5hbFNsb3Qobm9kZSwgaXNTdGF0aWMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlU3RhcnQuaW5kZXhlcnMucHVzaCh0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVJbmRleGVyKG5vZGUsIGlzU3RhdGljLCB2YXJpYW5jZSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMTApIHx8IHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICAgIGlmIChwcm90b1N0YXJ0TG9jICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQocHJvdG9TdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhcmlhbmNlKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKHZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZVN0YXJ0LmNhbGxQcm9wZXJ0aWVzLnB1c2godGhpcy5mbG93UGFyc2VPYmplY3RUeXBlQ2FsbFByb3BlcnR5KG5vZGUsIGlzU3RhdGljKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQga2luZCA9IFwiaW5pdFwiO1xuICAgICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTkpIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEwNCkpIHtcbiAgICAgICAgICBjb25zdCBsb29rYWhlYWQgPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgICAgIGlmICh0b2tlbklzTGl0ZXJhbFByb3BlcnR5TmFtZShsb29rYWhlYWQudHlwZSkpIHtcbiAgICAgICAgICAgIGtpbmQgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BPckluZXhhY3QgPSB0aGlzLmZsb3dQYXJzZU9iamVjdFR5cGVQcm9wZXJ0eShub2RlLCBpc1N0YXRpYywgcHJvdG9TdGFydExvYywgdmFyaWFuY2UsIGtpbmQsIGFsbG93U3ByZWFkLCBhbGxvd0luZXhhY3QgIT0gbnVsbCA/IGFsbG93SW5leGFjdCA6ICFleGFjdCk7XG4gICAgICAgIGlmIChwcm9wT3JJbmV4YWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgaW5leGFjdCA9IHRydWU7XG4gICAgICAgICAgaW5leGFjdFN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZVN0YXJ0LnByb3BlcnRpZXMucHVzaChwcm9wT3JJbmV4YWN0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5mbG93T2JqZWN0VHlwZVNlbWljb2xvbigpO1xuICAgICAgaWYgKGluZXhhY3RTdGFydExvYyAmJiAhdGhpcy5tYXRjaCg4KSAmJiAhdGhpcy5tYXRjaCg5KSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5leHBlY3RlZEV4cGxpY2l0SW5leGFjdEluT2JqZWN0LCBpbmV4YWN0U3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cGVjdChlbmREZWxpbSk7XG4gICAgaWYgKGFsbG93U3ByZWFkKSB7XG4gICAgICBub2RlU3RhcnQuaW5leGFjdCA9IGluZXhhY3Q7XG4gICAgfVxuICAgIGNvbnN0IG91dCA9IHRoaXMuZmluaXNoTm9kZShub2RlU3RhcnQsIFwiT2JqZWN0VHlwZUFubm90YXRpb25cIik7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICBmbG93UGFyc2VPYmplY3RUeXBlUHJvcGVydHkobm9kZSwgaXNTdGF0aWMsIHByb3RvU3RhcnRMb2MsIHZhcmlhbmNlLCBraW5kLCBhbGxvd1NwcmVhZCwgYWxsb3dJbmV4YWN0KSB7XG4gICAgaWYgKHRoaXMuZWF0KDIxKSkge1xuICAgICAgY29uc3QgaXNJbmV4YWN0VG9rZW4gPSB0aGlzLm1hdGNoKDEyKSB8fCB0aGlzLm1hdGNoKDEzKSB8fCB0aGlzLm1hdGNoKDgpIHx8IHRoaXMubWF0Y2goOSk7XG4gICAgICBpZiAoaXNJbmV4YWN0VG9rZW4pIHtcbiAgICAgICAgaWYgKCFhbGxvd1NwcmVhZCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbmV4YWN0SW5zaWRlTm9uT2JqZWN0LCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWFsbG93SW5leGFjdCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5JbmV4YWN0SW5zaWRlRXhhY3QsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuSW5leGFjdFZhcmlhbmNlLCB2YXJpYW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoIWFsbG93U3ByZWFkKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3ByZWFkVHlwZSwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgaWYgKHByb3RvU3RhcnRMb2MgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQocHJvdG9TdGFydExvYyk7XG4gICAgICB9XG4gICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlNwcmVhZFZhcmlhbmNlLCB2YXJpYW5jZSk7XG4gICAgICB9XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZVNwcmVhZFByb3BlcnR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmtleSA9IHRoaXMuZmxvd1BhcnNlT2JqZWN0UHJvcGVydHlLZXkoKTtcbiAgICAgIG5vZGUuc3RhdGljID0gaXNTdGF0aWM7XG4gICAgICBub2RlLnByb3RvID0gcHJvdG9TdGFydExvYyAhPSBudWxsO1xuICAgICAgbm9kZS5raW5kID0ga2luZDtcbiAgICAgIGxldCBvcHRpb25hbCA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goMTApKSB7XG4gICAgICAgIG5vZGUubWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgaWYgKHByb3RvU3RhcnRMb2MgIT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMudW5leHBlY3RlZChwcm90b1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFyaWFuY2UpIHtcbiAgICAgICAgICB0aGlzLnVuZXhwZWN0ZWQodmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlTWV0aG9kaXNoKHRoaXMuc3RhcnROb2RlQXQobm9kZS5sb2Muc3RhcnQpKTtcbiAgICAgICAgaWYgKGtpbmQgPT09IFwiZ2V0XCIgfHwga2luZCA9PT0gXCJzZXRcIikge1xuICAgICAgICAgIHRoaXMuZmxvd0NoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYWxsb3dTcHJlYWQgJiYgbm9kZS5rZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiICYmIG5vZGUudmFsdWUudGhpcykge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1CYW5uZWRJbkNvbnN0cnVjdG9yLCBub2RlLnZhbHVlLnRoaXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2luZCAhPT0gXCJpbml0XCIpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICBub2RlLm1ldGhvZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICAgICAgb3B0aW9uYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUudmFsdWUgPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgICAgICBub2RlLnZhcmlhbmNlID0gdmFyaWFuY2U7XG4gICAgICB9XG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiT2JqZWN0VHlwZVByb3BlcnR5XCIpO1xuICAgIH1cbiAgfVxuICBmbG93Q2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMocHJvcGVydHkpIHtcbiAgICBjb25zdCBwYXJhbUNvdW50ID0gcHJvcGVydHkua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICAgIGNvbnN0IGxlbmd0aCA9IHByb3BlcnR5LnZhbHVlLnBhcmFtcy5sZW5ndGggKyAocHJvcGVydHkudmFsdWUucmVzdCA/IDEgOiAwKTtcbiAgICBpZiAocHJvcGVydHkudmFsdWUudGhpcykge1xuICAgICAgdGhpcy5yYWlzZShwcm9wZXJ0eS5raW5kID09PSBcImdldFwiID8gRmxvd0Vycm9ycy5HZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtIDogRmxvd0Vycm9ycy5TZXR0ZXJNYXlOb3RIYXZlVGhpc1BhcmFtLCBwcm9wZXJ0eS52YWx1ZS50aGlzKTtcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgdGhpcy5yYWlzZShwcm9wZXJ0eS5raW5kID09PSBcImdldFwiID8gRXJyb3JzLkJhZEdldHRlckFyaXR5IDogRXJyb3JzLkJhZFNldHRlckFyaXR5LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIGlmIChwcm9wZXJ0eS5raW5kID09PSBcInNldFwiICYmIHByb3BlcnR5LnZhbHVlLnJlc3QpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkJhZFNldHRlclJlc3RQYXJhbWV0ZXIsIHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbiAgZmxvd09iamVjdFR5cGVTZW1pY29sb24oKSB7XG4gICAgaWYgKCF0aGlzLmVhdCgxMykgJiYgIXRoaXMuZWF0KDEyKSAmJiAhdGhpcy5tYXRjaCg4KSAmJiAhdGhpcy5tYXRjaCg5KSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICB9XG4gIGZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyKHN0YXJ0TG9jLCBpZCkge1xuICAgIHN0YXJ0TG9jICE9IG51bGwgPyBzdGFydExvYyA6IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBsZXQgbm9kZSA9IGlkIHx8IHRoaXMuZmxvd1BhcnNlUmVzdHJpY3RlZElkZW50aWZpZXIodHJ1ZSk7XG4gICAgd2hpbGUgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgY29uc3Qgbm9kZTIgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUyLnF1YWxpZmljYXRpb24gPSBub2RlO1xuICAgICAgbm9kZTIuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUpO1xuICAgICAgbm9kZSA9IHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJRdWFsaWZpZWRUeXBlSWRlbnRpZmllclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRMb2MsIGlkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVF1YWxpZmllZFR5cGVJZGVudGlmaWVyKHN0YXJ0TG9jLCBpZCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiR2VuZXJpY1R5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVvZlR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoODcpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLmZsb3dQYXJzZVByaW1hcnlUeXBlKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR1cGxlVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnR5cGVzID0gW107XG4gICAgdGhpcy5leHBlY3QoMCk7XG4gICAgd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGggJiYgIXRoaXMubWF0Y2goMykpIHtcbiAgICAgIG5vZGUudHlwZXMucHVzaCh0aGlzLmZsb3dQYXJzZVR5cGUoKSk7XG4gICAgICBpZiAodGhpcy5tYXRjaCgzKSkgYnJlYWs7XG4gICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUdXBsZVR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZpcnN0KSB7XG4gICAgbGV0IG5hbWUgPSBudWxsO1xuICAgIGxldCBvcHRpb25hbCA9IGZhbHNlO1xuICAgIGxldCB0eXBlQW5ub3RhdGlvbiA9IG51bGw7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgbGggPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgIGNvbnN0IGlzVGhpcyA9IHRoaXMuc3RhdGUudHlwZSA9PT0gNzg7XG4gICAgaWYgKGxoLnR5cGUgPT09IDE0IHx8IGxoLnR5cGUgPT09IDE3KSB7XG4gICAgICBpZiAoaXNUaGlzICYmICFmaXJzdCkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtTXVzdEJlRmlyc3QsIG5vZGUpO1xuICAgICAgfVxuICAgICAgbmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKGlzVGhpcyk7XG4gICAgICBpZiAodGhpcy5lYXQoMTcpKSB7XG4gICAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgaWYgKGlzVGhpcykge1xuICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1NYXlOb3RCZU9wdGlvbmFsLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVJbml0aWFsaXNlcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZSgpO1xuICAgIH1cbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZUFubm90YXRpb247XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZ1bmN0aW9uVHlwZVBhcmFtXCIpO1xuICB9XG4gIHJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0odHlwZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHR5cGUubG9jLnN0YXJ0KTtcbiAgICBub2RlLm5hbWUgPSBudWxsO1xuICAgIG5vZGUub3B0aW9uYWwgPSBmYWxzZTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlUGFyYW1cIik7XG4gIH1cbiAgZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKHBhcmFtcyA9IFtdKSB7XG4gICAgbGV0IHJlc3QgPSBudWxsO1xuICAgIGxldCBfdGhpcyA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goNzgpKSB7XG4gICAgICBfdGhpcyA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW0odHJ1ZSk7XG4gICAgICBfdGhpcy5uYW1lID0gbnVsbDtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoIXRoaXMubWF0Y2goMTEpICYmICF0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgcGFyYW1zLnB1c2godGhpcy5mbG93UGFyc2VGdW5jdGlvblR5cGVQYXJhbShmYWxzZSkpO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDExKSkge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCgyMSkpIHtcbiAgICAgIHJlc3QgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtKGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmFtcyxcbiAgICAgIHJlc3QsXG4gICAgICBfdGhpc1xuICAgIH07XG4gIH1cbiAgZmxvd0lkZW50VG9UeXBlQW5ub3RhdGlvbihzdGFydExvYywgbm9kZSwgaWQpIHtcbiAgICBzd2l0Y2ggKGlkLm5hbWUpIHtcbiAgICAgIGNhc2UgXCJhbnlcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFueVR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCb29sZWFuVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwibWl4ZWRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1peGVkVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwiZW1wdHlcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5VHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3ltYm9sVHlwZUFubm90YXRpb25cIik7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmNoZWNrTm90VW5kZXJzY29yZShpZC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlR2VuZXJpY1R5cGUoc3RhcnRMb2MsIGlkKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlUHJpbWFyeVR5cGUoKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGxldCB0bXA7XG4gICAgbGV0IHR5cGU7XG4gICAgbGV0IGlzR3JvdXBlZFR5cGUgPSBmYWxzZTtcbiAgICBjb25zdCBvbGROb0Fub25GdW5jdGlvblR5cGUgPSB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSA1OlxuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICAgICAgICBhbGxvd1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dFeGFjdDogZmFsc2UsXG4gICAgICAgICAgYWxsb3dTcHJlYWQ6IHRydWUsXG4gICAgICAgICAgYWxsb3dQcm90bzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dJbmV4YWN0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPYmplY3RUeXBlKHtcbiAgICAgICAgICBhbGxvd1N0YXRpYzogZmFsc2UsXG4gICAgICAgICAgYWxsb3dFeGFjdDogdHJ1ZSxcbiAgICAgICAgICBhbGxvd1NwcmVhZDogdHJ1ZSxcbiAgICAgICAgICBhbGxvd1Byb3RvOiBmYWxzZSxcbiAgICAgICAgICBhbGxvd0luZXhhY3Q6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgY2FzZSAwOlxuICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IGZhbHNlO1xuICAgICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUdXBsZVR5cGUoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICAgICAgICB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcygpO1xuICAgICAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgICBub2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICAgICAgICBub2RlLnRoaXMgPSB0bXAuX3RoaXM7XG4gICAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkgJiYgIXRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSB8fCB0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHRoaXMubG9va2FoZWFkKCkudHlwZTtcbiAgICAgICAgICAgICAgaXNHcm91cGVkVHlwZSA9IHRva2VuICE9PSAxNyAmJiB0b2tlbiAhPT0gMTQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpc0dyb3VwZWRUeXBlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzR3JvdXBlZFR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gZmFsc2U7XG4gICAgICAgICAgICB0eXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSA9IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSB8fCAhKHRoaXMubWF0Y2goMTIpIHx8IHRoaXMubWF0Y2goMTEpICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gMTkpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmVhdCgxMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlKSB7XG4gICAgICAgICAgICB0bXAgPSB0aGlzLmZsb3dQYXJzZUZ1bmN0aW9uVHlwZVBhcmFtcyhbdGhpcy5yZWludGVycHJldFR5cGVBc0Z1bmN0aW9uVHlwZVBhcmFtKHR5cGUpXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRtcCA9IHRoaXMuZmxvd1BhcnNlRnVuY3Rpb25UeXBlUGFyYW1zKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUucGFyYW1zID0gdG1wLnBhcmFtcztcbiAgICAgICAgICBub2RlLnJlc3QgPSB0bXAucmVzdDtcbiAgICAgICAgICBub2RlLnRoaXMgPSB0bXAuX3RoaXM7XG4gICAgICAgICAgdGhpcy5leHBlY3QoMTEpO1xuICAgICAgICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICAgICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxMzQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlLCBcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgODU6XG4gICAgICBjYXNlIDg2OlxuICAgICAgICBub2RlLnZhbHVlID0gdGhpcy5tYXRjaCg4NSk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgNTM6XG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnZhbHVlID09PSBcIi1cIikge1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDEzNSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbEF0Tm9kZSgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDEzNikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbEF0Tm9kZSgtdGhpcy5zdGF0ZS52YWx1ZSwgXCJCaWdJbnRMaXRlcmFsVHlwZUFubm90YXRpb25cIiwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbmV4cGVjdGVkU3VidHJhY3Rpb25PcGVyYW5kLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIGNhc2UgMTM1OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIDEzNjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUsIFwiQmlnSW50TGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgY2FzZSA4ODpcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWb2lkVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIDg0OlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIDc4OlxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIGNhc2UgNTU6XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhpc3RzVHlwZUFubm90YXRpb25cIik7XG4gICAgICBjYXNlIDg3OlxuICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VUeXBlb2ZUeXBlKCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodG9rZW5Jc0tleXdvcmQodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIGNvbnN0IGxhYmVsID0gdG9rZW5MYWJlbE5hbWUodGhpcy5zdGF0ZS50eXBlKTtcbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICByZXR1cm4gc3VwZXIuY3JlYXRlSWRlbnRpZmllcihub2RlLCBsYWJlbCk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2VUeXBlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dJZGVudFRvVHlwZUFubm90YXRpb24oc3RhcnRMb2MsIG5vZGUsIHRoaXMucGFyc2VJZGVudGlmaWVyKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIGZsb3dQYXJzZVBvc3RmaXhUeXBlKCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBsZXQgdHlwZSA9IHRoaXMuZmxvd1BhcnNlUHJpbWFyeVR5cGUoKTtcbiAgICBsZXQgc2Vlbk9wdGlvbmFsSW5kZXhlZEFjY2VzcyA9IGZhbHNlO1xuICAgIHdoaWxlICgodGhpcy5tYXRjaCgwKSB8fCB0aGlzLm1hdGNoKDE4KSkgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIGNvbnN0IG9wdGlvbmFsID0gdGhpcy5lYXQoMTgpO1xuICAgICAgc2Vlbk9wdGlvbmFsSW5kZXhlZEFjY2VzcyA9IHNlZW5PcHRpb25hbEluZGV4ZWRBY2Nlc3MgfHwgb3B0aW9uYWw7XG4gICAgICB0aGlzLmV4cGVjdCgwKTtcbiAgICAgIGlmICghb3B0aW9uYWwgJiYgdGhpcy5tYXRjaCgzKSkge1xuICAgICAgICBub2RlLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVR5cGVBbm5vdGF0aW9uXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5vYmplY3RUeXBlID0gdHlwZTtcbiAgICAgICAgbm9kZS5pbmRleFR5cGUgPSB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMyk7XG4gICAgICAgIGlmIChzZWVuT3B0aW9uYWxJbmRleGVkQWNjZXNzKSB7XG4gICAgICAgICAgbm9kZS5vcHRpb25hbCA9IG9wdGlvbmFsO1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbmRleGVkQWNjZXNzVHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBmbG93UGFyc2VQcmVmaXhUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVByZWZpeFR5cGUoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VQb3N0Zml4VHlwZSgpO1xuICAgIH1cbiAgfVxuICBmbG93UGFyc2VBbm9uRnVuY3Rpb25XaXRob3V0UGFyZW5zKCkge1xuICAgIGNvbnN0IHBhcmFtID0gdGhpcy5mbG93UGFyc2VQcmVmaXhUeXBlKCk7XG4gICAgaWYgKCF0aGlzLnN0YXRlLm5vQW5vbkZ1bmN0aW9uVHlwZSAmJiB0aGlzLmVhdCgxOSkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHBhcmFtLmxvYy5zdGFydCk7XG4gICAgICBub2RlLnBhcmFtcyA9IFt0aGlzLnJlaW50ZXJwcmV0VHlwZUFzRnVuY3Rpb25UeXBlUGFyYW0ocGFyYW0pXTtcbiAgICAgIG5vZGUucmVzdCA9IG51bGw7XG4gICAgICBub2RlLnRoaXMgPSBudWxsO1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlKCk7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW07XG4gIH1cbiAgZmxvd1BhcnNlSW50ZXJzZWN0aW9uVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmVhdCg0NSk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmxvd1BhcnNlQW5vbkZ1bmN0aW9uV2l0aG91dFBhcmVucygpO1xuICAgIG5vZGUudHlwZXMgPSBbdHlwZV07XG4gICAgd2hpbGUgKHRoaXMuZWF0KDQ1KSkge1xuICAgICAgbm9kZS50eXBlcy5wdXNoKHRoaXMuZmxvd1BhcnNlQW5vbkZ1bmN0aW9uV2l0aG91dFBhcmVucygpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudHlwZXMubGVuZ3RoID09PSAxID8gdHlwZSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVVuaW9uVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmVhdCg0Myk7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmxvd1BhcnNlSW50ZXJzZWN0aW9uVHlwZSgpO1xuICAgIG5vZGUudHlwZXMgPSBbdHlwZV07XG4gICAgd2hpbGUgKHRoaXMuZWF0KDQzKSkge1xuICAgICAgbm9kZS50eXBlcy5wdXNoKHRoaXMuZmxvd1BhcnNlSW50ZXJzZWN0aW9uVHlwZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUudHlwZXMubGVuZ3RoID09PSAxID8gdHlwZSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlVuaW9uVHlwZUFubm90YXRpb25cIik7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZSgpIHtcbiAgICBjb25zdCBvbGRJblR5cGUgPSB0aGlzLnN0YXRlLmluVHlwZTtcbiAgICB0aGlzLnN0YXRlLmluVHlwZSA9IHRydWU7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZmxvd1BhcnNlVW5pb25UeXBlKCk7XG4gICAgdGhpcy5zdGF0ZS5pblR5cGUgPSBvbGRJblR5cGU7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgZmxvd1BhcnNlVHlwZU9ySW1wbGljaXRJbnN0YW50aWF0aW9uKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IDEzMiAmJiB0aGlzLnN0YXRlLnZhbHVlID09PSBcIl9cIikge1xuICAgICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VHZW5lcmljVHlwZShzdGFydExvYywgbm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGUoKTtcbiAgICB9XG4gIH1cbiAgZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUluaXRpYWxpc2VyKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlR5cGVBbm5vdGF0aW9uXCIpO1xuICB9XG4gIGZsb3dQYXJzZVR5cGVBbm5vdGF0YWJsZUlkZW50aWZpZXIoYWxsb3dQcmltaXRpdmVPdmVycmlkZSkge1xuICAgIGNvbnN0IGlkZW50ID0gYWxsb3dQcmltaXRpdmVPdmVycmlkZSA/IHRoaXMucGFyc2VJZGVudGlmaWVyKCkgOiB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBpZGVudC50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihpZGVudCk7XG4gICAgfVxuICAgIHJldHVybiBpZGVudDtcbiAgfVxuICB0eXBlQ2FzdFRvUGFyYW1ldGVyKG5vZGUpIHtcbiAgICBub2RlLmV4cHJlc3Npb24udHlwZUFubm90YXRpb24gPSBub2RlLnR5cGVBbm5vdGF0aW9uO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihub2RlLmV4cHJlc3Npb24sIG5vZGUudHlwZUFubm90YXRpb24ubG9jLmVuZCk7XG4gICAgcmV0dXJuIG5vZGUuZXhwcmVzc2lvbjtcbiAgfVxuICBmbG93UGFyc2VWYXJpYW5jZSgpIHtcbiAgICBsZXQgdmFyaWFuY2UgPSBudWxsO1xuICAgIGlmICh0aGlzLm1hdGNoKDUzKSkge1xuICAgICAgdmFyaWFuY2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUudmFsdWUgPT09IFwiK1wiKSB7XG4gICAgICAgIHZhcmlhbmNlLmtpbmQgPSBcInBsdXNcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhcmlhbmNlLmtpbmQgPSBcIm1pbnVzXCI7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodmFyaWFuY2UsIFwiVmFyaWFuY2VcIik7XG4gICAgfVxuICAgIHJldHVybiB2YXJpYW5jZTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgaWYgKGFsbG93RXhwcmVzc2lvbkJvZHkpIHtcbiAgICAgIHRoaXMuZm9yd2FyZE5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQobm9kZSwgKCkgPT4gc3VwZXIucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgdHJ1ZSwgaXNNZXRob2QpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VGdW5jdGlvbkJvZHkobm9kZSwgZmFsc2UsIGlzTWV0aG9kKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCBpc01ldGhvZCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCB0eXBlTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBbdHlwZU5vZGUudHlwZUFubm90YXRpb24sIG5vZGUucHJlZGljYXRlXSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0eXBlTm9kZS50eXBlQW5ub3RhdGlvbiA/IHRoaXMuZmluaXNoTm9kZSh0eXBlTm9kZSwgXCJUeXBlQW5ub3RhdGlvblwiKSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUZ1bmN0aW9uQm9keUFuZEZpbmlzaChub2RlLCB0eXBlLCBpc01ldGhvZCk7XG4gIH1cbiAgcGFyc2VTdGF0ZW1lbnRMaWtlKGZsYWdzKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIHRoaXMuaXNDb250ZXh0dWFsKDEyOSkpIHtcbiAgICAgIGNvbnN0IGxvb2thaGVhZCA9IHRoaXMubG9va2FoZWFkKCk7XG4gICAgICBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIobG9va2FoZWFkLnR5cGUpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlSW50ZXJmYWNlKG5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI2KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUVudW1EZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gICAgY29uc3Qgc3RtdCA9IHN1cGVyLnBhcnNlU3RhdGVtZW50TGlrZShmbGFncyk7XG4gICAgaWYgKHRoaXMuZmxvd1ByYWdtYSA9PT0gdW5kZWZpbmVkICYmICF0aGlzLmlzVmFsaWREaXJlY3RpdmUoc3RtdCkpIHtcbiAgICAgIHRoaXMuZmxvd1ByYWdtYSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzdG10O1xuICB9XG4gIHBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByLCBkZWNvcmF0b3JzKSB7XG4gICAgaWYgKGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIGlmIChleHByLm5hbWUgPT09IFwiZGVjbGFyZVwiKSB7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDgwKSB8fCB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpIHx8IHRoaXMubWF0Y2goNjgpIHx8IHRoaXMubWF0Y2goNzQpIHx8IHRoaXMubWF0Y2goODIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxvd1BhcnNlRGVjbGFyZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIGlmIChleHByLm5hbWUgPT09IFwiaW50ZXJmYWNlXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2Uobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwci5uYW1lID09PSBcInR5cGVcIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChleHByLm5hbWUgPT09IFwib3BhcXVlXCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKG5vZGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIsIGRlY29yYXRvcnMpO1xuICB9XG4gIHNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSAxMjYgfHwgdG9rZW5Jc0Zsb3dJbnRlcmZhY2VPclR5cGVPck9wYXF1ZSh0eXBlKSkge1xuICAgICAgcmV0dXJuICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpO1xuICB9XG4gIGlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDEyNiB8fCB0b2tlbklzRmxvd0ludGVyZmFjZU9yVHlwZU9yT3BhcXVlKHR5cGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb250YWluc0VzYztcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpO1xuICB9XG4gIHBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNikpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCk7XG4gIH1cbiAgcGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICghdGhpcy5tYXRjaCgxNykpIHJldHVybiBleHByO1xuICAgIGlmICh0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMpIHtcbiAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgIGlmIChuZXh0Q2ggPT09IDQ0IHx8IG5leHRDaCA9PT0gNjEgfHwgbmV4dENoID09PSA1OCB8fCBuZXh0Q2ggPT09IDQxKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uYWxQYXJhbWV0ZXJzRXJyb3IocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgxNyk7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgY29uc3Qgb3JpZ2luYWxOb0Fycm93QXQgPSB0aGlzLnN0YXRlLm5vQXJyb3dBdDtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgbGV0IHtcbiAgICAgIGNvbnNlcXVlbnQsXG4gICAgICBmYWlsZWRcbiAgICB9ID0gdGhpcy50cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpO1xuICAgIGxldCBbdmFsaWQsIGludmFsaWRdID0gdGhpcy5nZXRBcnJvd0xpa2VFeHByZXNzaW9ucyhjb25zZXF1ZW50KTtcbiAgICBpZiAoZmFpbGVkIHx8IGludmFsaWQubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgbm9BcnJvd0F0ID0gWy4uLm9yaWdpbmFsTm9BcnJvd0F0XTtcbiAgICAgIGlmIChpbnZhbGlkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLnN0YXRlLm5vQXJyb3dBdCA9IG5vQXJyb3dBdDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnZhbGlkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9BcnJvd0F0LnB1c2goaW52YWxpZFtpXS5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgKHtcbiAgICAgICAgICBjb25zZXF1ZW50LFxuICAgICAgICAgIGZhaWxlZFxuICAgICAgICB9ID0gdGhpcy50cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpKTtcbiAgICAgICAgW3ZhbGlkLCBpbnZhbGlkXSA9IHRoaXMuZ2V0QXJyb3dMaWtlRXhwcmVzc2lvbnMoY29uc2VxdWVudCk7XG4gICAgICB9XG4gICAgICBpZiAoZmFpbGVkICYmIHZhbGlkLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkFtYmlndW91c0NvbmRpdGlvbmFsQXJyb3csIHN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWlsZWQgJiYgdmFsaWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgbm9BcnJvd0F0LnB1c2godmFsaWRbMF0uc3RhcnQpO1xuICAgICAgICB0aGlzLnN0YXRlLm5vQXJyb3dBdCA9IG5vQXJyb3dBdDtcbiAgICAgICAgKHtcbiAgICAgICAgICBjb25zZXF1ZW50LFxuICAgICAgICAgIGZhaWxlZFxuICAgICAgICB9ID0gdGhpcy50cnlQYXJzZUNvbmRpdGlvbmFsQ29uc2VxdWVudCgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5nZXRBcnJvd0xpa2VFeHByZXNzaW9ucyhjb25zZXF1ZW50LCB0cnVlKTtcbiAgICB0aGlzLnN0YXRlLm5vQXJyb3dBdCA9IG9yaWdpbmFsTm9BcnJvd0F0O1xuICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICBub2RlLnRlc3QgPSBleHByO1xuICAgIG5vZGUuY29uc2VxdWVudCA9IGNvbnNlcXVlbnQ7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmZvcndhcmROb0Fycm93UGFyYW1zQ29udmVyc2lvbkF0KG5vZGUsICgpID0+IHRoaXMucGFyc2VNYXliZUFzc2lnbih1bmRlZmluZWQsIHVuZGVmaW5lZCkpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIik7XG4gIH1cbiAgdHJ5UGFyc2VDb25kaXRpb25hbENvbnNlcXVlbnQoKSB7XG4gICAgdGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LnB1c2godGhpcy5zdGF0ZS5zdGFydCk7XG4gICAgY29uc3QgY29uc2VxdWVudCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICBjb25zdCBmYWlsZWQgPSAhdGhpcy5tYXRjaCgxNCk7XG4gICAgdGhpcy5zdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LnBvcCgpO1xuICAgIHJldHVybiB7XG4gICAgICBjb25zZXF1ZW50LFxuICAgICAgZmFpbGVkXG4gICAgfTtcbiAgfVxuICBnZXRBcnJvd0xpa2VFeHByZXNzaW9ucyhub2RlLCBkaXNhbGxvd0ludmFsaWQpIHtcbiAgICBjb25zdCBzdGFjayA9IFtub2RlXTtcbiAgICBjb25zdCBhcnJvd3MgPSBbXTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBub2RlID0gc3RhY2sucG9wKCk7XG4gICAgICBpZiAobm9kZS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgbm9kZS5ib2R5LnR5cGUgIT09IFwiQmxvY2tTdGF0ZW1lbnRcIikge1xuICAgICAgICBpZiAobm9kZS50eXBlUGFyYW1ldGVycyB8fCAhbm9kZS5yZXR1cm5UeXBlKSB7XG4gICAgICAgICAgdGhpcy5maW5pc2hBcnJvd1ZhbGlkYXRpb24obm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyb3dzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhY2sucHVzaChub2RlLmJvZHkpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgc3RhY2sucHVzaChub2RlLmNvbnNlcXVlbnQpO1xuICAgICAgICBzdGFjay5wdXNoKG5vZGUuYWx0ZXJuYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpc2FsbG93SW52YWxpZCkge1xuICAgICAgYXJyb3dzLmZvckVhY2gobm9kZSA9PiB0aGlzLmZpbmlzaEFycm93VmFsaWRhdGlvbihub2RlKSk7XG4gICAgICByZXR1cm4gW2Fycm93cywgW11dO1xuICAgIH1cbiAgICByZXR1cm4gcGFydGl0aW9uKGFycm93cywgbm9kZSA9PiBub2RlLnBhcmFtcy5ldmVyeShwYXJhbSA9PiB0aGlzLmlzQXNzaWduYWJsZShwYXJhbSwgdHJ1ZSkpKTtcbiAgfVxuICBmaW5pc2hBcnJvd1ZhbGlkYXRpb24obm9kZSkge1xuICAgIHZhciBfbm9kZSRleHRyYTtcbiAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5wYXJhbXMsIChfbm9kZSRleHRyYSA9IG5vZGUuZXh0cmEpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRleHRyYS50cmFpbGluZ0NvbW1hTG9jLCBmYWxzZSk7XG4gICAgdGhpcy5zY29wZS5lbnRlcig1MTQgfCA0KTtcbiAgICBzdXBlci5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gIH1cbiAgZm9yd2FyZE5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQobm9kZSwgcGFyc2UpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICh0aGlzLnN0YXRlLm5vQXJyb3dQYXJhbXNDb252ZXJzaW9uQXQuaW5jbHVkZXModGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhub2RlLnN0YXJ0KSkpIHtcbiAgICAgIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wdXNoKHRoaXMuc3RhdGUuc3RhcnQpO1xuICAgICAgcmVzdWx0ID0gcGFyc2UoKTtcbiAgICAgIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gcGFyc2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydExvYykge1xuICAgIGNvbnN0IG5ld05vZGUgPSBzdXBlci5wYXJzZVBhcmVuSXRlbShub2RlLCBzdGFydExvYyk7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgbmV3Tm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24obm9kZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgY29uc3QgdHlwZUNhc3ROb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICB0eXBlQ2FzdE5vZGUuZXhwcmVzc2lvbiA9IG5ld05vZGU7XG4gICAgICB0eXBlQ2FzdE5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHR5cGVDYXN0Tm9kZSwgXCJUeXBlQ2FzdEV4cHJlc3Npb25cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG4gIGFzc2VydE1vZHVsZU5vZGVBbGxvd2VkKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkltcG9ydERlY2xhcmF0aW9uXCIgJiYgKG5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVvZlwiKSB8fCBub2RlLnR5cGUgPT09IFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiICYmIG5vZGUuZXhwb3J0S2luZCA9PT0gXCJ0eXBlXCIgfHwgbm9kZS50eXBlID09PSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIgJiYgbm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5hc3NlcnRNb2R1bGVOb2RlQWxsb3dlZChub2RlKTtcbiAgfVxuICBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMwKSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyh0cnVlKTtcbiAgICAgICAgc3VwZXIucGFyc2VFeHBvcnRGcm9tKG5vZGUpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZVR5cGVBbGlhcyhkZWNsYXJhdGlvbk5vZGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTMxKSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VPcGFxdWVUeXBlKGRlY2xhcmF0aW9uTm9kZSwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI5KSkge1xuICAgICAgbm9kZS5leHBvcnRLaW5kID0gXCJ0eXBlXCI7XG4gICAgICBjb25zdCBkZWNsYXJhdGlvbk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5mbG93UGFyc2VJbnRlcmZhY2UoZGVjbGFyYXRpb25Ob2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNikpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLmZsb3dQYXJzZUVudW1EZWNsYXJhdGlvbihkZWNsYXJhdGlvbk5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gIH1cbiAgZWF0RXhwb3J0U3Rhcihub2RlKSB7XG4gICAgaWYgKHN1cGVyLmVhdEV4cG9ydFN0YXIobm9kZSkpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApICYmIHRoaXMubG9va2FoZWFkKCkudHlwZSA9PT0gNTUpIHtcbiAgICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidHlwZVwiO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWF5YmVQYXJzZUV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBoYXNOYW1lc3BhY2UgPSBzdXBlci5tYXliZVBhcnNlRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpO1xuICAgIGlmIChoYXNOYW1lc3BhY2UgJiYgbm9kZS5leHBvcnRLaW5kID09PSBcInR5cGVcIikge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKHN0YXJ0TG9jKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc05hbWVzcGFjZTtcbiAgfVxuICBwYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpIHtcbiAgICBzdXBlci5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpO1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuICB9XG4gIHBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI1KSkge1xuICAgICAgaWYgKHN1cGVyLnBhcnNlQ2xhc3NNZW1iZXJGcm9tTW9kaWZpZXIoY2xhc3NCb2R5LCBtZW1iZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG1lbWJlci5kZWNsYXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VDbGFzc01lbWJlcihjbGFzc0JvZHksIG1lbWJlciwgc3RhdGUpO1xuICAgIGlmIChtZW1iZXIuZGVjbGFyZSkge1xuICAgICAgaWYgKG1lbWJlci50eXBlICE9PSBcIkNsYXNzUHJvcGVydHlcIiAmJiBtZW1iZXIudHlwZSAhPT0gXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiICYmIG1lbWJlci50eXBlICE9PSBcIlByb3BlcnR5RGVmaW5pdGlvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5EZWNsYXJlQ2xhc3NFbGVtZW50LCBzdGFydExvYyk7XG4gICAgICB9IGVsc2UgaWYgKG1lbWJlci52YWx1ZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRGVjbGFyZUNsYXNzRmllbGRJbml0aWFsaXplciwgbWVtYmVyLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaXNJdGVyYXRvcih3b3JkKSB7XG4gICAgcmV0dXJuIHdvcmQgPT09IFwiaXRlcmF0b3JcIiB8fCB3b3JkID09PSBcImFzeW5jSXRlcmF0b3JcIjtcbiAgfVxuICByZWFkSXRlcmF0b3IoKSB7XG4gICAgY29uc3Qgd29yZCA9IHN1cGVyLnJlYWRXb3JkMSgpO1xuICAgIGNvbnN0IGZ1bGxXb3JkID0gXCJAQFwiICsgd29yZDtcbiAgICBpZiAoIXRoaXMuaXNJdGVyYXRvcih3b3JkKSB8fCAhdGhpcy5zdGF0ZS5pblR5cGUpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRJZGVudGlmaWVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCksIHtcbiAgICAgICAgaWRlbnRpZmllck5hbWU6IGZ1bGxXb3JkXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hUb2tlbigxMzIsIGZ1bGxXb3JkKTtcbiAgfVxuICBnZXRUb2tlbkZyb21Db2RlKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNvZGUgPT09IDEyMyAmJiBuZXh0ID09PSAxMjQpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNiwgMik7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmluVHlwZSAmJiAoY29kZSA9PT0gNjIgfHwgY29kZSA9PT0gNjApKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDYyID8gNDggOiA0NywgMSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlLmluVHlwZSAmJiBjb2RlID09PSA2Mykge1xuICAgICAgaWYgKG5leHQgPT09IDQ2KSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMTgsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCgxNywgMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0l0ZXJhdG9yU3RhcnQoY29kZSwgbmV4dCwgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMikpKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgdGhpcy5yZWFkSXRlcmF0b3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKTtcbiAgICB9XG4gIH1cbiAgaXNBc3NpZ25hYmxlKG5vZGUsIGlzQmluZGluZykge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5pc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTID0gZmFsc2UpIHtcbiAgICBpZiAoIWlzTEhTICYmIG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiICYmIG5vZGUubGVmdC50eXBlID09PSBcIlR5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZS5sZWZ0KTtcbiAgICB9XG4gICAgc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKTtcbiAgfVxuICB0b0Fzc2lnbmFibGVMaXN0KGV4cHJMaXN0LCB0cmFpbGluZ0NvbW1hTG9jLCBpc0xIUykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwckxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGV4cHIgPSBleHByTGlzdFtpXTtcbiAgICAgIGlmICgoZXhwciA9PSBudWxsID8gdm9pZCAwIDogZXhwci50eXBlKSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIikge1xuICAgICAgICBleHByTGlzdFtpXSA9IHRoaXMudHlwZUNhc3RUb1BhcmFtZXRlcihleHByKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIudG9Bc3NpZ25hYmxlTGlzdChleHByTGlzdCwgdHJhaWxpbmdDb21tYUxvYywgaXNMSFMpO1xuICB9XG4gIHRvUmVmZXJlbmNlZExpc3QoZXhwckxpc3QsIGlzUGFyZW50aGVzaXplZEV4cHIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHJMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX2V4cHIkZXh0cmE7XG4gICAgICBjb25zdCBleHByID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoZXhwciAmJiBleHByLnR5cGUgPT09IFwiVHlwZUNhc3RFeHByZXNzaW9uXCIgJiYgISgoX2V4cHIkZXh0cmEgPSBleHByLmV4dHJhKSAhPSBudWxsICYmIF9leHByJGV4dHJhLnBhcmVudGhlc2l6ZWQpICYmIChleHByTGlzdC5sZW5ndGggPiAxIHx8ICFpc1BhcmVudGhlc2l6ZWRFeHByKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVHlwZUNhc3RJblBhdHRlcm4sIGV4cHIudHlwZUFubm90YXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwckxpc3Q7XG4gIH1cbiAgcGFyc2VBcnJheUxpa2UoY2xvc2UsIGlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VBcnJheUxpa2UoY2xvc2UsIGlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzICE9IG51bGwgJiYgIXRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycykge1xuICAgICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0KG5vZGUuZWxlbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBpc1ZhbGlkTFZhbCh0eXBlLCBkaXNhbGxvd0NhbGxFeHByZXNzaW9uLCBpc1BhcmVudGhlc2l6ZWQsIGJpbmRpbmcpIHtcbiAgICByZXR1cm4gdHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiB8fCBzdXBlci5pc1ZhbGlkTFZhbCh0eXBlLCBkaXNhbGxvd0NhbGxFeHByZXNzaW9uLCBpc1BhcmVudGhlc2l6ZWQsIGJpbmRpbmcpO1xuICB9XG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzc1Byb3BlcnR5KG5vZGUpO1xuICB9XG4gIHBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSk7XG4gIH1cbiAgaXNDbGFzc01ldGhvZCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCg0NykgfHwgc3VwZXIuaXNDbGFzc01ldGhvZCgpO1xuICB9XG4gIGlzQ2xhc3NQcm9wZXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNCkgfHwgc3VwZXIuaXNDbGFzc1Byb3BlcnR5KCk7XG4gIH1cbiAgaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICByZXR1cm4gIXRoaXMubWF0Y2goMTQpICYmIHN1cGVyLmlzTm9uc3RhdGljQ29uc3RydWN0b3IobWV0aG9kKTtcbiAgfVxuICBwdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIGlmIChtZXRob2QudmFyaWFuY2UpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChtZXRob2QudmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICB9XG4gICAgZGVsZXRlIG1ldGhvZC52YXJpYW5jZTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG1ldGhvZC50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuICAgIHN1cGVyLnB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93c0RpcmVjdFN1cGVyKTtcbiAgICBpZiAobWV0aG9kLnBhcmFtcyAmJiBpc0NvbnN0cnVjdG9yKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBtZXRob2QucGFyYW1zO1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwICYmIHRoaXMuaXNUaGlzUGFyYW0ocGFyYW1zWzBdKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVGhpc1BhcmFtQmFubmVkSW5Db25zdHJ1Y3RvciwgbWV0aG9kKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1ldGhvZC50eXBlID09PSBcIk1ldGhvZERlZmluaXRpb25cIiAmJiBpc0NvbnN0cnVjdG9yICYmIG1ldGhvZC52YWx1ZS5wYXJhbXMpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG1ldGhvZC52YWx1ZS5wYXJhbXM7XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDAgJiYgdGhpcy5pc1RoaXNQYXJhbShwYXJhbXNbMF0pKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1CYW5uZWRJbkNvbnN0cnVjdG9yLCBtZXRob2QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYykge1xuICAgIGlmIChtZXRob2QudmFyaWFuY2UpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChtZXRob2QudmFyaWFuY2UubG9jLnN0YXJ0KTtcbiAgICB9XG4gICAgZGVsZXRlIG1ldGhvZC52YXJpYW5jZTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG1ldGhvZC50eXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKCk7XG4gICAgfVxuICAgIHN1cGVyLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgfVxuICBwYXJzZUNsYXNzU3VwZXIobm9kZSkge1xuICAgIHN1cGVyLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICBpZiAobm9kZS5zdXBlckNsYXNzICYmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkpIHtcbiAgICAgIG5vZGUuc3VwZXJUeXBlUGFyYW1ldGVycyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25JbkV4cHJlc3Npb24oKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExMykpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3QgaW1wbGVtZW50ZWQgPSBub2RlLmltcGxlbWVudHMgPSBbXTtcbiAgICAgIGRvIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIG5vZGUuaWQgPSB0aGlzLmZsb3dQYXJzZVJlc3RyaWN0ZWRJZGVudGlmaWVyKHRydWUpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGltcGxlbWVudGVkLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2xhc3NJbXBsZW1lbnRzXCIpKTtcbiAgICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgfVxuICB9XG4gIGNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG1ldGhvZCkge1xuICAgIHN1cGVyLmNoZWNrR2V0dGVyU2V0dGVyUGFyYW1zKG1ldGhvZCk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRPYmplY3RPckNsYXNzTWV0aG9kUGFyYW1zKG1ldGhvZCk7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBwYXJhbSA9IHBhcmFtc1swXTtcbiAgICAgIGlmICh0aGlzLmlzVGhpc1BhcmFtKHBhcmFtKSAmJiBtZXRob2Qua2luZCA9PT0gXCJnZXRcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuR2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbSwgcGFyYW0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVGhpc1BhcmFtKHBhcmFtKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuU2V0dGVyTWF5Tm90SGF2ZVRoaXNQYXJhbSwgcGFyYW0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZVByb3BlcnR5TmFtZVByZWZpeE9wZXJhdG9yKG5vZGUpIHtcbiAgICBub2RlLnZhcmlhbmNlID0gdGhpcy5mbG93UGFyc2VWYXJpYW5jZSgpO1xuICB9XG4gIHBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0TG9jLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHByb3AudmFyaWFuY2UpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChwcm9wLnZhcmlhbmNlLmxvYy5zdGFydCk7XG4gICAgfVxuICAgIGRlbGV0ZSBwcm9wLnZhcmlhbmNlO1xuICAgIGxldCB0eXBlUGFyYW1ldGVycztcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgJiYgIWlzQWNjZXNzb3IpIHtcbiAgICAgIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMCkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5wYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSB7XG4gICAgICAocmVzdWx0LnZhbHVlIHx8IHJlc3VsdCkudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1UeXBlKHBhcmFtKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgaWYgKHBhcmFtLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5QYXR0ZXJuSXNPcHRpb25hbCwgcGFyYW0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNUaGlzUGFyYW0ocGFyYW0pKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1NYXlOb3RCZU9wdGlvbmFsLCBwYXJhbSk7XG4gICAgICB9XG4gICAgICBwYXJhbS5vcHRpb25hbCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgcGFyYW0udHlwZUFubm90YXRpb24gPSB0aGlzLmZsb3dQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVGhpc1BhcmFtKHBhcmFtKSkge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbUFubm90YXRpb25SZXF1aXJlZCwgcGFyYW0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgyOSkgJiYgdGhpcy5pc1RoaXNQYXJhbShwYXJhbSkpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5UaGlzUGFyYW1Ob0RlZmF1bHQsIHBhcmFtKTtcbiAgICB9XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKHBhcmFtKTtcbiAgICByZXR1cm4gcGFyYW07XG4gIH1cbiAgcGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBjb25zdCBub2RlID0gc3VwZXIucGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGxlZnQpO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiQXNzaWdubWVudFBhdHRlcm5cIiAmJiBub2RlLnR5cGVBbm5vdGF0aW9uICYmIG5vZGUucmlnaHQuc3RhcnQgPCBub2RlLnR5cGVBbm5vdGF0aW9uLnN0YXJ0KSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVHlwZUJlZm9yZUluaXRpYWxpemVyLCBub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY2hlY2tJbXBvcnRSZWZsZWN0aW9uKG5vZGUpIHtcbiAgICBzdXBlci5jaGVja0ltcG9ydFJlZmxlY3Rpb24obm9kZSk7XG4gICAgaWYgKG5vZGUubW9kdWxlICYmIG5vZGUuaW1wb3J0S2luZCAhPT0gXCJ2YWx1ZVwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuSW1wb3J0UmVmbGVjdGlvbkhhc0ltcG9ydFR5cGUsIG5vZGUuc3BlY2lmaWVyc1swXS5sb2Muc3RhcnQpO1xuICAgIH1cbiAgfVxuICBwYXJzZUltcG9ydFNwZWNpZmllckxvY2FsKG5vZGUsIHNwZWNpZmllciwgdHlwZSkge1xuICAgIHNwZWNpZmllci5sb2NhbCA9IGhhc1R5cGVJbXBvcnRLaW5kKG5vZGUpID8gdGhpcy5mbG93UGFyc2VSZXN0cmljdGVkSWRlbnRpZmllcih0cnVlLCB0cnVlKSA6IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCB0eXBlKSk7XG4gIH1cbiAgaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShpc0V4cG9ydCkge1xuICAgIGlmIChzdXBlci5pc1BvdGVudGlhbEltcG9ydFBoYXNlKGlzRXhwb3J0KSkgcmV0dXJuIHRydWU7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMCkpIHtcbiAgICAgIGlmICghaXNFeHBvcnQpIHJldHVybiB0cnVlO1xuICAgICAgY29uc3QgY2ggPSB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7XG4gICAgICByZXR1cm4gY2ggPT09IDEyMyB8fCBjaCA9PT0gNDI7XG4gICAgfVxuICAgIHJldHVybiAhaXNFeHBvcnQgJiYgdGhpcy5pc0NvbnRleHR1YWwoODcpO1xuICB9XG4gIGFwcGx5SW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQsIHBoYXNlLCBsb2MpIHtcbiAgICBzdXBlci5hcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBwaGFzZSwgbG9jKTtcbiAgICBpZiAoaXNFeHBvcnQpIHtcbiAgICAgIGlmICghcGhhc2UgJiYgdGhpcy5tYXRjaCg2NSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbm9kZS5leHBvcnRLaW5kID0gcGhhc2UgPT09IFwidHlwZVwiID8gcGhhc2UgOiBcInZhbHVlXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwaGFzZSA9PT0gXCJ0eXBlXCIgJiYgdGhpcy5tYXRjaCg1NSkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgbm9kZS5pbXBvcnRLaW5kID0gcGhhc2UgPT09IFwidHlwZVwiIHx8IHBoYXNlID09PSBcInR5cGVvZlwiID8gcGhhc2UgOiBcInZhbHVlXCI7XG4gICAgfVxuICB9XG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHksIGJpbmRpbmdUeXBlKSB7XG4gICAgY29uc3QgZmlyc3RJZGVudCA9IHNwZWNpZmllci5pbXBvcnRlZDtcbiAgICBsZXQgc3BlY2lmaWVyVHlwZUtpbmQgPSBudWxsO1xuICAgIGlmIChmaXJzdElkZW50LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICBpZiAoZmlyc3RJZGVudC5uYW1lID09PSBcInR5cGVcIikge1xuICAgICAgICBzcGVjaWZpZXJUeXBlS2luZCA9IFwidHlwZVwiO1xuICAgICAgfSBlbHNlIGlmIChmaXJzdElkZW50Lm5hbWUgPT09IFwidHlwZW9mXCIpIHtcbiAgICAgICAgc3BlY2lmaWVyVHlwZUtpbmQgPSBcInR5cGVvZlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaXNCaW5kaW5nID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDkzKSAmJiAhdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJhc1wiKSkge1xuICAgICAgY29uc3QgYXNfaWRlbnQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIGlmIChzcGVjaWZpZXJUeXBlS2luZCAhPT0gbnVsbCAmJiAhdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSBhc19pZGVudDtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBzcGVjaWZpZXJUeXBlS2luZDtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5jbG9uZUlkZW50aWZpZXIoYXNfaWRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydGVkID0gZmlyc3RJZGVudDtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBudWxsO1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3BlY2lmaWVyVHlwZUtpbmQgIT09IG51bGwgJiYgdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBzcGVjaWZpZXJUeXBlS2luZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpbXBvcnRlZElzU3RyaW5nKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0QmluZGluZ0lzU3RyaW5nLCBzcGVjaWZpZXIsIHtcbiAgICAgICAgICAgIGltcG9ydE5hbWU6IGZpcnN0SWRlbnQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0ZWQgPSBmaXJzdElkZW50O1xuICAgICAgICBzcGVjaWZpZXIuaW1wb3J0S2luZCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgICBzcGVjaWZpZXIubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNCaW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgc3BlY2lmaWVyLmxvY2FsID0gdGhpcy5jbG9uZUlkZW50aWZpZXIoc3BlY2lmaWVyLmltcG9ydGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3BlY2lmaWVySXNUeXBlSW1wb3J0ID0gaGFzVHlwZUltcG9ydEtpbmQoc3BlY2lmaWVyKTtcbiAgICBpZiAoaXNJblR5cGVPbmx5SW1wb3J0ICYmIHNwZWNpZmllcklzVHlwZUltcG9ydCkge1xuICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkltcG9ydFR5cGVTaG9ydGhhbmRPbmx5SW5QdXJlSW1wb3J0LCBzcGVjaWZpZXIpO1xuICAgIH1cbiAgICBpZiAoaXNJblR5cGVPbmx5SW1wb3J0IHx8IHNwZWNpZmllcklzVHlwZUltcG9ydCkge1xuICAgICAgdGhpcy5jaGVja1Jlc2VydmVkVHlwZShzcGVjaWZpZXIubG9jYWwubmFtZSwgc3BlY2lmaWVyLmxvY2FsLmxvYy5zdGFydCwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChpc0JpbmRpbmcgJiYgIWlzSW5UeXBlT25seUltcG9ydCAmJiAhc3BlY2lmaWVySXNUeXBlSW1wb3J0KSB7XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKHNwZWNpZmllci5sb2NhbC5uYW1lLCBzcGVjaWZpZXIubG9jLnN0YXJ0LCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgXCJJbXBvcnRTcGVjaWZpZXJcIik7XG4gIH1cbiAgcGFyc2VCaW5kaW5nQXRvbSgpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSA3ODpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBpc0NvbnN0cnVjdG9yKSB7XG4gICAgY29uc3Qga2luZCA9IG5vZGUua2luZDtcbiAgICBpZiAoa2luZCAhPT0gXCJnZXRcIiAmJiBraW5kICE9PSBcInNldFwiICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb24oKTtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBpc0NvbnN0cnVjdG9yKTtcbiAgfVxuICBwYXJzZVZhcklkKGRlY2wsIGtpbmQpIHtcbiAgICBzdXBlci5wYXJzZVZhcklkKGRlY2wsIGtpbmQpO1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgZGVjbC5pZC50eXBlQW5ub3RhdGlvbiA9IHRoaXMuZmxvd1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihkZWNsLmlkKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKG5vZGUsIGNhbGwpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGNvbnN0IG9sZE5vQW5vbkZ1bmN0aW9uVHlwZSA9IHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSB0cnVlO1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gdGhpcy5mbG93UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGUgPSBvbGROb0Fub25GdW5jdGlvblR5cGU7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUFzeW5jQXJyb3dGcm9tQ2FsbEV4cHJlc3Npb24obm9kZSwgY2FsbCk7XG4gIH1cbiAgc2hvdWxkUGFyc2VBc3luY0Fycm93KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDE0KSB8fCBzdXBlci5zaG91bGRQYXJzZUFzeW5jQXJyb3coKTtcbiAgfVxuICBwYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgdmFyIF9qc3g7XG4gICAgbGV0IHN0YXRlID0gbnVsbDtcbiAgICBsZXQganN4O1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImpzeFwiKSAmJiAodGhpcy5tYXRjaCgxNDMpIHx8IHRoaXMubWF0Y2goNDcpKSkge1xuICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgICBqc3ggPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpLCBzdGF0ZSk7XG4gICAgICBpZiAoIWpzeC5lcnJvcikgcmV0dXJuIGpzeC5ub2RlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250ZXh0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250ZXh0ID0gY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGN1cnJlbnRDb250ZXh0ID09PSB0eXBlcy5qX29UYWcgfHwgY3VycmVudENvbnRleHQgPT09IHR5cGVzLmpfZXhwcikge1xuICAgICAgICBjb250ZXh0LnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoKF9qc3ggPSBqc3gpICE9IG51bGwgJiYgX2pzeC5lcnJvciB8fCB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgdmFyIF9qc3gyLCBfanN4MztcbiAgICAgIHN0YXRlID0gc3RhdGUgfHwgdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAgbGV0IHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgY29uc3QgYXJyb3cgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHtcbiAgICAgICAgdmFyIF9hcnJvd0V4cHJlc3Npb24kZXh0cjtcbiAgICAgICAgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvbigpO1xuICAgICAgICBjb25zdCBhcnJvd0V4cHJlc3Npb24gPSB0aGlzLmZvcndhcmROb0Fycm93UGFyYW1zQ29udmVyc2lvbkF0KHR5cGVQYXJhbWV0ZXJzLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSk7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShyZXN1bHQsIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKChfYXJyb3dFeHByZXNzaW9uJGV4dHIgPSBhcnJvd0V4cHJlc3Npb24uZXh0cmEpICE9IG51bGwgJiYgX2Fycm93RXhwcmVzc2lvbiRleHRyLnBhcmVudGhlc2l6ZWQpIGFib3J0KCk7XG4gICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLm1heWJlVW53cmFwVHlwZUNhc3RFeHByZXNzaW9uKGFycm93RXhwcmVzc2lvbik7XG4gICAgICAgIGlmIChleHByLnR5cGUgIT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIikgYWJvcnQoKTtcbiAgICAgICAgZXhwci50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKGV4cHIsIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgcmV0dXJuIGFycm93RXhwcmVzc2lvbjtcbiAgICAgIH0sIHN0YXRlKTtcbiAgICAgIGxldCBhcnJvd0V4cHJlc3Npb24gPSBudWxsO1xuICAgICAgaWYgKGFycm93Lm5vZGUgJiYgdGhpcy5tYXliZVVud3JhcFR5cGVDYXN0RXhwcmVzc2lvbihhcnJvdy5ub2RlKS50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIpIHtcbiAgICAgICAgaWYgKCFhcnJvdy5lcnJvciAmJiAhYXJyb3cuYWJvcnRlZCkge1xuICAgICAgICAgIGlmIChhcnJvdy5ub2RlLmFzeW5jKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuVW5leHBlY3RlZFR5cGVQYXJhbWV0ZXJCZWZvcmVBc3luY0Fycm93RnVuY3Rpb24sIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycm93Lm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgYXJyb3dFeHByZXNzaW9uID0gYXJyb3cubm9kZTtcbiAgICAgIH1cbiAgICAgIGlmICgoX2pzeDIgPSBqc3gpICE9IG51bGwgJiYgX2pzeDIubm9kZSkge1xuICAgICAgICB0aGlzLnN0YXRlID0ganN4LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIGpzeC5ub2RlO1xuICAgICAgfVxuICAgICAgaWYgKGFycm93RXhwcmVzc2lvbikge1xuICAgICAgICB0aGlzLnN0YXRlID0gYXJyb3cuZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4gYXJyb3dFeHByZXNzaW9uO1xuICAgICAgfVxuICAgICAgaWYgKChfanN4MyA9IGpzeCkgIT0gbnVsbCAmJiBfanN4My50aHJvd24pIHRocm93IGpzeC5lcnJvcjtcbiAgICAgIGlmIChhcnJvdy50aHJvd24pIHRocm93IGFycm93LmVycm9yO1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShGbG93RXJyb3JzLlVuZXhwZWN0ZWRUb2tlbkFmdGVyVHlwZVBhcmFtZXRlciwgdHlwZVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSk7XG4gIH1cbiAgcGFyc2VBcnJvdyhub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkTm9Bbm9uRnVuY3Rpb25UeXBlID0gdGhpcy5zdGF0ZS5ub0Fub25GdW5jdGlvblR5cGU7XG4gICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdHlwZU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBbdHlwZU5vZGUudHlwZUFubm90YXRpb24sIG5vZGUucHJlZGljYXRlXSA9IHRoaXMuZmxvd1BhcnNlVHlwZUFuZFByZWRpY2F0ZUluaXRpYWxpc2VyKCk7XG4gICAgICAgIHRoaXMuc3RhdGUubm9Bbm9uRnVuY3Rpb25UeXBlID0gb2xkTm9Bbm9uRnVuY3Rpb25UeXBlO1xuICAgICAgICBpZiAodGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaCgxOSkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICByZXR1cm4gdHlwZU5vZGU7XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXN1bHQudGhyb3duKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgICAgbm9kZS5yZXR1cm5UeXBlID0gcmVzdWx0Lm5vZGUudHlwZUFubm90YXRpb24gPyB0aGlzLmZpbmlzaE5vZGUocmVzdWx0Lm5vZGUsIFwiVHlwZUFubm90YXRpb25cIikgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VBcnJvdyhub2RlKTtcbiAgfVxuICBzaG91bGRQYXJzZUFycm93KHBhcmFtcykge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDE0KSB8fCBzdXBlci5zaG91bGRQYXJzZUFycm93KHBhcmFtcyk7XG4gIH1cbiAgc2V0QXJyb3dGdW5jdGlvblBhcmFtZXRlcnMobm9kZSwgcGFyYW1zKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5pbmNsdWRlcyh0aGlzLm9mZnNldFRvU291cmNlUG9zKG5vZGUuc3RhcnQpKSkge1xuICAgICAgbm9kZS5wYXJhbXMgPSBwYXJhbXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcyk7XG4gICAgfVxuICB9XG4gIGNoZWNrUGFyYW1zKG5vZGUsIGFsbG93RHVwbGljYXRlcywgaXNBcnJvd0Z1bmN0aW9uLCBzdHJpY3RNb2RlQ2hhbmdlZCA9IHRydWUpIHtcbiAgICBpZiAoaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMuc3RhdGUubm9BcnJvd1BhcmFtc0NvbnZlcnNpb25BdC5pbmNsdWRlcyh0aGlzLm9mZnNldFRvU291cmNlUG9zKG5vZGUuc3RhcnQpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5pc1RoaXNQYXJhbShub2RlLnBhcmFtc1tpXSkgJiYgaSA+IDApIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLlRoaXNQYXJhbU11c3RCZUZpcnN0LCBub2RlLnBhcmFtc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLmNoZWNrUGFyYW1zKG5vZGUsIGFsbG93RHVwbGljYXRlcywgaXNBcnJvd0Z1bmN0aW9uLCBzdHJpY3RNb2RlQ2hhbmdlZCk7XG4gIH1cbiAgcGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KSB7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlUGFyZW5BbmREaXN0aW5ndWlzaEV4cHJlc3Npb24oY2FuQmVBcnJvdyAmJiAhdGhpcy5zdGF0ZS5ub0Fycm93QXQuaW5jbHVkZXModGhpcy5zb3VyY2VUb09mZnNldFBvcyh0aGlzLnN0YXRlLnN0YXJ0KSkpO1xuICB9XG4gIHBhcnNlU3Vic2NyaXB0cyhiYXNlLCBzdGFydExvYywgbm9DYWxscykge1xuICAgIGlmIChiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmIHRoaXMuc3RhdGUubm9BcnJvd0F0LmluY2x1ZGVzKHN0YXJ0TG9jLmluZGV4KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub2RlLmNhbGxlZSA9IGJhc2U7XG4gICAgICBub2RlLmFyZ3VtZW50cyA9IHN1cGVyLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoKTtcbiAgICAgIGJhc2UgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgYmFzZS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgICAgY29uc3QgYXJyb3cgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHRoaXMucGFyc2VBc3luY0Fycm93V2l0aFR5cGVQYXJhbWV0ZXJzKHN0YXJ0TG9jKSB8fCBhYm9ydCgpLCBzdGF0ZSk7XG4gICAgICBpZiAoIWFycm93LmVycm9yICYmICFhcnJvdy5hYm9ydGVkKSByZXR1cm4gYXJyb3cubm9kZTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHJ5UGFyc2UoKCkgPT4gc3VwZXIucGFyc2VTdWJzY3JpcHRzKGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzKSwgc3RhdGUpO1xuICAgICAgaWYgKHJlc3VsdC5ub2RlICYmICFyZXN1bHQuZXJyb3IpIHJldHVybiByZXN1bHQubm9kZTtcbiAgICAgIGlmIChhcnJvdy5ub2RlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBhcnJvdy5mYWlsU3RhdGU7XG4gICAgICAgIHJldHVybiBhcnJvdy5ub2RlO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5ub2RlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSByZXN1bHQuZmFpbFN0YXRlO1xuICAgICAgICByZXR1cm4gcmVzdWx0Lm5vZGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBhcnJvdy5lcnJvciB8fCByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZVN1YnNjcmlwdHMoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMpO1xuICB9XG4gIHBhcnNlU3Vic2NyaXB0KGJhc2UsIHN0YXJ0TG9jLCBub0NhbGxzLCBzdWJzY3JpcHRTdGF0ZSkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE4KSAmJiB0aGlzLmlzTG9va2FoZWFkVG9rZW5fbHQoKSkge1xuICAgICAgc3Vic2NyaXB0U3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlciA9IHRydWU7XG4gICAgICBpZiAobm9DYWxscykge1xuICAgICAgICBzdWJzY3JpcHRTdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25JbkV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKCk7XG4gICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIHRydWUpO1xuICAgIH0gZWxzZSBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5zaG91bGRQYXJzZVR5cGVzKCkgJiYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goNTEpKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy50cnlQYXJzZSgoKSA9PiB7XG4gICAgICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRoaXMuZmxvd1BhcnNlVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25DYWxsT3JOZXcoKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTApO1xuICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHN1cGVyLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoKTtcbiAgICAgICAgaWYgKHN1YnNjcmlwdFN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpIHtcbiAgICAgICAgICBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgc3Vic2NyaXB0U3RhdGUub3B0aW9uYWxDaGFpbk1lbWJlcik7XG4gICAgICB9KTtcbiAgICAgIGlmIChyZXN1bHQubm9kZSkge1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB0aGlzLnN0YXRlID0gcmVzdWx0LmZhaWxTdGF0ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5ub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN1YnNjcmlwdFN0YXRlKTtcbiAgfVxuICBwYXJzZU5ld0NhbGxlZShub2RlKSB7XG4gICAgc3VwZXIucGFyc2VOZXdDYWxsZWUobm9kZSk7XG4gICAgbGV0IHRhcmdzID0gbnVsbDtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZVR5cGVzKCkgJiYgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHRhcmdzID0gdGhpcy50cnlQYXJzZSgoKSA9PiB0aGlzLmZsb3dQYXJzZVR5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uQ2FsbE9yTmV3KCkpLm5vZGU7XG4gICAgfVxuICAgIG5vZGUudHlwZUFyZ3VtZW50cyA9IHRhcmdzO1xuICB9XG4gIHBhcnNlQXN5bmNBcnJvd1dpdGhUeXBlUGFyYW1ldGVycyhzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgZmFsc2UpO1xuICAgIGlmICghdGhpcy5wYXJzZUFycm93KG5vZGUpKSByZXR1cm47XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbiAgcmVhZFRva2VuX211bHRfbW9kdWxvKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNvZGUgPT09IDQyICYmIG5leHQgPT09IDQ3ICYmIHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQpIHtcbiAgICAgIHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQgPSBmYWxzZTtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSk7XG4gIH1cbiAgcmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKGNvZGUgPT09IDEyNCAmJiBuZXh0ID09PSAxMjUpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoOSwgMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYWRUb2tlbl9waXBlX2FtcChjb2RlKTtcbiAgfVxuICBwYXJzZVRvcExldmVsKGZpbGUsIHByb2dyYW0pIHtcbiAgICBjb25zdCBmaWxlTm9kZSA9IHN1cGVyLnBhcnNlVG9wTGV2ZWwoZmlsZSwgcHJvZ3JhbSk7XG4gICAgaWYgKHRoaXMuc3RhdGUuaGFzRmxvd0NvbW1lbnQpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5VbnRlcm1pbmF0ZWRGbG93Q29tbWVudCwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVOb2RlO1xuICB9XG4gIHNraXBCbG9ja0NvbW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZmxvd0NvbW1lbnRzXCIpICYmIHRoaXMuc2tpcEZsb3dDb21tZW50KCkpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50KSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRmxvd0Vycm9ycy5OZXN0ZWRGbG93Q29tbWVudCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhhc0Zsb3dDb21tZW50Q29tcGxldGlvbigpO1xuICAgICAgY29uc3QgY29tbWVudFNraXAgPSB0aGlzLnNraXBGbG93Q29tbWVudCgpO1xuICAgICAgaWYgKGNvbW1lbnRTa2lwKSB7XG4gICAgICAgIHRoaXMuc3RhdGUucG9zICs9IGNvbW1lbnRTa2lwO1xuICAgICAgICB0aGlzLnN0YXRlLmhhc0Zsb3dDb21tZW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnNraXBCbG9ja0NvbW1lbnQodGhpcy5zdGF0ZS5oYXNGbG93Q29tbWVudCA/IFwiKi0vXCIgOiBcIiovXCIpO1xuICB9XG4gIHNraXBGbG93Q29tbWVudCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwb3NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBsZXQgc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSA9IDI7XG4gICAgd2hpbGUgKFszMiwgOV0uaW5jbHVkZXModGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UpKSkge1xuICAgICAgc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSsrO1xuICAgIH1cbiAgICBjb25zdCBjaDIgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIHBvcyk7XG4gICAgY29uc3QgY2gzID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyBwb3MgKyAxKTtcbiAgICBpZiAoY2gyID09PSA1OCAmJiBjaDMgPT09IDU4KSB7XG4gICAgICByZXR1cm4gc2hpZnRUb0ZpcnN0Tm9uV2hpdGVTcGFjZSArIDI7XG4gICAgfVxuICAgIGlmICh0aGlzLmlucHV0LnNsaWNlKHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyBwb3MsIHNoaWZ0VG9GaXJzdE5vbldoaXRlU3BhY2UgKyBwb3MgKyAxMikgPT09IFwiZmxvdy1pbmNsdWRlXCIpIHtcbiAgICAgIHJldHVybiBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlICsgMTI7XG4gICAgfVxuICAgIGlmIChjaDIgPT09IDU4ICYmIGNoMyAhPT0gNTgpIHtcbiAgICAgIHJldHVybiBzaGlmdFRvRmlyc3ROb25XaGl0ZVNwYWNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaGFzRmxvd0NvbW1lbnRDb21wbGV0aW9uKCkge1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihcIiovXCIsIHRoaXMuc3RhdGUucG9zKTtcbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkQ29tbWVudCwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gIH1cbiAgZmxvd0VudW1FcnJvckJvb2xlYW5NZW1iZXJOb3RJbml0aWFsaXplZChsb2MsIHtcbiAgICBlbnVtTmFtZSxcbiAgICBtZW1iZXJOYW1lXG4gIH0pIHtcbiAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bUJvb2xlYW5NZW1iZXJOb3RJbml0aWFsaXplZCwgbG9jLCB7XG4gICAgICBtZW1iZXJOYW1lLFxuICAgICAgZW51bU5hbWVcbiAgICB9KTtcbiAgfVxuICBmbG93RW51bUVycm9ySW52YWxpZE1lbWJlckluaXRpYWxpemVyKGxvYywgZW51bUNvbnRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5yYWlzZSghZW51bUNvbnRleHQuZXhwbGljaXRUeXBlID8gRmxvd0Vycm9ycy5FbnVtSW52YWxpZE1lbWJlckluaXRpYWxpemVyVW5rbm93blR5cGUgOiBlbnVtQ29udGV4dC5leHBsaWNpdFR5cGUgPT09IFwic3ltYm9sXCIgPyBGbG93RXJyb3JzLkVudW1JbnZhbGlkTWVtYmVySW5pdGlhbGl6ZXJTeW1ib2xUeXBlIDogRmxvd0Vycm9ycy5FbnVtSW52YWxpZE1lbWJlckluaXRpYWxpemVyUHJpbWFyeVR5cGUsIGxvYywgZW51bUNvbnRleHQpO1xuICB9XG4gIGZsb3dFbnVtRXJyb3JOdW1iZXJNZW1iZXJOb3RJbml0aWFsaXplZChsb2MsIGRldGFpbHMpIHtcbiAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bU51bWJlck1lbWJlck5vdEluaXRpYWxpemVkLCBsb2MsIGRldGFpbHMpO1xuICB9XG4gIGZsb3dFbnVtRXJyb3JTdHJpbmdNZW1iZXJJbmNvbnNpc3RlbnRseUluaXRpYWxpemVkKG5vZGUsIGRldGFpbHMpIHtcbiAgICB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bVN0cmluZ01lbWJlckluY29uc2lzdGVudGx5SW5pdGlhbGl6ZWQsIG5vZGUsIGRldGFpbHMpO1xuICB9XG4gIGZsb3dFbnVtTWVtYmVySW5pdCgpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgZW5kT2ZJbml0ID0gKCkgPT4gdGhpcy5tYXRjaCgxMikgfHwgdGhpcy5tYXRjaCg4KTtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUudHlwZSkge1xuICAgICAgY2FzZSAxMzU6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsID0gdGhpcy5wYXJzZU51bWVyaWNMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICAgIGlmIChlbmRPZkluaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgbG9jOiBsaXRlcmFsLmxvYy5zdGFydCxcbiAgICAgICAgICAgICAgdmFsdWU6IGxpdGVyYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImludmFsaWRcIixcbiAgICAgICAgICAgIGxvYzogc3RhcnRMb2NcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICBjYXNlIDEzNDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGxpdGVyYWwgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgICAgICBpZiAoZW5kT2ZJbml0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIGxvYzogbGl0ZXJhbC5sb2Muc3RhcnQsXG4gICAgICAgICAgICAgIHZhbHVlOiBsaXRlcmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgICBsb2M6IHN0YXJ0TG9jXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA4NTpcbiAgICAgIGNhc2UgODY6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsaXRlcmFsID0gdGhpcy5wYXJzZUJvb2xlYW5MaXRlcmFsKHRoaXMubWF0Y2goODUpKTtcbiAgICAgICAgICBpZiAoZW5kT2ZJbml0KCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICBsb2M6IGxpdGVyYWwubG9jLnN0YXJ0LFxuICAgICAgICAgICAgICB2YWx1ZTogbGl0ZXJhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiaW52YWxpZFwiLFxuICAgICAgICAgICAgbG9jOiBzdGFydExvY1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogXCJpbnZhbGlkXCIsXG4gICAgICAgICAgbG9jOiBzdGFydExvY1xuICAgICAgICB9O1xuICAgIH1cbiAgfVxuICBmbG93RW51bU1lbWJlclJhdygpIHtcbiAgICBjb25zdCBsb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgY29uc3QgaW5pdCA9IHRoaXMuZWF0KDI5KSA/IHRoaXMuZmxvd0VudW1NZW1iZXJJbml0KCkgOiB7XG4gICAgICB0eXBlOiBcIm5vbmVcIixcbiAgICAgIGxvY1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkLFxuICAgICAgaW5pdFxuICAgIH07XG4gIH1cbiAgZmxvd0VudW1DaGVja0V4cGxpY2l0VHlwZU1pc21hdGNoKGxvYywgY29udGV4dCwgZXhwZWN0ZWRUeXBlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXhwbGljaXRUeXBlXG4gICAgfSA9IGNvbnRleHQ7XG4gICAgaWYgKGV4cGxpY2l0VHlwZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXhwbGljaXRUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgIHRoaXMuZmxvd0VudW1FcnJvckludmFsaWRNZW1iZXJJbml0aWFsaXplcihsb2MsIGNvbnRleHQpO1xuICAgIH1cbiAgfVxuICBmbG93RW51bU1lbWJlcnMoe1xuICAgIGVudW1OYW1lLFxuICAgIGV4cGxpY2l0VHlwZVxuICB9KSB7XG4gICAgY29uc3Qgc2Vlbk5hbWVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB7XG4gICAgICBib29sZWFuTWVtYmVyczogW10sXG4gICAgICBudW1iZXJNZW1iZXJzOiBbXSxcbiAgICAgIHN0cmluZ01lbWJlcnM6IFtdLFxuICAgICAgZGVmYXVsdGVkTWVtYmVyczogW11cbiAgICB9O1xuICAgIGxldCBoYXNVbmtub3duTWVtYmVycyA9IGZhbHNlO1xuICAgIHdoaWxlICghdGhpcy5tYXRjaCg4KSkge1xuICAgICAgaWYgKHRoaXMuZWF0KDIxKSkge1xuICAgICAgICBoYXNVbmtub3duTWVtYmVycyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29uc3QgbWVtYmVyTm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkLFxuICAgICAgICBpbml0XG4gICAgICB9ID0gdGhpcy5mbG93RW51bU1lbWJlclJhdygpO1xuICAgICAgY29uc3QgbWVtYmVyTmFtZSA9IGlkLm5hbWU7XG4gICAgICBpZiAobWVtYmVyTmFtZSA9PT0gXCJcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICgvXlthLXpdLy50ZXN0KG1lbWJlck5hbWUpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtSW52YWxpZE1lbWJlck5hbWUsIGlkLCB7XG4gICAgICAgICAgbWVtYmVyTmFtZSxcbiAgICAgICAgICBzdWdnZXN0aW9uOiBtZW1iZXJOYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBtZW1iZXJOYW1lLnNsaWNlKDEpLFxuICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHNlZW5OYW1lcy5oYXMobWVtYmVyTmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShGbG93RXJyb3JzLkVudW1EdXBsaWNhdGVNZW1iZXJOYW1lLCBpZCwge1xuICAgICAgICAgIG1lbWJlck5hbWUsXG4gICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzZWVuTmFtZXMuYWRkKG1lbWJlck5hbWUpO1xuICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgZW51bU5hbWUsXG4gICAgICAgIGV4cGxpY2l0VHlwZSxcbiAgICAgICAgbWVtYmVyTmFtZVxuICAgICAgfTtcbiAgICAgIG1lbWJlck5vZGUuaWQgPSBpZDtcbiAgICAgIHN3aXRjaCAoaW5pdC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5mbG93RW51bUNoZWNrRXhwbGljaXRUeXBlTWlzbWF0Y2goaW5pdC5sb2MsIGNvbnRleHQsIFwiYm9vbGVhblwiKTtcbiAgICAgICAgICAgIG1lbWJlck5vZGUuaW5pdCA9IGluaXQudmFsdWU7XG4gICAgICAgICAgICBtZW1iZXJzLmJvb2xlYW5NZW1iZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKG1lbWJlck5vZGUsIFwiRW51bUJvb2xlYW5NZW1iZXJcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5mbG93RW51bUNoZWNrRXhwbGljaXRUeXBlTWlzbWF0Y2goaW5pdC5sb2MsIGNvbnRleHQsIFwibnVtYmVyXCIpO1xuICAgICAgICAgICAgbWVtYmVyTm9kZS5pbml0ID0gaW5pdC52YWx1ZTtcbiAgICAgICAgICAgIG1lbWJlcnMubnVtYmVyTWVtYmVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShtZW1iZXJOb2RlLCBcIkVudW1OdW1iZXJNZW1iZXJcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5mbG93RW51bUNoZWNrRXhwbGljaXRUeXBlTWlzbWF0Y2goaW5pdC5sb2MsIGNvbnRleHQsIFwic3RyaW5nXCIpO1xuICAgICAgICAgICAgbWVtYmVyTm9kZS5pbml0ID0gaW5pdC52YWx1ZTtcbiAgICAgICAgICAgIG1lbWJlcnMuc3RyaW5nTWVtYmVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShtZW1iZXJOb2RlLCBcIkVudW1TdHJpbmdNZW1iZXJcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiaW52YWxpZFwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZmxvd0VudW1FcnJvckludmFsaWRNZW1iZXJJbml0aWFsaXplcihpbml0LmxvYywgY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhwbGljaXRUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5mbG93RW51bUVycm9yQm9vbGVhbk1lbWJlck5vdEluaXRpYWxpemVkKGluaXQubG9jLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgICAgIHRoaXMuZmxvd0VudW1FcnJvck51bWJlck1lbWJlck5vdEluaXRpYWxpemVkKGluaXQubG9jLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobWVtYmVyTm9kZSwgXCJFbnVtRGVmYXVsdGVkTWVtYmVyXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubWF0Y2goOCkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbWVtYmVycyxcbiAgICAgIGhhc1Vua25vd25NZW1iZXJzXG4gICAgfTtcbiAgfVxuICBmbG93RW51bVN0cmluZ01lbWJlcnMoaW5pdGlhbGl6ZWRNZW1iZXJzLCBkZWZhdWx0ZWRNZW1iZXJzLCB7XG4gICAgZW51bU5hbWVcbiAgfSkge1xuICAgIGlmIChpbml0aWFsaXplZE1lbWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdGVkTWVtYmVycztcbiAgICB9IGVsc2UgaWYgKGRlZmF1bHRlZE1lbWJlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gaW5pdGlhbGl6ZWRNZW1iZXJzO1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdGVkTWVtYmVycy5sZW5ndGggPiBpbml0aWFsaXplZE1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBpbml0aWFsaXplZE1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5mbG93RW51bUVycm9yU3RyaW5nTWVtYmVySW5jb25zaXN0ZW50bHlJbml0aWFsaXplZChtZW1iZXIsIHtcbiAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZhdWx0ZWRNZW1iZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBkZWZhdWx0ZWRNZW1iZXJzKSB7XG4gICAgICAgIHRoaXMuZmxvd0VudW1FcnJvclN0cmluZ01lbWJlckluY29uc2lzdGVudGx5SW5pdGlhbGl6ZWQobWVtYmVyLCB7XG4gICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5pdGlhbGl6ZWRNZW1iZXJzO1xuICAgIH1cbiAgfVxuICBmbG93RW51bVBhcnNlRXhwbGljaXRUeXBlKHtcbiAgICBlbnVtTmFtZVxuICB9KSB7XG4gICAgaWYgKCF0aGlzLmVhdENvbnRleHR1YWwoMTAyKSkgcmV0dXJuIG51bGw7XG4gICAgaWYgKCF0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEZsb3dFcnJvcnMuRW51bUludmFsaWRFeHBsaWNpdFR5cGVVbmtub3duU3VwcGxpZWQsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgZW51bU5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh2YWx1ZSAhPT0gXCJib29sZWFuXCIgJiYgdmFsdWUgIT09IFwibnVtYmVyXCIgJiYgdmFsdWUgIT09IFwic3RyaW5nXCIgJiYgdmFsdWUgIT09IFwic3ltYm9sXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtSW52YWxpZEV4cGxpY2l0VHlwZSwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICBlbnVtTmFtZSxcbiAgICAgICAgaW52YWxpZEVudW1UeXBlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmbG93RW51bUJvZHkobm9kZSwgaWQpIHtcbiAgICBjb25zdCBlbnVtTmFtZSA9IGlkLm5hbWU7XG4gICAgY29uc3QgbmFtZUxvYyA9IGlkLmxvYy5zdGFydDtcbiAgICBjb25zdCBleHBsaWNpdFR5cGUgPSB0aGlzLmZsb3dFbnVtUGFyc2VFeHBsaWNpdFR5cGUoe1xuICAgICAgZW51bU5hbWVcbiAgICB9KTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBjb25zdCB7XG4gICAgICBtZW1iZXJzLFxuICAgICAgaGFzVW5rbm93bk1lbWJlcnNcbiAgICB9ID0gdGhpcy5mbG93RW51bU1lbWJlcnMoe1xuICAgICAgZW51bU5hbWUsXG4gICAgICBleHBsaWNpdFR5cGVcbiAgICB9KTtcbiAgICBub2RlLmhhc1Vua25vd25NZW1iZXJzID0gaGFzVW5rbm93bk1lbWJlcnM7XG4gICAgc3dpdGNoIChleHBsaWNpdFR5cGUpIHtcbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIG5vZGUuZXhwbGljaXRUeXBlID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5ib29sZWFuTWVtYmVycztcbiAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtQm9vbGVhbkJvZHlcIik7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIG5vZGUuZXhwbGljaXRUeXBlID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5udW1iZXJNZW1iZXJzO1xuICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVudW1OdW1iZXJCb2R5XCIpO1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBub2RlLmV4cGxpY2l0VHlwZSA9IHRydWU7XG4gICAgICAgIG5vZGUubWVtYmVycyA9IHRoaXMuZmxvd0VudW1TdHJpbmdNZW1iZXJzKG1lbWJlcnMuc3RyaW5nTWVtYmVycywgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLCB7XG4gICAgICAgICAgZW51bU5hbWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bVN0cmluZ0JvZHlcIik7XG4gICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgIG5vZGUubWVtYmVycyA9IG1lbWJlcnMuZGVmYXVsdGVkTWVtYmVycztcbiAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtU3ltYm9sQm9keVwiKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBlbXB0eSA9ICgpID0+IHtcbiAgICAgICAgICAgIG5vZGUubWVtYmVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bVN0cmluZ0JvZHlcIik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBub2RlLmV4cGxpY2l0VHlwZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGJvb2xzTGVuID0gbWVtYmVycy5ib29sZWFuTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgbnVtc0xlbiA9IG1lbWJlcnMubnVtYmVyTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgY29uc3Qgc3Ryc0xlbiA9IG1lbWJlcnMuc3RyaW5nTWVtYmVycy5sZW5ndGg7XG4gICAgICAgICAgY29uc3QgZGVmYXVsdGVkTGVuID0gbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzLmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWJvb2xzTGVuICYmICFudW1zTGVuICYmICFzdHJzTGVuICYmICFkZWZhdWx0ZWRMZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWJvb2xzTGVuICYmICFudW1zTGVuKSB7XG4gICAgICAgICAgICBub2RlLm1lbWJlcnMgPSB0aGlzLmZsb3dFbnVtU3RyaW5nTWVtYmVycyhtZW1iZXJzLnN0cmluZ01lbWJlcnMsIG1lbWJlcnMuZGVmYXVsdGVkTWVtYmVycywge1xuICAgICAgICAgICAgICBlbnVtTmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtU3RyaW5nQm9keVwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFudW1zTGVuICYmICFzdHJzTGVuICYmIGJvb2xzTGVuID49IGRlZmF1bHRlZExlbikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgbWVtYmVycy5kZWZhdWx0ZWRNZW1iZXJzKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmxvd0VudW1FcnJvckJvb2xlYW5NZW1iZXJOb3RJbml0aWFsaXplZChtZW1iZXIubG9jLnN0YXJ0LCB7XG4gICAgICAgICAgICAgICAgZW51bU5hbWUsXG4gICAgICAgICAgICAgICAgbWVtYmVyTmFtZTogbWVtYmVyLmlkLm5hbWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLm1lbWJlcnMgPSBtZW1iZXJzLmJvb2xlYW5NZW1iZXJzO1xuICAgICAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bUJvb2xlYW5Cb2R5XCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWJvb2xzTGVuICYmICFzdHJzTGVuICYmIG51bXNMZW4gPj0gZGVmYXVsdGVkTGVuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiBtZW1iZXJzLmRlZmF1bHRlZE1lbWJlcnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5mbG93RW51bUVycm9yTnVtYmVyTWVtYmVyTm90SW5pdGlhbGl6ZWQobWVtYmVyLmxvYy5zdGFydCwge1xuICAgICAgICAgICAgICAgIGVudW1OYW1lLFxuICAgICAgICAgICAgICAgIG1lbWJlck5hbWU6IG1lbWJlci5pZC5uYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5tZW1iZXJzID0gbWVtYmVycy5udW1iZXJNZW1iZXJzO1xuICAgICAgICAgICAgdGhpcy5leHBlY3QoOCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW51bU51bWJlckJvZHlcIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRmxvd0Vycm9ycy5FbnVtSW5jb25zaXN0ZW50TWVtYmVyVmFsdWVzLCBuYW1lTG9jLCB7XG4gICAgICAgICAgICAgIGVudW1OYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBlbXB0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBmbG93UGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICBub2RlLmlkID0gaWQ7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy5mbG93RW51bUJvZHkodGhpcy5zdGFydE5vZGUoKSwgaWQpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFbnVtRGVjbGFyYXRpb25cIik7XG4gIH1cbiAganN4UGFyc2VPcGVuaW5nRWxlbWVudEFmdGVyTmFtZShub2RlKSB7XG4gICAgaWYgKHRoaXMuc2hvdWxkUGFyc2VUeXBlcygpKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCg1MSkpIHtcbiAgICAgICAgbm9kZS50eXBlQXJndW1lbnRzID0gdGhpcy5mbG93UGFyc2VUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvbkluRXhwcmVzc2lvbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuanN4UGFyc2VPcGVuaW5nRWxlbWVudEFmdGVyTmFtZShub2RlKTtcbiAgfVxuICBpc0xvb2thaGVhZFRva2VuX2x0KCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KSA9PT0gNjApIHtcbiAgICAgIGNvbnN0IGFmdGVyTmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0ICsgMSk7XG4gICAgICByZXR1cm4gYWZ0ZXJOZXh0ICE9PSA2MCAmJiBhZnRlck5leHQgIT09IDYxO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVTY2FuX2x0X2d0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gNDcpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDE7XG4gICAgICB0aGlzLnJlYWRUb2tlbl9sdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNDgpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDE7XG4gICAgICB0aGlzLnJlYWRUb2tlbl9ndCgpO1xuICAgIH1cbiAgfVxuICByZVNjYW5fbHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSA1MSkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgLT0gMjtcbiAgICAgIHRoaXMuZmluaXNoT3AoNDcsIDEpO1xuICAgICAgcmV0dXJuIDQ3O1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBtYXliZVVud3JhcFR5cGVDYXN0RXhwcmVzc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJUeXBlQ2FzdEV4cHJlc3Npb25cIiA/IG5vZGUuZXhwcmVzc2lvbiA6IG5vZGU7XG4gIH1cbn07XG5jb25zdCBlbnRpdGllcyA9IHtcbiAgX19wcm90b19fOiBudWxsLFxuICBxdW90OiBcIlxcdTAwMjJcIixcbiAgYW1wOiBcIiZcIixcbiAgYXBvczogXCJcXHUwMDI3XCIsXG4gIGx0OiBcIjxcIixcbiAgZ3Q6IFwiPlwiLFxuICBuYnNwOiBcIlxcdTAwQTBcIixcbiAgaWV4Y2w6IFwiXFx1MDBBMVwiLFxuICBjZW50OiBcIlxcdTAwQTJcIixcbiAgcG91bmQ6IFwiXFx1MDBBM1wiLFxuICBjdXJyZW46IFwiXFx1MDBBNFwiLFxuICB5ZW46IFwiXFx1MDBBNVwiLFxuICBicnZiYXI6IFwiXFx1MDBBNlwiLFxuICBzZWN0OiBcIlxcdTAwQTdcIixcbiAgdW1sOiBcIlxcdTAwQThcIixcbiAgY29weTogXCJcXHUwMEE5XCIsXG4gIG9yZGY6IFwiXFx1MDBBQVwiLFxuICBsYXF1bzogXCJcXHUwMEFCXCIsXG4gIG5vdDogXCJcXHUwMEFDXCIsXG4gIHNoeTogXCJcXHUwMEFEXCIsXG4gIHJlZzogXCJcXHUwMEFFXCIsXG4gIG1hY3I6IFwiXFx1MDBBRlwiLFxuICBkZWc6IFwiXFx1MDBCMFwiLFxuICBwbHVzbW46IFwiXFx1MDBCMVwiLFxuICBzdXAyOiBcIlxcdTAwQjJcIixcbiAgc3VwMzogXCJcXHUwMEIzXCIsXG4gIGFjdXRlOiBcIlxcdTAwQjRcIixcbiAgbWljcm86IFwiXFx1MDBCNVwiLFxuICBwYXJhOiBcIlxcdTAwQjZcIixcbiAgbWlkZG90OiBcIlxcdTAwQjdcIixcbiAgY2VkaWw6IFwiXFx1MDBCOFwiLFxuICBzdXAxOiBcIlxcdTAwQjlcIixcbiAgb3JkbTogXCJcXHUwMEJBXCIsXG4gIHJhcXVvOiBcIlxcdTAwQkJcIixcbiAgZnJhYzE0OiBcIlxcdTAwQkNcIixcbiAgZnJhYzEyOiBcIlxcdTAwQkRcIixcbiAgZnJhYzM0OiBcIlxcdTAwQkVcIixcbiAgaXF1ZXN0OiBcIlxcdTAwQkZcIixcbiAgQWdyYXZlOiBcIlxcdTAwQzBcIixcbiAgQWFjdXRlOiBcIlxcdTAwQzFcIixcbiAgQWNpcmM6IFwiXFx1MDBDMlwiLFxuICBBdGlsZGU6IFwiXFx1MDBDM1wiLFxuICBBdW1sOiBcIlxcdTAwQzRcIixcbiAgQXJpbmc6IFwiXFx1MDBDNVwiLFxuICBBRWxpZzogXCJcXHUwMEM2XCIsXG4gIENjZWRpbDogXCJcXHUwMEM3XCIsXG4gIEVncmF2ZTogXCJcXHUwMEM4XCIsXG4gIEVhY3V0ZTogXCJcXHUwMEM5XCIsXG4gIEVjaXJjOiBcIlxcdTAwQ0FcIixcbiAgRXVtbDogXCJcXHUwMENCXCIsXG4gIElncmF2ZTogXCJcXHUwMENDXCIsXG4gIElhY3V0ZTogXCJcXHUwMENEXCIsXG4gIEljaXJjOiBcIlxcdTAwQ0VcIixcbiAgSXVtbDogXCJcXHUwMENGXCIsXG4gIEVUSDogXCJcXHUwMEQwXCIsXG4gIE50aWxkZTogXCJcXHUwMEQxXCIsXG4gIE9ncmF2ZTogXCJcXHUwMEQyXCIsXG4gIE9hY3V0ZTogXCJcXHUwMEQzXCIsXG4gIE9jaXJjOiBcIlxcdTAwRDRcIixcbiAgT3RpbGRlOiBcIlxcdTAwRDVcIixcbiAgT3VtbDogXCJcXHUwMEQ2XCIsXG4gIHRpbWVzOiBcIlxcdTAwRDdcIixcbiAgT3NsYXNoOiBcIlxcdTAwRDhcIixcbiAgVWdyYXZlOiBcIlxcdTAwRDlcIixcbiAgVWFjdXRlOiBcIlxcdTAwREFcIixcbiAgVWNpcmM6IFwiXFx1MDBEQlwiLFxuICBVdW1sOiBcIlxcdTAwRENcIixcbiAgWWFjdXRlOiBcIlxcdTAwRERcIixcbiAgVEhPUk46IFwiXFx1MDBERVwiLFxuICBzemxpZzogXCJcXHUwMERGXCIsXG4gIGFncmF2ZTogXCJcXHUwMEUwXCIsXG4gIGFhY3V0ZTogXCJcXHUwMEUxXCIsXG4gIGFjaXJjOiBcIlxcdTAwRTJcIixcbiAgYXRpbGRlOiBcIlxcdTAwRTNcIixcbiAgYXVtbDogXCJcXHUwMEU0XCIsXG4gIGFyaW5nOiBcIlxcdTAwRTVcIixcbiAgYWVsaWc6IFwiXFx1MDBFNlwiLFxuICBjY2VkaWw6IFwiXFx1MDBFN1wiLFxuICBlZ3JhdmU6IFwiXFx1MDBFOFwiLFxuICBlYWN1dGU6IFwiXFx1MDBFOVwiLFxuICBlY2lyYzogXCJcXHUwMEVBXCIsXG4gIGV1bWw6IFwiXFx1MDBFQlwiLFxuICBpZ3JhdmU6IFwiXFx1MDBFQ1wiLFxuICBpYWN1dGU6IFwiXFx1MDBFRFwiLFxuICBpY2lyYzogXCJcXHUwMEVFXCIsXG4gIGl1bWw6IFwiXFx1MDBFRlwiLFxuICBldGg6IFwiXFx1MDBGMFwiLFxuICBudGlsZGU6IFwiXFx1MDBGMVwiLFxuICBvZ3JhdmU6IFwiXFx1MDBGMlwiLFxuICBvYWN1dGU6IFwiXFx1MDBGM1wiLFxuICBvY2lyYzogXCJcXHUwMEY0XCIsXG4gIG90aWxkZTogXCJcXHUwMEY1XCIsXG4gIG91bWw6IFwiXFx1MDBGNlwiLFxuICBkaXZpZGU6IFwiXFx1MDBGN1wiLFxuICBvc2xhc2g6IFwiXFx1MDBGOFwiLFxuICB1Z3JhdmU6IFwiXFx1MDBGOVwiLFxuICB1YWN1dGU6IFwiXFx1MDBGQVwiLFxuICB1Y2lyYzogXCJcXHUwMEZCXCIsXG4gIHV1bWw6IFwiXFx1MDBGQ1wiLFxuICB5YWN1dGU6IFwiXFx1MDBGRFwiLFxuICB0aG9ybjogXCJcXHUwMEZFXCIsXG4gIHl1bWw6IFwiXFx1MDBGRlwiLFxuICBPRWxpZzogXCJcXHUwMTUyXCIsXG4gIG9lbGlnOiBcIlxcdTAxNTNcIixcbiAgU2Nhcm9uOiBcIlxcdTAxNjBcIixcbiAgc2Nhcm9uOiBcIlxcdTAxNjFcIixcbiAgWXVtbDogXCJcXHUwMTc4XCIsXG4gIGZub2Y6IFwiXFx1MDE5MlwiLFxuICBjaXJjOiBcIlxcdTAyQzZcIixcbiAgdGlsZGU6IFwiXFx1MDJEQ1wiLFxuICBBbHBoYTogXCJcXHUwMzkxXCIsXG4gIEJldGE6IFwiXFx1MDM5MlwiLFxuICBHYW1tYTogXCJcXHUwMzkzXCIsXG4gIERlbHRhOiBcIlxcdTAzOTRcIixcbiAgRXBzaWxvbjogXCJcXHUwMzk1XCIsXG4gIFpldGE6IFwiXFx1MDM5NlwiLFxuICBFdGE6IFwiXFx1MDM5N1wiLFxuICBUaGV0YTogXCJcXHUwMzk4XCIsXG4gIElvdGE6IFwiXFx1MDM5OVwiLFxuICBLYXBwYTogXCJcXHUwMzlBXCIsXG4gIExhbWJkYTogXCJcXHUwMzlCXCIsXG4gIE11OiBcIlxcdTAzOUNcIixcbiAgTnU6IFwiXFx1MDM5RFwiLFxuICBYaTogXCJcXHUwMzlFXCIsXG4gIE9taWNyb246IFwiXFx1MDM5RlwiLFxuICBQaTogXCJcXHUwM0EwXCIsXG4gIFJobzogXCJcXHUwM0ExXCIsXG4gIFNpZ21hOiBcIlxcdTAzQTNcIixcbiAgVGF1OiBcIlxcdTAzQTRcIixcbiAgVXBzaWxvbjogXCJcXHUwM0E1XCIsXG4gIFBoaTogXCJcXHUwM0E2XCIsXG4gIENoaTogXCJcXHUwM0E3XCIsXG4gIFBzaTogXCJcXHUwM0E4XCIsXG4gIE9tZWdhOiBcIlxcdTAzQTlcIixcbiAgYWxwaGE6IFwiXFx1MDNCMVwiLFxuICBiZXRhOiBcIlxcdTAzQjJcIixcbiAgZ2FtbWE6IFwiXFx1MDNCM1wiLFxuICBkZWx0YTogXCJcXHUwM0I0XCIsXG4gIGVwc2lsb246IFwiXFx1MDNCNVwiLFxuICB6ZXRhOiBcIlxcdTAzQjZcIixcbiAgZXRhOiBcIlxcdTAzQjdcIixcbiAgdGhldGE6IFwiXFx1MDNCOFwiLFxuICBpb3RhOiBcIlxcdTAzQjlcIixcbiAga2FwcGE6IFwiXFx1MDNCQVwiLFxuICBsYW1iZGE6IFwiXFx1MDNCQlwiLFxuICBtdTogXCJcXHUwM0JDXCIsXG4gIG51OiBcIlxcdTAzQkRcIixcbiAgeGk6IFwiXFx1MDNCRVwiLFxuICBvbWljcm9uOiBcIlxcdTAzQkZcIixcbiAgcGk6IFwiXFx1MDNDMFwiLFxuICByaG86IFwiXFx1MDNDMVwiLFxuICBzaWdtYWY6IFwiXFx1MDNDMlwiLFxuICBzaWdtYTogXCJcXHUwM0MzXCIsXG4gIHRhdTogXCJcXHUwM0M0XCIsXG4gIHVwc2lsb246IFwiXFx1MDNDNVwiLFxuICBwaGk6IFwiXFx1MDNDNlwiLFxuICBjaGk6IFwiXFx1MDNDN1wiLFxuICBwc2k6IFwiXFx1MDNDOFwiLFxuICBvbWVnYTogXCJcXHUwM0M5XCIsXG4gIHRoZXRhc3ltOiBcIlxcdTAzRDFcIixcbiAgdXBzaWg6IFwiXFx1MDNEMlwiLFxuICBwaXY6IFwiXFx1MDNENlwiLFxuICBlbnNwOiBcIlxcdTIwMDJcIixcbiAgZW1zcDogXCJcXHUyMDAzXCIsXG4gIHRoaW5zcDogXCJcXHUyMDA5XCIsXG4gIHp3bmo6IFwiXFx1MjAwQ1wiLFxuICB6d2o6IFwiXFx1MjAwRFwiLFxuICBscm06IFwiXFx1MjAwRVwiLFxuICBybG06IFwiXFx1MjAwRlwiLFxuICBuZGFzaDogXCJcXHUyMDEzXCIsXG4gIG1kYXNoOiBcIlxcdTIwMTRcIixcbiAgbHNxdW86IFwiXFx1MjAxOFwiLFxuICByc3F1bzogXCJcXHUyMDE5XCIsXG4gIHNicXVvOiBcIlxcdTIwMUFcIixcbiAgbGRxdW86IFwiXFx1MjAxQ1wiLFxuICByZHF1bzogXCJcXHUyMDFEXCIsXG4gIGJkcXVvOiBcIlxcdTIwMUVcIixcbiAgZGFnZ2VyOiBcIlxcdTIwMjBcIixcbiAgRGFnZ2VyOiBcIlxcdTIwMjFcIixcbiAgYnVsbDogXCJcXHUyMDIyXCIsXG4gIGhlbGxpcDogXCJcXHUyMDI2XCIsXG4gIHBlcm1pbDogXCJcXHUyMDMwXCIsXG4gIHByaW1lOiBcIlxcdTIwMzJcIixcbiAgUHJpbWU6IFwiXFx1MjAzM1wiLFxuICBsc2FxdW86IFwiXFx1MjAzOVwiLFxuICByc2FxdW86IFwiXFx1MjAzQVwiLFxuICBvbGluZTogXCJcXHUyMDNFXCIsXG4gIGZyYXNsOiBcIlxcdTIwNDRcIixcbiAgZXVybzogXCJcXHUyMEFDXCIsXG4gIGltYWdlOiBcIlxcdTIxMTFcIixcbiAgd2VpZXJwOiBcIlxcdTIxMThcIixcbiAgcmVhbDogXCJcXHUyMTFDXCIsXG4gIHRyYWRlOiBcIlxcdTIxMjJcIixcbiAgYWxlZnN5bTogXCJcXHUyMTM1XCIsXG4gIGxhcnI6IFwiXFx1MjE5MFwiLFxuICB1YXJyOiBcIlxcdTIxOTFcIixcbiAgcmFycjogXCJcXHUyMTkyXCIsXG4gIGRhcnI6IFwiXFx1MjE5M1wiLFxuICBoYXJyOiBcIlxcdTIxOTRcIixcbiAgY3JhcnI6IFwiXFx1MjFCNVwiLFxuICBsQXJyOiBcIlxcdTIxRDBcIixcbiAgdUFycjogXCJcXHUyMUQxXCIsXG4gIHJBcnI6IFwiXFx1MjFEMlwiLFxuICBkQXJyOiBcIlxcdTIxRDNcIixcbiAgaEFycjogXCJcXHUyMUQ0XCIsXG4gIGZvcmFsbDogXCJcXHUyMjAwXCIsXG4gIHBhcnQ6IFwiXFx1MjIwMlwiLFxuICBleGlzdDogXCJcXHUyMjAzXCIsXG4gIGVtcHR5OiBcIlxcdTIyMDVcIixcbiAgbmFibGE6IFwiXFx1MjIwN1wiLFxuICBpc2luOiBcIlxcdTIyMDhcIixcbiAgbm90aW46IFwiXFx1MjIwOVwiLFxuICBuaTogXCJcXHUyMjBCXCIsXG4gIHByb2Q6IFwiXFx1MjIwRlwiLFxuICBzdW06IFwiXFx1MjIxMVwiLFxuICBtaW51czogXCJcXHUyMjEyXCIsXG4gIGxvd2FzdDogXCJcXHUyMjE3XCIsXG4gIHJhZGljOiBcIlxcdTIyMUFcIixcbiAgcHJvcDogXCJcXHUyMjFEXCIsXG4gIGluZmluOiBcIlxcdTIyMUVcIixcbiAgYW5nOiBcIlxcdTIyMjBcIixcbiAgYW5kOiBcIlxcdTIyMjdcIixcbiAgb3I6IFwiXFx1MjIyOFwiLFxuICBjYXA6IFwiXFx1MjIyOVwiLFxuICBjdXA6IFwiXFx1MjIyQVwiLFxuICBpbnQ6IFwiXFx1MjIyQlwiLFxuICB0aGVyZTQ6IFwiXFx1MjIzNFwiLFxuICBzaW06IFwiXFx1MjIzQ1wiLFxuICBjb25nOiBcIlxcdTIyNDVcIixcbiAgYXN5bXA6IFwiXFx1MjI0OFwiLFxuICBuZTogXCJcXHUyMjYwXCIsXG4gIGVxdWl2OiBcIlxcdTIyNjFcIixcbiAgbGU6IFwiXFx1MjI2NFwiLFxuICBnZTogXCJcXHUyMjY1XCIsXG4gIHN1YjogXCJcXHUyMjgyXCIsXG4gIHN1cDogXCJcXHUyMjgzXCIsXG4gIG5zdWI6IFwiXFx1MjI4NFwiLFxuICBzdWJlOiBcIlxcdTIyODZcIixcbiAgc3VwZTogXCJcXHUyMjg3XCIsXG4gIG9wbHVzOiBcIlxcdTIyOTVcIixcbiAgb3RpbWVzOiBcIlxcdTIyOTdcIixcbiAgcGVycDogXCJcXHUyMkE1XCIsXG4gIHNkb3Q6IFwiXFx1MjJDNVwiLFxuICBsY2VpbDogXCJcXHUyMzA4XCIsXG4gIHJjZWlsOiBcIlxcdTIzMDlcIixcbiAgbGZsb29yOiBcIlxcdTIzMEFcIixcbiAgcmZsb29yOiBcIlxcdTIzMEJcIixcbiAgbGFuZzogXCJcXHUyMzI5XCIsXG4gIHJhbmc6IFwiXFx1MjMyQVwiLFxuICBsb3o6IFwiXFx1MjVDQVwiLFxuICBzcGFkZXM6IFwiXFx1MjY2MFwiLFxuICBjbHViczogXCJcXHUyNjYzXCIsXG4gIGhlYXJ0czogXCJcXHUyNjY1XCIsXG4gIGRpYW1zOiBcIlxcdTI2NjZcIlxufTtcbmNvbnN0IGxpbmVCcmVhayA9IC9cXHJcXG58W1xcclxcblxcdTIwMjhcXHUyMDI5XS87XG5jb25zdCBsaW5lQnJlYWtHID0gbmV3IFJlZ0V4cChsaW5lQnJlYWsuc291cmNlLCBcImdcIik7XG5mdW5jdGlvbiBpc05ld0xpbmUoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDEwOlxuICAgIGNhc2UgMTM6XG4gICAgY2FzZSA4MjMyOlxuICAgIGNhc2UgODIzMzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGhhc05ld0xpbmUoaW5wdXQsIHN0YXJ0LCBlbmQpIHtcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoaXNOZXdMaW5lKGlucHV0LmNoYXJDb2RlQXQoaSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3Qgc2tpcFdoaXRlU3BhY2UgPSAvKD86XFxzfFxcL1xcLy4qfFxcL1xcKlteXSo/XFwqXFwvKSovZztcbmNvbnN0IHNraXBXaGl0ZVNwYWNlSW5MaW5lID0gLyg/OlteXFxTXFxuXFxyXFx1MjAyOFxcdTIwMjldfFxcL1xcLy4qfFxcL1xcKi4qP1xcKlxcLykqL2c7XG5mdW5jdGlvbiBpc1doaXRlc3BhY2UoY29kZSkge1xuICBzd2l0Y2ggKGNvZGUpIHtcbiAgICBjYXNlIDB4MDAwOTpcbiAgICBjYXNlIDB4MDAwYjpcbiAgICBjYXNlIDB4MDAwYzpcbiAgICBjYXNlIDMyOlxuICAgIGNhc2UgMTYwOlxuICAgIGNhc2UgNTc2MDpcbiAgICBjYXNlIDB4MjAwMDpcbiAgICBjYXNlIDB4MjAwMTpcbiAgICBjYXNlIDB4MjAwMjpcbiAgICBjYXNlIDB4MjAwMzpcbiAgICBjYXNlIDB4MjAwNDpcbiAgICBjYXNlIDB4MjAwNTpcbiAgICBjYXNlIDB4MjAwNjpcbiAgICBjYXNlIDB4MjAwNzpcbiAgICBjYXNlIDB4MjAwODpcbiAgICBjYXNlIDB4MjAwOTpcbiAgICBjYXNlIDB4MjAwYTpcbiAgICBjYXNlIDB4MjAyZjpcbiAgICBjYXNlIDB4MjA1ZjpcbiAgICBjYXNlIDB4MzAwMDpcbiAgICBjYXNlIDB4ZmVmZjpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNvbnN0IEpzeEVycm9ycyA9IFBhcnNlRXJyb3JFbnVtYGpzeGAoe1xuICBBdHRyaWJ1dGVJc0VtcHR5OiBcIkpTWCBhdHRyaWJ1dGVzIG11c3Qgb25seSBiZSBhc3NpZ25lZCBhIG5vbi1lbXB0eSBleHByZXNzaW9uLlwiLFxuICBNaXNzaW5nQ2xvc2luZ1RhZ0VsZW1lbnQ6ICh7XG4gICAgb3BlbmluZ1RhZ05hbWVcbiAgfSkgPT4gYEV4cGVjdGVkIGNvcnJlc3BvbmRpbmcgSlNYIGNsb3NpbmcgdGFnIGZvciA8JHtvcGVuaW5nVGFnTmFtZX0+LmAsXG4gIE1pc3NpbmdDbG9zaW5nVGFnRnJhZ21lbnQ6IFwiRXhwZWN0ZWQgY29ycmVzcG9uZGluZyBKU1ggY2xvc2luZyB0YWcgZm9yIDw+LlwiLFxuICBVbmV4cGVjdGVkU2VxdWVuY2VFeHByZXNzaW9uOiBcIlNlcXVlbmNlIGV4cHJlc3Npb25zIGNhbm5vdCBiZSBkaXJlY3RseSBuZXN0ZWQgaW5zaWRlIEpTWC4gRGlkIHlvdSBtZWFuIHRvIHdyYXAgaXQgaW4gcGFyZW50aGVzZXMgKC4uLik/XCIsXG4gIFVuZXhwZWN0ZWRUb2tlbjogKHtcbiAgICB1bmV4cGVjdGVkLFxuICAgIEhUTUxFbnRpdHlcbiAgfSkgPT4gYFVuZXhwZWN0ZWQgdG9rZW4gXFxgJHt1bmV4cGVjdGVkfVxcYC4gRGlkIHlvdSBtZWFuIFxcYCR7SFRNTEVudGl0eX1cXGAgb3IgXFxgeycke3VuZXhwZWN0ZWR9J31cXGA/YCxcbiAgVW5zdXBwb3J0ZWRKc3hWYWx1ZTogXCJKU1ggdmFsdWUgc2hvdWxkIGJlIGVpdGhlciBhbiBleHByZXNzaW9uIG9yIGEgcXVvdGVkIEpTWCB0ZXh0LlwiLFxuICBVbnRlcm1pbmF0ZWRKc3hDb250ZW50OiBcIlVudGVybWluYXRlZCBKU1ggY29udGVudHMuXCIsXG4gIFVud3JhcHBlZEFkamFjZW50SlNYRWxlbWVudHM6IFwiQWRqYWNlbnQgSlNYIGVsZW1lbnRzIG11c3QgYmUgd3JhcHBlZCBpbiBhbiBlbmNsb3NpbmcgdGFnLiBEaWQgeW91IHdhbnQgYSBKU1ggZnJhZ21lbnQgPD4uLi48Lz4/XCJcbn0pO1xuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA/IG9iamVjdC50eXBlID09PSBcIkpTWE9wZW5pbmdGcmFnbWVudFwiIHx8IG9iamVjdC50eXBlID09PSBcIkpTWENsb3NpbmdGcmFnbWVudFwiIDogZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9iamVjdCkge1xuICBpZiAob2JqZWN0LnR5cGUgPT09IFwiSlNYSWRlbnRpZmllclwiKSB7XG4gICAgcmV0dXJuIG9iamVjdC5uYW1lO1xuICB9XG4gIGlmIChvYmplY3QudHlwZSA9PT0gXCJKU1hOYW1lc3BhY2VkTmFtZVwiKSB7XG4gICAgcmV0dXJuIG9iamVjdC5uYW1lc3BhY2UubmFtZSArIFwiOlwiICsgb2JqZWN0Lm5hbWUubmFtZTtcbiAgfVxuICBpZiAob2JqZWN0LnR5cGUgPT09IFwiSlNYTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgcmV0dXJuIGdldFF1YWxpZmllZEpTWE5hbWUob2JqZWN0Lm9iamVjdCkgKyBcIi5cIiArIGdldFF1YWxpZmllZEpTWE5hbWUob2JqZWN0LnByb3BlcnR5KTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlIGhhZCB1bmV4cGVjdGVkIHR5cGU6IFwiICsgb2JqZWN0LnR5cGUpO1xufVxudmFyIGpzeCA9IHN1cGVyQ2xhc3MgPT4gY2xhc3MgSlNYUGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAganN4UmVhZFRva2VuKCkge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGxldCBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMuc3RhdGUucG9zID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoSnN4RXJyb3JzLlVudGVybWluYXRlZEpzeENvbnRlbnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlIDYwOlxuICAgICAgICBjYXNlIDEyMzpcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IHRoaXMuc3RhdGUuc3RhcnQpIHtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gNjAgJiYgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxNDMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3VwZXIuZ2V0VG9rZW5Gcm9tQ29kZShjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDE0Miwgb3V0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgb3V0ICs9IHRoaXMuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWRFbnRpdHkoKTtcbiAgICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjI6XG4gICAgICAgIGNhc2UgMTI1OlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgICAgICBvdXQgKz0gdGhpcy5qc3hSZWFkTmV3TGluZSh0cnVlKTtcbiAgICAgICAgICAgIGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGpzeFJlYWROZXdMaW5lKG5vcm1hbGl6ZUNSTEYpIHtcbiAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgbGV0IG91dDtcbiAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgIGlmIChjaCA9PT0gMTMgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKSA9PT0gMTApIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICBvdXQgPSBub3JtYWxpemVDUkxGID8gXCJcXG5cIiA6IFwiXFxyXFxuXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuICAgIH1cbiAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcbiAgICB0aGlzLnN0YXRlLmxpbmVTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAganN4UmVhZFN0cmluZyhxdW90ZSkge1xuICAgIGxldCBvdXQgPSBcIlwiO1xuICAgIGxldCBjaHVua1N0YXJ0ID0gKyt0aGlzLnN0YXRlLnBvcztcbiAgICBmb3IgKDs7KSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkU3RyaW5nLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIGlmIChjaCA9PT0gcXVvdGUpIGJyZWFrO1xuICAgICAgaWYgKGNoID09PSAzOCkge1xuICAgICAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICAgIG91dCArPSB0aGlzLmpzeFJlYWRFbnRpdHkoKTtcbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIGlmIChpc05ld0xpbmUoY2gpKSB7XG4gICAgICAgIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgb3V0ICs9IHRoaXMuanN4UmVhZE5ld0xpbmUoZmFsc2UpO1xuICAgICAgICBjaHVua1N0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuICAgIH1cbiAgICBvdXQgKz0gdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcysrKTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKDEzNCwgb3V0KTtcbiAgfVxuICBqc3hSZWFkRW50aXR5KCkge1xuICAgIGNvbnN0IHN0YXJ0UG9zID0gKyt0aGlzLnN0YXRlLnBvcztcbiAgICBpZiAodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykgPT09IDM1KSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgbGV0IHJhZGl4ID0gMTA7XG4gICAgICBpZiAodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykgPT09IDEyMCkge1xuICAgICAgICByYWRpeCA9IDE2O1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuICAgICAgY29uc3QgY29kZVBvaW50ID0gdGhpcy5yZWFkSW50KHJhZGl4LCB1bmRlZmluZWQsIGZhbHNlLCBcImJhaWxcIik7XG4gICAgICBpZiAoY29kZVBvaW50ICE9PSBudWxsICYmIHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpID09PSA1OSkge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZVBvaW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgIGxldCBzZW1pID0gZmFsc2U7XG4gICAgICB3aGlsZSAoY291bnQrKyA8IDEwICYmIHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGggJiYgIShzZW1pID0gdGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykgPT09IDU5KSkge1xuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgfVxuICAgICAgaWYgKHNlbWkpIHtcbiAgICAgICAgY29uc3QgZGVzYyA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnRQb3MsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgY29uc3QgZW50aXR5ID0gZW50aXRpZXNbZGVzY107XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIGlmIChlbnRpdHkpIHtcbiAgICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc3RhdGUucG9zID0gc3RhcnRQb3M7XG4gICAgcmV0dXJuIFwiJlwiO1xuICB9XG4gIGpzeFJlYWRXb3JkKCkge1xuICAgIGxldCBjaDtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGRvIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5zdGF0ZS5wb3MpO1xuICAgIH0gd2hpbGUgKGlzSWRlbnRpZmllckNoYXIoY2gpIHx8IGNoID09PSA0NSk7XG4gICAgdGhpcy5maW5pc2hUb2tlbigxNDEsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMuc3RhdGUucG9zKSk7XG4gIH1cbiAganN4UGFyc2VJZGVudGlmaWVyKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0aGlzLm1hdGNoKDE0MSkpIHtcbiAgICAgIG5vZGUubmFtZSA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgfSBlbHNlIGlmICh0b2tlbklzS2V5d29yZCh0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICBub2RlLm5hbWUgPSB0b2tlbkxhYmVsTmFtZSh0aGlzLnN0YXRlLnR5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWElkZW50aWZpZXJcIik7XG4gIH1cbiAganN4UGFyc2VOYW1lc3BhY2VkTmFtZSgpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuanN4UGFyc2VJZGVudGlmaWVyKCk7XG4gICAgaWYgKCF0aGlzLmVhdCgxNCkpIHJldHVybiBuYW1lO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBub2RlLm5hbWVzcGFjZSA9IG5hbWU7XG4gICAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZUlkZW50aWZpZXIoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYTmFtZXNwYWNlZE5hbWVcIik7XG4gIH1cbiAganN4UGFyc2VFbGVtZW50TmFtZSgpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGV0IG5vZGUgPSB0aGlzLmpzeFBhcnNlTmFtZXNwYWNlZE5hbWUoKTtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkpTWE5hbWVzcGFjZWROYW1lXCIpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICB3aGlsZSAodGhpcy5lYXQoMTYpKSB7XG4gICAgICBjb25zdCBuZXdOb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBuZXdOb2RlLm9iamVjdCA9IG5vZGU7XG4gICAgICBuZXdOb2RlLnByb3BlcnR5ID0gdGhpcy5qc3hQYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIG5vZGUgPSB0aGlzLmZpbmlzaE5vZGUobmV3Tm9kZSwgXCJKU1hNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBqc3hQYXJzZUF0dHJpYnV0ZVZhbHVlKCkge1xuICAgIGxldCBub2RlO1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICBjYXNlIDU6XG4gICAgICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICB0aGlzLnNldENvbnRleHQodHlwZXMuYnJhY2UpO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgbm9kZSA9IHRoaXMuanN4UGFyc2VFeHByZXNzaW9uQ29udGFpbmVyKG5vZGUsIHR5cGVzLmpfb1RhZyk7XG4gICAgICAgIGlmIChub2RlLmV4cHJlc3Npb24udHlwZSA9PT0gXCJKU1hFbXB0eUV4cHJlc3Npb25cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoSnN4RXJyb3JzLkF0dHJpYnV0ZUlzRW1wdHksIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgY2FzZSAxNDM6XG4gICAgICBjYXNlIDEzNDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByQXRvbSgpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShKc3hFcnJvcnMuVW5zdXBwb3J0ZWRKc3hWYWx1ZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICB9XG4gIGpzeFBhcnNlRW1wdHlFeHByZXNzaW9uKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KG5vZGUsIFwiSlNYRW1wdHlFeHByZXNzaW9uXCIsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICB9XG4gIGpzeFBhcnNlU3ByZWFkQ2hpbGQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgdGhpcy5zZXRDb250ZXh0KHR5cGVzLmpfZXhwcik7XG4gICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hTcHJlYWRDaGlsZFwiKTtcbiAgfVxuICBqc3hQYXJzZUV4cHJlc3Npb25Db250YWluZXIobm9kZSwgcHJldmlvdXNDb250ZXh0KSB7XG4gICAgaWYgKHRoaXMubWF0Y2goOCkpIHtcbiAgICAgIG5vZGUuZXhwcmVzc2lvbiA9IHRoaXMuanN4UGFyc2VFbXB0eUV4cHJlc3Npb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXhwcmVzc2lvbiA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSBleHByZXNzaW9uO1xuICAgIH1cbiAgICB0aGlzLnNldENvbnRleHQocHJldmlvdXNDb250ZXh0KTtcbiAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEV4cHJlc3Npb25Db250YWluZXJcIik7XG4gIH1cbiAganN4UGFyc2VBdHRyaWJ1dGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dCh0eXBlcy5icmFjZSk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuZXhwZWN0KDIxKTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICB0aGlzLnNldENvbnRleHQodHlwZXMual9vVGFnKTtcbiAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gdHJ1ZTtcbiAgICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiKTtcbiAgICB9XG4gICAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZU5hbWVzcGFjZWROYW1lKCk7XG4gICAgbm9kZS52YWx1ZSA9IHRoaXMuZWF0KDI5KSA/IHRoaXMuanN4UGFyc2VBdHRyaWJ1dGVWYWx1ZSgpIDogbnVsbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYQXR0cmlidXRlXCIpO1xuICB9XG4gIGpzeFBhcnNlT3BlbmluZ0VsZW1lbnRBdChzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBpZiAodGhpcy5lYXQoMTQ0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWE9wZW5pbmdGcmFnbWVudFwiKTtcbiAgICB9XG4gICAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZUVsZW1lbnROYW1lKCk7XG4gICAgcmV0dXJuIHRoaXMuanN4UGFyc2VPcGVuaW5nRWxlbWVudEFmdGVyTmFtZShub2RlKTtcbiAgfVxuICBqc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpIHtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gW107XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDU2KSAmJiAhdGhpcy5tYXRjaCgxNDQpKSB7XG4gICAgICBhdHRyaWJ1dGVzLnB1c2godGhpcy5qc3hQYXJzZUF0dHJpYnV0ZSgpKTtcbiAgICB9XG4gICAgbm9kZS5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgICBub2RlLnNlbGZDbG9zaW5nID0gdGhpcy5lYXQoNTYpO1xuICAgIHRoaXMuZXhwZWN0KDE0NCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWE9wZW5pbmdFbGVtZW50XCIpO1xuICB9XG4gIGpzeFBhcnNlQ2xvc2luZ0VsZW1lbnRBdChzdGFydExvYykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBpZiAodGhpcy5lYXQoMTQ0KSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWENsb3NpbmdGcmFnbWVudFwiKTtcbiAgICB9XG4gICAgbm9kZS5uYW1lID0gdGhpcy5qc3hQYXJzZUVsZW1lbnROYW1lKCk7XG4gICAgdGhpcy5leHBlY3QoMTQ0KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSlNYQ2xvc2luZ0VsZW1lbnRcIik7XG4gIH1cbiAganN4UGFyc2VFbGVtZW50QXQoc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICBjb25zdCBvcGVuaW5nRWxlbWVudCA9IHRoaXMuanN4UGFyc2VPcGVuaW5nRWxlbWVudEF0KHN0YXJ0TG9jKTtcbiAgICBsZXQgY2xvc2luZ0VsZW1lbnQgPSBudWxsO1xuICAgIGlmICghb3BlbmluZ0VsZW1lbnQuc2VsZkNsb3NpbmcpIHtcbiAgICAgIGNvbnRlbnRzOiBmb3IgKDs7KSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAxNDM6XG4gICAgICAgICAgICBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVhdCg1NikpIHtcbiAgICAgICAgICAgICAgY2xvc2luZ0VsZW1lbnQgPSB0aGlzLmpzeFBhcnNlQ2xvc2luZ0VsZW1lbnRBdChzdGFydExvYyk7XG4gICAgICAgICAgICAgIGJyZWFrIGNvbnRlbnRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmpzeFBhcnNlRWxlbWVudEF0KHN0YXJ0TG9jKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE0MjpcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGhpcy5wYXJzZUxpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSwgXCJKU1hUZXh0XCIpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgIHRoaXMuc2V0Q29udGV4dCh0eXBlcy5icmFjZSk7XG4gICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICBpZiAodGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHRoaXMuanN4UGFyc2VTcHJlYWRDaGlsZChub2RlKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmpzeFBhcnNlRXhwcmVzc2lvbkNvbnRhaW5lcihub2RlLCB0eXBlcy5qX2V4cHIpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0ZyYWdtZW50KG9wZW5pbmdFbGVtZW50KSAmJiAhaXNGcmFnbWVudChjbG9zaW5nRWxlbWVudCkgJiYgY2xvc2luZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5yYWlzZShKc3hFcnJvcnMuTWlzc2luZ0Nsb3NpbmdUYWdGcmFnbWVudCwgY2xvc2luZ0VsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICghaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkgJiYgaXNGcmFnbWVudChjbG9zaW5nRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShKc3hFcnJvcnMuTWlzc2luZ0Nsb3NpbmdUYWdFbGVtZW50LCBjbG9zaW5nRWxlbWVudCwge1xuICAgICAgICAgIG9wZW5pbmdUYWdOYW1lOiBnZXRRdWFsaWZpZWRKU1hOYW1lKG9wZW5pbmdFbGVtZW50Lm5hbWUpXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkgJiYgIWlzRnJhZ21lbnQoY2xvc2luZ0VsZW1lbnQpKSB7XG4gICAgICAgIGlmIChnZXRRdWFsaWZpZWRKU1hOYW1lKGNsb3NpbmdFbGVtZW50Lm5hbWUpICE9PSBnZXRRdWFsaWZpZWRKU1hOYW1lKG9wZW5pbmdFbGVtZW50Lm5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShKc3hFcnJvcnMuTWlzc2luZ0Nsb3NpbmdUYWdFbGVtZW50LCBjbG9zaW5nRWxlbWVudCwge1xuICAgICAgICAgICAgb3BlbmluZ1RhZ05hbWU6IGdldFF1YWxpZmllZEpTWE5hbWUob3BlbmluZ0VsZW1lbnQubmFtZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkpIHtcbiAgICAgIG5vZGUub3BlbmluZ0ZyYWdtZW50ID0gb3BlbmluZ0VsZW1lbnQ7XG4gICAgICBub2RlLmNsb3NpbmdGcmFnbWVudCA9IGNsb3NpbmdFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLm9wZW5pbmdFbGVtZW50ID0gb3BlbmluZ0VsZW1lbnQ7XG4gICAgICBub2RlLmNsb3NpbmdFbGVtZW50ID0gY2xvc2luZ0VsZW1lbnQ7XG4gICAgfVxuICAgIG5vZGUuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoSnN4RXJyb3JzLlVud3JhcHBlZEFkamFjZW50SlNYRWxlbWVudHMsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICByZXR1cm4gaXNGcmFnbWVudChvcGVuaW5nRWxlbWVudCkgPyB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJKU1hGcmFnbWVudFwiKSA6IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkpTWEVsZW1lbnRcIik7XG4gIH1cbiAganN4UGFyc2VFbGVtZW50KCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5qc3hQYXJzZUVsZW1lbnRBdChzdGFydExvYyk7XG4gIH1cbiAgc2V0Q29udGV4dChuZXdDb250ZXh0KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXSA9IG5ld0NvbnRleHQ7XG4gIH1cbiAgcGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuanN4UGFyc2VFbGVtZW50KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDQ3KSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MpICE9PSAzMykge1xuICAgICAgdGhpcy5yZXBsYWNlVG9rZW4oMTQzKTtcbiAgICAgIHJldHVybiB0aGlzLmpzeFBhcnNlRWxlbWVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICB9XG4gIH1cbiAgc2tpcFNwYWNlKCkge1xuICAgIGNvbnN0IGN1ckNvbnRleHQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgICBpZiAoIWN1ckNvbnRleHQucHJlc2VydmVTcGFjZSkgc3VwZXIuc2tpcFNwYWNlKCk7XG4gIH1cbiAgZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuY3VyQ29udGV4dCgpO1xuICAgIGlmIChjb250ZXh0ID09PSB0eXBlcy5qX2V4cHIpIHtcbiAgICAgIHRoaXMuanN4UmVhZFRva2VuKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb250ZXh0ID09PSB0eXBlcy5qX29UYWcgfHwgY29udGV4dCA9PT0gdHlwZXMual9jVGFnKSB7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSkpIHtcbiAgICAgICAgdGhpcy5qc3hSZWFkV29yZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxNDQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKGNvZGUgPT09IDM0IHx8IGNvZGUgPT09IDM5KSAmJiBjb250ZXh0ID09PSB0eXBlcy5qX29UYWcpIHtcbiAgICAgICAgdGhpcy5qc3hSZWFkU3RyaW5nKGNvZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA2MCAmJiB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSAhPT0gMzMpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDE0Myk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmdldFRva2VuRnJvbUNvZGUoY29kZSk7XG4gIH1cbiAgdXBkYXRlQ29udGV4dChwcmV2VHlwZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDU2ICYmIHByZXZUeXBlID09PSAxNDMpIHtcbiAgICAgIGNvbnRleHQuc3BsaWNlKC0yLCAyLCB0eXBlcy5qX2NUYWcpO1xuICAgICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDE0Mykge1xuICAgICAgY29udGV4dC5wdXNoKHR5cGVzLmpfb1RhZyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAxNDQpIHtcbiAgICAgIGNvbnN0IG91dCA9IGNvbnRleHRbY29udGV4dC5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChvdXQgPT09IHR5cGVzLmpfb1RhZyAmJiBwcmV2VHlwZSA9PT0gNTYgfHwgb3V0ID09PSB0eXBlcy5qX2NUYWcpIHtcbiAgICAgICAgY29udGV4dC5wb3AoKTtcbiAgICAgICAgdGhpcy5zdGF0ZS5jYW5TdGFydEpTWEVsZW1lbnQgPSBjb250ZXh0W2NvbnRleHQubGVuZ3RoIC0gMV0gPT09IHR5cGVzLmpfZXhwcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0Q29udGV4dCh0eXBlcy5qX2V4cHIpO1xuICAgICAgICB0aGlzLnN0YXRlLmNhblN0YXJ0SlNYRWxlbWVudCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gdG9rZW5Db21lc0JlZm9yZUV4cHJlc3Npb24odHlwZSk7XG4gICAgfVxuICB9XG59O1xuY2xhc3MgVHlwZVNjcmlwdFNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgdGhpcy50c05hbWVzID0gbmV3IE1hcCgpO1xuICB9XG59XG5jbGFzcyBUeXBlU2NyaXB0U2NvcGVIYW5kbGVyIGV4dGVuZHMgU2NvcGVIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuaW1wb3J0c1N0YWNrID0gW107XG4gIH1cbiAgY3JlYXRlU2NvcGUoZmxhZ3MpIHtcbiAgICB0aGlzLmltcG9ydHNTdGFjay5wdXNoKG5ldyBTZXQoKSk7XG4gICAgcmV0dXJuIG5ldyBUeXBlU2NyaXB0U2NvcGUoZmxhZ3MpO1xuICB9XG4gIGVudGVyKGZsYWdzKSB7XG4gICAgaWYgKGZsYWdzID09PSAxMDI0KSB7XG4gICAgICB0aGlzLmltcG9ydHNTdGFjay5wdXNoKG5ldyBTZXQoKSk7XG4gICAgfVxuICAgIHN1cGVyLmVudGVyKGZsYWdzKTtcbiAgfVxuICBleGl0KCkge1xuICAgIGNvbnN0IGZsYWdzID0gc3VwZXIuZXhpdCgpO1xuICAgIGlmIChmbGFncyA9PT0gMTAyNCkge1xuICAgICAgdGhpcy5pbXBvcnRzU3RhY2sucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiBmbGFncztcbiAgfVxuICBoYXNJbXBvcnQobmFtZSwgYWxsb3dTaGFkb3cpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmltcG9ydHNTdGFjay5sZW5ndGg7XG4gICAgaWYgKHRoaXMuaW1wb3J0c1N0YWNrW2xlbiAtIDFdLmhhcyhuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghYWxsb3dTaGFkb3cgJiYgbGVuID4gMSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuaW1wb3J0c1N0YWNrW2ldLmhhcyhuYW1lKSkgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBkZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKSB7XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgNDA5Nikge1xuICAgICAgaWYgKHRoaXMuaGFzSW1wb3J0KG5hbWUsIHRydWUpKSB7XG4gICAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5WYXJSZWRlY2xhcmF0aW9uLCBsb2MsIHtcbiAgICAgICAgICBpZGVudGlmaWVyTmFtZTogbmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW1wb3J0c1N0YWNrW3RoaXMuaW1wb3J0c1N0YWNrLmxlbmd0aCAtIDFdLmFkZChuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGUgPSB0aGlzLmN1cnJlbnRTY29wZSgpO1xuICAgIGxldCB0eXBlID0gc2NvcGUudHNOYW1lcy5nZXQobmFtZSkgfHwgMDtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiAxMDI0KSB7XG4gICAgICB0aGlzLm1heWJlRXhwb3J0RGVmaW5lZChzY29wZSwgbmFtZSk7XG4gICAgICBzY29wZS50c05hbWVzLnNldChuYW1lLCB0eXBlIHwgMTYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5kZWNsYXJlTmFtZShuYW1lLCBiaW5kaW5nVHlwZSwgbG9jKTtcbiAgICBpZiAoYmluZGluZ1R5cGUgJiAyKSB7XG4gICAgICBpZiAoIShiaW5kaW5nVHlwZSAmIDEpKSB7XG4gICAgICAgIHRoaXMuY2hlY2tSZWRlY2xhcmF0aW9uSW5TY29wZShzY29wZSwgbmFtZSwgYmluZGluZ1R5cGUsIGxvYyk7XG4gICAgICAgIHRoaXMubWF5YmVFeHBvcnREZWZpbmVkKHNjb3BlLCBuYW1lKTtcbiAgICAgIH1cbiAgICAgIHR5cGUgPSB0eXBlIHwgMTtcbiAgICB9XG4gICAgaWYgKGJpbmRpbmdUeXBlICYgMjU2KSB7XG4gICAgICB0eXBlID0gdHlwZSB8IDI7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nVHlwZSAmIDUxMikge1xuICAgICAgdHlwZSA9IHR5cGUgfCA0O1xuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiAxMjgpIHtcbiAgICAgIHR5cGUgPSB0eXBlIHwgODtcbiAgICB9XG4gICAgaWYgKHR5cGUpIHNjb3BlLnRzTmFtZXMuc2V0KG5hbWUsIHR5cGUpO1xuICB9XG4gIGlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKSB7XG4gICAgY29uc3QgdHlwZSA9IHNjb3BlLnRzTmFtZXMuZ2V0KG5hbWUpO1xuICAgIGlmICgodHlwZSAmIDIpID4gMCkge1xuICAgICAgaWYgKGJpbmRpbmdUeXBlICYgMjU2KSB7XG4gICAgICAgIGNvbnN0IGlzQ29uc3QgPSAhIShiaW5kaW5nVHlwZSAmIDUxMik7XG4gICAgICAgIGNvbnN0IHdhc0NvbnN0ID0gKHR5cGUgJiA0KSA+IDA7XG4gICAgICAgIHJldHVybiBpc0NvbnN0ICE9PSB3YXNDb25zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiAxMjggJiYgKHR5cGUgJiA4KSA+IDApIHtcbiAgICAgIGlmIChzY29wZS5uYW1lcy5nZXQobmFtZSkgJiAyKSB7XG4gICAgICAgIHJldHVybiAhIShiaW5kaW5nVHlwZSAmIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiAyICYmICh0eXBlICYgMSkgPiAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzUmVkZWNsYXJlZEluU2NvcGUoc2NvcGUsIG5hbWUsIGJpbmRpbmdUeXBlKTtcbiAgfVxuICBjaGVja0xvY2FsRXhwb3J0KGlkKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZVxuICAgIH0gPSBpZDtcbiAgICBpZiAodGhpcy5oYXNJbXBvcnQobmFtZSkpIHJldHVybjtcbiAgICBjb25zdCBsZW4gPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgY29uc3Qgc2NvcGUgPSB0aGlzLnNjb3BlU3RhY2tbaV07XG4gICAgICBjb25zdCB0eXBlID0gc2NvcGUudHNOYW1lcy5nZXQobmFtZSk7XG4gICAgICBpZiAoKHR5cGUgJiAxKSA+IDAgfHwgKHR5cGUgJiAxNikgPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc3VwZXIuY2hlY2tMb2NhbEV4cG9ydChpZCk7XG4gIH1cbn1cbmNsYXNzIFByb2R1Y3Rpb25QYXJhbWV0ZXJIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGFja3MgPSBbXTtcbiAgfVxuICBlbnRlcihmbGFncykge1xuICAgIHRoaXMuc3RhY2tzLnB1c2goZmxhZ3MpO1xuICB9XG4gIGV4aXQoKSB7XG4gICAgdGhpcy5zdGFja3MucG9wKCk7XG4gIH1cbiAgY3VycmVudEZsYWdzKCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrc1t0aGlzLnN0YWNrcy5sZW5ndGggLSAxXTtcbiAgfVxuICBnZXQgaGFzQXdhaXQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmN1cnJlbnRGbGFncygpICYgMikgPiAwO1xuICB9XG4gIGdldCBoYXNZaWVsZCgpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudEZsYWdzKCkgJiAxKSA+IDA7XG4gIH1cbiAgZ2V0IGhhc1JldHVybigpIHtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudEZsYWdzKCkgJiA0KSA+IDA7XG4gIH1cbiAgZ2V0IGhhc0luKCkge1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50RmxhZ3MoKSAmIDgpID4gMDtcbiAgfVxufVxuZnVuY3Rpb24gZnVuY3Rpb25GbGFncyhpc0FzeW5jLCBpc0dlbmVyYXRvcikge1xuICByZXR1cm4gKGlzQXN5bmMgPyAyIDogMCkgfCAoaXNHZW5lcmF0b3IgPyAxIDogMCk7XG59XG5jbGFzcyBCYXNlUGFyc2VyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IGZhbHNlO1xuICAgIHRoaXMuYW1iaWd1b3VzU2NyaXB0RGlmZmVyZW50QXN0ID0gZmFsc2U7XG4gIH1cbiAgc291cmNlVG9PZmZzZXRQb3Moc291cmNlUG9zKSB7XG4gICAgcmV0dXJuIHNvdXJjZVBvcyArIHRoaXMuc3RhcnRJbmRleDtcbiAgfVxuICBvZmZzZXRUb1NvdXJjZVBvcyhvZmZzZXRQb3MpIHtcbiAgICByZXR1cm4gb2Zmc2V0UG9zIC0gdGhpcy5zdGFydEluZGV4O1xuICB9XG4gIGhhc1BsdWdpbihwbHVnaW5Db25maWcpIHtcbiAgICBpZiAodHlwZW9mIHBsdWdpbkNvbmZpZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIHRoaXMucGx1Z2lucy5oYXMocGx1Z2luQ29uZmlnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgW3BsdWdpbk5hbWUsIHBsdWdpbk9wdGlvbnNdID0gcGx1Z2luQ29uZmlnO1xuICAgICAgaWYgKCF0aGlzLmhhc1BsdWdpbihwbHVnaW5OYW1lKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBhY3R1YWxPcHRpb25zID0gdGhpcy5wbHVnaW5zLmdldChwbHVnaW5OYW1lKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHBsdWdpbk9wdGlvbnMpKSB7XG4gICAgICAgIGlmICgoYWN0dWFsT3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogYWN0dWFsT3B0aW9uc1trZXldKSAhPT0gcGx1Z2luT3B0aW9uc1trZXldKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgZ2V0UGx1Z2luT3B0aW9uKHBsdWdpbiwgbmFtZSkge1xuICAgIHZhciBfdGhpcyRwbHVnaW5zJGdldDtcbiAgICByZXR1cm4gKF90aGlzJHBsdWdpbnMkZ2V0ID0gdGhpcy5wbHVnaW5zLmdldChwbHVnaW4pKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXMkcGx1Z2lucyRnZXRbbmFtZV07XG4gIH1cbn1cbmZ1bmN0aW9uIHNldFRyYWlsaW5nQ29tbWVudHMobm9kZSwgY29tbWVudHMpIHtcbiAgaWYgKG5vZGUudHJhaWxpbmdDb21tZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzID0gY29tbWVudHM7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS50cmFpbGluZ0NvbW1lbnRzLnVuc2hpZnQoLi4uY29tbWVudHMpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRMZWFkaW5nQ29tbWVudHMobm9kZSwgY29tbWVudHMpIHtcbiAgaWYgKG5vZGUubGVhZGluZ0NvbW1lbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBub2RlLmxlYWRpbmdDb21tZW50cyA9IGNvbW1lbnRzO1xuICB9IGVsc2Uge1xuICAgIG5vZGUubGVhZGluZ0NvbW1lbnRzLnVuc2hpZnQoLi4uY29tbWVudHMpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRJbm5lckNvbW1lbnRzKG5vZGUsIGNvbW1lbnRzKSB7XG4gIGlmIChub2RlLmlubmVyQ29tbWVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIG5vZGUuaW5uZXJDb21tZW50cyA9IGNvbW1lbnRzO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJDb21tZW50cy51bnNoaWZ0KC4uLmNvbW1lbnRzKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRqdXN0SW5uZXJDb21tZW50cyhub2RlLCBlbGVtZW50cywgY29tbWVudFdTKSB7XG4gIGxldCBsYXN0RWxlbWVudCA9IG51bGw7XG4gIGxldCBpID0gZWxlbWVudHMubGVuZ3RoO1xuICB3aGlsZSAobGFzdEVsZW1lbnQgPT09IG51bGwgJiYgaSA+IDApIHtcbiAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnRzWy0taV07XG4gIH1cbiAgaWYgKGxhc3RFbGVtZW50ID09PSBudWxsIHx8IGxhc3RFbGVtZW50LnN0YXJ0ID4gY29tbWVudFdTLnN0YXJ0KSB7XG4gICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjb21tZW50V1MuY29tbWVudHMpO1xuICB9IGVsc2Uge1xuICAgIHNldFRyYWlsaW5nQ29tbWVudHMobGFzdEVsZW1lbnQsIGNvbW1lbnRXUy5jb21tZW50cyk7XG4gIH1cbn1cbmNsYXNzIENvbW1lbnRzUGFyc2VyIGV4dGVuZHMgQmFzZVBhcnNlciB7XG4gIGFkZENvbW1lbnQoY29tbWVudCkge1xuICAgIGlmICh0aGlzLmZpbGVuYW1lKSBjb21tZW50LmxvYy5maWxlbmFtZSA9IHRoaXMuZmlsZW5hbWU7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWVudHNMZW5cbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodGhpcy5jb21tZW50cy5sZW5ndGggIT09IGNvbW1lbnRzTGVuKSB7XG4gICAgICB0aGlzLmNvbW1lbnRzLmxlbmd0aCA9IGNvbW1lbnRzTGVuO1xuICAgIH1cbiAgICB0aGlzLmNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgdGhpcy5zdGF0ZS5jb21tZW50c0xlbisrO1xuICB9XG4gIHByb2Nlc3NDb21tZW50KG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50U3RhY2tcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjb21tZW50U3RhY2tMZW5ndGggPSBjb21tZW50U3RhY2subGVuZ3RoO1xuICAgIGlmIChjb21tZW50U3RhY2tMZW5ndGggPT09IDApIHJldHVybjtcbiAgICBsZXQgaSA9IGNvbW1lbnRTdGFja0xlbmd0aCAtIDE7XG4gICAgY29uc3QgbGFzdENvbW1lbnRXUyA9IGNvbW1lbnRTdGFja1tpXTtcbiAgICBpZiAobGFzdENvbW1lbnRXUy5zdGFydCA9PT0gbm9kZS5lbmQpIHtcbiAgICAgIGxhc3RDb21tZW50V1MubGVhZGluZ05vZGUgPSBub2RlO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdGFydDogbm9kZVN0YXJ0XG4gICAgfSA9IG5vZGU7XG4gICAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBjb21tZW50V1MgPSBjb21tZW50U3RhY2tbaV07XG4gICAgICBjb25zdCBjb21tZW50RW5kID0gY29tbWVudFdTLmVuZDtcbiAgICAgIGlmIChjb21tZW50RW5kID4gbm9kZVN0YXJ0KSB7XG4gICAgICAgIGNvbW1lbnRXUy5jb250YWluaW5nTm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMuZmluYWxpemVDb21tZW50KGNvbW1lbnRXUyk7XG4gICAgICAgIGNvbW1lbnRTdGFjay5zcGxpY2UoaSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY29tbWVudEVuZCA9PT0gbm9kZVN0YXJ0KSB7XG4gICAgICAgICAgY29tbWVudFdTLnRyYWlsaW5nTm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmFsaXplQ29tbWVudChjb21tZW50V1MpIHtcbiAgICB2YXIgX25vZGUkb3B0aW9ucztcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50c1xuICAgIH0gPSBjb21tZW50V1M7XG4gICAgaWYgKGNvbW1lbnRXUy5sZWFkaW5nTm9kZSAhPT0gbnVsbCB8fCBjb21tZW50V1MudHJhaWxpbmdOb2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAoY29tbWVudFdTLmxlYWRpbmdOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIHNldFRyYWlsaW5nQ29tbWVudHMoY29tbWVudFdTLmxlYWRpbmdOb2RlLCBjb21tZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWVudFdTLnRyYWlsaW5nTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBzZXRMZWFkaW5nQ29tbWVudHMoY29tbWVudFdTLnRyYWlsaW5nTm9kZSwgY29tbWVudHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub2RlID0gY29tbWVudFdTLmNvbnRhaW5pbmdOb2RlO1xuICAgICAgY29uc3QgY29tbWVudFN0YXJ0ID0gY29tbWVudFdTLnN0YXJ0O1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLm9mZnNldFRvU291cmNlUG9zKGNvbW1lbnRTdGFydCkgLSAxKSA9PT0gNDQpIHtcbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiT2JqZWN0RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUucHJvcGVydGllcywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJDYWxsRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuYXJndW1lbnRzLCBjb21tZW50V1MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkltcG9ydEV4cHJlc3Npb25cIjpcbiAgICAgICAgICAgIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgW25vZGUuc291cmNlLCAoX25vZGUkb3B0aW9ucyA9IG5vZGUub3B0aW9ucykgIT0gbnVsbCA/IF9ub2RlJG9wdGlvbnMgOiBudWxsXSwgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJPYmplY3RNZXRob2RcIjpcbiAgICAgICAgICBjYXNlIFwiQ2xhc3NNZXRob2RcIjpcbiAgICAgICAgICBjYXNlIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUucGFyYW1zLCBjb21tZW50V1MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICAgIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICAgICAgICAgIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgbm9kZS5lbGVtZW50cywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgY2FzZSBcIkltcG9ydERlY2xhcmF0aW9uXCI6XG4gICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuc3BlY2lmaWVycywgY29tbWVudFdTKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJUU0VudW1EZWNsYXJhdGlvblwiOlxuICAgICAgICAgICAgYWRqdXN0SW5uZXJDb21tZW50cyhub2RlLCBub2RlLm1lbWJlcnMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiVFNFbnVtQm9keVwiOlxuICAgICAgICAgICAgYWRqdXN0SW5uZXJDb21tZW50cyhub2RlLCBub2RlLm1lbWJlcnMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSBcIlJlY29yZEV4cHJlc3Npb25cIikge1xuICAgICAgICAgICAgICAgIGFkanVzdElubmVyQ29tbWVudHMobm9kZSwgbm9kZS5wcm9wZXJ0aWVzLCBjb21tZW50V1MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09IFwiVHVwbGVFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICAgICAgICBhZGp1c3RJbm5lckNvbW1lbnRzKG5vZGUsIG5vZGUuZWxlbWVudHMsIGNvbW1lbnRXUyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjb21tZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldElubmVyQ29tbWVudHMobm9kZSwgY29tbWVudHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaW5hbGl6ZVJlbWFpbmluZ0NvbW1lbnRzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRTdGFja1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGZvciAobGV0IGkgPSBjb21tZW50U3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMuZmluYWxpemVDb21tZW50KGNvbW1lbnRTdGFja1tpXSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuY29tbWVudFN0YWNrID0gW107XG4gIH1cbiAgcmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21tZW50U3RhY2tcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGhcbiAgICB9ID0gY29tbWVudFN0YWNrO1xuICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybjtcbiAgICBjb25zdCBjb21tZW50V1MgPSBjb21tZW50U3RhY2tbbGVuZ3RoIC0gMV07XG4gICAgaWYgKGNvbW1lbnRXUy5sZWFkaW5nTm9kZSA9PT0gbm9kZSkge1xuICAgICAgY29tbWVudFdTLmxlYWRpbmdOb2RlID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgdGFrZVN1cnJvdW5kaW5nQ29tbWVudHMobm9kZSwgc3RhcnQsIGVuZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1lbnRTdGFja1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGNvbW1lbnRTdGFja0xlbmd0aCA9IGNvbW1lbnRTdGFjay5sZW5ndGg7XG4gICAgaWYgKGNvbW1lbnRTdGFja0xlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGxldCBpID0gY29tbWVudFN0YWNrTGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGNvbW1lbnRXUyA9IGNvbW1lbnRTdGFja1tpXTtcbiAgICAgIGNvbnN0IGNvbW1lbnRFbmQgPSBjb21tZW50V1MuZW5kO1xuICAgICAgY29uc3QgY29tbWVudFN0YXJ0ID0gY29tbWVudFdTLnN0YXJ0O1xuICAgICAgaWYgKGNvbW1lbnRTdGFydCA9PT0gZW5kKSB7XG4gICAgICAgIGNvbW1lbnRXUy5sZWFkaW5nTm9kZSA9IG5vZGU7XG4gICAgICB9IGVsc2UgaWYgKGNvbW1lbnRFbmQgPT09IHN0YXJ0KSB7XG4gICAgICAgIGNvbW1lbnRXUy50cmFpbGluZ05vZGUgPSBub2RlO1xuICAgICAgfSBlbHNlIGlmIChjb21tZW50RW5kIDwgc3RhcnQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZmxhZ3MgPSAxMDI0O1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IHZvaWQgMDtcbiAgICB0aGlzLmN1ckxpbmUgPSB2b2lkIDA7XG4gICAgdGhpcy5saW5lU3RhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFydExvYyA9IHZvaWQgMDtcbiAgICB0aGlzLmVuZExvYyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuICAgIHRoaXMubm9BcnJvd0F0ID0gW107XG4gICAgdGhpcy5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0ID0gW107XG4gICAgdGhpcy50b3BpY0NvbnRleHQgPSB7XG4gICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDAsXG4gICAgICBtYXhUb3BpY0luZGV4OiBudWxsXG4gICAgfTtcbiAgICB0aGlzLmxhYmVscyA9IFtdO1xuICAgIHRoaXMuY29tbWVudHNMZW4gPSAwO1xuICAgIHRoaXMuY29tbWVudFN0YWNrID0gW107XG4gICAgdGhpcy5wb3MgPSAwO1xuICAgIHRoaXMudHlwZSA9IDE0MDtcbiAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLmVuZCA9IDA7XG4gICAgdGhpcy5sYXN0VG9rRW5kTG9jID0gbnVsbDtcbiAgICB0aGlzLmxhc3RUb2tTdGFydExvYyA9IG51bGw7XG4gICAgdGhpcy5jb250ZXh0ID0gW3R5cGVzLmJyYWNlXTtcbiAgICB0aGlzLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zID0gbnVsbDtcbiAgICB0aGlzLnN0cmljdEVycm9ycyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRva2Vuc0xlbmd0aCA9IDA7XG4gIH1cbiAgZ2V0IHN0cmljdCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxKSA+IDA7XG4gIH1cbiAgc2V0IHN0cmljdCh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gMTtlbHNlIHRoaXMuZmxhZ3MgJj0gLTI7XG4gIH1cbiAgaW5pdCh7XG4gICAgc3RyaWN0TW9kZSxcbiAgICBzb3VyY2VUeXBlLFxuICAgIHN0YXJ0SW5kZXgsXG4gICAgc3RhcnRMaW5lLFxuICAgIHN0YXJ0Q29sdW1uXG4gIH0pIHtcbiAgICB0aGlzLnN0cmljdCA9IHN0cmljdE1vZGUgPT09IGZhbHNlID8gZmFsc2UgOiBzdHJpY3RNb2RlID09PSB0cnVlID8gdHJ1ZSA6IHNvdXJjZVR5cGUgPT09IFwibW9kdWxlXCI7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICB0aGlzLmN1ckxpbmUgPSBzdGFydExpbmU7XG4gICAgdGhpcy5saW5lU3RhcnQgPSAtc3RhcnRDb2x1bW47XG4gICAgdGhpcy5zdGFydExvYyA9IHRoaXMuZW5kTG9jID0gbmV3IFBvc2l0aW9uKHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4sIHN0YXJ0SW5kZXgpO1xuICB9XG4gIGdldCBtYXliZUluQXJyb3dQYXJhbWV0ZXJzKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIpID4gMDtcbiAgfVxuICBzZXQgbWF5YmVJbkFycm93UGFyYW1ldGVycyh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gMjtlbHNlIHRoaXMuZmxhZ3MgJj0gLTM7XG4gIH1cbiAgZ2V0IGluVHlwZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0KSA+IDA7XG4gIH1cbiAgc2V0IGluVHlwZSh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gNDtlbHNlIHRoaXMuZmxhZ3MgJj0gLTU7XG4gIH1cbiAgZ2V0IG5vQW5vbkZ1bmN0aW9uVHlwZSgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4KSA+IDA7XG4gIH1cbiAgc2V0IG5vQW5vbkZ1bmN0aW9uVHlwZSh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gODtlbHNlIHRoaXMuZmxhZ3MgJj0gLTk7XG4gIH1cbiAgZ2V0IGhhc0Zsb3dDb21tZW50KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDE2KSA+IDA7XG4gIH1cbiAgc2V0IGhhc0Zsb3dDb21tZW50KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAxNjtlbHNlIHRoaXMuZmxhZ3MgJj0gLTE3O1xuICB9XG4gIGdldCBpc0FtYmllbnRDb250ZXh0KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDMyKSA+IDA7XG4gIH1cbiAgc2V0IGlzQW1iaWVudENvbnRleHQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDMyO2Vsc2UgdGhpcy5mbGFncyAmPSAtMzM7XG4gIH1cbiAgZ2V0IGluQWJzdHJhY3RDbGFzcygpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA2NCkgPiAwO1xuICB9XG4gIHNldCBpbkFic3RyYWN0Q2xhc3Modikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDY0O2Vsc2UgdGhpcy5mbGFncyAmPSAtNjU7XG4gIH1cbiAgZ2V0IGluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxMjgpID4gMDtcbiAgfVxuICBzZXQgaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAxMjg7ZWxzZSB0aGlzLmZsYWdzICY9IC0xMjk7XG4gIH1cbiAgZ2V0IHNvbG9Bd2FpdCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyNTYpID4gMDtcbiAgfVxuICBzZXQgc29sb0F3YWl0KHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAyNTY7ZWxzZSB0aGlzLmZsYWdzICY9IC0yNTc7XG4gIH1cbiAgZ2V0IGluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5KCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDUxMikgPiAwO1xuICB9XG4gIHNldCBpbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSh2KSB7XG4gICAgaWYgKHYpIHRoaXMuZmxhZ3MgfD0gNTEyO2Vsc2UgdGhpcy5mbGFncyAmPSAtNTEzO1xuICB9XG4gIGdldCBjYW5TdGFydEpTWEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMTAyNCkgPiAwO1xuICB9XG4gIHNldCBjYW5TdGFydEpTWEVsZW1lbnQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDEwMjQ7ZWxzZSB0aGlzLmZsYWdzICY9IC0xMDI1O1xuICB9XG4gIGdldCBjb250YWluc0VzYygpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyMDQ4KSA+IDA7XG4gIH1cbiAgc2V0IGNvbnRhaW5zRXNjKHYpIHtcbiAgICBpZiAodikgdGhpcy5mbGFncyB8PSAyMDQ4O2Vsc2UgdGhpcy5mbGFncyAmPSAtMjA0OTtcbiAgfVxuICBnZXQgaGFzVG9wTGV2ZWxBd2FpdCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA0MDk2KSA+IDA7XG4gIH1cbiAgc2V0IGhhc1RvcExldmVsQXdhaXQodikge1xuICAgIGlmICh2KSB0aGlzLmZsYWdzIHw9IDQwOTY7ZWxzZSB0aGlzLmZsYWdzICY9IC00MDk3O1xuICB9XG4gIGN1clBvc2l0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0LCB0aGlzLnBvcyArIHRoaXMuc3RhcnRJbmRleCk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgY29uc3Qgc3RhdGUgPSBuZXcgU3RhdGUoKTtcbiAgICBzdGF0ZS5mbGFncyA9IHRoaXMuZmxhZ3M7XG4gICAgc3RhdGUuc3RhcnRJbmRleCA9IHRoaXMuc3RhcnRJbmRleDtcbiAgICBzdGF0ZS5jdXJMaW5lID0gdGhpcy5jdXJMaW5lO1xuICAgIHN0YXRlLmxpbmVTdGFydCA9IHRoaXMubGluZVN0YXJ0O1xuICAgIHN0YXRlLnN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICBzdGF0ZS5lbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgICBzdGF0ZS5lcnJvcnMgPSB0aGlzLmVycm9ycy5zbGljZSgpO1xuICAgIHN0YXRlLnBvdGVudGlhbEFycm93QXQgPSB0aGlzLnBvdGVudGlhbEFycm93QXQ7XG4gICAgc3RhdGUubm9BcnJvd0F0ID0gdGhpcy5ub0Fycm93QXQuc2xpY2UoKTtcbiAgICBzdGF0ZS5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0ID0gdGhpcy5ub0Fycm93UGFyYW1zQ29udmVyc2lvbkF0LnNsaWNlKCk7XG4gICAgc3RhdGUudG9waWNDb250ZXh0ID0gdGhpcy50b3BpY0NvbnRleHQ7XG4gICAgc3RhdGUubGFiZWxzID0gdGhpcy5sYWJlbHMuc2xpY2UoKTtcbiAgICBzdGF0ZS5jb21tZW50c0xlbiA9IHRoaXMuY29tbWVudHNMZW47XG4gICAgc3RhdGUuY29tbWVudFN0YWNrID0gdGhpcy5jb21tZW50U3RhY2suc2xpY2UoKTtcbiAgICBzdGF0ZS5wb3MgPSB0aGlzLnBvcztcbiAgICBzdGF0ZS50eXBlID0gdGhpcy50eXBlO1xuICAgIHN0YXRlLnZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBzdGF0ZS5zdGFydCA9IHRoaXMuc3RhcnQ7XG4gICAgc3RhdGUuZW5kID0gdGhpcy5lbmQ7XG4gICAgc3RhdGUubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva0VuZExvYztcbiAgICBzdGF0ZS5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLmxhc3RUb2tTdGFydExvYztcbiAgICBzdGF0ZS5jb250ZXh0ID0gdGhpcy5jb250ZXh0LnNsaWNlKCk7XG4gICAgc3RhdGUuZmlyc3RJbnZhbGlkVGVtcGxhdGVFc2NhcGVQb3MgPSB0aGlzLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zO1xuICAgIHN0YXRlLnN0cmljdEVycm9ycyA9IHRoaXMuc3RyaWN0RXJyb3JzO1xuICAgIHN0YXRlLnRva2Vuc0xlbmd0aCA9IHRoaXMudG9rZW5zTGVuZ3RoO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxufVxudmFyIF9pc0RpZ2l0ID0gZnVuY3Rpb24gaXNEaWdpdChjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTc7XG59O1xuY29uc3QgZm9yYmlkZGVuTnVtZXJpY1NlcGFyYXRvclNpYmxpbmdzID0ge1xuICBkZWNCaW5PY3Q6IG5ldyBTZXQoWzQ2LCA2NiwgNjksIDc5LCA5NSwgOTgsIDEwMSwgMTExXSksXG4gIGhleDogbmV3IFNldChbNDYsIDg4LCA5NSwgMTIwXSlcbn07XG5jb25zdCBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZyA9IHtcbiAgYmluOiBjaCA9PiBjaCA9PT0gNDggfHwgY2ggPT09IDQ5LFxuICBvY3Q6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU1LFxuICBkZWM6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU3LFxuICBoZXg6IGNoID0+IGNoID49IDQ4ICYmIGNoIDw9IDU3IHx8IGNoID49IDY1ICYmIGNoIDw9IDcwIHx8IGNoID49IDk3ICYmIGNoIDw9IDEwMlxufTtcbmZ1bmN0aW9uIHJlYWRTdHJpbmdDb250ZW50cyh0eXBlLCBpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIGVycm9ycykge1xuICBjb25zdCBpbml0aWFsUG9zID0gcG9zO1xuICBjb25zdCBpbml0aWFsTGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICBjb25zdCBpbml0aWFsQ3VyTGluZSA9IGN1ckxpbmU7XG4gIGxldCBvdXQgPSBcIlwiO1xuICBsZXQgZmlyc3RJbnZhbGlkTG9jID0gbnVsbDtcbiAgbGV0IGNodW5rU3RhcnQgPSBwb3M7XG4gIGNvbnN0IHtcbiAgICBsZW5ndGhcbiAgfSA9IGlucHV0O1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHBvcyA+PSBsZW5ndGgpIHtcbiAgICAgIGVycm9ycy51bnRlcm1pbmF0ZWQoaW5pdGlhbFBvcywgaW5pdGlhbExpbmVTdGFydCwgaW5pdGlhbEN1ckxpbmUpO1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgaWYgKGlzU3RyaW5nRW5kKHR5cGUsIGNoLCBpbnB1dCwgcG9zKSkge1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGNoID09PSA5Mikge1xuICAgICAgb3V0ICs9IGlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHBvcyk7XG4gICAgICBjb25zdCByZXMgPSByZWFkRXNjYXBlZENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCB0eXBlID09PSBcInRlbXBsYXRlXCIsIGVycm9ycyk7XG4gICAgICBpZiAocmVzLmNoID09PSBudWxsICYmICFmaXJzdEludmFsaWRMb2MpIHtcbiAgICAgICAgZmlyc3RJbnZhbGlkTG9jID0ge1xuICAgICAgICAgIHBvcyxcbiAgICAgICAgICBsaW5lU3RhcnQsXG4gICAgICAgICAgY3VyTGluZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ICs9IHJlcy5jaDtcbiAgICAgIH1cbiAgICAgICh7XG4gICAgICAgIHBvcyxcbiAgICAgICAgbGluZVN0YXJ0LFxuICAgICAgICBjdXJMaW5lXG4gICAgICB9ID0gcmVzKTtcbiAgICAgIGNodW5rU3RhcnQgPSBwb3M7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gODIzMiB8fCBjaCA9PT0gODIzMykge1xuICAgICAgKytwb3M7XG4gICAgICArK2N1ckxpbmU7XG4gICAgICBsaW5lU3RhcnQgPSBwb3M7XG4gICAgfSBlbHNlIGlmIChjaCA9PT0gMTAgfHwgY2ggPT09IDEzKSB7XG4gICAgICBpZiAodHlwZSA9PT0gXCJ0ZW1wbGF0ZVwiKSB7XG4gICAgICAgIG91dCArPSBpbnB1dC5zbGljZShjaHVua1N0YXJ0LCBwb3MpICsgXCJcXG5cIjtcbiAgICAgICAgKytwb3M7XG4gICAgICAgIGlmIChjaCA9PT0gMTMgJiYgaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG4gICAgICAgICsrY3VyTGluZTtcbiAgICAgICAgY2h1bmtTdGFydCA9IGxpbmVTdGFydCA9IHBvcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy51bnRlcm1pbmF0ZWQoaW5pdGlhbFBvcywgaW5pdGlhbExpbmVTdGFydCwgaW5pdGlhbEN1ckxpbmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICArK3BvcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwb3MsXG4gICAgc3RyOiBvdXQsXG4gICAgZmlyc3RJbnZhbGlkTG9jLFxuICAgIGxpbmVTdGFydCxcbiAgICBjdXJMaW5lLFxuICAgIGNvbnRhaW5zSW52YWxpZDogISFmaXJzdEludmFsaWRMb2NcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzU3RyaW5nRW5kKHR5cGUsIGNoLCBpbnB1dCwgcG9zKSB7XG4gIGlmICh0eXBlID09PSBcInRlbXBsYXRlXCIpIHtcbiAgICByZXR1cm4gY2ggPT09IDk2IHx8IGNoID09PSAzNiAmJiBpbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpID09PSAxMjM7XG4gIH1cbiAgcmV0dXJuIGNoID09PSAodHlwZSA9PT0gXCJkb3VibGVcIiA/IDM0IDogMzkpO1xufVxuZnVuY3Rpb24gcmVhZEVzY2FwZWRDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgaW5UZW1wbGF0ZSwgZXJyb3JzKSB7XG4gIGNvbnN0IHRocm93T25JbnZhbGlkID0gIWluVGVtcGxhdGU7XG4gIHBvcysrO1xuICBjb25zdCByZXMgPSBjaCA9PiAoe1xuICAgIHBvcyxcbiAgICBjaCxcbiAgICBsaW5lU3RhcnQsXG4gICAgY3VyTGluZVxuICB9KTtcbiAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcysrKTtcbiAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMTEwOlxuICAgICAgcmV0dXJuIHJlcyhcIlxcblwiKTtcbiAgICBjYXNlIDExNDpcbiAgICAgIHJldHVybiByZXMoXCJcXHJcIik7XG4gICAgY2FzZSAxMjA6XG4gICAgICB7XG4gICAgICAgIGxldCBjb2RlO1xuICAgICAgICAoe1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH0gPSByZWFkSGV4Q2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIDIsIGZhbHNlLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gICAgICAgIHJldHVybiByZXMoY29kZSA9PT0gbnVsbCA/IG51bGwgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKTtcbiAgICAgIH1cbiAgICBjYXNlIDExNzpcbiAgICAgIHtcbiAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICh7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfSA9IHJlYWRDb2RlUG9pbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCB0aHJvd09uSW52YWxpZCwgZXJyb3JzKSk7XG4gICAgICAgIHJldHVybiByZXMoY29kZSA9PT0gbnVsbCA/IG51bGwgOiBTdHJpbmcuZnJvbUNvZGVQb2ludChjb2RlKSk7XG4gICAgICB9XG4gICAgY2FzZSAxMTY6XG4gICAgICByZXR1cm4gcmVzKFwiXFx0XCIpO1xuICAgIGNhc2UgOTg6XG4gICAgICByZXR1cm4gcmVzKFwiXFxiXCIpO1xuICAgIGNhc2UgMTE4OlxuICAgICAgcmV0dXJuIHJlcyhcIlxcdTAwMGJcIik7XG4gICAgY2FzZSAxMDI6XG4gICAgICByZXR1cm4gcmVzKFwiXFxmXCIpO1xuICAgIGNhc2UgMTM6XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAxMCkge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cbiAgICBjYXNlIDEwOlxuICAgICAgbGluZVN0YXJ0ID0gcG9zO1xuICAgICAgKytjdXJMaW5lO1xuICAgIGNhc2UgODIzMjpcbiAgICBjYXNlIDgyMzM6XG4gICAgICByZXR1cm4gcmVzKFwiXCIpO1xuICAgIGNhc2UgNTY6XG4gICAgY2FzZSA1NzpcbiAgICAgIGlmIChpblRlbXBsYXRlKSB7XG4gICAgICAgIHJldHVybiByZXMobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcnMuc3RyaWN0TnVtZXJpY0VzY2FwZShwb3MgLSAxLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBwb3MgLSAxO1xuICAgICAgICBjb25zdCBtYXRjaCA9IC9eWzAtN10rLy5leGVjKGlucHV0LnNsaWNlKHN0YXJ0UG9zLCBwb3MgKyAyKSk7XG4gICAgICAgIGxldCBvY3RhbFN0ciA9IG1hdGNoWzBdO1xuICAgICAgICBsZXQgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICAgIG9jdGFsU3RyID0gb2N0YWxTdHIuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIG9jdGFsID0gcGFyc2VJbnQob2N0YWxTdHIsIDgpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBvY3RhbFN0ci5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBuZXh0ID0gaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAob2N0YWxTdHIgIT09IFwiMFwiIHx8IG5leHQgPT09IDU2IHx8IG5leHQgPT09IDU3KSB7XG4gICAgICAgICAgaWYgKGluVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMobnVsbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9ycy5zdHJpY3ROdW1lcmljRXNjYXBlKHN0YXJ0UG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzKFN0cmluZy5mcm9tQ2hhckNvZGUob2N0YWwpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMoU3RyaW5nLmZyb21DaGFyQ29kZShjaCkpO1xuICB9XG59XG5mdW5jdGlvbiByZWFkSGV4Q2hhcihpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIGxlbiwgZm9yY2VMZW4sIHRocm93T25JbnZhbGlkLCBlcnJvcnMpIHtcbiAgY29uc3QgaW5pdGlhbFBvcyA9IHBvcztcbiAgbGV0IG47XG4gICh7XG4gICAgbixcbiAgICBwb3NcbiAgfSA9IHJlYWRJbnQoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCAxNiwgbGVuLCBmb3JjZUxlbiwgZmFsc2UsIGVycm9ycywgIXRocm93T25JbnZhbGlkKSk7XG4gIGlmIChuID09PSBudWxsKSB7XG4gICAgaWYgKHRocm93T25JbnZhbGlkKSB7XG4gICAgICBlcnJvcnMuaW52YWxpZEVzY2FwZVNlcXVlbmNlKGluaXRpYWxQb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcyA9IGluaXRpYWxQb3MgLSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGNvZGU6IG4sXG4gICAgcG9zXG4gIH07XG59XG5mdW5jdGlvbiByZWFkSW50KGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgcmFkaXgsIGxlbiwgZm9yY2VMZW4sIGFsbG93TnVtU2VwYXJhdG9yLCBlcnJvcnMsIGJhaWxPbkVycm9yKSB7XG4gIGNvbnN0IHN0YXJ0ID0gcG9zO1xuICBjb25zdCBmb3JiaWRkZW5TaWJsaW5ncyA9IHJhZGl4ID09PSAxNiA/IGZvcmJpZGRlbk51bWVyaWNTZXBhcmF0b3JTaWJsaW5ncy5oZXggOiBmb3JiaWRkZW5OdW1lcmljU2VwYXJhdG9yU2libGluZ3MuZGVjQmluT2N0O1xuICBjb25zdCBpc0FsbG93ZWRTaWJsaW5nID0gcmFkaXggPT09IDE2ID8gaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcuaGV4IDogcmFkaXggPT09IDEwID8gaXNBbGxvd2VkTnVtZXJpY1NlcGFyYXRvclNpYmxpbmcuZGVjIDogcmFkaXggPT09IDggPyBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZy5vY3QgOiBpc0FsbG93ZWROdW1lcmljU2VwYXJhdG9yU2libGluZy5iaW47XG4gIGxldCBpbnZhbGlkID0gZmFsc2U7XG4gIGxldCB0b3RhbCA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBlID0gbGVuID09IG51bGwgPyBJbmZpbml0eSA6IGxlbjsgaSA8IGU7ICsraSkge1xuICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gICAgbGV0IHZhbDtcbiAgICBpZiAoY29kZSA9PT0gOTUgJiYgYWxsb3dOdW1TZXBhcmF0b3IgIT09IFwiYmFpbFwiKSB7XG4gICAgICBjb25zdCBwcmV2ID0gaW5wdXQuY2hhckNvZGVBdChwb3MgLSAxKTtcbiAgICAgIGNvbnN0IG5leHQgPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyArIDEpO1xuICAgICAgaWYgKCFhbGxvd051bVNlcGFyYXRvcikge1xuICAgICAgICBpZiAoYmFpbE9uRXJyb3IpIHJldHVybiB7XG4gICAgICAgICAgbjogbnVsbCxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfTtcbiAgICAgICAgZXJyb3JzLm51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzTmFOKG5leHQpIHx8ICFpc0FsbG93ZWRTaWJsaW5nKG5leHQpIHx8IGZvcmJpZGRlblNpYmxpbmdzLmhhcyhwcmV2KSB8fCBmb3JiaWRkZW5TaWJsaW5ncy5oYXMobmV4dCkpIHtcbiAgICAgICAgaWYgKGJhaWxPbkVycm9yKSByZXR1cm4ge1xuICAgICAgICAgIG46IG51bGwsXG4gICAgICAgICAgcG9zXG4gICAgICAgIH07XG4gICAgICAgIGVycm9ycy51bmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcihwb3MsIGxpbmVTdGFydCwgY3VyTGluZSk7XG4gICAgICB9XG4gICAgICArK3BvcztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoY29kZSA+PSA5Nykge1xuICAgICAgdmFsID0gY29kZSAtIDk3ICsgMTA7XG4gICAgfSBlbHNlIGlmIChjb2RlID49IDY1KSB7XG4gICAgICB2YWwgPSBjb2RlIC0gNjUgKyAxMDtcbiAgICB9IGVsc2UgaWYgKF9pc0RpZ2l0KGNvZGUpKSB7XG4gICAgICB2YWwgPSBjb2RlIC0gNDg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IEluZmluaXR5O1xuICAgIH1cbiAgICBpZiAodmFsID49IHJhZGl4KSB7XG4gICAgICBpZiAodmFsIDw9IDkgJiYgYmFpbE9uRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuOiBudWxsLFxuICAgICAgICAgIHBvc1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh2YWwgPD0gOSAmJiBlcnJvcnMuaW52YWxpZERpZ2l0KHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCByYWRpeCkpIHtcbiAgICAgICAgdmFsID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZm9yY2VMZW4pIHtcbiAgICAgICAgdmFsID0gMDtcbiAgICAgICAgaW52YWxpZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgKytwb3M7XG4gICAgdG90YWwgPSB0b3RhbCAqIHJhZGl4ICsgdmFsO1xuICB9XG4gIGlmIChwb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHBvcyAtIHN0YXJ0ICE9PSBsZW4gfHwgaW52YWxpZCkge1xuICAgIHJldHVybiB7XG4gICAgICBuOiBudWxsLFxuICAgICAgcG9zXG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIG46IHRvdGFsLFxuICAgIHBvc1xuICB9O1xufVxuZnVuY3Rpb24gcmVhZENvZGVQb2ludChpbnB1dCwgcG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHRocm93T25JbnZhbGlkLCBlcnJvcnMpIHtcbiAgY29uc3QgY2ggPSBpbnB1dC5jaGFyQ29kZUF0KHBvcyk7XG4gIGxldCBjb2RlO1xuICBpZiAoY2ggPT09IDEyMykge1xuICAgICsrcG9zO1xuICAgICh7XG4gICAgICBjb2RlLFxuICAgICAgcG9zXG4gICAgfSA9IHJlYWRIZXhDaGFyKGlucHV0LCBwb3MsIGxpbmVTdGFydCwgY3VyTGluZSwgaW5wdXQuaW5kZXhPZihcIn1cIiwgcG9zKSAtIHBvcywgdHJ1ZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykpO1xuICAgICsrcG9zO1xuICAgIGlmIChjb2RlICE9PSBudWxsICYmIGNvZGUgPiAweDEwZmZmZikge1xuICAgICAgaWYgKHRocm93T25JbnZhbGlkKSB7XG4gICAgICAgIGVycm9ycy5pbnZhbGlkQ29kZVBvaW50KHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29kZTogbnVsbCxcbiAgICAgICAgICBwb3NcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgKHtcbiAgICAgIGNvZGUsXG4gICAgICBwb3NcbiAgICB9ID0gcmVhZEhleENoYXIoaW5wdXQsIHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lLCA0LCBmYWxzZSwgdGhyb3dPbkludmFsaWQsIGVycm9ycykpO1xuICB9XG4gIHJldHVybiB7XG4gICAgY29kZSxcbiAgICBwb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpIHtcbiAgcmV0dXJuIG5ldyBQb3NpdGlvbihjdXJMaW5lLCBwb3MgLSBsaW5lU3RhcnQsIHBvcyk7XG59XG5jb25zdCBWQUxJRF9SRUdFWF9GTEFHUyA9IG5ldyBTZXQoWzEwMywgMTA5LCAxMTUsIDEwNSwgMTIxLCAxMTcsIDEwMCwgMTE4XSk7XG5jbGFzcyBUb2tlbiB7XG4gIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IHN0YXRlLnN0YXJ0SW5kZXggfHwgMDtcbiAgICB0aGlzLnR5cGUgPSBzdGF0ZS50eXBlO1xuICAgIHRoaXMudmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnRJbmRleCArIHN0YXRlLnN0YXJ0O1xuICAgIHRoaXMuZW5kID0gc3RhcnRJbmRleCArIHN0YXRlLmVuZDtcbiAgICB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihzdGF0ZS5zdGFydExvYywgc3RhdGUuZW5kTG9jKTtcbiAgfVxufVxuY2xhc3MgVG9rZW5pemVyIGV4dGVuZHMgQ29tbWVudHNQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpbnB1dCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IHZvaWQgMDtcbiAgICB0aGlzLnRva2VucyA9IFtdO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkSW50ID0ge1xuICAgICAgaW52YWxpZERpZ2l0OiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUsIHJhZGl4KSA9PiB7XG4gICAgICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiAyMDQ4KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGlnaXQsIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpLCB7XG4gICAgICAgICAgcmFkaXhcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIG51bWVyaWNTZXBhcmF0b3JJbkVzY2FwZVNlcXVlbmNlOiB0aGlzLmVycm9yQnVpbGRlcihFcnJvcnMuTnVtZXJpY1NlcGFyYXRvckluRXNjYXBlU2VxdWVuY2UpLFxuICAgICAgdW5leHBlY3RlZE51bWVyaWNTZXBhcmF0b3I6IHRoaXMuZXJyb3JCdWlsZGVyKEVycm9ycy5VbmV4cGVjdGVkTnVtZXJpY1NlcGFyYXRvcilcbiAgICB9O1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkQ29kZVBvaW50ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRJbnQsIHtcbiAgICAgIGludmFsaWRFc2NhcGVTZXF1ZW5jZTogdGhpcy5lcnJvckJ1aWxkZXIoRXJyb3JzLkludmFsaWRFc2NhcGVTZXF1ZW5jZSksXG4gICAgICBpbnZhbGlkQ29kZVBvaW50OiB0aGlzLmVycm9yQnVpbGRlcihFcnJvcnMuSW52YWxpZENvZGVQb2ludClcbiAgICB9KTtcbiAgICB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZFN0cmluZ0NvbnRlbnRzX3N0cmluZyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkQ29kZVBvaW50LCB7XG4gICAgICBzdHJpY3ROdW1lcmljRXNjYXBlOiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpID0+IHtcbiAgICAgICAgdGhpcy5yZWNvcmRTdHJpY3RNb2RlRXJyb3JzKEVycm9ycy5TdHJpY3ROdW1lcmljRXNjYXBlLCBidWlsZFBvc2l0aW9uKHBvcywgbGluZVN0YXJ0LCBjdXJMaW5lKSk7XG4gICAgICB9LFxuICAgICAgdW50ZXJtaW5hdGVkOiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpID0+IHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkU3RyaW5nLCBidWlsZFBvc2l0aW9uKHBvcyAtIDEsIGxpbmVTdGFydCwgY3VyTGluZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkU3RyaW5nQ29udGVudHNfdGVtcGxhdGUgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZENvZGVQb2ludCwge1xuICAgICAgc3RyaWN0TnVtZXJpY0VzY2FwZTogdGhpcy5lcnJvckJ1aWxkZXIoRXJyb3JzLlN0cmljdE51bWVyaWNFc2NhcGUpLFxuICAgICAgdW50ZXJtaW5hdGVkOiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpID0+IHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkVGVtcGxhdGUsIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlKCk7XG4gICAgdGhpcy5zdGF0ZS5pbml0KG9wdGlvbnMpO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICB0aGlzLmNvbW1lbnRzID0gW107XG4gICAgdGhpcy5pc0xvb2thaGVhZCA9IGZhbHNlO1xuICB9XG4gIHB1c2hUb2tlbih0b2tlbikge1xuICAgIHRoaXMudG9rZW5zLmxlbmd0aCA9IHRoaXMuc3RhdGUudG9rZW5zTGVuZ3RoO1xuICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgICsrdGhpcy5zdGF0ZS50b2tlbnNMZW5ndGg7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICB0aGlzLmNoZWNrS2V5d29yZEVzY2FwZXMoKTtcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDI1Nikge1xuICAgICAgdGhpcy5wdXNoVG9rZW4obmV3IFRva2VuKHRoaXMuc3RhdGUpKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jID0gdGhpcy5zdGF0ZS5lbmRMb2M7XG4gICAgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMubmV4dFRva2VuKCk7XG4gIH1cbiAgZWF0KHR5cGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCh0eXBlKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBtYXRjaCh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudHlwZSA9PT0gdHlwZTtcbiAgfVxuICBjcmVhdGVMb29rYWhlYWRTdGF0ZShzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBwb3M6IHN0YXRlLnBvcyxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgdHlwZTogc3RhdGUudHlwZSxcbiAgICAgIHN0YXJ0OiBzdGF0ZS5zdGFydCxcbiAgICAgIGVuZDogc3RhdGUuZW5kLFxuICAgICAgY29udGV4dDogW3RoaXMuY3VyQ29udGV4dCgpXSxcbiAgICAgIGluVHlwZTogc3RhdGUuaW5UeXBlLFxuICAgICAgc3RhcnRMb2M6IHN0YXRlLnN0YXJ0TG9jLFxuICAgICAgbGFzdFRva0VuZExvYzogc3RhdGUubGFzdFRva0VuZExvYyxcbiAgICAgIGN1ckxpbmU6IHN0YXRlLmN1ckxpbmUsXG4gICAgICBsaW5lU3RhcnQ6IHN0YXRlLmxpbmVTdGFydCxcbiAgICAgIGN1clBvc2l0aW9uOiBzdGF0ZS5jdXJQb3NpdGlvblxuICAgIH07XG4gIH1cbiAgbG9va2FoZWFkKCkge1xuICAgIGNvbnN0IG9sZCA9IHRoaXMuc3RhdGU7XG4gICAgdGhpcy5zdGF0ZSA9IHRoaXMuY3JlYXRlTG9va2FoZWFkU3RhdGUob2xkKTtcbiAgICB0aGlzLmlzTG9va2FoZWFkID0gdHJ1ZTtcbiAgICB0aGlzLm5leHRUb2tlbigpO1xuICAgIHRoaXMuaXNMb29rYWhlYWQgPSBmYWxzZTtcbiAgICBjb25zdCBjdXJyID0gdGhpcy5zdGF0ZTtcbiAgICB0aGlzLnN0YXRlID0gb2xkO1xuICAgIHJldHVybiBjdXJyO1xuICB9XG4gIG5leHRUb2tlblN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLm5leHRUb2tlblN0YXJ0U2luY2UodGhpcy5zdGF0ZS5wb3MpO1xuICB9XG4gIG5leHRUb2tlblN0YXJ0U2luY2UocG9zKSB7XG4gICAgc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4ID0gcG9zO1xuICAgIHJldHVybiBza2lwV2hpdGVTcGFjZS50ZXN0KHRoaXMuaW5wdXQpID8gc2tpcFdoaXRlU3BhY2UubGFzdEluZGV4IDogcG9zO1xuICB9XG4gIGxvb2thaGVhZENoYXJDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLmxvb2thaGVhZENoYXJDb2RlU2luY2UodGhpcy5zdGF0ZS5wb3MpO1xuICB9XG4gIGxvb2thaGVhZENoYXJDb2RlU2luY2UocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLm5leHRUb2tlblN0YXJ0U2luY2UocG9zKSk7XG4gIH1cbiAgbmV4dFRva2VuSW5MaW5lU3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnRTaW5jZSh0aGlzLnN0YXRlLnBvcyk7XG4gIH1cbiAgbmV4dFRva2VuSW5MaW5lU3RhcnRTaW5jZShwb3MpIHtcbiAgICBza2lwV2hpdGVTcGFjZUluTGluZS5sYXN0SW5kZXggPSBwb3M7XG4gICAgcmV0dXJuIHNraXBXaGl0ZVNwYWNlSW5MaW5lLnRlc3QodGhpcy5pbnB1dCkgPyBza2lwV2hpdGVTcGFjZUluTGluZS5sYXN0SW5kZXggOiBwb3M7XG4gIH1cbiAgbG9va2FoZWFkSW5MaW5lQ2hhckNvZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLm5leHRUb2tlbkluTGluZVN0YXJ0KCkpO1xuICB9XG4gIGNvZGVQb2ludEF0UG9zKHBvcykge1xuICAgIGxldCBjcCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgIGlmICgoY3AgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKytwb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgdHJhaWwgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zKTtcbiAgICAgIGlmICgodHJhaWwgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgY3AgPSAweDEwMDAwICsgKChjcCAmIDB4M2ZmKSA8PCAxMCkgKyAodHJhaWwgJiAweDNmZik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcDtcbiAgfVxuICBzZXRTdHJpY3Qoc3RyaWN0KSB7XG4gICAgdGhpcy5zdGF0ZS5zdHJpY3QgPSBzdHJpY3Q7XG4gICAgaWYgKHN0cmljdCkge1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuZm9yRWFjaCgoW3RvUGFyc2VFcnJvciwgYXRdKSA9PiB0aGlzLnJhaXNlKHRvUGFyc2VFcnJvciwgYXQpKTtcbiAgICAgIHRoaXMuc3RhdGUuc3RyaWN0RXJyb3JzLmNsZWFyKCk7XG4gICAgfVxuICB9XG4gIGN1ckNvbnRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY29udGV4dFt0aGlzLnN0YXRlLmNvbnRleHQubGVuZ3RoIC0gMV07XG4gIH1cbiAgbmV4dFRva2VuKCkge1xuICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgdGhpcy5zdGF0ZS5zdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGlmICghdGhpcy5pc0xvb2thaGVhZCkgdGhpcy5zdGF0ZS5zdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTQwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5nZXRUb2tlbkZyb21Db2RlKHRoaXMuY29kZVBvaW50QXRQb3ModGhpcy5zdGF0ZS5wb3MpKTtcbiAgfVxuICBza2lwQmxvY2tDb21tZW50KGNvbW1lbnRFbmQpIHtcbiAgICBsZXQgc3RhcnRMb2M7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuaW5wdXQuaW5kZXhPZihjb21tZW50RW5kLCBzdGFydCArIDIpO1xuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbnRlcm1pbmF0ZWRDb21tZW50LCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLnBvcyA9IGVuZCArIGNvbW1lbnRFbmQubGVuZ3RoO1xuICAgIGxpbmVCcmVha0cubGFzdEluZGV4ID0gc3RhcnQgKyAyO1xuICAgIHdoaWxlIChsaW5lQnJlYWtHLnRlc3QodGhpcy5pbnB1dCkgJiYgbGluZUJyZWFrRy5sYXN0SW5kZXggPD0gZW5kKSB7XG4gICAgICArK3RoaXMuc3RhdGUuY3VyTGluZTtcbiAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gbGluZUJyZWFrRy5sYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTG9va2FoZWFkKSByZXR1cm47XG4gICAgY29uc3QgY29tbWVudCA9IHtcbiAgICAgIHR5cGU6IFwiQ29tbWVudEJsb2NrXCIsXG4gICAgICB2YWx1ZTogdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksXG4gICAgICBzdGFydDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyhzdGFydCksXG4gICAgICBlbmQ6IHRoaXMuc291cmNlVG9PZmZzZXRQb3MoZW5kICsgY29tbWVudEVuZC5sZW5ndGgpLFxuICAgICAgbG9jOiBuZXcgU291cmNlTG9jYXRpb24oc3RhcnRMb2MsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSlcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMjU2KSB0aGlzLnB1c2hUb2tlbihjb21tZW50KTtcbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuICBza2lwTGluZUNvbW1lbnQoc3RhcnRTa2lwKSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBsZXQgc3RhcnRMb2M7XG4gICAgaWYgKCF0aGlzLmlzTG9va2FoZWFkKSBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBsZXQgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKz0gc3RhcnRTa2lwKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgd2hpbGUgKCFpc05ld0xpbmUoY2gpICYmICsrdGhpcy5zdGF0ZS5wb3MgPCB0aGlzLmxlbmd0aCkge1xuICAgICAgICBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTG9va2FoZWFkKSByZXR1cm47XG4gICAgY29uc3QgZW5kID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgc3RhcnRTa2lwLCBlbmQpO1xuICAgIGNvbnN0IGNvbW1lbnQgPSB7XG4gICAgICB0eXBlOiBcIkNvbW1lbnRMaW5lXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHN0YXJ0KSxcbiAgICAgIGVuZDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyhlbmQpLFxuICAgICAgbG9jOiBuZXcgU291cmNlTG9jYXRpb24oc3RhcnRMb2MsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSlcbiAgICB9O1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMjU2KSB0aGlzLnB1c2hUb2tlbihjb21tZW50KTtcbiAgICByZXR1cm4gY29tbWVudDtcbiAgfVxuICBza2lwU3BhY2UoKSB7XG4gICAgY29uc3Qgc3BhY2VTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIGNvbnN0IGNvbW1lbnRzID0gdGhpcy5vcHRpb25GbGFncyAmIDQwOTYgPyBbXSA6IG51bGw7XG4gICAgbG9vcDogd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgY2FzZSAxNjA6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDEwOlxuICAgICAgICBjYXNlIDgyMzI6XG4gICAgICAgIGNhc2UgODIzMzpcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgICsrdGhpcy5zdGF0ZS5jdXJMaW5lO1xuICAgICAgICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDc6XG4gICAgICAgICAgc3dpdGNoICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSkge1xuICAgICAgICAgICAgY2FzZSA0MjpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1lbnQgPSB0aGlzLnNraXBCbG9ja0NvbW1lbnQoXCIqL1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkZENvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgICBjb21tZW50cyA9PSBudWxsIHx8IGNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuc2tpcExpbmVDb21tZW50KDIpO1xuICAgICAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tbWVudChjb21tZW50KTtcbiAgICAgICAgICAgICAgICAgIGNvbW1lbnRzID09IG51bGwgfHwgY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChpc1doaXRlc3BhY2UoY2gpKSB7XG4gICAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDQ1ICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMub3B0aW9uRmxhZ3MgJiA4MTkyKSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDQ1ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAyKSA9PT0gNjIgJiYgKHNwYWNlU3RhcnQgPT09IDAgfHwgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPiBzcGFjZVN0YXJ0KSkge1xuICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5za2lwTGluZUNvbW1lbnQoMyk7XG4gICAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgY29tbWVudHMgPT0gbnVsbCB8fCBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09IDYwICYmICF0aGlzLmluTW9kdWxlICYmIHRoaXMub3B0aW9uRmxhZ3MgJiA4MTkyKSB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMSkgPT09IDMzICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAyKSA9PT0gNDUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDMpID09PSA0NSkge1xuICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5za2lwTGluZUNvbW1lbnQoNCk7XG4gICAgICAgICAgICAgIGlmIChjb21tZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbW1lbnQoY29tbWVudCk7XG4gICAgICAgICAgICAgICAgY29tbWVudHMgPT0gbnVsbCB8fCBjb21tZW50cy5wdXNoKGNvbW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKChjb21tZW50cyA9PSBudWxsID8gdm9pZCAwIDogY29tbWVudHMubGVuZ3RoKSA+IDApIHtcbiAgICAgIGNvbnN0IGVuZCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgY29uc3QgY29tbWVudFdoaXRlc3BhY2UgPSB7XG4gICAgICAgIHN0YXJ0OiB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHNwYWNlU3RhcnQpLFxuICAgICAgICBlbmQ6IHRoaXMuc291cmNlVG9PZmZzZXRQb3MoZW5kKSxcbiAgICAgICAgY29tbWVudHM6IGNvbW1lbnRzLFxuICAgICAgICBsZWFkaW5nTm9kZTogbnVsbCxcbiAgICAgICAgdHJhaWxpbmdOb2RlOiBudWxsLFxuICAgICAgICBjb250YWluaW5nTm9kZTogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuc3RhdGUuY29tbWVudFN0YWNrLnB1c2goY29tbWVudFdoaXRlc3BhY2UpO1xuICAgIH1cbiAgfVxuICBmaW5pc2hUb2tlbih0eXBlLCB2YWwpIHtcbiAgICB0aGlzLnN0YXRlLmVuZCA9IHRoaXMuc3RhdGUucG9zO1xuICAgIHRoaXMuc3RhdGUuZW5kTG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgIGNvbnN0IHByZXZUeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIHRoaXMuc3RhdGUudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zdGF0ZS52YWx1ZSA9IHZhbDtcbiAgICBpZiAoIXRoaXMuaXNMb29rYWhlYWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29udGV4dChwcmV2VHlwZSk7XG4gICAgfVxuICB9XG4gIHJlcGxhY2VUb2tlbih0eXBlKSB7XG4gICAgdGhpcy5zdGF0ZS50eXBlID0gdHlwZTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRleHQoKTtcbiAgfVxuICByZWFkVG9rZW5fbnVtYmVyU2lnbigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5wb3MgPT09IDAgJiYgdGhpcy5yZWFkVG9rZW5faW50ZXJwcmV0ZXIoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuZXh0UG9zID0gdGhpcy5zdGF0ZS5wb3MgKyAxO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHRQb3MpO1xuICAgIGlmIChuZXh0ID49IDQ4ICYmIG5leHQgPD0gNTcpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWREaWdpdEFmdGVySGFzaCwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDEyMyB8fCBuZXh0ID09PSA5MSAmJiB0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpO1xuICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicmVjb3JkQW5kVHVwbGVcIiwgXCJzeW50YXhUeXBlXCIpID09PSBcImJhclwiKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UobmV4dCA9PT0gMTIzID8gRXJyb3JzLlJlY29yZEV4cHJlc3Npb25IYXNoSW5jb3JyZWN0U3RhcnRTeW50YXhUeXBlIDogRXJyb3JzLlR1cGxlRXhwcmVzc2lvbkhhc2hJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgaWYgKG5leHQgPT09IDEyMykge1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzSWRlbnRpZmllclN0YXJ0KG5leHQpKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzksIHRoaXMucmVhZFdvcmQxKG5leHQpKTtcbiAgICB9IGVsc2UgaWYgKG5leHQgPT09IDkyKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzksIHRoaXMucmVhZFdvcmQxKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDI3LCAxKTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX2RvdCgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1Nykge1xuICAgICAgdGhpcy5yZWFkTnVtYmVyKHRydWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNDYgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMikgPT09IDQ2KSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAzO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigyMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDE2KTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX3NsYXNoKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzEsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDU2LCAxKTtcbiAgICB9XG4gIH1cbiAgcmVhZFRva2VuX2ludGVycHJldGVyKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnBvcyAhPT0gMCB8fCB0aGlzLmxlbmd0aCA8IDIpIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAoY2ggIT09IDMzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICB0aGlzLnN0YXRlLnBvcyArPSAxO1xuICAgIHdoaWxlICghaXNOZXdMaW5lKGNoKSAmJiArK3RoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0ICsgMiwgdGhpcy5zdGF0ZS5wb3MpO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMjgsIHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSkge1xuICAgIGxldCB0eXBlID0gY29kZSA9PT0gNDIgPyA1NSA6IDU0O1xuICAgIGxldCB3aWR0aCA9IDE7XG4gICAgbGV0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAoY29kZSA9PT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICAgIHdpZHRoKys7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMik7XG4gICAgICB0eXBlID0gNTc7XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSAmJiAhdGhpcy5zdGF0ZS5pblR5cGUpIHtcbiAgICAgIHdpZHRoKys7XG4gICAgICB0eXBlID0gY29kZSA9PT0gMzcgPyAzMyA6IDMwO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaE9wKHR5cGUsIHdpZHRoKTtcbiAgfVxuICByZWFkVG9rZW5fcGlwZV9hbXAoY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA2MSkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDMwLCAzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gNDEgOiA0MiwgMik7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjb2RlID09PSAxMjQpIHtcbiAgICAgIGlmIChuZXh0ID09PSA2Mikge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDM5LCAyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwicmVjb3JkQW5kVHVwbGVcIikgJiYgbmV4dCA9PT0gMTI1KSB7XG4gICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSAhPT0gXCJiYXJcIikge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RFbmRTeW50YXhUeXBlLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oOSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpICYmIG5leHQgPT09IDkzKSB7XG4gICAgICAgIGlmICh0aGlzLmdldFBsdWdpbk9wdGlvbihcInJlY29yZEFuZFR1cGxlXCIsIFwic3ludGF4VHlwZVwiKSAhPT0gXCJiYXJcIikge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlR1cGxlRXhwcmVzc2lvbkJhckluY29ycmVjdEVuZFN5bnRheFR5cGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbig0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMzAsIDIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IDQzIDogNDUsIDEpO1xuICB9XG4gIHJlYWRUb2tlbl9jYXJldCgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYxICYmICF0aGlzLnN0YXRlLmluVHlwZSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzMiwgMik7XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSA5NCAmJiB0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgIHByb3Bvc2FsOiBcImhhY2tcIixcbiAgICAgIHRvcGljVG9rZW46IFwiXl5cIlxuICAgIH1dKSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzNywgMik7XG4gICAgICBjb25zdCBsb29rYWhlYWRDaCA9IHRoaXMuaW5wdXQuY29kZVBvaW50QXQodGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgaWYgKGxvb2thaGVhZENoID09PSA5NCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maW5pc2hPcCg0NCwgMSk7XG4gICAgfVxuICB9XG4gIHJlYWRUb2tlbl9hdFNpZ24oKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGlmIChuZXh0ID09PSA2NCAmJiB0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgIHByb3Bvc2FsOiBcImhhY2tcIixcbiAgICAgIHRvcGljVG9rZW46IFwiQEBcIlxuICAgIH1dKSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzOCwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoMjYsIDEpO1xuICAgIH1cbiAgfVxuICByZWFkVG9rZW5fcGx1c19taW4oY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gY29kZSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzNCwgMik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSA2MSkge1xuICAgICAgdGhpcy5maW5pc2hPcCgzMCwgMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNTMsIDEpO1xuICAgIH1cbiAgfVxuICByZWFkVG9rZW5fbHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcG9zXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjApIHtcbiAgICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMikgPT09IDYxKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMzAsIDMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZpbmlzaE9wKDUxLCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ5LCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hPcCg0NywgMSk7XG4gIH1cbiAgcmVhZFRva2VuX2d0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBvc1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQocG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDYyKSB7XG4gICAgICBjb25zdCBzaXplID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MgKyBzaXplKSA9PT0gNjEpIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCgzMCwgc2l6ZSArIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmZpbmlzaE9wKDUyLCBzaXplKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5leHQgPT09IDYxKSB7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ5LCAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5pc2hPcCg0OCwgMSk7XG4gIH1cbiAgcmVhZFRva2VuX2VxX2V4Y2woY29kZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICBpZiAobmV4dCA9PT0gNjEpIHtcbiAgICAgIHRoaXMuZmluaXNoT3AoNDYsIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDIpID09PSA2MSA/IDMgOiAyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNvZGUgPT09IDYxICYmIG5leHQgPT09IDYyKSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxOSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyAyOSA6IDM1LCAxKTtcbiAgfVxuICByZWFkVG9rZW5fcXVlc3Rpb24oKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpO1xuICAgIGNvbnN0IG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zICsgMik7XG4gICAgaWYgKG5leHQgPT09IDYzKSB7XG4gICAgICBpZiAobmV4dDIgPT09IDYxKSB7XG4gICAgICAgIHRoaXMuZmluaXNoT3AoMzAsIDMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCg0MCwgMik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0ID09PSA0NiAmJiAhKG5leHQyID49IDQ4ICYmIG5leHQyIDw9IDU3KSkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gMjtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTgpO1xuICAgIH0gZWxzZSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxNyk7XG4gICAgfVxuICB9XG4gIGdldFRva2VuRnJvbUNvZGUoY29kZSkge1xuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSA0NjpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fZG90KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNDA6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTApO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDQxOlxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICB0aGlzLmZpbmlzaFRva2VuKDExKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA1OTpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigxMyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNDQ6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTIpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDkxOlxuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gMTI0KSB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicmVjb3JkQW5kVHVwbGVcIiwgXCJzeW50YXhUeXBlXCIpICE9PSBcImJhclwiKSB7XG4gICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5UdXBsZUV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA5MzpcbiAgICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgICAgdGhpcy5maW5pc2hUb2tlbigzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAxMjM6XG4gICAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAxMjQpIHtcbiAgICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJyZWNvcmRBbmRUdXBsZVwiLCBcInN5bnRheFR5cGVcIikgIT09IFwiYmFyXCIpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlJlY29yZEV4cHJlc3Npb25CYXJJbmNvcnJlY3RTdGFydFN5bnRheFR5cGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc3RhdGUucG9zICs9IDI7XG4gICAgICAgICAgdGhpcy5maW5pc2hUb2tlbig2KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oNSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSAxMjU6XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICAgIHRoaXMuZmluaXNoVG9rZW4oOCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNTg6XG4gICAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImZ1bmN0aW9uQmluZFwiKSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKSA9PT0gNTgpIHtcbiAgICAgICAgICB0aGlzLmZpbmlzaE9wKDE1LCAyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICAgIHRoaXMuZmluaXNoVG9rZW4oMTQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNjM6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX3F1ZXN0aW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgOTY6XG4gICAgICAgIHRoaXMucmVhZFRlbXBsYXRlVG9rZW4oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA0ODpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5zdGF0ZS5wb3MgKyAxKTtcbiAgICAgICAgICBpZiAobmV4dCA9PT0gMTIwIHx8IG5leHQgPT09IDg4KSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRSYWRpeE51bWJlcigxNik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmV4dCA9PT0gOTggfHwgbmV4dCA9PT0gNjYpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZFJhZGl4TnVtYmVyKDIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgY2FzZSA0OTpcbiAgICAgIGNhc2UgNTA6XG4gICAgICBjYXNlIDUxOlxuICAgICAgY2FzZSA1MjpcbiAgICAgIGNhc2UgNTM6XG4gICAgICBjYXNlIDU0OlxuICAgICAgY2FzZSA1NTpcbiAgICAgIGNhc2UgNTY6XG4gICAgICBjYXNlIDU3OlxuICAgICAgICB0aGlzLnJlYWROdW1iZXIoZmFsc2UpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDM0OlxuICAgICAgY2FzZSAzOTpcbiAgICAgICAgdGhpcy5yZWFkU3RyaW5nKGNvZGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDQ3OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9zbGFzaCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIDM3OlxuICAgICAgY2FzZSA0MjpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fbXVsdF9tb2R1bG8oY29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMTI0OlxuICAgICAgY2FzZSAzODpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fcGlwZV9hbXAoY29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgOTQ6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2NhcmV0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgNDM6XG4gICAgICBjYXNlIDQ1OlxuICAgICAgICB0aGlzLnJlYWRUb2tlbl9wbHVzX21pbihjb2RlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fbHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fZ3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA2MTpcbiAgICAgIGNhc2UgMzM6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX2VxX2V4Y2woY29kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMTI2OlxuICAgICAgICB0aGlzLmZpbmlzaE9wKDM2LCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA2NDpcbiAgICAgICAgdGhpcy5yZWFkVG9rZW5fYXRTaWduKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgMzU6XG4gICAgICAgIHRoaXMucmVhZFRva2VuX251bWJlclNpZ24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSA5MjpcbiAgICAgICAgdGhpcy5yZWFkV29yZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY29kZSkpIHtcbiAgICAgICAgICB0aGlzLnJlYWRXb3JkKGNvZGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkT3JVbmV4cGVjdGVkVG9rZW4sIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSwge1xuICAgICAgdW5leHBlY3RlZDogU3RyaW5nLmZyb21Db2RlUG9pbnQoY29kZSlcbiAgICB9KTtcbiAgfVxuICBmaW5pc2hPcCh0eXBlLCBzaXplKSB7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXRlLnBvcywgdGhpcy5zdGF0ZS5wb3MgKyBzaXplKTtcbiAgICB0aGlzLnN0YXRlLnBvcyArPSBzaXplO1xuICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgc3RyKTtcbiAgfVxuICByZWFkUmVnZXhwKCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBzdGFydCA9IHRoaXMuc3RhdGUuc3RhcnQgKyAxO1xuICAgIGxldCBlc2NhcGVkLCBpbkNsYXNzO1xuICAgIGxldCB7XG4gICAgICBwb3NcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBmb3IgKDs7ICsrcG9zKSB7XG4gICAgICBpZiAocG9zID49IHRoaXMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVudGVybWluYXRlZFJlZ0V4cCwgY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHN0YXJ0TG9jLCAxKSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW50ZXJtaW5hdGVkUmVnRXhwLCBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIDEpKTtcbiAgICAgIH1cbiAgICAgIGlmIChlc2NhcGVkKSB7XG4gICAgICAgIGVzY2FwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjaCA9PT0gOTEpIHtcbiAgICAgICAgICBpbkNsYXNzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gOTMgJiYgaW5DbGFzcykge1xuICAgICAgICAgIGluQ2xhc3MgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gNDcgJiYgIWluQ2xhc3MpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlc2NhcGVkID0gY2ggPT09IDkyO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb250ZW50ID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgcG9zKTtcbiAgICArK3BvcztcbiAgICBsZXQgbW9kcyA9IFwiXCI7XG4gICAgY29uc3QgbmV4dFBvcyA9ICgpID0+IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgcG9zICsgMiAtIHN0YXJ0KTtcbiAgICB3aGlsZSAocG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNwID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhwb3MpO1xuICAgICAgY29uc3QgY2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApO1xuICAgICAgaWYgKFZBTElEX1JFR0VYX0ZMQUdTLmhhcyhjcCkpIHtcbiAgICAgICAgaWYgKGNwID09PSAxMTgpIHtcbiAgICAgICAgICBpZiAobW9kcy5pbmNsdWRlcyhcInVcIikpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkluY29tcGF0aWJsZVJlZ0V4cFVWRmxhZ3MsIG5leHRQb3MoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNwID09PSAxMTcpIHtcbiAgICAgICAgICBpZiAobW9kcy5pbmNsdWRlcyhcInZcIikpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkluY29tcGF0aWJsZVJlZ0V4cFVWRmxhZ3MsIG5leHRQb3MoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtb2RzLmluY2x1ZGVzKGNoYXIpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlUmVnRXhwRmxhZ3MsIG5leHRQb3MoKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNJZGVudGlmaWVyQ2hhcihjcCkgfHwgY3AgPT09IDkyKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1hbGZvcm1lZFJlZ0V4cEZsYWdzLCBuZXh0UG9zKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICArK3BvcztcbiAgICAgIG1vZHMgKz0gY2hhcjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3M7XG4gICAgdGhpcy5maW5pc2hUb2tlbigxMzgsIHtcbiAgICAgIHBhdHRlcm46IGNvbnRlbnQsXG4gICAgICBmbGFnczogbW9kc1xuICAgIH0pO1xuICB9XG4gIHJlYWRJbnQocmFkaXgsIGxlbiwgZm9yY2VMZW4gPSBmYWxzZSwgYWxsb3dOdW1TZXBhcmF0b3IgPSB0cnVlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbixcbiAgICAgIHBvc1xuICAgIH0gPSByZWFkSW50KHRoaXMuaW5wdXQsIHRoaXMuc3RhdGUucG9zLCB0aGlzLnN0YXRlLmxpbmVTdGFydCwgdGhpcy5zdGF0ZS5jdXJMaW5lLCByYWRpeCwgbGVuLCBmb3JjZUxlbiwgYWxsb3dOdW1TZXBhcmF0b3IsIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkSW50LCBmYWxzZSk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3M7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgcmVhZFJhZGl4TnVtYmVyKHJhZGl4KSB7XG4gICAgY29uc3Qgc3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKTtcbiAgICBsZXQgaXNCaWdJbnQgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXRlLnBvcyArPSAyO1xuICAgIGNvbnN0IHZhbCA9IHRoaXMucmVhZEludChyYWRpeCk7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGlnaXQsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChzdGFydExvYywgMiksIHtcbiAgICAgICAgcmFkaXhcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gMTEwKSB7XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgaXNCaWdJbnQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gMTA5KSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGVjaW1hbCwgc3RhcnRMb2MpO1xuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5OdW1iZXJJZGVudGlmaWVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICBpZiAoaXNCaWdJbnQpIHtcbiAgICAgIGNvbnN0IHN0ciA9IHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQsIHRoaXMuc3RhdGUucG9zKS5yZXBsYWNlKC9bX25dL2csIFwiXCIpO1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzYsIHN0cik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZmluaXNoVG9rZW4oMTM1LCB2YWwpO1xuICB9XG4gIHJlYWROdW1iZXIoc3RhcnRzV2l0aERvdCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgbGV0IGlzRmxvYXQgPSBmYWxzZTtcbiAgICBsZXQgaXNCaWdJbnQgPSBmYWxzZTtcbiAgICBsZXQgaGFzRXhwb25lbnQgPSBmYWxzZTtcbiAgICBsZXQgaXNPY3RhbCA9IGZhbHNlO1xuICAgIGlmICghc3RhcnRzV2l0aERvdCAmJiB0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkTnVtYmVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICBjb25zdCBoYXNMZWFkaW5nWmVybyA9IHRoaXMuc3RhdGUucG9zIC0gc3RhcnQgPj0gMiAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQoc3RhcnQpID09PSA0ODtcbiAgICBpZiAoaGFzTGVhZGluZ1plcm8pIHtcbiAgICAgIGNvbnN0IGludGVnZXIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gICAgICB0aGlzLnJlY29yZFN0cmljdE1vZGVFcnJvcnMoRXJyb3JzLlN0cmljdE9jdGFsTGl0ZXJhbCwgc3RhcnRMb2MpO1xuICAgICAgaWYgKCF0aGlzLnN0YXRlLnN0cmljdCkge1xuICAgICAgICBjb25zdCB1bmRlcnNjb3JlUG9zID0gaW50ZWdlci5pbmRleE9mKFwiX1wiKTtcbiAgICAgICAgaWYgKHVuZGVyc2NvcmVQb3MgPiAwKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuWmVyb0RpZ2l0TnVtZXJpY1NlcGFyYXRvciwgY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHN0YXJ0TG9jLCB1bmRlcnNjb3JlUG9zKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlzT2N0YWwgPSBoYXNMZWFkaW5nWmVybyAmJiAhL1s4OV0vLnRlc3QoaW50ZWdlcik7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gNDYgJiYgIWlzT2N0YWwpIHtcbiAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB0aGlzLnJlYWRJbnQoMTApO1xuICAgICAgaXNGbG9hdCA9IHRydWU7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMuc3RhdGUucG9zKTtcbiAgICB9XG4gICAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFpc09jdGFsKSB7XG4gICAgICBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KCsrdGhpcy5zdGF0ZS5wb3MpO1xuICAgICAgaWYgKG5leHQgPT09IDQzIHx8IG5leHQgPT09IDQ1KSB7XG4gICAgICAgICsrdGhpcy5zdGF0ZS5wb3M7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZWFkSW50KDEwKSA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkT3JNaXNzaW5nRXhwb25lbnQsIHN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIGlzRmxvYXQgPSB0cnVlO1xuICAgICAgaGFzRXhwb25lbnQgPSB0cnVlO1xuICAgICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyk7XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSAxMTApIHtcbiAgICAgIGlmIChpc0Zsb2F0IHx8IGhhc0xlYWRpbmdaZXJvKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRCaWdJbnRMaXRlcmFsLCBzdGFydExvYyk7XG4gICAgICB9XG4gICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgaXNCaWdJbnQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobmV4dCA9PT0gMTA5KSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRlY2ltYWxcIiwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgIGlmIChoYXNFeHBvbmVudCB8fCBoYXNMZWFkaW5nWmVybykge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRGVjaW1hbCwgc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgKyt0aGlzLnN0YXRlLnBvcztcbiAgICAgIHZhciBpc0RlY2ltYWwgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQodGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcykpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5OdW1iZXJJZGVudGlmaWVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgIH1cbiAgICBjb25zdCBzdHIgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnN0YXRlLnBvcykucmVwbGFjZSgvW19tbl0vZywgXCJcIik7XG4gICAgaWYgKGlzQmlnSW50KSB7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDEzNiwgc3RyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRGVjaW1hbCkge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigxMzcsIHN0cik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHZhbCA9IGlzT2N0YWwgPyBwYXJzZUludChzdHIsIDgpIDogcGFyc2VGbG9hdChzdHIpO1xuICAgIHRoaXMuZmluaXNoVG9rZW4oMTM1LCB2YWwpO1xuICB9XG4gIHJlYWRDb2RlUG9pbnQodGhyb3dPbkludmFsaWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb2RlLFxuICAgICAgcG9zXG4gICAgfSA9IHJlYWRDb2RlUG9pbnQodGhpcy5pbnB1dCwgdGhpcy5zdGF0ZS5wb3MsIHRoaXMuc3RhdGUubGluZVN0YXJ0LCB0aGlzLnN0YXRlLmN1ckxpbmUsIHRocm93T25JbnZhbGlkLCB0aGlzLmVycm9ySGFuZGxlcnNfcmVhZENvZGVQb2ludCk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3M7XG4gICAgcmV0dXJuIGNvZGU7XG4gIH1cbiAgcmVhZFN0cmluZyhxdW90ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0cixcbiAgICAgIHBvcyxcbiAgICAgIGN1ckxpbmUsXG4gICAgICBsaW5lU3RhcnRcbiAgICB9ID0gcmVhZFN0cmluZ0NvbnRlbnRzKHF1b3RlID09PSAzNCA/IFwiZG91YmxlXCIgOiBcInNpbmdsZVwiLCB0aGlzLmlucHV0LCB0aGlzLnN0YXRlLnBvcyArIDEsIHRoaXMuc3RhdGUubGluZVN0YXJ0LCB0aGlzLnN0YXRlLmN1ckxpbmUsIHRoaXMuZXJyb3JIYW5kbGVyc19yZWFkU3RyaW5nQ29udGVudHNfc3RyaW5nKTtcbiAgICB0aGlzLnN0YXRlLnBvcyA9IHBvcyArIDE7XG4gICAgdGhpcy5zdGF0ZS5saW5lU3RhcnQgPSBsaW5lU3RhcnQ7XG4gICAgdGhpcy5zdGF0ZS5jdXJMaW5lID0gY3VyTGluZTtcbiAgICB0aGlzLmZpbmlzaFRva2VuKDEzNCwgc3RyKTtcbiAgfVxuICByZWFkVGVtcGxhdGVDb250aW51YXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQobnVsbCwgOCk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUucG9zLS07XG4gICAgdGhpcy5yZWFkVGVtcGxhdGVUb2tlbigpO1xuICB9XG4gIHJlYWRUZW1wbGF0ZVRva2VuKCkge1xuICAgIGNvbnN0IG9wZW5pbmcgPSB0aGlzLmlucHV0W3RoaXMuc3RhdGUucG9zXTtcbiAgICBjb25zdCB7XG4gICAgICBzdHIsXG4gICAgICBmaXJzdEludmFsaWRMb2MsXG4gICAgICBwb3MsXG4gICAgICBjdXJMaW5lLFxuICAgICAgbGluZVN0YXJ0XG4gICAgfSA9IHJlYWRTdHJpbmdDb250ZW50cyhcInRlbXBsYXRlXCIsIHRoaXMuaW5wdXQsIHRoaXMuc3RhdGUucG9zICsgMSwgdGhpcy5zdGF0ZS5saW5lU3RhcnQsIHRoaXMuc3RhdGUuY3VyTGluZSwgdGhpcy5lcnJvckhhbmRsZXJzX3JlYWRTdHJpbmdDb250ZW50c190ZW1wbGF0ZSk7XG4gICAgdGhpcy5zdGF0ZS5wb3MgPSBwb3MgKyAxO1xuICAgIHRoaXMuc3RhdGUubGluZVN0YXJ0ID0gbGluZVN0YXJ0O1xuICAgIHRoaXMuc3RhdGUuY3VyTGluZSA9IGN1ckxpbmU7XG4gICAgaWYgKGZpcnN0SW52YWxpZExvYykge1xuICAgICAgdGhpcy5zdGF0ZS5maXJzdEludmFsaWRUZW1wbGF0ZUVzY2FwZVBvcyA9IG5ldyBQb3NpdGlvbihmaXJzdEludmFsaWRMb2MuY3VyTGluZSwgZmlyc3RJbnZhbGlkTG9jLnBvcyAtIGZpcnN0SW52YWxpZExvYy5saW5lU3RhcnQsIHRoaXMuc291cmNlVG9PZmZzZXRQb3MoZmlyc3RJbnZhbGlkTG9jLnBvcykpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbnB1dC5jb2RlUG9pbnRBdChwb3MpID09PSA5Nikge1xuICAgICAgdGhpcy5maW5pc2hUb2tlbigyNCwgZmlyc3RJbnZhbGlkTG9jID8gbnVsbCA6IG9wZW5pbmcgKyBzdHIgKyBcImBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zKys7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDI1LCBmaXJzdEludmFsaWRMb2MgPyBudWxsIDogb3BlbmluZyArIHN0ciArIFwiJHtcIik7XG4gICAgfVxuICB9XG4gIHJlY29yZFN0cmljdE1vZGVFcnJvcnModG9QYXJzZUVycm9yLCBhdCkge1xuICAgIGNvbnN0IGluZGV4ID0gYXQuaW5kZXg7XG4gICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmICF0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5oYXMoaW5kZXgpKSB7XG4gICAgICB0aGlzLnJhaXNlKHRvUGFyc2VFcnJvciwgYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5zZXQoaW5kZXgsIFt0b1BhcnNlRXJyb3IsIGF0XSk7XG4gICAgfVxuICB9XG4gIHJlYWRXb3JkMShmaXJzdENvZGUpIHtcbiAgICB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gICAgbGV0IHdvcmQgPSBcIlwiO1xuICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5zdGF0ZS5wb3M7XG4gICAgbGV0IGNodW5rU3RhcnQgPSB0aGlzLnN0YXRlLnBvcztcbiAgICBpZiAoZmlyc3RDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zICs9IGZpcnN0Q29kZSA8PSAweGZmZmYgPyAxIDogMjtcbiAgICB9XG4gICAgd2hpbGUgKHRoaXMuc3RhdGUucG9zIDwgdGhpcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGNoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyh0aGlzLnN0YXRlLnBvcyk7XG4gICAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZS5wb3MgKz0gY2ggPD0gMHhmZmZmID8gMSA6IDI7XG4gICAgICB9IGVsc2UgaWYgKGNoID09PSA5Mikge1xuICAgICAgICB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjID0gdHJ1ZTtcbiAgICAgICAgd29yZCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMuc3RhdGUucG9zKTtcbiAgICAgICAgY29uc3QgZXNjU3RhcnQgPSB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCk7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXJDaGVjayA9IHRoaXMuc3RhdGUucG9zID09PSBzdGFydCA/IGlzSWRlbnRpZmllclN0YXJ0IDogaXNJZGVudGlmaWVyQ2hhcjtcbiAgICAgICAgaWYgKHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMuc3RhdGUucG9zKSAhPT0gMTE3KSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ1VuaWNvZGVFc2NhcGUsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICArK3RoaXMuc3RhdGUucG9zO1xuICAgICAgICBjb25zdCBlc2MgPSB0aGlzLnJlYWRDb2RlUG9pbnQodHJ1ZSk7XG4gICAgICAgIGlmIChlc2MgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoIWlkZW50aWZpZXJDaGVjayhlc2MpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Fc2NhcGVkQ2hhck5vdEFuSWRlbnRpZmllciwgZXNjU3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JkICs9IFN0cmluZy5mcm9tQ29kZVBvaW50KGVzYyk7XG4gICAgICAgIH1cbiAgICAgICAgY2h1bmtTdGFydCA9IHRoaXMuc3RhdGUucG9zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3b3JkICsgdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnN0YXRlLnBvcyk7XG4gIH1cbiAgcmVhZFdvcmQoZmlyc3RDb2RlKSB7XG4gICAgY29uc3Qgd29yZCA9IHRoaXMucmVhZFdvcmQxKGZpcnN0Q29kZSk7XG4gICAgY29uc3QgdHlwZSA9IGtleXdvcmRzJDEuZ2V0KHdvcmQpO1xuICAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgdG9rZW5MYWJlbE5hbWUodHlwZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpbmlzaFRva2VuKDEzMiwgd29yZCk7XG4gICAgfVxuICB9XG4gIGNoZWNrS2V5d29yZEVzY2FwZXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0b2tlbklzS2V5d29yZCh0eXBlKSAmJiB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkRXNjYXBlZFJlc2VydmVkV29yZCwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICByZXNlcnZlZFdvcmQ6IHRva2VuTGFiZWxOYW1lKHR5cGUpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmFpc2UodG9QYXJzZUVycm9yLCBhdCwgZGV0YWlscyA9IHt9KSB7XG4gICAgY29uc3QgbG9jID0gYXQgaW5zdGFuY2VvZiBQb3NpdGlvbiA/IGF0IDogYXQubG9jLnN0YXJ0O1xuICAgIGNvbnN0IGVycm9yID0gdG9QYXJzZUVycm9yKGxvYywgZGV0YWlscyk7XG4gICAgaWYgKCEodGhpcy5vcHRpb25GbGFncyAmIDIwNDgpKSB0aHJvdyBlcnJvcjtcbiAgICBpZiAoIXRoaXMuaXNMb29rYWhlYWQpIHRoaXMuc3RhdGUuZXJyb3JzLnB1c2goZXJyb3IpO1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICByYWlzZU92ZXJ3cml0ZSh0b1BhcnNlRXJyb3IsIGF0LCBkZXRhaWxzID0ge30pIHtcbiAgICBjb25zdCBsb2MgPSBhdCBpbnN0YW5jZW9mIFBvc2l0aW9uID8gYXQgOiBhdC5sb2Muc3RhcnQ7XG4gICAgY29uc3QgcG9zID0gbG9jLmluZGV4O1xuICAgIGNvbnN0IGVycm9ycyA9IHRoaXMuc3RhdGUuZXJyb3JzO1xuICAgIGZvciAobGV0IGkgPSBlcnJvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGVycm9yID0gZXJyb3JzW2ldO1xuICAgICAgaWYgKGVycm9yLmxvYy5pbmRleCA9PT0gcG9zKSB7XG4gICAgICAgIHJldHVybiBlcnJvcnNbaV0gPSB0b1BhcnNlRXJyb3IobG9jLCBkZXRhaWxzKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5sb2MuaW5kZXggPCBwb3MpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yYWlzZSh0b1BhcnNlRXJyb3IsIGF0LCBkZXRhaWxzKTtcbiAgfVxuICB1cGRhdGVDb250ZXh0KHByZXZUeXBlKSB7fVxuICB1bmV4cGVjdGVkKGxvYywgdHlwZSkge1xuICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRUb2tlbiwgbG9jICE9IG51bGwgPyBsb2MgOiB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICBleHBlY3RlZDogdHlwZSA/IHRva2VuTGFiZWxOYW1lKHR5cGUpIDogbnVsbFxuICAgIH0pO1xuICB9XG4gIGV4cGVjdFBsdWdpbihwbHVnaW5OYW1lLCBsb2MpIHtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4ocGx1Z2luTmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5NaXNzaW5nUGx1Z2luLCBsb2MgIT0gbnVsbCA/IGxvYyA6IHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgIG1pc3NpbmdQbHVnaW46IFtwbHVnaW5OYW1lXVxuICAgIH0pO1xuICB9XG4gIGV4cGVjdE9uZVBsdWdpbihwbHVnaW5OYW1lcykge1xuICAgIGlmICghcGx1Z2luTmFtZXMuc29tZShuYW1lID0+IHRoaXMuaGFzUGx1Z2luKG5hbWUpKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ09uZU9mUGx1Z2lucywgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICBtaXNzaW5nUGx1Z2luOiBwbHVnaW5OYW1lc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGVycm9yQnVpbGRlcihlcnJvcikge1xuICAgIHJldHVybiAocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpID0+IHtcbiAgICAgIHRoaXMucmFpc2UoZXJyb3IsIGJ1aWxkUG9zaXRpb24ocG9zLCBsaW5lU3RhcnQsIGN1ckxpbmUpKTtcbiAgICB9O1xuICB9XG59XG5jbGFzcyBDbGFzc1Njb3BlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5wcml2YXRlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5sb25lQWNjZXNzb3JzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudW5kZWZpbmVkUHJpdmF0ZU5hbWVzID0gbmV3IE1hcCgpO1xuICB9XG59XG5jbGFzcyBDbGFzc1Njb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLnVuZGVmaW5lZFByaXZhdGVOYW1lcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBjdXJyZW50KCkge1xuICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gIH1cbiAgZW50ZXIoKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKG5ldyBDbGFzc1Njb3BlKCkpO1xuICB9XG4gIGV4aXQoKSB7XG4gICAgY29uc3Qgb2xkQ2xhc3NTY29wZSA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudCgpO1xuICAgIGZvciAoY29uc3QgW25hbWUsIGxvY10gb2YgQXJyYXkuZnJvbShvbGRDbGFzc1Njb3BlLnVuZGVmaW5lZFByaXZhdGVOYW1lcykpIHtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIGlmICghY3VycmVudC51bmRlZmluZWRQcml2YXRlTmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgY3VycmVudC51bmRlZmluZWRQcml2YXRlTmFtZXMuc2V0KG5hbWUsIGxvYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucGFyc2VyLnJhaXNlKEVycm9ycy5JbnZhbGlkUHJpdmF0ZUZpZWxkUmVzb2x1dGlvbiwgbG9jLCB7XG4gICAgICAgICAgaWRlbnRpZmllck5hbWU6IG5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRlY2xhcmVQcml2YXRlTmFtZShuYW1lLCBlbGVtZW50VHlwZSwgbG9jKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZU5hbWVzLFxuICAgICAgbG9uZUFjY2Vzc29ycyxcbiAgICAgIHVuZGVmaW5lZFByaXZhdGVOYW1lc1xuICAgIH0gPSB0aGlzLmN1cnJlbnQoKTtcbiAgICBsZXQgcmVkZWZpbmVkID0gcHJpdmF0ZU5hbWVzLmhhcyhuYW1lKTtcbiAgICBpZiAoZWxlbWVudFR5cGUgJiAzKSB7XG4gICAgICBjb25zdCBhY2Nlc3NvciA9IHJlZGVmaW5lZCAmJiBsb25lQWNjZXNzb3JzLmdldChuYW1lKTtcbiAgICAgIGlmIChhY2Nlc3Nvcikge1xuICAgICAgICBjb25zdCBvbGRTdGF0aWMgPSBhY2Nlc3NvciAmIDQ7XG4gICAgICAgIGNvbnN0IG5ld1N0YXRpYyA9IGVsZW1lbnRUeXBlICYgNDtcbiAgICAgICAgY29uc3Qgb2xkS2luZCA9IGFjY2Vzc29yICYgMztcbiAgICAgICAgY29uc3QgbmV3S2luZCA9IGVsZW1lbnRUeXBlICYgMztcbiAgICAgICAgcmVkZWZpbmVkID0gb2xkS2luZCA9PT0gbmV3S2luZCB8fCBvbGRTdGF0aWMgIT09IG5ld1N0YXRpYztcbiAgICAgICAgaWYgKCFyZWRlZmluZWQpIGxvbmVBY2Nlc3NvcnMuZGVsZXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIGlmICghcmVkZWZpbmVkKSB7XG4gICAgICAgIGxvbmVBY2Nlc3NvcnMuc2V0KG5hbWUsIGVsZW1lbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlZGVmaW5lZCkge1xuICAgICAgdGhpcy5wYXJzZXIucmFpc2UoRXJyb3JzLlByaXZhdGVOYW1lUmVkZWNsYXJhdGlvbiwgbG9jLCB7XG4gICAgICAgIGlkZW50aWZpZXJOYW1lOiBuYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgcHJpdmF0ZU5hbWVzLmFkZChuYW1lKTtcbiAgICB1bmRlZmluZWRQcml2YXRlTmFtZXMuZGVsZXRlKG5hbWUpO1xuICB9XG4gIHVzZVByaXZhdGVOYW1lKG5hbWUsIGxvYykge1xuICAgIGxldCBjbGFzc1Njb3BlO1xuICAgIGZvciAoY2xhc3NTY29wZSBvZiB0aGlzLnN0YWNrKSB7XG4gICAgICBpZiAoY2xhc3NTY29wZS5wcml2YXRlTmFtZXMuaGFzKG5hbWUpKSByZXR1cm47XG4gICAgfVxuICAgIGlmIChjbGFzc1Njb3BlKSB7XG4gICAgICBjbGFzc1Njb3BlLnVuZGVmaW5lZFByaXZhdGVOYW1lcy5zZXQobmFtZSwgbG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJzZXIucmFpc2UoRXJyb3JzLkludmFsaWRQcml2YXRlRmllbGRSZXNvbHV0aW9uLCBsb2MsIHtcbiAgICAgICAgaWRlbnRpZmllck5hbWU6IG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgRXhwcmVzc2lvblNjb3BlIHtcbiAgY29uc3RydWN0b3IodHlwZSA9IDApIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG4gIGNhbkJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSAyIHx8IHRoaXMudHlwZSA9PT0gMTtcbiAgfVxuICBpc0NlcnRhaW5seVBhcmFtZXRlckRlY2xhcmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09IDM7XG4gIH1cbn1cbmNsYXNzIEFycm93SGVhZFBhcnNpbmdTY29wZSBleHRlbmRzIEV4cHJlc3Npb25TY29wZSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICBzdXBlcih0eXBlKTtcbiAgICB0aGlzLmRlY2xhcmF0aW9uRXJyb3JzID0gbmV3IE1hcCgpO1xuICB9XG4gIHJlY29yZERlY2xhcmF0aW9uRXJyb3IoUGFyc2luZ0Vycm9yQ2xhc3MsIGF0KSB7XG4gICAgY29uc3QgaW5kZXggPSBhdC5pbmRleDtcbiAgICB0aGlzLmRlY2xhcmF0aW9uRXJyb3JzLnNldChpbmRleCwgW1BhcnNpbmdFcnJvckNsYXNzLCBhdF0pO1xuICB9XG4gIGNsZWFyRGVjbGFyYXRpb25FcnJvcihpbmRleCkge1xuICAgIHRoaXMuZGVjbGFyYXRpb25FcnJvcnMuZGVsZXRlKGluZGV4KTtcbiAgfVxuICBpdGVyYXRlRXJyb3JzKGl0ZXJhdG9yKSB7XG4gICAgdGhpcy5kZWNsYXJhdGlvbkVycm9ycy5mb3JFYWNoKGl0ZXJhdG9yKTtcbiAgfVxufVxuY2xhc3MgRXhwcmVzc2lvblNjb3BlSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlcikge1xuICAgIHRoaXMucGFyc2VyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhY2sgPSBbbmV3IEV4cHJlc3Npb25TY29wZSgpXTtcbiAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgfVxuICBlbnRlcihzY29wZSkge1xuICAgIHRoaXMuc3RhY2sucHVzaChzY29wZSk7XG4gIH1cbiAgZXhpdCgpIHtcbiAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICB9XG4gIHJlY29yZFBhcmFtZXRlckluaXRpYWxpemVyRXJyb3IodG9QYXJzZUVycm9yLCBub2RlKSB7XG4gICAgY29uc3Qgb3JpZ2luID0gbm9kZS5sb2Muc3RhcnQ7XG4gICAgY29uc3Qge1xuICAgICAgc3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgaSA9IHN0YWNrLmxlbmd0aCAtIDE7XG4gICAgbGV0IHNjb3BlID0gc3RhY2tbaV07XG4gICAgd2hpbGUgKCFzY29wZS5pc0NlcnRhaW5seVBhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHtcbiAgICAgIGlmIChzY29wZS5jYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSkge1xuICAgICAgICBzY29wZS5yZWNvcmREZWNsYXJhdGlvbkVycm9yKHRvUGFyc2VFcnJvciwgb3JpZ2luKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHNjb3BlID0gc3RhY2tbLS1pXTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZXIucmFpc2UodG9QYXJzZUVycm9yLCBvcmlnaW4pO1xuICB9XG4gIHJlY29yZEFycm93UGFyYW1ldGVyQmluZGluZ0Vycm9yKGVycm9yLCBub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhY2tcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBzY29wZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUubG9jLnN0YXJ0O1xuICAgIGlmIChzY29wZS5pc0NlcnRhaW5seVBhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKGVycm9yLCBvcmlnaW4pO1xuICAgIH0gZWxzZSBpZiAoc2NvcGUuY2FuQmVBcnJvd1BhcmFtZXRlckRlY2xhcmF0aW9uKCkpIHtcbiAgICAgIHNjb3BlLnJlY29yZERlY2xhcmF0aW9uRXJyb3IoZXJyb3IsIG9yaWdpbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgcmVjb3JkQXN5bmNBcnJvd1BhcmFtZXRlcnNFcnJvcihhdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICAgIGxldCBzY29wZSA9IHN0YWNrW2ldO1xuICAgIHdoaWxlIChzY29wZS5jYW5CZUFycm93UGFyYW1ldGVyRGVjbGFyYXRpb24oKSkge1xuICAgICAgaWYgKHNjb3BlLnR5cGUgPT09IDIpIHtcbiAgICAgICAgc2NvcGUucmVjb3JkRGVjbGFyYXRpb25FcnJvcihFcnJvcnMuQXdhaXRCaW5kaW5nSWRlbnRpZmllciwgYXQpO1xuICAgICAgfVxuICAgICAgc2NvcGUgPSBzdGFja1stLWldO1xuICAgIH1cbiAgfVxuICB2YWxpZGF0ZUFzUGF0dGVybigpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFja1xuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGN1cnJlbnRTY29wZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmICghY3VycmVudFNjb3BlLmNhbkJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSByZXR1cm47XG4gICAgY3VycmVudFNjb3BlLml0ZXJhdGVFcnJvcnMoKFt0b1BhcnNlRXJyb3IsIGxvY10pID0+IHtcbiAgICAgIHRoaXMucGFyc2VyLnJhaXNlKHRvUGFyc2VFcnJvciwgbG9jKTtcbiAgICAgIGxldCBpID0gc3RhY2subGVuZ3RoIC0gMjtcbiAgICAgIGxldCBzY29wZSA9IHN0YWNrW2ldO1xuICAgICAgd2hpbGUgKHNjb3BlLmNhbkJlQXJyb3dQYXJhbWV0ZXJEZWNsYXJhdGlvbigpKSB7XG4gICAgICAgIHNjb3BlLmNsZWFyRGVjbGFyYXRpb25FcnJvcihsb2MuaW5kZXgpO1xuICAgICAgICBzY29wZSA9IHN0YWNrWy0taV07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5ld1BhcmFtZXRlckRlY2xhcmF0aW9uU2NvcGUoKSB7XG4gIHJldHVybiBuZXcgRXhwcmVzc2lvblNjb3BlKDMpO1xufVxuZnVuY3Rpb24gbmV3QXJyb3dIZWFkU2NvcGUoKSB7XG4gIHJldHVybiBuZXcgQXJyb3dIZWFkUGFyc2luZ1Njb3BlKDEpO1xufVxuZnVuY3Rpb24gbmV3QXN5bmNBcnJvd1Njb3BlKCkge1xuICByZXR1cm4gbmV3IEFycm93SGVhZFBhcnNpbmdTY29wZSgyKTtcbn1cbmZ1bmN0aW9uIG5ld0V4cHJlc3Npb25TY29wZSgpIHtcbiAgcmV0dXJuIG5ldyBFeHByZXNzaW9uU2NvcGUoKTtcbn1cbmNsYXNzIFV0aWxQYXJzZXIgZXh0ZW5kcyBUb2tlbml6ZXIge1xuICBhZGRFeHRyYShub2RlLCBrZXksIHZhbHVlLCBlbnVtZXJhYmxlID0gdHJ1ZSkge1xuICAgIGlmICghbm9kZSkgcmV0dXJuO1xuICAgIGxldCB7XG4gICAgICBleHRyYVxuICAgIH0gPSBub2RlO1xuICAgIGlmIChleHRyYSA9PSBudWxsKSB7XG4gICAgICBleHRyYSA9IHt9O1xuICAgICAgbm9kZS5leHRyYSA9IGV4dHJhO1xuICAgIH1cbiAgICBpZiAoZW51bWVyYWJsZSkge1xuICAgICAgZXh0cmFba2V5XSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXh0cmEsIGtleSwge1xuICAgICAgICBlbnVtZXJhYmxlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlzQ29udGV4dHVhbCh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLnR5cGUgPT09IHRva2VuICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICB9XG4gIGlzVW5wYXJzZWRDb250ZXh0dWFsKG5hbWVTdGFydCwgbmFtZSkge1xuICAgIGlmICh0aGlzLmlucHV0LnN0YXJ0c1dpdGgobmFtZSwgbmFtZVN0YXJ0KSkge1xuICAgICAgY29uc3QgbmV4dENoID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5hbWVTdGFydCArIG5hbWUubGVuZ3RoKTtcbiAgICAgIHJldHVybiAhKGlzSWRlbnRpZmllckNoYXIobmV4dENoKSB8fCAobmV4dENoICYgMHhmYzAwKSA9PT0gMHhkODAwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlzTG9va2FoZWFkQ29udGV4dHVhbChuYW1lKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICByZXR1cm4gdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBuYW1lKTtcbiAgfVxuICBlYXRDb250ZXh0dWFsKHRva2VuKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKHRva2VuKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4cGVjdENvbnRleHR1YWwodG9rZW4sIHRvUGFyc2VFcnJvcikge1xuICAgIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKHRva2VuKSkge1xuICAgICAgaWYgKHRvUGFyc2VFcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UodG9QYXJzZUVycm9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCB0b2tlbik7XG4gICAgfVxuICB9XG4gIGNhbkluc2VydFNlbWljb2xvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNDApIHx8IHRoaXMubWF0Y2goOCkgfHwgdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKTtcbiAgfVxuICBoYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSB7XG4gICAgcmV0dXJuIGhhc05ld0xpbmUodGhpcy5pbnB1dCwgdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyh0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MuaW5kZXgpLCB0aGlzLnN0YXRlLnN0YXJ0KTtcbiAgfVxuICBoYXNGb2xsb3dpbmdMaW5lQnJlYWsoKSB7XG4gICAgcmV0dXJuIGhhc05ld0xpbmUodGhpcy5pbnB1dCwgdGhpcy5zdGF0ZS5lbmQsIHRoaXMubmV4dFRva2VuU3RhcnQoKSk7XG4gIH1cbiAgaXNMaW5lVGVybWluYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5lYXQoMTMpIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gIH1cbiAgc2VtaWNvbG9uKGFsbG93QXNpID0gdHJ1ZSkge1xuICAgIGlmIChhbGxvd0FzaSA/IHRoaXMuaXNMaW5lVGVybWluYXRvcigpIDogdGhpcy5lYXQoMTMpKSByZXR1cm47XG4gICAgdGhpcy5yYWlzZShFcnJvcnMuTWlzc2luZ1NlbWljb2xvbiwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgfVxuICBleHBlY3QodHlwZSwgbG9jKSB7XG4gICAgaWYgKCF0aGlzLmVhdCh0eXBlKSkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKGxvYywgdHlwZSk7XG4gICAgfVxuICB9XG4gIHRyeVBhcnNlKGZuLCBvbGRTdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKSkge1xuICAgIGNvbnN0IGFib3J0U2lnbmFsID0ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5vZGUgPSBmbigobm9kZSA9IG51bGwpID0+IHtcbiAgICAgICAgYWJvcnRTaWduYWwubm9kZSA9IG5vZGU7XG4gICAgICAgIHRocm93IGFib3J0U2lnbmFsO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcnMubGVuZ3RoID4gb2xkU3RhdGUuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBmYWlsU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICB0aGlzLnN0YXRlID0gb2xkU3RhdGU7XG4gICAgICAgIHRoaXMuc3RhdGUudG9rZW5zTGVuZ3RoID0gZmFpbFN0YXRlLnRva2Vuc0xlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGVycm9yOiBmYWlsU3RhdGUuZXJyb3JzW29sZFN0YXRlLmVycm9ycy5sZW5ndGhdLFxuICAgICAgICAgIHRocm93bjogZmFsc2UsXG4gICAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgdGhyb3duOiBmYWxzZSxcbiAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgIGZhaWxTdGF0ZTogbnVsbFxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZmFpbFN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgIHRoaXMuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbnVsbCxcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICB0aHJvd246IHRydWUsXG4gICAgICAgICAgYWJvcnRlZDogZmFsc2UsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IgPT09IGFib3J0U2lnbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogYWJvcnRTaWduYWwubm9kZSxcbiAgICAgICAgICBlcnJvcjogbnVsbCxcbiAgICAgICAgICB0aHJvd246IGZhbHNlLFxuICAgICAgICAgIGFib3J0ZWQ6IHRydWUsXG4gICAgICAgICAgZmFpbFN0YXRlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFuZFRocm93KSB7XG4gICAgaWYgKCFyZWZFeHByZXNzaW9uRXJyb3JzKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3Qge1xuICAgICAgc2hvcnRoYW5kQXNzaWduTG9jLFxuICAgICAgZG91YmxlUHJvdG9Mb2MsXG4gICAgICBwcml2YXRlS2V5TG9jLFxuICAgICAgb3B0aW9uYWxQYXJhbWV0ZXJzTG9jLFxuICAgICAgdm9pZFBhdHRlcm5Mb2NcbiAgICB9ID0gcmVmRXhwcmVzc2lvbkVycm9ycztcbiAgICBjb25zdCBoYXNFcnJvcnMgPSAhIXNob3J0aGFuZEFzc2lnbkxvYyB8fCAhIWRvdWJsZVByb3RvTG9jIHx8ICEhb3B0aW9uYWxQYXJhbWV0ZXJzTG9jIHx8ICEhcHJpdmF0ZUtleUxvYyB8fCAhIXZvaWRQYXR0ZXJuTG9jO1xuICAgIGlmICghYW5kVGhyb3cpIHtcbiAgICAgIHJldHVybiBoYXNFcnJvcnM7XG4gICAgfVxuICAgIGlmIChzaG9ydGhhbmRBc3NpZ25Mb2MgIT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZENvdmVySW5pdGlhbGl6ZWROYW1lLCBzaG9ydGhhbmRBc3NpZ25Mb2MpO1xuICAgIH1cbiAgICBpZiAoZG91YmxlUHJvdG9Mb2MgIT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlUHJvdG8sIGRvdWJsZVByb3RvTG9jKTtcbiAgICB9XG4gICAgaWYgKHByaXZhdGVLZXlMb2MgIT0gbnVsbCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFByaXZhdGVGaWVsZCwgcHJpdmF0ZUtleUxvYyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25hbFBhcmFtZXRlcnNMb2MgIT0gbnVsbCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG9wdGlvbmFsUGFyYW1ldGVyc0xvYyk7XG4gICAgfVxuICAgIGlmICh2b2lkUGF0dGVybkxvYyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkQ292ZXJEaXNjYXJkRWxlbWVudCwgdm9pZFBhdHRlcm5Mb2MpO1xuICAgIH1cbiAgfVxuICBpc0xpdGVyYWxQcm9wZXJ0eU5hbWUoKSB7XG4gICAgcmV0dXJuIHRva2VuSXNMaXRlcmFsUHJvcGVydHlOYW1lKHRoaXMuc3RhdGUudHlwZSk7XG4gIH1cbiAgaXNQcml2YXRlTmFtZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJQcml2YXRlTmFtZVwiO1xuICB9XG4gIGdldFByaXZhdGVOYW1lU1Yobm9kZSkge1xuICAgIHJldHVybiBub2RlLmlkLm5hbWU7XG4gIH1cbiAgaGFzUHJvcGVydHlBc1ByaXZhdGVOYW1lKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUudHlwZSA9PT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgfHwgbm9kZS50eXBlID09PSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiKSAmJiB0aGlzLmlzUHJpdmF0ZU5hbWUobm9kZS5wcm9wZXJ0eSk7XG4gIH1cbiAgaXNPYmplY3RQcm9wZXJ0eShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJPYmplY3RQcm9wZXJ0eVwiO1xuICB9XG4gIGlzT2JqZWN0TWV0aG9kKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS50eXBlID09PSBcIk9iamVjdE1ldGhvZFwiO1xuICB9XG4gIGluaXRpYWxpemVTY29wZXMoaW5Nb2R1bGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIikge1xuICAgIGNvbnN0IG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgY29uc3Qgb2xkRXhwb3J0ZWRJZGVudGlmaWVycyA9IHRoaXMuZXhwb3J0ZWRJZGVudGlmaWVycztcbiAgICB0aGlzLmV4cG9ydGVkSWRlbnRpZmllcnMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3Qgb2xkSW5Nb2R1bGUgPSB0aGlzLmluTW9kdWxlO1xuICAgIHRoaXMuaW5Nb2R1bGUgPSBpbk1vZHVsZTtcbiAgICBjb25zdCBvbGRTY29wZSA9IHRoaXMuc2NvcGU7XG4gICAgY29uc3QgU2NvcGVIYW5kbGVyID0gdGhpcy5nZXRTY29wZUhhbmRsZXIoKTtcbiAgICB0aGlzLnNjb3BlID0gbmV3IFNjb3BlSGFuZGxlcih0aGlzLCBpbk1vZHVsZSk7XG4gICAgY29uc3Qgb2xkUHJvZFBhcmFtID0gdGhpcy5wcm9kUGFyYW07XG4gICAgdGhpcy5wcm9kUGFyYW0gPSBuZXcgUHJvZHVjdGlvblBhcmFtZXRlckhhbmRsZXIoKTtcbiAgICBjb25zdCBvbGRDbGFzc1Njb3BlID0gdGhpcy5jbGFzc1Njb3BlO1xuICAgIHRoaXMuY2xhc3NTY29wZSA9IG5ldyBDbGFzc1Njb3BlSGFuZGxlcih0aGlzKTtcbiAgICBjb25zdCBvbGRFeHByZXNzaW9uU2NvcGUgPSB0aGlzLmV4cHJlc3Npb25TY29wZTtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZSA9IG5ldyBFeHByZXNzaW9uU2NvcGVIYW5kbGVyKHRoaXMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aGlzLnN0YXRlLmxhYmVscyA9IG9sZExhYmVscztcbiAgICAgIHRoaXMuZXhwb3J0ZWRJZGVudGlmaWVycyA9IG9sZEV4cG9ydGVkSWRlbnRpZmllcnM7XG4gICAgICB0aGlzLmluTW9kdWxlID0gb2xkSW5Nb2R1bGU7XG4gICAgICB0aGlzLnNjb3BlID0gb2xkU2NvcGU7XG4gICAgICB0aGlzLnByb2RQYXJhbSA9IG9sZFByb2RQYXJhbTtcbiAgICAgIHRoaXMuY2xhc3NTY29wZSA9IG9sZENsYXNzU2NvcGU7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZSA9IG9sZEV4cHJlc3Npb25TY29wZTtcbiAgICB9O1xuICB9XG4gIGVudGVySW5pdGlhbFNjb3BlcygpIHtcbiAgICBsZXQgcGFyYW1GbGFncyA9IDA7XG4gICAgaWYgKHRoaXMuaW5Nb2R1bGUgfHwgdGhpcy5vcHRpb25GbGFncyAmIDEpIHtcbiAgICAgIHBhcmFtRmxhZ3MgfD0gMjtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAzMikge1xuICAgICAgcGFyYW1GbGFncyB8PSAxO1xuICAgIH1cbiAgICBjb25zdCBpc0NvbW1vbkpTID0gIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5vcHRpb25zLnNvdXJjZVR5cGUgPT09IFwiY29tbW9uanNcIjtcbiAgICBpZiAoaXNDb21tb25KUyB8fCB0aGlzLm9wdGlvbkZsYWdzICYgMikge1xuICAgICAgcGFyYW1GbGFncyB8PSA0O1xuICAgIH1cbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihwYXJhbUZsYWdzKTtcbiAgICBsZXQgc2NvcGVGbGFncyA9IGlzQ29tbW9uSlMgPyA1MTQgOiAxO1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgNCkge1xuICAgICAgc2NvcGVGbGFncyB8PSA1MTI7XG4gICAgfVxuICAgIHRoaXMuc2NvcGUuZW50ZXIoc2NvcGVGbGFncyk7XG4gIH1cbiAgY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJpdmF0ZUtleUxvY1xuICAgIH0gPSByZWZFeHByZXNzaW9uRXJyb3JzO1xuICAgIGlmIChwcml2YXRlS2V5TG9jICE9PSBudWxsKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRlc3RydWN0dXJpbmdQcml2YXRlXCIsIHByaXZhdGVLZXlMb2MpO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgRXhwcmVzc2lvbkVycm9ycyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc2hvcnRoYW5kQXNzaWduTG9jID0gbnVsbDtcbiAgICB0aGlzLmRvdWJsZVByb3RvTG9jID0gbnVsbDtcbiAgICB0aGlzLnByaXZhdGVLZXlMb2MgPSBudWxsO1xuICAgIHRoaXMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jID0gbnVsbDtcbiAgICB0aGlzLnZvaWRQYXR0ZXJuTG9jID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHBhcnNlciwgcG9zLCBsb2MpIHtcbiAgICB0aGlzLnR5cGUgPSBcIlwiO1xuICAgIHRoaXMuc3RhcnQgPSBwb3M7XG4gICAgdGhpcy5lbmQgPSAwO1xuICAgIHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKGxvYyk7XG4gICAgaWYgKChwYXJzZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcnNlci5vcHRpb25GbGFncykgJiAxMjgpIHRoaXMucmFuZ2UgPSBbcG9zLCAwXTtcbiAgICBpZiAocGFyc2VyICE9IG51bGwgJiYgcGFyc2VyLmZpbGVuYW1lKSB0aGlzLmxvYy5maWxlbmFtZSA9IHBhcnNlci5maWxlbmFtZTtcbiAgfVxufVxuY29uc3QgTm9kZVByb3RvdHlwZSA9IE5vZGUucHJvdG90eXBlO1xuTm9kZVByb3RvdHlwZS5fX2Nsb25lID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBuZXdOb2RlID0gbmV3IE5vZGUodW5kZWZpbmVkLCB0aGlzLnN0YXJ0LCB0aGlzLmxvYy5zdGFydCk7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBrZXkgPSBrZXlzW2ldO1xuICAgIGlmIChrZXkgIT09IFwibGVhZGluZ0NvbW1lbnRzXCIgJiYga2V5ICE9PSBcInRyYWlsaW5nQ29tbWVudHNcIiAmJiBrZXkgIT09IFwiaW5uZXJDb21tZW50c1wiKSB7XG4gICAgICBuZXdOb2RlW2tleV0gPSB0aGlzW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdOb2RlO1xufTtcbmNsYXNzIE5vZGVVdGlscyBleHRlbmRzIFV0aWxQYXJzZXIge1xuICBzdGFydE5vZGUoKSB7XG4gICAgY29uc3QgbG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgbG9jLmluZGV4LCBsb2MpO1xuICB9XG4gIHN0YXJ0Tm9kZUF0KGxvYykge1xuICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBsb2MuaW5kZXgsIGxvYyk7XG4gIH1cbiAgc3RhcnROb2RlQXROb2RlKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydE5vZGVBdCh0eXBlLmxvYy5zdGFydCk7XG4gIH1cbiAgZmluaXNoTm9kZShub2RlLCB0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYyk7XG4gIH1cbiAgZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIGVuZExvYykge1xuICAgIG5vZGUudHlwZSA9IHR5cGU7XG4gICAgbm9kZS5lbmQgPSBlbmRMb2MuaW5kZXg7XG4gICAgbm9kZS5sb2MuZW5kID0gZW5kTG9jO1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgMTI4KSBub2RlLnJhbmdlWzFdID0gZW5kTG9jLmluZGV4O1xuICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgNDA5Nikge1xuICAgICAgdGhpcy5wcm9jZXNzQ29tbWVudChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcmVzZXRTdGFydExvY2F0aW9uKG5vZGUsIHN0YXJ0TG9jKSB7XG4gICAgbm9kZS5zdGFydCA9IHN0YXJ0TG9jLmluZGV4O1xuICAgIG5vZGUubG9jLnN0YXJ0ID0gc3RhcnRMb2M7XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAxMjgpIG5vZGUucmFuZ2VbMF0gPSBzdGFydExvYy5pbmRleDtcbiAgfVxuICByZXNldEVuZExvY2F0aW9uKG5vZGUsIGVuZExvYyA9IHRoaXMuc3RhdGUubGFzdFRva0VuZExvYykge1xuICAgIG5vZGUuZW5kID0gZW5kTG9jLmluZGV4O1xuICAgIG5vZGUubG9jLmVuZCA9IGVuZExvYztcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDEyOCkgbm9kZS5yYW5nZVsxXSA9IGVuZExvYy5pbmRleDtcbiAgfVxuICByZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShub2RlLCBsb2NhdGlvbk5vZGUpIHtcbiAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbihub2RlLCBsb2NhdGlvbk5vZGUubG9jLnN0YXJ0KTtcbiAgfVxuICBjYXN0Tm9kZVRvKG5vZGUsIHR5cGUpIHtcbiAgICBub2RlLnR5cGUgPSB0eXBlO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNsb25lSWRlbnRpZmllcihub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgbG9jLFxuICAgICAgcmFuZ2UsXG4gICAgICBuYW1lXG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3QgY2xvbmVkID0gT2JqZWN0LmNyZWF0ZShOb2RlUHJvdG90eXBlKTtcbiAgICBjbG9uZWQudHlwZSA9IHR5cGU7XG4gICAgY2xvbmVkLnN0YXJ0ID0gc3RhcnQ7XG4gICAgY2xvbmVkLmVuZCA9IGVuZDtcbiAgICBjbG9uZWQubG9jID0gbG9jO1xuICAgIGNsb25lZC5yYW5nZSA9IHJhbmdlO1xuICAgIGNsb25lZC5uYW1lID0gbmFtZTtcbiAgICBpZiAobm9kZS5leHRyYSkgY2xvbmVkLmV4dHJhID0gbm9kZS5leHRyYTtcbiAgICByZXR1cm4gY2xvbmVkO1xuICB9XG4gIGNsb25lU3RyaW5nTGl0ZXJhbChub2RlKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgbG9jLFxuICAgICAgcmFuZ2UsXG4gICAgICBleHRyYVxuICAgIH0gPSBub2RlO1xuICAgIGNvbnN0IGNsb25lZCA9IE9iamVjdC5jcmVhdGUoTm9kZVByb3RvdHlwZSk7XG4gICAgY2xvbmVkLnR5cGUgPSB0eXBlO1xuICAgIGNsb25lZC5zdGFydCA9IHN0YXJ0O1xuICAgIGNsb25lZC5lbmQgPSBlbmQ7XG4gICAgY2xvbmVkLmxvYyA9IGxvYztcbiAgICBjbG9uZWQucmFuZ2UgPSByYW5nZTtcbiAgICBjbG9uZWQuZXh0cmEgPSBleHRyYTtcbiAgICBjbG9uZWQudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgIHJldHVybiBjbG9uZWQ7XG4gIH1cbn1cbmNvbnN0IHVud3JhcFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uID0gbm9kZSA9PiB7XG4gIHJldHVybiBub2RlLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiA/IHVud3JhcFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uKG5vZGUuZXhwcmVzc2lvbikgOiBub2RlO1xufTtcbmNsYXNzIExWYWxQYXJzZXIgZXh0ZW5kcyBOb2RlVXRpbHMge1xuICB0b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMgPSBmYWxzZSkge1xuICAgIHZhciBfbm9kZSRleHRyYSwgX25vZGUkZXh0cmEzO1xuICAgIGxldCBwYXJlbnRoZXNpemVkID0gdW5kZWZpbmVkO1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIiB8fCAoX25vZGUkZXh0cmEgPSBub2RlLmV4dHJhKSAhPSBudWxsICYmIF9ub2RlJGV4dHJhLnBhcmVudGhlc2l6ZWQpIHtcbiAgICAgIHBhcmVudGhlc2l6ZWQgPSB1bndyYXBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbihub2RlKTtcbiAgICAgIGlmIChpc0xIUykge1xuICAgICAgICBpZiAocGFyZW50aGVzaXplZC50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnJlY29yZEFycm93UGFyYW1ldGVyQmluZGluZ0Vycm9yKEVycm9ycy5JbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQsIG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcmVudGhlc2l6ZWQudHlwZSAhPT0gXCJDYWxsRXhwcmVzc2lvblwiICYmIHBhcmVudGhlc2l6ZWQudHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIgJiYgIXRoaXMuaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24ocGFyZW50aGVzaXplZCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUGFyZW50aGVzaXplZEFzc2lnbm1lbnQsIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIklkZW50aWZpZXJcIjpcbiAgICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXJyYXlQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgY2FzZSBcIlZvaWRQYXR0ZXJuXCI6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIk9iamVjdEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy5jYXN0Tm9kZVRvKG5vZGUsIFwiT2JqZWN0UGF0dGVyblwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbmd0aCA9IG5vZGUucHJvcGVydGllcy5sZW5ndGgsIGxhc3QgPSBsZW5ndGggLSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgX25vZGUkZXh0cmEyO1xuICAgICAgICAgIGNvbnN0IHByb3AgPSBub2RlLnByb3BlcnRpZXNbaV07XG4gICAgICAgICAgY29uc3QgaXNMYXN0ID0gaSA9PT0gbGFzdDtcbiAgICAgICAgICB0aGlzLnRvQXNzaWduYWJsZU9iamVjdEV4cHJlc3Npb25Qcm9wKHByb3AsIGlzTGFzdCwgaXNMSFMpO1xuICAgICAgICAgIGlmIChpc0xhc3QgJiYgcHJvcC50eXBlID09PSBcIlJlc3RFbGVtZW50XCIgJiYgKF9ub2RlJGV4dHJhMiA9IG5vZGUuZXh0cmEpICE9IG51bGwgJiYgX25vZGUkZXh0cmEyLnRyYWlsaW5nQ29tbWFMb2MpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlJlc3RUcmFpbGluZ0NvbW1hLCBub2RlLmV4dHJhLnRyYWlsaW5nQ29tbWFMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJPYmplY3RQcm9wZXJ0eVwiOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gbm9kZTtcbiAgICAgICAgICBpZiAodGhpcy5pc1ByaXZhdGVOYW1lKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NTY29wZS51c2VQcml2YXRlTmFtZSh0aGlzLmdldFByaXZhdGVOYW1lU1Yoa2V5KSwga2V5LmxvYy5zdGFydCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKHZhbHVlLCBpc0xIUyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnRlcm5hbCBAYmFiZWwvcGFyc2VyIGVycm9yICh0aGlzIGlzIGEgYnVnLCBwbGVhc2UgcmVwb3J0IGl0KS5cIiArIFwiIFNwcmVhZEVsZW1lbnQgc2hvdWxkIGJlIGNvbnZlcnRlZCBieSAudG9Bc3NpZ25hYmxlJ3MgY2FsbGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIkFycmF5RXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLmNhc3ROb2RlVG8obm9kZSwgXCJBcnJheVBhdHRlcm5cIik7XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlTGlzdChub2RlLmVsZW1lbnRzLCAoX25vZGUkZXh0cmEzID0gbm9kZS5leHRyYSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ub2RlJGV4dHJhMy50cmFpbGluZ0NvbW1hTG9jLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChub2RlLm9wZXJhdG9yICE9PSBcIj1cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1pc3NpbmdFcUluQXNzaWdubWVudCwgbm9kZS5sZWZ0LmxvYy5lbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpO1xuICAgICAgICBkZWxldGUgbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgaWYgKG5vZGUubGVmdC50eXBlID09PSBcIlZvaWRQYXR0ZXJuXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Wb2lkUGF0dGVybkluaXRpYWxpemVyLCBub2RlLmxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUubGVmdCwgaXNMSFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShwYXJlbnRoZXNpemVkLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0b0Fzc2lnbmFibGVPYmplY3RFeHByZXNzaW9uUHJvcChwcm9wLCBpc0xhc3QsIGlzTEhTKSB7XG4gICAgaWYgKHByb3AudHlwZSA9PT0gXCJPYmplY3RNZXRob2RcIikge1xuICAgICAgdGhpcy5yYWlzZShwcm9wLmtpbmQgPT09IFwiZ2V0XCIgfHwgcHJvcC5raW5kID09PSBcInNldFwiID8gRXJyb3JzLlBhdHRlcm5IYXNBY2Nlc3NvciA6IEVycm9ycy5QYXR0ZXJuSGFzTWV0aG9kLCBwcm9wLmtleSk7XG4gICAgfSBlbHNlIGlmIChwcm9wLnR5cGUgPT09IFwiU3ByZWFkRWxlbWVudFwiKSB7XG4gICAgICB0aGlzLmNhc3ROb2RlVG8ocHJvcCwgXCJSZXN0RWxlbWVudFwiKTtcbiAgICAgIGNvbnN0IGFyZyA9IHByb3AuYXJndW1lbnQ7XG4gICAgICB0aGlzLmNoZWNrVG9SZXN0Q29udmVyc2lvbihhcmcsIGZhbHNlKTtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGFyZywgaXNMSFMpO1xuICAgICAgaWYgKCFpc0xhc3QpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUmVzdFRyYWlsaW5nQ29tbWEsIHByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShwcm9wLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIHRvQXNzaWduYWJsZUxpc3QoZXhwckxpc3QsIHRyYWlsaW5nQ29tbWFMb2MsIGlzTEhTKSB7XG4gICAgY29uc3QgZW5kID0gZXhwckxpc3QubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgICBpZiAoIWVsdCkgY29udGludWU7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3RJdGVtKGV4cHJMaXN0LCBpLCBpc0xIUyk7XG4gICAgICBpZiAoZWx0LnR5cGUgPT09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgICBpZiAoaSA8IGVuZCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlJlc3RUcmFpbGluZ0NvbW1hLCBlbHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRyYWlsaW5nQ29tbWFMb2MpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5SZXN0VHJhaWxpbmdDb21tYSwgdHJhaWxpbmdDb21tYUxvYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlTGlzdEl0ZW0oZXhwckxpc3QsIGluZGV4LCBpc0xIUykge1xuICAgIGNvbnN0IG5vZGUgPSBleHByTGlzdFtpbmRleF07XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgIHRoaXMuY2FzdE5vZGVUbyhub2RlLCBcIlJlc3RFbGVtZW50XCIpO1xuICAgICAgY29uc3QgYXJnID0gbm9kZS5hcmd1bWVudDtcbiAgICAgIHRoaXMuY2hlY2tUb1Jlc3RDb252ZXJzaW9uKGFyZywgdHJ1ZSk7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShhcmcsIGlzTEhTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMpO1xuICAgIH1cbiAgfVxuICBpc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiUmVzdEVsZW1lbnRcIjpcbiAgICAgIGNhc2UgXCJWb2lkUGF0dGVyblwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBsYXN0ID0gbm9kZS5wcm9wZXJ0aWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgcmV0dXJuIG5vZGUucHJvcGVydGllcy5ldmVyeSgocHJvcCwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByb3AudHlwZSAhPT0gXCJPYmplY3RNZXRob2RcIiAmJiAoaSA9PT0gbGFzdCB8fCBwcm9wLnR5cGUgIT09IFwiU3ByZWFkRWxlbWVudFwiKSAmJiB0aGlzLmlzQXNzaWduYWJsZShwcm9wKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLnZhbHVlKTtcbiAgICAgIGNhc2UgXCJTcHJlYWRFbGVtZW50XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLmFyZ3VtZW50KTtcbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIG5vZGUuZWxlbWVudHMuZXZlcnkoZWxlbWVudCA9PiBlbGVtZW50ID09PSBudWxsIHx8IHRoaXMuaXNBc3NpZ25hYmxlKGVsZW1lbnQpKTtcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gbm9kZS5vcGVyYXRvciA9PT0gXCI9XCI7XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbik7XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gIWlzQmluZGluZztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgdG9SZWZlcmVuY2VkTGlzdChleHByTGlzdCwgaXNQYXJlbnRoZXNpemVkRXhwcikge1xuICAgIHJldHVybiBleHByTGlzdDtcbiAgfVxuICB0b1JlZmVyZW5jZWRMaXN0RGVlcChleHByTGlzdCwgaXNQYXJlbnRoZXNpemVkRXhwcikge1xuICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChleHByTGlzdCwgaXNQYXJlbnRoZXNpemVkRXhwcik7XG4gICAgZm9yIChjb25zdCBleHByIG9mIGV4cHJMaXN0KSB7XG4gICAgICBpZiAoKGV4cHIgPT0gbnVsbCA/IHZvaWQgMCA6IGV4cHIudHlwZSkgPT09IFwiQXJyYXlFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0RGVlcChleHByLmVsZW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcGFyc2VTcHJlYWQocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKHJlZkV4cHJlc3Npb25FcnJvcnMsIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VSZXN0QmluZGluZygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBhcmd1bWVudCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIGlmIChhcmd1bWVudC50eXBlID09PSBcIlZvaWRQYXR0ZXJuXCIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRWb2lkUGF0dGVybiwgYXJndW1lbnQpO1xuICAgIH1cbiAgICBub2RlLmFyZ3VtZW50ID0gYXJndW1lbnQ7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlc3RFbGVtZW50XCIpO1xuICB9XG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QoMywgOTMsIDEpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJheVBhdHRlcm5cIik7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3RMaWtlKDgsIHRydWUpO1xuICAgICAgY2FzZSA4ODpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWb2lkUGF0dGVybihudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gIH1cbiAgcGFyc2VCaW5kaW5nTGlzdChjbG9zZSwgY2xvc2VDaGFyQ29kZSwgZmxhZ3MpIHtcbiAgICBjb25zdCBhbGxvd0VtcHR5ID0gZmxhZ3MgJiAxO1xuICAgIGNvbnN0IGVsdHMgPSBbXTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIHdoaWxlICghdGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICBpZiAoZmlyc3QpIHtcbiAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd0VtcHR5ICYmIHRoaXMubWF0Y2goMTIpKSB7XG4gICAgICAgIGVsdHMucHVzaChudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5lYXQoY2xvc2UpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgICBsZXQgcmVzdCA9IHRoaXMucGFyc2VSZXN0QmluZGluZygpO1xuICAgICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmbG93XCIpIHx8IGZsYWdzICYgMikge1xuICAgICAgICAgIHJlc3QgPSB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbVR5cGUocmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWx0cy5wdXNoKHJlc3QpO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tDb21tYUFmdGVyUmVzdChjbG9zZUNoYXJDb2RlKSkge1xuICAgICAgICAgIHRoaXMuZXhwZWN0KGNsb3NlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICBpZiAoZmxhZ3MgJiAyKSB7XG4gICAgICAgICAgaWYgKHRoaXMubWF0Y2goMjYpICYmIHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWRQYXJhbWV0ZXJEZWNvcmF0b3IsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAodGhpcy5tYXRjaCgyNikpIHtcbiAgICAgICAgICAgIGRlY29yYXRvcnMucHVzaCh0aGlzLnBhcnNlRGVjb3JhdG9yKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHRzLnB1c2godGhpcy5wYXJzZUJpbmRpbmdFbGVtZW50KGZsYWdzLCBkZWNvcmF0b3JzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbHRzO1xuICB9XG4gIHBhcnNlQmluZGluZ1Jlc3RQcm9wZXJ0eShwcm9wKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGlzY2FyZEJpbmRpbmdcIikgJiYgdGhpcy5tYXRjaCg4OCkpIHtcbiAgICAgIHByb3AuYXJndW1lbnQgPSB0aGlzLnBhcnNlVm9pZFBhdHRlcm4obnVsbCk7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVm9pZFBhdHRlcm4sIHByb3AuYXJndW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja0NvbW1hQWZ0ZXJSZXN0KDEyNSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcm9wLCBcIlJlc3RFbGVtZW50XCIpO1xuICB9XG4gIHBhcnNlQmluZGluZ1Byb3BlcnR5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICBzdGFydExvY1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSAyMSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VCaW5kaW5nUmVzdFByb3BlcnR5KHRoaXMuc3RhcnROb2RlKCkpO1xuICAgIH1cbiAgICBjb25zdCBwcm9wID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodHlwZSA9PT0gMTM5KSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImRlc3RydWN0dXJpbmdQcml2YXRlXCIsIHN0YXJ0TG9jKTtcbiAgICAgIHRoaXMuY2xhc3NTY29wZS51c2VQcml2YXRlTmFtZSh0aGlzLnN0YXRlLnZhbHVlLCBzdGFydExvYyk7XG4gICAgICBwcm9wLmtleSA9IHRoaXMucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICAgIH1cbiAgICBwcm9wLm1ldGhvZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLnBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0TG9jLCBmYWxzZSwgZmFsc2UsIHRydWUsIGZhbHNlKTtcbiAgfVxuICBwYXJzZUJpbmRpbmdFbGVtZW50KGZsYWdzLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgbGVmdCA9IHRoaXMucGFyc2VNYXliZURlZmF1bHQoKTtcbiAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJmbG93XCIpIHx8IGZsYWdzICYgMikge1xuICAgICAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1UeXBlKGxlZnQpO1xuICAgIH1cbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIGxlZnQuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKGxlZnQsIGRlY29yYXRvcnNbMF0pO1xuICAgIH1cbiAgICBjb25zdCBlbHQgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KGxlZnQubG9jLnN0YXJ0LCBsZWZ0KTtcbiAgICByZXR1cm4gZWx0O1xuICB9XG4gIHBhcnNlRnVuY3Rpb25QYXJhbVR5cGUocGFyYW0pIHtcbiAgICByZXR1cm4gcGFyYW07XG4gIH1cbiAgcGFyc2VNYXliZURlZmF1bHQoc3RhcnRMb2MsIGxlZnQpIHtcbiAgICBzdGFydExvYyAhPSBudWxsID8gc3RhcnRMb2MgOiBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGVmdCA9IGxlZnQgIT0gbnVsbCA/IGxlZnQgOiB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICBpZiAoIXRoaXMuZWF0KDI5KSkgcmV0dXJuIGxlZnQ7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiVm9pZFBhdHRlcm5cIikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVm9pZFBhdHRlcm5Jbml0aWFsaXplciwgbGVmdCk7XG4gICAgfVxuICAgIG5vZGUubGVmdCA9IGxlZnQ7XG4gICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudFBhdHRlcm5cIik7XG4gIH1cbiAgaXNWYWxpZExWYWwodHlwZSwgZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiwgaXNVbnBhcmVudGhlc2l6ZWRJbkFzc2lnbiwgYmluZGluZykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICAgIHJldHVybiBcImxlZnRcIjtcbiAgICAgIGNhc2UgXCJSZXN0RWxlbWVudFwiOlxuICAgICAgICByZXR1cm4gXCJhcmd1bWVudFwiO1xuICAgICAgY2FzZSBcIk9iamVjdFByb3BlcnR5XCI6XG4gICAgICAgIHJldHVybiBcInZhbHVlXCI7XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIFwiZXhwcmVzc2lvblwiO1xuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgICByZXR1cm4gXCJlbGVtZW50c1wiO1xuICAgICAgY2FzZSBcIk9iamVjdFBhdHRlcm5cIjpcbiAgICAgICAgcmV0dXJuIFwicHJvcGVydGllc1wiO1xuICAgICAgY2FzZSBcIlZvaWRQYXR0ZXJuXCI6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSBcIkNhbGxFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmICghZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiAmJiAhdGhpcy5zdGF0ZS5zdHJpY3QgJiYgdGhpcy5vcHRpb25GbGFncyAmIDgxOTIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24oZXhwcmVzc2lvbikge1xuICAgIHJldHVybiBleHByZXNzaW9uLnR5cGUgPT09IFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI7XG4gIH1cbiAgY2hlY2tMVmFsKGV4cHJlc3Npb24sIGFuY2VzdG9yLCBiaW5kaW5nID0gNjQsIGNoZWNrQ2xhc2hlcyA9IGZhbHNlLCBzdHJpY3RNb2RlQ2hhbmdlZCA9IGZhbHNlLCBoYXNQYXJlbnRoZXNpemVkQW5jZXN0b3IgPSBmYWxzZSwgZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiA9IGZhbHNlKSB7XG4gICAgdmFyIF9leHByZXNzaW9uJGV4dHJhO1xuICAgIGNvbnN0IHR5cGUgPSBleHByZXNzaW9uLnR5cGU7XG4gICAgaWYgKHRoaXMuaXNPYmplY3RNZXRob2QoZXhwcmVzc2lvbikpIHJldHVybjtcbiAgICBjb25zdCBpc09wdGlvbmFsTWVtYmVyRXhwcmVzc2lvbiA9IHRoaXMuaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gICAgaWYgKGlzT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uIHx8IHR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICBpZiAoaXNPcHRpb25hbE1lbWJlckV4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJvcHRpb25hbENoYWluaW5nQXNzaWduXCIsIGV4cHJlc3Npb24ubG9jLnN0YXJ0KTtcbiAgICAgICAgaWYgKGFuY2VzdG9yLnR5cGUgIT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRMaHNPcHRpb25hbENoYWluaW5nLCBleHByZXNzaW9uLCB7XG4gICAgICAgICAgICBhbmNlc3RvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYmluZGluZyAhPT0gNjQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZFByb3BlcnR5QmluZGluZ1BhdHRlcm4sIGV4cHJlc3Npb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKGV4cHJlc3Npb24sIGJpbmRpbmcsIHN0cmljdE1vZGVDaGFuZ2VkKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IGV4cHJlc3Npb247XG4gICAgICBpZiAoY2hlY2tDbGFzaGVzKSB7XG4gICAgICAgIGlmIChjaGVja0NsYXNoZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGFyYW1EdXBlLCBleHByZXNzaW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjaGVja0NsYXNoZXMuYWRkKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcIlZvaWRQYXR0ZXJuXCIgJiYgYW5jZXN0b3IudHlwZSA9PT0gXCJDYXRjaENsYXVzZVwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Wb2lkUGF0dGVybkNhdGNoQ2xhdXNlUGFyYW0sIGV4cHJlc3Npb24pO1xuICAgIH1cbiAgICBjb25zdCB1bndyYXBwZWRFeHByZXNzaW9uID0gdW53cmFwUGFyZW50aGVzaXplZEV4cHJlc3Npb24oZXhwcmVzc2lvbik7XG4gICAgZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiB8fCAoZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiA9IHVud3JhcHBlZEV4cHJlc3Npb24udHlwZSA9PT0gXCJDYWxsRXhwcmVzc2lvblwiICYmICh1bndyYXBwZWRFeHByZXNzaW9uLmNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiIHx8IHVud3JhcHBlZEV4cHJlc3Npb24uY2FsbGVlLnR5cGUgPT09IFwiU3VwZXJcIikpO1xuICAgIGNvbnN0IHZhbGlkaXR5ID0gdGhpcy5pc1ZhbGlkTFZhbCh0eXBlLCBkaXNhbGxvd0NhbGxFeHByZXNzaW9uLCAhKGhhc1BhcmVudGhlc2l6ZWRBbmNlc3RvciB8fCAoX2V4cHJlc3Npb24kZXh0cmEgPSBleHByZXNzaW9uLmV4dHJhKSAhPSBudWxsICYmIF9leHByZXNzaW9uJGV4dHJhLnBhcmVudGhlc2l6ZWQpICYmIGFuY2VzdG9yLnR5cGUgPT09IFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiwgYmluZGluZyk7XG4gICAgaWYgKHZhbGlkaXR5ID09PSB0cnVlKSByZXR1cm47XG4gICAgaWYgKHZhbGlkaXR5ID09PSBmYWxzZSkge1xuICAgICAgY29uc3QgUGFyc2VFcnJvckNsYXNzID0gYmluZGluZyA9PT0gNjQgPyBFcnJvcnMuSW52YWxpZExocyA6IEVycm9ycy5JbnZhbGlkTGhzQmluZGluZztcbiAgICAgIHRoaXMucmFpc2UoUGFyc2VFcnJvckNsYXNzLCBleHByZXNzaW9uLCB7XG4gICAgICAgIGFuY2VzdG9yXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGtleSwgaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbjtcbiAgICBpZiAodHlwZW9mIHZhbGlkaXR5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBrZXkgPSB2YWxpZGl0eTtcbiAgICAgIGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb24gPSB0eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIFtrZXksIGlzUGFyZW50aGVzaXplZEV4cHJlc3Npb25dID0gdmFsaWRpdHk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRBbmNlc3RvciA9IHR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIgfHwgdHlwZSA9PT0gXCJPYmplY3RQYXR0ZXJuXCIgPyB7XG4gICAgICB0eXBlXG4gICAgfSA6IGFuY2VzdG9yO1xuICAgIGNvbnN0IHZhbCA9IGV4cHJlc3Npb25ba2V5XTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHZhbCkge1xuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrTFZhbChjaGlsZCwgbmV4dEFuY2VzdG9yLCBiaW5kaW5nLCBjaGVja0NsYXNoZXMsIHN0cmljdE1vZGVDaGFuZ2VkLCBpc1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodmFsKSB7XG4gICAgICB0aGlzLmNoZWNrTFZhbCh2YWwsIG5leHRBbmNlc3RvciwgYmluZGluZywgY2hlY2tDbGFzaGVzLCBzdHJpY3RNb2RlQ2hhbmdlZCwgaXNQYXJlbnRoZXNpemVkRXhwcmVzc2lvbiwgZGlzYWxsb3dDYWxsRXhwcmVzc2lvbik7XG4gICAgfVxuICB9XG4gIGNoZWNrSWRlbnRpZmllcihhdCwgYmluZGluZ1R5cGUsIHN0cmljdE1vZGVDaGFuZ2VkID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QgJiYgKHN0cmljdE1vZGVDaGFuZ2VkID8gaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkKGF0Lm5hbWUsIHRoaXMuaW5Nb2R1bGUpIDogaXNTdHJpY3RCaW5kT25seVJlc2VydmVkV29yZChhdC5uYW1lKSkpIHtcbiAgICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gNjQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RyaWN0RXZhbEFyZ3VtZW50cywgYXQsIHtcbiAgICAgICAgICByZWZlcmVuY2VOYW1lOiBhdC5uYW1lXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RyaWN0RXZhbEFyZ3VtZW50c0JpbmRpbmcsIGF0LCB7XG4gICAgICAgICAgYmluZGluZ05hbWU6IGF0Lm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChiaW5kaW5nVHlwZSAmIDgxOTIgJiYgYXQubmFtZSA9PT0gXCJsZXRcIikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTGV0SW5MZXhpY2FsQmluZGluZywgYXQpO1xuICAgIH1cbiAgICBpZiAoIShiaW5kaW5nVHlwZSAmIDY0KSkge1xuICAgICAgdGhpcy5kZWNsYXJlTmFtZUZyb21JZGVudGlmaWVyKGF0LCBiaW5kaW5nVHlwZSk7XG4gICAgfVxuICB9XG4gIGRlY2xhcmVOYW1lRnJvbUlkZW50aWZpZXIoaWRlbnRpZmllciwgYmluZGluZykge1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUoaWRlbnRpZmllci5uYW1lLCBiaW5kaW5nLCBpZGVudGlmaWVyLmxvYy5zdGFydCk7XG4gIH1cbiAgY2hlY2tUb1Jlc3RDb252ZXJzaW9uKG5vZGUsIGFsbG93UGF0dGVybikge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy5jaGVja1RvUmVzdENvbnZlcnNpb24obm9kZS5leHByZXNzaW9uLCBhbGxvd1BhdHRlcm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJZGVudGlmaWVyXCI6XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICAgIGlmIChhbGxvd1BhdHRlcm4pIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZFJlc3RBc3NpZ25tZW50UGF0dGVybiwgbm9kZSk7XG4gICAgfVxuICB9XG4gIGNoZWNrQ29tbWFBZnRlclJlc3QoY2xvc2UpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goMTIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMucmFpc2UodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSBjbG9zZSA/IEVycm9ycy5SZXN0VHJhaWxpbmdDb21tYSA6IEVycm9ycy5FbGVtZW50QWZ0ZXJSZXN0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuY29uc3Qga2V5d29yZEFuZFRTUmVsYXRpb25hbE9wZXJhdG9yID0gL2luKD86c3RhbmNlb2YpP3xhc3xzYXRpc2ZpZXMveTtcbmZ1bmN0aW9uIG5vbk51bGwoeCkge1xuICBpZiAoeCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkICR7eH0gdmFsdWUuYCk7XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBhc3NlcnQoeCkge1xuICBpZiAoIXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnQgZmFpbFwiKTtcbiAgfVxufVxuY29uc3QgVFNFcnJvcnMgPSBQYXJzZUVycm9yRW51bWB0eXBlc2NyaXB0YCh7XG4gIEFic3RyYWN0TWV0aG9kSGFzSW1wbGVtZW50YXRpb246ICh7XG4gICAgbWV0aG9kTmFtZVxuICB9KSA9PiBgTWV0aG9kICcke21ldGhvZE5hbWV9JyBjYW5ub3QgaGF2ZSBhbiBpbXBsZW1lbnRhdGlvbiBiZWNhdXNlIGl0IGlzIG1hcmtlZCBhYnN0cmFjdC5gLFxuICBBYnN0cmFjdFByb3BlcnR5SGFzSW5pdGlhbGl6ZXI6ICh7XG4gICAgcHJvcGVydHlOYW1lXG4gIH0pID0+IGBQcm9wZXJ0eSAnJHtwcm9wZXJ0eU5hbWV9JyBjYW5ub3QgaGF2ZSBhbiBpbml0aWFsaXplciBiZWNhdXNlIGl0IGlzIG1hcmtlZCBhYnN0cmFjdC5gLFxuICBBY2Nlc3NvckNhbm5vdEJlT3B0aW9uYWw6IFwiQW4gJ2FjY2Vzc29yJyBwcm9wZXJ0eSBjYW5ub3QgYmUgZGVjbGFyZWQgb3B0aW9uYWwuXCIsXG4gIEFjY2Vzc29yQ2Fubm90RGVjbGFyZVRoaXNQYXJhbWV0ZXI6IFwiJ2dldCcgYW5kICdzZXQnIGFjY2Vzc29ycyBjYW5ub3QgZGVjbGFyZSAndGhpcycgcGFyYW1ldGVycy5cIixcbiAgQWNjZXNzb3JDYW5ub3RIYXZlVHlwZVBhcmFtZXRlcnM6IFwiQW4gYWNjZXNzb3IgY2Fubm90IGhhdmUgdHlwZSBwYXJhbWV0ZXJzLlwiLFxuICBDbGFzc01ldGhvZEhhc0RlY2xhcmU6IFwiQ2xhc3MgbWV0aG9kcyBjYW5ub3QgaGF2ZSB0aGUgJ2RlY2xhcmUnIG1vZGlmaWVyLlwiLFxuICBDbGFzc01ldGhvZEhhc1JlYWRvbmx5OiBcIkNsYXNzIG1ldGhvZHMgY2Fubm90IGhhdmUgdGhlICdyZWFkb25seScgbW9kaWZpZXIuXCIsXG4gIENvbnN0SW5pdGlhbGl6ZXJNdXN0QmVTdHJpbmdPck51bWVyaWNMaXRlcmFsT3JMaXRlcmFsRW51bVJlZmVyZW5jZTogXCJBICdjb25zdCcgaW5pdGlhbGl6ZXIgaW4gYW4gYW1iaWVudCBjb250ZXh0IG11c3QgYmUgYSBzdHJpbmcgb3IgbnVtZXJpYyBsaXRlcmFsIG9yIGxpdGVyYWwgZW51bSByZWZlcmVuY2UuXCIsXG4gIENvbnN0cnVjdG9ySGFzVHlwZVBhcmFtZXRlcnM6IFwiVHlwZSBwYXJhbWV0ZXJzIGNhbm5vdCBhcHBlYXIgb24gYSBjb25zdHJ1Y3RvciBkZWNsYXJhdGlvbi5cIixcbiAgRGVjbGFyZUFjY2Vzc29yOiAoe1xuICAgIGtpbmRcbiAgfSkgPT4gYCdkZWNsYXJlJyBpcyBub3QgYWxsb3dlZCBpbiAke2tpbmR9dGVycy5gLFxuICBEZWNsYXJlQ2xhc3NGaWVsZEhhc0luaXRpYWxpemVyOiBcIkluaXRpYWxpemVycyBhcmUgbm90IGFsbG93ZWQgaW4gYW1iaWVudCBjb250ZXh0cy5cIixcbiAgRGVjbGFyZUZ1bmN0aW9uSGFzSW1wbGVtZW50YXRpb246IFwiQW4gaW1wbGVtZW50YXRpb24gY2Fubm90IGJlIGRlY2xhcmVkIGluIGFtYmllbnQgY29udGV4dHMuXCIsXG4gIER1cGxpY2F0ZUFjY2Vzc2liaWxpdHlNb2RpZmllcjogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgQWNjZXNzaWJpbGl0eSBtb2RpZmllciBhbHJlYWR5IHNlZW46ICcke21vZGlmaWVyfScuYCxcbiAgRHVwbGljYXRlTW9kaWZpZXI6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYER1cGxpY2F0ZSBtb2RpZmllcjogJyR7bW9kaWZpZXJ9Jy5gLFxuICBFbXB0eUhlcml0YWdlQ2xhdXNlVHlwZTogKHtcbiAgICB0b2tlblxuICB9KSA9PiBgJyR7dG9rZW59JyBsaXN0IGNhbm5vdCBiZSBlbXB0eS5gLFxuICBFbXB0eVR5cGVBcmd1bWVudHM6IFwiVHlwZSBhcmd1bWVudCBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIixcbiAgRW1wdHlUeXBlUGFyYW1ldGVyczogXCJUeXBlIHBhcmFtZXRlciBsaXN0IGNhbm5vdCBiZSBlbXB0eS5cIixcbiAgRXhwZWN0ZWRBbWJpZW50QWZ0ZXJFeHBvcnREZWNsYXJlOiBcIidleHBvcnQgZGVjbGFyZScgbXVzdCBiZSBmb2xsb3dlZCBieSBhbiBhbWJpZW50IGRlY2xhcmF0aW9uLlwiLFxuICBJbXBvcnRBbGlhc0hhc0ltcG9ydFR5cGU6IFwiQW4gaW1wb3J0IGFsaWFzIGNhbiBub3QgdXNlICdpbXBvcnQgdHlwZScuXCIsXG4gIEltcG9ydFJlZmxlY3Rpb25IYXNJbXBvcnRUeXBlOiBcIkFuIGBpbXBvcnQgbW9kdWxlYCBkZWNsYXJhdGlvbiBjYW4gbm90IHVzZSBgdHlwZWAgbW9kaWZpZXJcIixcbiAgSW5jb21wYXRpYmxlTW9kaWZpZXJzOiAoe1xuICAgIG1vZGlmaWVyc1xuICB9KSA9PiBgJyR7bW9kaWZpZXJzWzBdfScgbW9kaWZpZXIgY2Fubm90IGJlIHVzZWQgd2l0aCAnJHttb2RpZmllcnNbMV19JyBtb2RpZmllci5gLFxuICBJbmRleFNpZ25hdHVyZUhhc0Fic3RyYWN0OiBcIkluZGV4IHNpZ25hdHVyZXMgY2Fubm90IGhhdmUgdGhlICdhYnN0cmFjdCcgbW9kaWZpZXIuXCIsXG4gIEluZGV4U2lnbmF0dXJlSGFzQWNjZXNzaWJpbGl0eTogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSBhbiBhY2Nlc3NpYmlsaXR5IG1vZGlmaWVyICgnJHttb2RpZmllcn0nKS5gLFxuICBJbmRleFNpZ25hdHVyZUhhc0RlY2xhcmU6IFwiSW5kZXggc2lnbmF0dXJlcyBjYW5ub3QgaGF2ZSB0aGUgJ2RlY2xhcmUnIG1vZGlmaWVyLlwiLFxuICBJbmRleFNpZ25hdHVyZUhhc092ZXJyaWRlOiBcIidvdmVycmlkZScgbW9kaWZpZXIgY2Fubm90IGFwcGVhciBvbiBhbiBpbmRleCBzaWduYXR1cmUuXCIsXG4gIEluZGV4U2lnbmF0dXJlSGFzU3RhdGljOiBcIkluZGV4IHNpZ25hdHVyZXMgY2Fubm90IGhhdmUgdGhlICdzdGF0aWMnIG1vZGlmaWVyLlwiLFxuICBJbml0aWFsaXplck5vdEFsbG93ZWRJbkFtYmllbnRDb250ZXh0OiBcIkluaXRpYWxpemVycyBhcmUgbm90IGFsbG93ZWQgaW4gYW1iaWVudCBjb250ZXh0cy5cIixcbiAgSW52YWxpZEhlcml0YWdlQ2xhdXNlVHlwZTogKHtcbiAgICB0b2tlblxuICB9KSA9PiBgJyR7dG9rZW59JyBsaXN0IGNhbiBvbmx5IGluY2x1ZGUgaWRlbnRpZmllcnMgb3IgcXVhbGlmaWVkLW5hbWVzIHdpdGggb3B0aW9uYWwgdHlwZSBhcmd1bWVudHMuYCxcbiAgSW52YWxpZE1vZGlmaWVyT25Bd2FpdFVzaW5nRGVjbGFyYXRpb246IG1vZGlmaWVyID0+IGAnJHttb2RpZmllcn0nIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYW4gYXdhaXQgdXNpbmcgZGVjbGFyYXRpb24uYCxcbiAgSW52YWxpZE1vZGlmaWVyT25UeXBlTWVtYmVyOiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGAnJHttb2RpZmllcn0nIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYSB0eXBlIG1lbWJlci5gLFxuICBJbnZhbGlkTW9kaWZpZXJPblR5cGVQYXJhbWV0ZXI6ICh7XG4gICAgbW9kaWZpZXJcbiAgfSkgPT4gYCcke21vZGlmaWVyfScgbW9kaWZpZXIgY2Fubm90IGFwcGVhciBvbiBhIHR5cGUgcGFyYW1ldGVyLmAsXG4gIEludmFsaWRNb2RpZmllck9uVHlwZVBhcmFtZXRlclBvc2l0aW9uczogKHtcbiAgICBtb2RpZmllclxuICB9KSA9PiBgJyR7bW9kaWZpZXJ9JyBtb2RpZmllciBjYW4gb25seSBhcHBlYXIgb24gYSB0eXBlIHBhcmFtZXRlciBvZiBhIGNsYXNzLCBpbnRlcmZhY2Ugb3IgdHlwZSBhbGlhcy5gLFxuICBJbnZhbGlkTW9kaWZpZXJPblVzaW5nRGVjbGFyYXRpb246IG1vZGlmaWVyID0+IGAnJHttb2RpZmllcn0nIG1vZGlmaWVyIGNhbm5vdCBhcHBlYXIgb24gYSB1c2luZyBkZWNsYXJhdGlvbi5gLFxuICBJbnZhbGlkTW9kaWZpZXJzT3JkZXI6ICh7XG4gICAgb3JkZXJlZE1vZGlmaWVyc1xuICB9KSA9PiBgJyR7b3JkZXJlZE1vZGlmaWVyc1swXX0nIG1vZGlmaWVyIG11c3QgcHJlY2VkZSAnJHtvcmRlcmVkTW9kaWZpZXJzWzFdfScgbW9kaWZpZXIuYCxcbiAgSW52YWxpZFByb3BlcnR5QWNjZXNzQWZ0ZXJJbnN0YW50aWF0aW9uRXhwcmVzc2lvbjogXCJJbnZhbGlkIHByb3BlcnR5IGFjY2VzcyBhZnRlciBhbiBpbnN0YW50aWF0aW9uIGV4cHJlc3Npb24uIFwiICsgXCJZb3UgY2FuIGVpdGhlciB3cmFwIHRoZSBpbnN0YW50aWF0aW9uIGV4cHJlc3Npb24gaW4gcGFyZW50aGVzZXMsIG9yIGRlbGV0ZSB0aGUgdHlwZSBhcmd1bWVudHMuXCIsXG4gIEludmFsaWRUdXBsZU1lbWJlckxhYmVsOiBcIlR1cGxlIG1lbWJlcnMgbXVzdCBiZSBsYWJlbGVkIHdpdGggYSBzaW1wbGUgaWRlbnRpZmllci5cIixcbiAgTWlzc2luZ0ludGVyZmFjZU5hbWU6IFwiJ2ludGVyZmFjZScgZGVjbGFyYXRpb25zIG11c3QgYmUgZm9sbG93ZWQgYnkgYW4gaWRlbnRpZmllci5cIixcbiAgTm9uQWJzdHJhY3RDbGFzc0hhc0Fic3RyYWN0TWV0aG9kOiBcIkFic3RyYWN0IG1ldGhvZHMgY2FuIG9ubHkgYXBwZWFyIHdpdGhpbiBhbiBhYnN0cmFjdCBjbGFzcy5cIixcbiAgTm9uQ2xhc3NNZXRob2RQcm9wZXJ0eUhhc0Fic3RyYWN0TW9kaWZpZXI6IFwiJ2Fic3RyYWN0JyBtb2RpZmllciBjYW4gb25seSBhcHBlYXIgb24gYSBjbGFzcywgbWV0aG9kLCBvciBwcm9wZXJ0eSBkZWNsYXJhdGlvbi5cIixcbiAgT3B0aW9uYWxUeXBlQmVmb3JlUmVxdWlyZWQ6IFwiQSByZXF1aXJlZCBlbGVtZW50IGNhbm5vdCBmb2xsb3cgYW4gb3B0aW9uYWwgZWxlbWVudC5cIixcbiAgT3ZlcnJpZGVOb3RJblN1YkNsYXNzOiBcIlRoaXMgbWVtYmVyIGNhbm5vdCBoYXZlIGFuICdvdmVycmlkZScgbW9kaWZpZXIgYmVjYXVzZSBpdHMgY29udGFpbmluZyBjbGFzcyBkb2VzIG5vdCBleHRlbmQgYW5vdGhlciBjbGFzcy5cIixcbiAgUGF0dGVybklzT3B0aW9uYWw6IFwiQSBiaW5kaW5nIHBhdHRlcm4gcGFyYW1ldGVyIGNhbm5vdCBiZSBvcHRpb25hbCBpbiBhbiBpbXBsZW1lbnRhdGlvbiBzaWduYXR1cmUuXCIsXG4gIFByaXZhdGVFbGVtZW50SGFzQWJzdHJhY3Q6IFwiUHJpdmF0ZSBlbGVtZW50cyBjYW5ub3QgaGF2ZSB0aGUgJ2Fic3RyYWN0JyBtb2RpZmllci5cIixcbiAgUHJpdmF0ZUVsZW1lbnRIYXNBY2Nlc3NpYmlsaXR5OiAoe1xuICAgIG1vZGlmaWVyXG4gIH0pID0+IGBQcml2YXRlIGVsZW1lbnRzIGNhbm5vdCBoYXZlIGFuIGFjY2Vzc2liaWxpdHkgbW9kaWZpZXIgKCcke21vZGlmaWVyfScpLmAsXG4gIFJlYWRvbmx5Rm9yTWV0aG9kU2lnbmF0dXJlOiBcIidyZWFkb25seScgbW9kaWZpZXIgY2FuIG9ubHkgYXBwZWFyIG9uIGEgcHJvcGVydHkgZGVjbGFyYXRpb24gb3IgaW5kZXggc2lnbmF0dXJlLlwiLFxuICBSZXNlcnZlZEFycm93VHlwZVBhcmFtOiBcIlRoaXMgc3ludGF4IGlzIHJlc2VydmVkIGluIGZpbGVzIHdpdGggdGhlIC5tdHMgb3IgLmN0cyBleHRlbnNpb24uIEFkZCBhIHRyYWlsaW5nIGNvbW1hLCBhcyBpbiBgPFQsPigpID0+IC4uLmAuXCIsXG4gIFJlc2VydmVkVHlwZUFzc2VydGlvbjogXCJUaGlzIHN5bnRheCBpcyByZXNlcnZlZCBpbiBmaWxlcyB3aXRoIHRoZSAubXRzIG9yIC5jdHMgZXh0ZW5zaW9uLiBVc2UgYW4gYGFzYCBleHByZXNzaW9uIGluc3RlYWQuXCIsXG4gIFNldEFjY2Vzc29yQ2Fubm90SGF2ZU9wdGlvbmFsUGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNzb3IgY2Fubm90IGhhdmUgYW4gb3B0aW9uYWwgcGFyYW1ldGVyLlwiLFxuICBTZXRBY2Nlc3NvckNhbm5vdEhhdmVSZXN0UGFyYW1ldGVyOiBcIkEgJ3NldCcgYWNjZXNzb3IgY2Fubm90IGhhdmUgcmVzdCBwYXJhbWV0ZXIuXCIsXG4gIFNldEFjY2Vzc29yQ2Fubm90SGF2ZVJldHVyblR5cGU6IFwiQSAnc2V0JyBhY2Nlc3NvciBjYW5ub3QgaGF2ZSBhIHJldHVybiB0eXBlIGFubm90YXRpb24uXCIsXG4gIFNpbmdsZVR5cGVQYXJhbWV0ZXJXaXRob3V0VHJhaWxpbmdDb21tYTogKHtcbiAgICB0eXBlUGFyYW1ldGVyTmFtZVxuICB9KSA9PiBgU2luZ2xlIHR5cGUgcGFyYW1ldGVyICR7dHlwZVBhcmFtZXRlck5hbWV9IHNob3VsZCBoYXZlIGEgdHJhaWxpbmcgY29tbWEuIEV4YW1wbGUgdXNhZ2U6IDwke3R5cGVQYXJhbWV0ZXJOYW1lfSw+LmAsXG4gIFN0YXRpY0Jsb2NrQ2Fubm90SGF2ZU1vZGlmaWVyOiBcIlN0YXRpYyBjbGFzcyBibG9ja3MgY2Fubm90IGhhdmUgYW55IG1vZGlmaWVyLlwiLFxuICBUdXBsZU9wdGlvbmFsQWZ0ZXJUeXBlOiBcIkEgbGFiZWxlZCB0dXBsZSBvcHRpb25hbCBlbGVtZW50IG11c3QgYmUgZGVjbGFyZWQgdXNpbmcgYSBxdWVzdGlvbiBtYXJrIGFmdGVyIHRoZSBuYW1lIGFuZCBiZWZvcmUgdGhlIGNvbG9uIChgbmFtZT86IHR5cGVgKSwgcmF0aGVyIHRoYW4gYWZ0ZXIgdGhlIHR5cGUgKGBuYW1lOiB0eXBlP2ApLlwiLFxuICBUeXBlQW5ub3RhdGlvbkFmdGVyQXNzaWduOiBcIlR5cGUgYW5ub3RhdGlvbnMgbXVzdCBjb21lIGJlZm9yZSBkZWZhdWx0IGFzc2lnbm1lbnRzLCBlLmcuIGluc3RlYWQgb2YgYGFnZSA9IDI1OiBudW1iZXJgIHVzZSBgYWdlOiBudW1iZXIgPSAyNWAuXCIsXG4gIFR5cGVJbXBvcnRDYW5ub3RTcGVjaWZ5RGVmYXVsdEFuZE5hbWVkOiBcIkEgdHlwZS1vbmx5IGltcG9ydCBjYW4gc3BlY2lmeSBhIGRlZmF1bHQgaW1wb3J0IG9yIG5hbWVkIGJpbmRpbmdzLCBidXQgbm90IGJvdGguXCIsXG4gIFR5cGVNb2RpZmllcklzVXNlZEluVHlwZUV4cG9ydHM6IFwiVGhlICd0eXBlJyBtb2RpZmllciBjYW5ub3QgYmUgdXNlZCBvbiBhIG5hbWVkIGV4cG9ydCB3aGVuICdleHBvcnQgdHlwZScgaXMgdXNlZCBvbiBpdHMgZXhwb3J0IHN0YXRlbWVudC5cIixcbiAgVHlwZU1vZGlmaWVySXNVc2VkSW5UeXBlSW1wb3J0czogXCJUaGUgJ3R5cGUnIG1vZGlmaWVyIGNhbm5vdCBiZSB1c2VkIG9uIGEgbmFtZWQgaW1wb3J0IHdoZW4gJ2ltcG9ydCB0eXBlJyBpcyB1c2VkIG9uIGl0cyBpbXBvcnQgc3RhdGVtZW50LlwiLFxuICBVbmV4cGVjdGVkUGFyYW1ldGVyTW9kaWZpZXI6IFwiQSBwYXJhbWV0ZXIgcHJvcGVydHkgaXMgb25seSBhbGxvd2VkIGluIGEgY29uc3RydWN0b3IgaW1wbGVtZW50YXRpb24uXCIsXG4gIFVuZXhwZWN0ZWRSZWFkb25seTogXCIncmVhZG9ubHknIHR5cGUgbW9kaWZpZXIgaXMgb25seSBwZXJtaXR0ZWQgb24gYXJyYXkgYW5kIHR1cGxlIGxpdGVyYWwgdHlwZXMuXCIsXG4gIFVuZXhwZWN0ZWRUeXBlQW5ub3RhdGlvbjogXCJEaWQgbm90IGV4cGVjdCBhIHR5cGUgYW5ub3RhdGlvbiBoZXJlLlwiLFxuICBVbmV4cGVjdGVkVHlwZUNhc3RJblBhcmFtZXRlcjogXCJVbmV4cGVjdGVkIHR5cGUgY2FzdCBpbiBwYXJhbWV0ZXIgcG9zaXRpb24uXCIsXG4gIFVuc3VwcG9ydGVkSW1wb3J0VHlwZUFyZ3VtZW50OiBcIkFyZ3VtZW50IGluIGEgdHlwZSBpbXBvcnQgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsLlwiLFxuICBVbnN1cHBvcnRlZFBhcmFtZXRlclByb3BlcnR5S2luZDogXCJBIHBhcmFtZXRlciBwcm9wZXJ0eSBtYXkgbm90IGJlIGRlY2xhcmVkIHVzaW5nIGEgYmluZGluZyBwYXR0ZXJuLlwiLFxuICBVbnN1cHBvcnRlZFNpZ25hdHVyZVBhcmFtZXRlcktpbmQ6ICh7XG4gICAgdHlwZVxuICB9KSA9PiBgTmFtZSBpbiBhIHNpZ25hdHVyZSBtdXN0IGJlIGFuIElkZW50aWZpZXIsIE9iamVjdFBhdHRlcm4gb3IgQXJyYXlQYXR0ZXJuLCBpbnN0ZWFkIGdvdCAke3R5cGV9LmAsXG4gIFVzaW5nRGVjbGFyYXRpb25JbkFtYmllbnRDb250ZXh0OiBraW5kID0+IGAnJHtraW5kfScgZGVjbGFyYXRpb25zIGFyZSBub3QgYWxsb3dlZCBpbiBhbWJpZW50IGNvbnRleHRzLmBcbn0pO1xuZnVuY3Rpb24ga2V5d29yZFR5cGVGcm9tTmFtZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSBcImFueVwiOlxuICAgICAgcmV0dXJuIFwiVFNBbnlLZXl3b3JkXCI7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBcIlRTQm9vbGVhbktleXdvcmRcIjtcbiAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICByZXR1cm4gXCJUU0JpZ0ludEtleXdvcmRcIjtcbiAgICBjYXNlIFwibmV2ZXJcIjpcbiAgICAgIHJldHVybiBcIlRTTmV2ZXJLZXl3b3JkXCI7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIFwiVFNOdW1iZXJLZXl3b3JkXCI7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIFwiVFNPYmplY3RLZXl3b3JkXCI7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIFwiVFNTdHJpbmdLZXl3b3JkXCI7XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgcmV0dXJuIFwiVFNTeW1ib2xLZXl3b3JkXCI7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIFwiVFNVbmRlZmluZWRLZXl3b3JkXCI7XG4gICAgY2FzZSBcInVua25vd25cIjpcbiAgICAgIHJldHVybiBcIlRTVW5rbm93bktleXdvcmRcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuZnVuY3Rpb24gdHNJc0FjY2Vzc01vZGlmaWVyKG1vZGlmaWVyKSB7XG4gIHJldHVybiBtb2RpZmllciA9PT0gXCJwcml2YXRlXCIgfHwgbW9kaWZpZXIgPT09IFwicHVibGljXCIgfHwgbW9kaWZpZXIgPT09IFwicHJvdGVjdGVkXCI7XG59XG5mdW5jdGlvbiB0c0lzVmFyaWFuY2VBbm5vdGF0aW9ucyhtb2RpZmllcikge1xuICByZXR1cm4gbW9kaWZpZXIgPT09IFwiaW5cIiB8fCBtb2RpZmllciA9PT0gXCJvdXRcIjtcbn1cbnZhciB0eXBlc2NyaXB0ID0gc3VwZXJDbGFzcyA9PiBjbGFzcyBUeXBlU2NyaXB0UGFyc2VyTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMudHNQYXJzZUluT3V0TW9kaWZpZXJzID0gdGhpcy50c1BhcnNlTW9kaWZpZXJzLmJpbmQodGhpcywge1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIl0sXG4gICAgICBkaXNhbGxvd2VkTW9kaWZpZXJzOiBbXCJjb25zdFwiLCBcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJyZWFkb25seVwiLCBcImRlY2xhcmVcIiwgXCJhYnN0cmFjdFwiLCBcIm92ZXJyaWRlXCJdLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyXG4gICAgfSk7XG4gICAgdGhpcy50c1BhcnNlQ29uc3RNb2RpZmllciA9IHRoaXMudHNQYXJzZU1vZGlmaWVycy5iaW5kKHRoaXMsIHtcbiAgICAgIGFsbG93ZWRNb2RpZmllcnM6IFtcImNvbnN0XCJdLFxuICAgICAgZGlzYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIl0sXG4gICAgICBlcnJvclRlbXBsYXRlOiBUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblR5cGVQYXJhbWV0ZXJQb3NpdGlvbnNcbiAgICB9KTtcbiAgICB0aGlzLnRzUGFyc2VJbk91dENvbnN0TW9kaWZpZXJzID0gdGhpcy50c1BhcnNlTW9kaWZpZXJzLmJpbmQodGhpcywge1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wiaW5cIiwgXCJvdXRcIiwgXCJjb25zdFwiXSxcbiAgICAgIGRpc2FsbG93ZWRNb2RpZmllcnM6IFtcInB1YmxpY1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJyZWFkb25seVwiLCBcImRlY2xhcmVcIiwgXCJhYnN0cmFjdFwiLCBcIm92ZXJyaWRlXCJdLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyXG4gICAgfSk7XG4gIH1cbiAgZ2V0U2NvcGVIYW5kbGVyKCkge1xuICAgIHJldHVybiBUeXBlU2NyaXB0U2NvcGVIYW5kbGVyO1xuICB9XG4gIHRzSXNJZGVudGlmaWVyKCkge1xuICAgIHJldHVybiB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpO1xuICB9XG4gIHRzVG9rZW5DYW5Gb2xsb3dNb2RpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgwKSB8fCB0aGlzLm1hdGNoKDUpIHx8IHRoaXMubWF0Y2goNTUpIHx8IHRoaXMubWF0Y2goMjEpIHx8IHRoaXMubWF0Y2goMTM5KSB8fCB0aGlzLmlzTGl0ZXJhbFByb3BlcnR5TmFtZSgpO1xuICB9XG4gIHRzTmV4dFRva2VuT25TYW1lTGluZUFuZENhbkZvbGxvd01vZGlmaWVyKCkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRzVG9rZW5DYW5Gb2xsb3dNb2RpZmllcigpO1xuICB9XG4gIHRzTmV4dFRva2VuQ2FuRm9sbG93TW9kaWZpZXIoKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTA2KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy50c1Rva2VuQ2FuRm9sbG93TW9kaWZpZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudHNOZXh0VG9rZW5PblNhbWVMaW5lQW5kQ2FuRm9sbG93TW9kaWZpZXIoKTtcbiAgfVxuICB0c1BhcnNlTW9kaWZpZXIoYWxsb3dlZE1vZGlmaWVycywgc3RvcE9uU3RhcnRPZkNsYXNzU3RhdGljQmxvY2ssIGhhc1NlZW5TdGF0aWNNb2RpZmllcikge1xuICAgIGlmICghdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSAmJiB0aGlzLnN0YXRlLnR5cGUgIT09IDU4ICYmIHRoaXMuc3RhdGUudHlwZSAhPT0gNzUpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IG1vZGlmaWVyID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICBpZiAoYWxsb3dlZE1vZGlmaWVycy5pbmNsdWRlcyhtb2RpZmllcikpIHtcbiAgICAgIGlmIChoYXNTZWVuU3RhdGljTW9kaWZpZXIgJiYgdGhpcy5tYXRjaCgxMDYpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc3RvcE9uU3RhcnRPZkNsYXNzU3RhdGljQmxvY2sgJiYgdGhpcy50c0lzU3RhcnRPZlN0YXRpY0Jsb2NrcygpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50c1RyeVBhcnNlKHRoaXMudHNOZXh0VG9rZW5DYW5Gb2xsb3dNb2RpZmllci5iaW5kKHRoaXMpKSkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgdHNQYXJzZU1vZGlmaWVycyh7XG4gICAgYWxsb3dlZE1vZGlmaWVycyxcbiAgICBkaXNhbGxvd2VkTW9kaWZpZXJzLFxuICAgIHN0b3BPblN0YXJ0T2ZDbGFzc1N0YXRpY0Jsb2NrLFxuICAgIGVycm9yVGVtcGxhdGUgPSBUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblR5cGVNZW1iZXJcbiAgfSwgbW9kaWZpZWQpIHtcbiAgICBjb25zdCBlbmZvcmNlT3JkZXIgPSAobG9jLCBtb2RpZmllciwgYmVmb3JlLCBhZnRlcikgPT4ge1xuICAgICAgaWYgKG1vZGlmaWVyID09PSBiZWZvcmUgJiYgbW9kaWZpZWRbYWZ0ZXJdKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyc09yZGVyLCBsb2MsIHtcbiAgICAgICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbYmVmb3JlLCBhZnRlcl1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbmNvbXBhdGlibGUgPSAobG9jLCBtb2RpZmllciwgbW9kMSwgbW9kMikgPT4ge1xuICAgICAgaWYgKG1vZGlmaWVkW21vZDFdICYmIG1vZGlmaWVyID09PSBtb2QyIHx8IG1vZGlmaWVkW21vZDJdICYmIG1vZGlmaWVyID09PSBtb2QxKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5jb21wYXRpYmxlTW9kaWZpZXJzLCBsb2MsIHtcbiAgICAgICAgICBtb2RpZmllcnM6IFttb2QxLCBtb2QyXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoOzspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRMb2NcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgbW9kaWZpZXIgPSB0aGlzLnRzUGFyc2VNb2RpZmllcihhbGxvd2VkTW9kaWZpZXJzLmNvbmNhdChkaXNhbGxvd2VkTW9kaWZpZXJzICE9IG51bGwgPyBkaXNhbGxvd2VkTW9kaWZpZXJzIDogW10pLCBzdG9wT25TdGFydE9mQ2xhc3NTdGF0aWNCbG9jaywgbW9kaWZpZWQuc3RhdGljKTtcbiAgICAgIGlmICghbW9kaWZpZXIpIGJyZWFrO1xuICAgICAgaWYgKHRzSXNBY2Nlc3NNb2RpZmllcihtb2RpZmllcikpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVkLmFjY2Vzc2liaWxpdHkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkR1cGxpY2F0ZUFjY2Vzc2liaWxpdHlNb2RpZmllciwgc3RhcnRMb2MsIHtcbiAgICAgICAgICAgIG1vZGlmaWVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgbW9kaWZpZXIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgbW9kaWZpZXIsIFwic3RhdGljXCIpO1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIG1vZGlmaWVyLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICAgIG1vZGlmaWVkLmFjY2Vzc2liaWxpdHkgPSBtb2RpZmllcjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0c0lzVmFyaWFuY2VBbm5vdGF0aW9ucyhtb2RpZmllcikpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVkW21vZGlmaWVyXSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRHVwbGljYXRlTW9kaWZpZXIsIHN0YXJ0TG9jLCB7XG4gICAgICAgICAgICBtb2RpZmllclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1vZGlmaWVkW21vZGlmaWVyXSA9IHRydWU7XG4gICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIFwiaW5cIiwgXCJvdXRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChtb2RpZmllZCwgbW9kaWZpZXIpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EdXBsaWNhdGVNb2RpZmllciwgc3RhcnRMb2MsIHtcbiAgICAgICAgICAgIG1vZGlmaWVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5mb3JjZU9yZGVyKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJzdGF0aWNcIiwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBcInN0YXRpY1wiLCBcIm92ZXJyaWRlXCIpO1xuICAgICAgICAgIGVuZm9yY2VPcmRlcihzdGFydExvYywgbW9kaWZpZXIsIFwib3ZlcnJpZGVcIiwgXCJyZWFkb25seVwiKTtcbiAgICAgICAgICBlbmZvcmNlT3JkZXIoc3RhcnRMb2MsIG1vZGlmaWVyLCBcImFic3RyYWN0XCIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgaW5jb21wYXRpYmxlKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJkZWNsYXJlXCIsIFwib3ZlcnJpZGVcIik7XG4gICAgICAgICAgaW5jb21wYXRpYmxlKHN0YXJ0TG9jLCBtb2RpZmllciwgXCJzdGF0aWNcIiwgXCJhYnN0cmFjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBtb2RpZmllZFttb2RpZmllcl0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRpc2FsbG93ZWRNb2RpZmllcnMgIT0gbnVsbCAmJiBkaXNhbGxvd2VkTW9kaWZpZXJzLmluY2x1ZGVzKG1vZGlmaWVyKSkge1xuICAgICAgICB0aGlzLnJhaXNlKGVycm9yVGVtcGxhdGUsIHN0YXJ0TG9jLCB7XG4gICAgICAgICAgbW9kaWZpZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRzSXNMaXN0VGVybWluYXRvcihraW5kKSB7XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIFwiRW51bU1lbWJlcnNcIjpcbiAgICAgIGNhc2UgXCJUeXBlTWVtYmVyc1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCg4KTtcbiAgICAgIGNhc2UgXCJIZXJpdGFnZUNsYXVzZUVsZW1lbnRcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goNSk7XG4gICAgICBjYXNlIFwiVHVwbGVFbGVtZW50VHlwZXNcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2goMyk7XG4gICAgICBjYXNlIFwiVHlwZVBhcmFtZXRlcnNPckFyZ3VtZW50c1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaCg0OCk7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VMaXN0KGtpbmQsIHBhcnNlRWxlbWVudCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlICghdGhpcy50c0lzTGlzdFRlcm1pbmF0b3Ioa2luZCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHBhcnNlRWxlbWVudCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB0c1BhcnNlRGVsaW1pdGVkTGlzdChraW5kLCBwYXJzZUVsZW1lbnQsIHJlZlRyYWlsaW5nQ29tbWFQb3MpIHtcbiAgICByZXR1cm4gbm9uTnVsbCh0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0V29ya2VyKGtpbmQsIHBhcnNlRWxlbWVudCwgdHJ1ZSwgcmVmVHJhaWxpbmdDb21tYVBvcykpO1xuICB9XG4gIHRzUGFyc2VEZWxpbWl0ZWRMaXN0V29ya2VyKGtpbmQsIHBhcnNlRWxlbWVudCwgZXhwZWN0U3VjY2VzcywgcmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCB0cmFpbGluZ0NvbW1hUG9zID0gLTE7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKHRoaXMudHNJc0xpc3RUZXJtaW5hdG9yKGtpbmQpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJhaWxpbmdDb21tYVBvcyA9IC0xO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHBhcnNlRWxlbWVudCgpO1xuICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG4gICAgICBpZiAodGhpcy5lYXQoMTIpKSB7XG4gICAgICAgIHRyYWlsaW5nQ29tbWFQb3MgPSB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYy5pbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50c0lzTGlzdFRlcm1pbmF0b3Ioa2luZCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZWN0U3VjY2Vzcykge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAocmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgICAgcmVmVHJhaWxpbmdDb21tYVBvcy52YWx1ZSA9IHRyYWlsaW5nQ29tbWFQb3M7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHNQYXJzZUJyYWNrZXRlZExpc3Qoa2luZCwgcGFyc2VFbGVtZW50LCBicmFja2V0LCBza2lwRmlyc3RUb2tlbiwgcmVmVHJhaWxpbmdDb21tYVBvcykge1xuICAgIGlmICghc2tpcEZpcnN0VG9rZW4pIHtcbiAgICAgIGlmIChicmFja2V0KSB7XG4gICAgICAgIHRoaXMuZXhwZWN0KDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoNDcpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KGtpbmQsIHBhcnNlRWxlbWVudCwgcmVmVHJhaWxpbmdDb21tYVBvcyk7XG4gICAgaWYgKGJyYWNrZXQpIHtcbiAgICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV4cGVjdCg0OCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdHNQYXJzZUltcG9ydFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoODMpO1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBpZiAoIXRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbnN1cHBvcnRlZEltcG9ydFR5cGVBcmd1bWVudCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gc3VwZXIucGFyc2VFeHByQXRvbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZVN0cmluZ0xpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdCgxMikpIHtcbiAgICAgIG5vZGUub3B0aW9ucyA9IHRoaXMudHNQYXJzZUltcG9ydFR5cGVPcHRpb25zKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUub3B0aW9ucyA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICBpZiAodGhpcy5lYXQoMTYpKSB7XG4gICAgICBub2RlLnF1YWxpZmllciA9IHRoaXMudHNQYXJzZUVudGl0eU5hbWUoMSB8IDIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0ltcG9ydFR5cGVcIik7XG4gIH1cbiAgdHNQYXJzZUltcG9ydFR5cGVPcHRpb25zKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIGNvbnN0IHdpdGhQcm9wZXJ0eSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDc2KSkge1xuICAgICAgd2l0aFByb3BlcnR5Lm1ldGhvZCA9IGZhbHNlO1xuICAgICAgd2l0aFByb3BlcnR5LmtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgd2l0aFByb3BlcnR5LmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICB3aXRoUHJvcGVydHkuc2hvcnRoYW5kID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCA3Nik7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICB3aXRoUHJvcGVydHkudmFsdWUgPSB0aGlzLnRzUGFyc2VJbXBvcnRUeXBlV2l0aFByb3BlcnR5VmFsdWUoKTtcbiAgICBub2RlLnByb3BlcnRpZXMgPSBbdGhpcy5maW5pc2hPYmplY3RQcm9wZXJ0eSh3aXRoUHJvcGVydHkpXTtcbiAgICB0aGlzLmVhdCgxMik7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdEV4cHJlc3Npb25cIik7XG4gIH1cbiAgdHNQYXJzZUltcG9ydFR5cGVXaXRoUHJvcGVydHlWYWx1ZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gW107XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKDgpKSB7XG4gICAgICBjb25zdCB0eXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHR5cGUpIHx8IHR5cGUgPT09IDEzNCkge1xuICAgICAgICBwcm9wZXJ0aWVzLnB1c2goc3VwZXIucGFyc2VQcm9wZXJ0eURlZmluaXRpb24obnVsbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVhdCgxMik7XG4gICAgfVxuICAgIG5vZGUucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk9iamVjdEV4cHJlc3Npb25cIik7XG4gIH1cbiAgdHNQYXJzZUVudGl0eU5hbWUoZmxhZ3MpIHtcbiAgICBsZXQgZW50aXR5O1xuICAgIGlmIChmbGFncyAmIDEgJiYgdGhpcy5tYXRjaCg3OCkpIHtcbiAgICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgICAgZW50aXR5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIGVudGl0eSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRoaXNFeHByZXNzaW9uXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbnRpdHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcighIShmbGFncyAmIDEpKTtcbiAgICB9XG4gICAgd2hpbGUgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKGVudGl0eSk7XG4gICAgICBub2RlLmxlZnQgPSBlbnRpdHk7XG4gICAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoISEoZmxhZ3MgJiAxKSk7XG4gICAgICBlbnRpdHkgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1F1YWxpZmllZE5hbWVcIik7XG4gICAgfVxuICAgIHJldHVybiBlbnRpdHk7XG4gIH1cbiAgdHNQYXJzZVR5cGVSZWZlcmVuY2UoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS50eXBlTmFtZSA9IHRoaXMudHNQYXJzZUVudGl0eU5hbWUoMSk7XG4gICAgaWYgKCF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUmVmZXJlbmNlXCIpO1xuICB9XG4gIHRzUGFyc2VUaGlzVHlwZVByZWRpY2F0ZShsaHMpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdE5vZGUobGhzKTtcbiAgICBub2RlLnBhcmFtZXRlck5hbWUgPSBsaHM7XG4gICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKGZhbHNlKTtcbiAgICBub2RlLmFzc2VydHMgPSBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICB9XG4gIHRzUGFyc2VUaGlzVHlwZU5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVGhpc1R5cGVcIik7XG4gIH1cbiAgdHNQYXJzZVR5cGVRdWVyeSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCg4Nyk7XG4gICAgaWYgKHRoaXMubWF0Y2goODMpKSB7XG4gICAgICBub2RlLmV4cHJOYW1lID0gdGhpcy50c1BhcnNlSW1wb3J0VHlwZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmV4cHJOYW1lID0gdGhpcy50c1BhcnNlRW50aXR5TmFtZSgxIHwgMik7XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZVF1ZXJ5XCIpO1xuICB9XG4gIHRzUGFyc2VUeXBlUGFyYW1ldGVyKHBhcnNlTW9kaWZpZXJzKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgcGFyc2VNb2RpZmllcnMobm9kZSk7XG4gICAgbm9kZS5uYW1lID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlck5hbWUoKTtcbiAgICBub2RlLmNvbnN0cmFpbnQgPSB0aGlzLnRzRWF0VGhlblBhcnNlVHlwZSg4MSk7XG4gICAgbm9kZS5kZWZhdWx0ID0gdGhpcy50c0VhdFRoZW5QYXJzZVR5cGUoMjkpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQYXJhbWV0ZXJcIik7XG4gIH1cbiAgdHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHBhcnNlTW9kaWZpZXJzKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlcnMocGFyc2VNb2RpZmllcnMpO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlVHlwZVBhcmFtZXRlcnMocGFyc2VNb2RpZmllcnMpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCgxNDMpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHJlZlRyYWlsaW5nQ29tbWFQb3MgPSB7XG4gICAgICB2YWx1ZTogLTFcbiAgICB9O1xuICAgIG5vZGUucGFyYW1zID0gdGhpcy50c1BhcnNlQnJhY2tldGVkTGlzdChcIlR5cGVQYXJhbWV0ZXJzT3JBcmd1bWVudHNcIiwgdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlci5iaW5kKHRoaXMsIHBhcnNlTW9kaWZpZXJzKSwgZmFsc2UsIHRydWUsIHJlZlRyYWlsaW5nQ29tbWFQb3MpO1xuICAgIGlmIChub2RlLnBhcmFtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRW1wdHlUeXBlUGFyYW1ldGVycywgbm9kZSk7XG4gICAgfVxuICAgIGlmIChyZWZUcmFpbGluZ0NvbW1hUG9zLnZhbHVlICE9PSAtMSkge1xuICAgICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInRyYWlsaW5nQ29tbWFcIiwgcmVmVHJhaWxpbmdDb21tYVBvcy52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiKTtcbiAgfVxuICB0c0ZpbGxTaWduYXR1cmUocmV0dXJuVG9rZW4sIHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHJldHVyblRva2VuUmVxdWlyZWQgPSByZXR1cm5Ub2tlbiA9PT0gMTk7XG4gICAgY29uc3QgcGFyYW1zS2V5ID0gXCJwYXJhbWV0ZXJzXCI7XG4gICAgY29uc3QgcmV0dXJuVHlwZUtleSA9IFwidHlwZUFubm90YXRpb25cIjtcbiAgICBzaWduYXR1cmUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VDb25zdE1vZGlmaWVyKTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgc2lnbmF0dXJlW3BhcmFtc0tleV0gPSB0aGlzLnRzUGFyc2VCaW5kaW5nTGlzdEZvclNpZ25hdHVyZSgpO1xuICAgIGlmIChyZXR1cm5Ub2tlblJlcXVpcmVkKSB7XG4gICAgICBzaWduYXR1cmVbcmV0dXJuVHlwZUtleV0gPSB0aGlzLnRzUGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbihyZXR1cm5Ub2tlbik7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKHJldHVyblRva2VuKSkge1xuICAgICAgc2lnbmF0dXJlW3JldHVyblR5cGVLZXldID0gdGhpcy50c1BhcnNlVHlwZU9yVHlwZVByZWRpY2F0ZUFubm90YXRpb24ocmV0dXJuVG9rZW4pO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlQmluZGluZ0xpc3RGb3JTaWduYXR1cmUoKSB7XG4gICAgY29uc3QgbGlzdCA9IHN1cGVyLnBhcnNlQmluZGluZ0xpc3QoMTEsIDQxLCAyKTtcbiAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgbGlzdCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlXG4gICAgICB9ID0gcGF0dGVybjtcbiAgICAgIGlmICh0eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgfHwgdHlwZSA9PT0gXCJUU1BhcmFtZXRlclByb3BlcnR5XCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbnN1cHBvcnRlZFNpZ25hdHVyZVBhcmFtZXRlcktpbmQsIHBhdHRlcm4sIHtcbiAgICAgICAgICB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuICB0c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpIHtcbiAgICBpZiAoIXRoaXMuZWF0KDEyKSAmJiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0KDEzKTtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZVNpZ25hdHVyZU1lbWJlcihraW5kLCBub2RlKSB7XG4gICAgdGhpcy50c0ZpbGxTaWduYXR1cmUoMTQsIG5vZGUpO1xuICAgIHRoaXMudHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGtpbmQpO1xuICB9XG4gIHRzSXNVbmFtYmlndW91c2x5SW5kZXhTaWduYXR1cmUoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMubWF0Y2goMTQpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHNUcnlQYXJzZUluZGV4U2lnbmF0dXJlKG5vZGUpIHtcbiAgICBpZiAoISh0aGlzLm1hdGNoKDApICYmIHRoaXMudHNMb29rQWhlYWQodGhpcy50c0lzVW5hbWJpZ3VvdXNseUluZGV4U2lnbmF0dXJlLmJpbmQodGhpcykpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdCgwKTtcbiAgICBjb25zdCBpZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgaWQudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihpZCk7XG4gICAgdGhpcy5leHBlY3QoMyk7XG4gICAgbm9kZS5wYXJhbWV0ZXJzID0gW2lkXTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgdGhpcy50c1BhcnNlVHlwZU1lbWJlclNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0luZGV4U2lnbmF0dXJlXCIpO1xuICB9XG4gIHRzUGFyc2VQcm9wZXJ0eU9yTWV0aG9kU2lnbmF0dXJlKG5vZGUsIHJlYWRvbmx5KSB7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkgbm9kZS5vcHRpb25hbCA9IHRydWU7XG4gICAgaWYgKHRoaXMubWF0Y2goMTApIHx8IHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICBpZiAocmVhZG9ubHkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5SZWFkb25seUZvck1ldGhvZFNpZ25hdHVyZSwgbm9kZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXRob2QgPSBub2RlO1xuICAgICAgaWYgKG1ldGhvZC5raW5kICYmIHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQWNjZXNzb3JDYW5ub3RIYXZlVHlwZVBhcmFtZXRlcnMsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRzRmlsbFNpZ25hdHVyZSgxNCwgbWV0aG9kKTtcbiAgICAgIHRoaXMudHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKTtcbiAgICAgIGNvbnN0IHBhcmFtc0tleSA9IFwicGFyYW1ldGVyc1wiO1xuICAgICAgY29uc3QgcmV0dXJuVHlwZUtleSA9IFwidHlwZUFubm90YXRpb25cIjtcbiAgICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJnZXRcIikge1xuICAgICAgICBpZiAobWV0aG9kW3BhcmFtc0tleV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkJhZEdldHRlckFyaXR5LCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIGlmICh0aGlzLmlzVGhpc1BhcmFtKG1ldGhvZFtwYXJhbXNLZXldWzBdKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5BY2Nlc3NvckNhbm5vdERlY2xhcmVUaGlzUGFyYW1ldGVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIikge1xuICAgICAgICBpZiAobWV0aG9kW3BhcmFtc0tleV0ubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQmFkU2V0dGVyQXJpdHksIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgZmlyc3RQYXJhbWV0ZXIgPSBtZXRob2RbcGFyYW1zS2V5XVswXTtcbiAgICAgICAgICBpZiAodGhpcy5pc1RoaXNQYXJhbShmaXJzdFBhcmFtZXRlcikpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQWNjZXNzb3JDYW5ub3REZWNsYXJlVGhpc1BhcmFtZXRlciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZpcnN0UGFyYW1ldGVyLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGZpcnN0UGFyYW1ldGVyLm9wdGlvbmFsKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlNldEFjY2Vzc29yQ2Fubm90SGF2ZU9wdGlvbmFsUGFyYW1ldGVyLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmlyc3RQYXJhbWV0ZXIudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlNldEFjY2Vzc29yQ2Fubm90SGF2ZVJlc3RQYXJhbWV0ZXIsIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2RbcmV0dXJuVHlwZUtleV0pIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlNldEFjY2Vzc29yQ2Fubm90SGF2ZVJldHVyblR5cGUsIG1ldGhvZFtyZXR1cm5UeXBlS2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIlRTTWV0aG9kU2lnbmF0dXJlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcm9wZXJ0eSA9IG5vZGU7XG4gICAgICBpZiAocmVhZG9ubHkpIHByb3BlcnR5LnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgICAgaWYgKHR5cGUpIHByb3BlcnR5LnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICAgIHRoaXMudHNQYXJzZVR5cGVNZW1iZXJTZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcGVydHksIFwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiKTtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZVR5cGVNZW1iZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTApIHx8IHRoaXMubWF0Y2goNDcpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlU2lnbmF0dXJlTWVtYmVyKFwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIiwgbm9kZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDc3KSkge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCgxMCkgfHwgdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVNpZ25hdHVyZU1lbWJlcihcIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIiwgbm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmtleSA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcihpZCwgXCJuZXdcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VQcm9wZXJ0eU9yTWV0aG9kU2lnbmF0dXJlKG5vZGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy50c1BhcnNlTW9kaWZpZXJzKHtcbiAgICAgIGFsbG93ZWRNb2RpZmllcnM6IFtcInJlYWRvbmx5XCJdLFxuICAgICAgZGlzYWxsb3dlZE1vZGlmaWVyczogW1wiZGVjbGFyZVwiLCBcImFic3RyYWN0XCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcInB1YmxpY1wiLCBcInN0YXRpY1wiLCBcIm92ZXJyaWRlXCJdXG4gICAgfSwgbm9kZSk7XG4gICAgY29uc3QgaWR4ID0gdGhpcy50c1RyeVBhcnNlSW5kZXhTaWduYXR1cmUobm9kZSk7XG4gICAgaWYgKGlkeCkge1xuICAgICAgcmV0dXJuIGlkeDtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VQcm9wZXJ0eU5hbWUobm9kZSk7XG4gICAgaWYgKCFub2RlLmNvbXB1dGVkICYmIG5vZGUua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIChub2RlLmtleS5uYW1lID09PSBcImdldFwiIHx8IG5vZGUua2V5Lm5hbWUgPT09IFwic2V0XCIpICYmIHRoaXMudHNUb2tlbkNhbkZvbGxvd01vZGlmaWVyKCkpIHtcbiAgICAgIG5vZGUua2luZCA9IG5vZGUua2V5Lm5hbWU7XG4gICAgICBzdXBlci5wYXJzZVByb3BlcnR5TmFtZShub2RlKTtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMCkgJiYgIXRoaXMubWF0Y2goNDcpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCAxMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRzUGFyc2VQcm9wZXJ0eU9yTWV0aG9kU2lnbmF0dXJlKG5vZGUsICEhbm9kZS5yZWFkb25seSk7XG4gIH1cbiAgdHNQYXJzZVR5cGVMaXRlcmFsKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubWVtYmVycyA9IHRoaXMudHNQYXJzZU9iamVjdFR5cGVNZW1iZXJzKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUxpdGVyYWxcIik7XG4gIH1cbiAgdHNQYXJzZU9iamVjdFR5cGVNZW1iZXJzKCkge1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIGNvbnN0IG1lbWJlcnMgPSB0aGlzLnRzUGFyc2VMaXN0KFwiVHlwZU1lbWJlcnNcIiwgdGhpcy50c1BhcnNlVHlwZU1lbWJlci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gbWVtYmVycztcbiAgfVxuICB0c0lzU3RhcnRPZk1hcHBlZFR5cGUoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuZWF0KDUzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDEyMik7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjIpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm1hdGNoKDApKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICghdGhpcy50c0lzSWRlbnRpZmllcigpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDU4KTtcbiAgfVxuICB0c1BhcnNlTWFwcGVkVHlwZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBpZiAodGhpcy5tYXRjaCg1MykpIHtcbiAgICAgIG5vZGUucmVhZG9ubHkgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTIyKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCgxMjIpKSB7XG4gICAgICBub2RlLnJlYWRvbmx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMCk7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdHlwZVBhcmFtZXRlci5uYW1lID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlck5hbWUoKTtcbiAgICB0eXBlUGFyYW1ldGVyLmNvbnN0cmFpbnQgPSB0aGlzLnRzRXhwZWN0VGhlblBhcnNlVHlwZSg1OCk7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVyID0gdGhpcy5maW5pc2hOb2RlKHR5cGVQYXJhbWV0ZXIsIFwiVFNUeXBlUGFyYW1ldGVyXCIpO1xuICAgIG5vZGUubmFtZVR5cGUgPSB0aGlzLmVhdENvbnRleHR1YWwoOTMpID8gdGhpcy50c1BhcnNlVHlwZSgpIDogbnVsbDtcbiAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICBpZiAodGhpcy5tYXRjaCg1MykpIHtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdCgxNyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgIH1cbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1RyeVBhcnNlVHlwZSgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTWFwcGVkVHlwZVwiKTtcbiAgfVxuICB0c1BhcnNlVHVwbGVUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUuZWxlbWVudFR5cGVzID0gdGhpcy50c1BhcnNlQnJhY2tldGVkTGlzdChcIlR1cGxlRWxlbWVudFR5cGVzXCIsIHRoaXMudHNQYXJzZVR1cGxlRWxlbWVudFR5cGUuYmluZCh0aGlzKSwgdHJ1ZSwgZmFsc2UpO1xuICAgIGxldCBzZWVuT3B0aW9uYWxFbGVtZW50ID0gZmFsc2U7XG4gICAgbm9kZS5lbGVtZW50VHlwZXMuZm9yRWFjaChlbGVtZW50Tm9kZSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSBlbGVtZW50Tm9kZTtcbiAgICAgIGlmIChzZWVuT3B0aW9uYWxFbGVtZW50ICYmIHR5cGUgIT09IFwiVFNSZXN0VHlwZVwiICYmIHR5cGUgIT09IFwiVFNPcHRpb25hbFR5cGVcIiAmJiAhKHR5cGUgPT09IFwiVFNOYW1lZFR1cGxlTWVtYmVyXCIgJiYgZWxlbWVudE5vZGUub3B0aW9uYWwpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuT3B0aW9uYWxUeXBlQmVmb3JlUmVxdWlyZWQsIGVsZW1lbnROb2RlKTtcbiAgICAgIH1cbiAgICAgIHNlZW5PcHRpb25hbEVsZW1lbnQgfHwgKHNlZW5PcHRpb25hbEVsZW1lbnQgPSB0eXBlID09PSBcIlRTTmFtZWRUdXBsZU1lbWJlclwiICYmIGVsZW1lbnROb2RlLm9wdGlvbmFsIHx8IHR5cGUgPT09IFwiVFNPcHRpb25hbFR5cGVcIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHVwbGVUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VUdXBsZUVsZW1lbnRUeXBlKCkge1xuICAgIGNvbnN0IHJlc3RTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgcmVzdCA9IHRoaXMuZWF0KDIxKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydExvY1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGxldCBsYWJlbGVkO1xuICAgIGxldCBsYWJlbDtcbiAgICBsZXQgb3B0aW9uYWw7XG4gICAgbGV0IHR5cGU7XG4gICAgY29uc3QgaXNXb3JkID0gdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKTtcbiAgICBjb25zdCBjaEFmdGVyV29yZCA9IGlzV29yZCA/IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA6IG51bGw7XG4gICAgaWYgKGNoQWZ0ZXJXb3JkID09PSA1OCkge1xuICAgICAgbGFiZWxlZCA9IHRydWU7XG4gICAgICBvcHRpb25hbCA9IGZhbHNlO1xuICAgICAgbGFiZWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgIHRoaXMuZXhwZWN0KDE0KTtcbiAgICAgIHR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSBlbHNlIGlmIChjaEFmdGVyV29yZCA9PT0gNjMpIHtcbiAgICAgIG9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHdvcmROYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIGNvbnN0IHR5cGVPckxhYmVsID0gdGhpcy50c1BhcnNlTm9uQXJyYXlUeXBlKCk7XG4gICAgICBpZiAodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA1OCkge1xuICAgICAgICBsYWJlbGVkID0gdHJ1ZTtcbiAgICAgICAgbGFiZWwgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdChzdGFydExvYyksIHdvcmROYW1lKTtcbiAgICAgICAgdGhpcy5leHBlY3QoMTcpO1xuICAgICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICAgIHR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYWJlbGVkID0gZmFsc2U7XG4gICAgICAgIHR5cGUgPSB0eXBlT3JMYWJlbDtcbiAgICAgICAgdGhpcy5leHBlY3QoMTcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgICAgb3B0aW9uYWwgPSB0aGlzLmVhdCgxNyk7XG4gICAgICBsYWJlbGVkID0gdGhpcy5lYXQoMTQpO1xuICAgIH1cbiAgICBpZiAobGFiZWxlZCkge1xuICAgICAgbGV0IGxhYmVsZWROb2RlO1xuICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgIGxhYmVsZWROb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICAgIGxhYmVsZWROb2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgICAgIGxhYmVsZWROb2RlLmxhYmVsID0gbGFiZWw7XG4gICAgICAgIGxhYmVsZWROb2RlLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgICAgIGxhYmVsZWROb2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlR1cGxlT3B0aW9uYWxBZnRlclR5cGUsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFiZWxlZE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgICAgbGFiZWxlZE5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbnZhbGlkVHVwbGVNZW1iZXJMYWJlbCwgdHlwZSk7XG4gICAgICAgIGxhYmVsZWROb2RlLmxhYmVsID0gdHlwZTtcbiAgICAgICAgbGFiZWxlZE5vZGUuZWxlbWVudFR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICB9XG4gICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKGxhYmVsZWROb2RlLCBcIlRTTmFtZWRUdXBsZU1lbWJlclwiKTtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbmFsKSB7XG4gICAgICBjb25zdCBvcHRpb25hbFR5cGVOb2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBvcHRpb25hbFR5cGVOb2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICAgIHR5cGUgPSB0aGlzLmZpbmlzaE5vZGUob3B0aW9uYWxUeXBlTm9kZSwgXCJUU09wdGlvbmFsVHlwZVwiKTtcbiAgICB9XG4gICAgaWYgKHJlc3QpIHtcbiAgICAgIGNvbnN0IHJlc3ROb2RlID0gdGhpcy5zdGFydE5vZGVBdChyZXN0U3RhcnRMb2MpO1xuICAgICAgcmVzdE5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShyZXN0Tm9kZSwgXCJUU1Jlc3RUeXBlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICB0c1BhcnNlUGFyZW50aGVzaXplZFR5cGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1BhcmVudGhlc2l6ZWRUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKHR5cGUsIGFic3RyYWN0KSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHR5cGUgPT09IFwiVFNDb25zdHJ1Y3RvclR5cGVcIikge1xuICAgICAgbm9kZS5hYnN0cmFjdCA9ICEhYWJzdHJhY3Q7XG4gICAgICBpZiAoYWJzdHJhY3QpIHRoaXMubmV4dCgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIHRoaXMudHNJbkFsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQoKCkgPT4gdGhpcy50c0ZpbGxTaWduYXR1cmUoMTksIG5vZGUpKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIHR5cGUpO1xuICB9XG4gIHRzUGFyc2VMaXRlcmFsVHlwZU5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgMTM1OlxuICAgICAgY2FzZSAxMzY6XG4gICAgICBjYXNlIDEzNDpcbiAgICAgIGNhc2UgODU6XG4gICAgICBjYXNlIDg2OlxuICAgICAgICBub2RlLmxpdGVyYWwgPSBzdXBlci5wYXJzZUV4cHJBdG9tKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0xpdGVyYWxUeXBlXCIpO1xuICB9XG4gIHRzUGFyc2VUZW1wbGF0ZUxpdGVyYWxUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubGl0ZXJhbCA9IHN1cGVyLnBhcnNlVGVtcGxhdGUoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0xpdGVyYWxUeXBlXCIpO1xuICB9XG4gIHBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaW5UeXBlKSByZXR1cm4gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIHJldHVybiBzdXBlci5wYXJzZVRlbXBsYXRlU3Vic3RpdHV0aW9uKCk7XG4gIH1cbiAgdHNQYXJzZVRoaXNUeXBlT3JUaGlzVHlwZVByZWRpY2F0ZSgpIHtcbiAgICBjb25zdCB0aGlzS2V5d29yZCA9IHRoaXMudHNQYXJzZVRoaXNUeXBlTm9kZSgpO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMTYpICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVGhpc1R5cGVQcmVkaWNhdGUodGhpc0tleXdvcmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpc0tleXdvcmQ7XG4gICAgfVxuICB9XG4gIHRzUGFyc2VOb25BcnJheVR5cGUoKSB7XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlLnR5cGUpIHtcbiAgICAgIGNhc2UgMTM0OlxuICAgICAgY2FzZSAxMzU6XG4gICAgICBjYXNlIDEzNjpcbiAgICAgIGNhc2UgODU6XG4gICAgICBjYXNlIDg2OlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlTGl0ZXJhbFR5cGVOb2RlKCk7XG4gICAgICBjYXNlIDUzOlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS52YWx1ZSA9PT0gXCItXCIpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLmxvb2thaGVhZCgpO1xuICAgICAgICAgIGlmIChuZXh0VG9rZW4udHlwZSAhPT0gMTM1ICYmIG5leHRUb2tlbi50eXBlICE9PSAxMzYpIHtcbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmxpdGVyYWwgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeSgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0xpdGVyYWxUeXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA3ODpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVRoaXNUeXBlT3JUaGlzVHlwZVByZWRpY2F0ZSgpO1xuICAgICAgY2FzZSA4NzpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVRdWVyeSgpO1xuICAgICAgY2FzZSA4MzpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUltcG9ydFR5cGUoKTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRoaXMudHNMb29rQWhlYWQodGhpcy50c0lzU3RhcnRPZk1hcHBlZFR5cGUuYmluZCh0aGlzKSkgPyB0aGlzLnRzUGFyc2VNYXBwZWRUeXBlKCkgOiB0aGlzLnRzUGFyc2VUeXBlTGl0ZXJhbCgpO1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHVwbGVUeXBlKCk7XG4gICAgICBjYXNlIDEwOlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlUGFyZW50aGVzaXplZFR5cGUoKTtcbiAgICAgIGNhc2UgMjU6XG4gICAgICBjYXNlIDI0OlxuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVGVtcGxhdGVMaXRlcmFsVHlwZSgpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodHlwZSkgfHwgdHlwZSA9PT0gODggfHwgdHlwZSA9PT0gODQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVUeXBlID0gdHlwZSA9PT0gODggPyBcIlRTVm9pZEtleXdvcmRcIiA6IHR5cGUgPT09IDg0ID8gXCJUU051bGxLZXl3b3JkXCIgOiBrZXl3b3JkVHlwZUZyb21OYW1lKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICAgICAgaWYgKG5vZGVUeXBlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpICE9PSA0Nikge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbm9kZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVSZWZlcmVuY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgdHNQYXJzZUFycmF5VHlwZU9ySGlnaGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0TG9jXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgbGV0IHR5cGUgPSB0aGlzLnRzUGFyc2VOb25BcnJheVR5cGUoKTtcbiAgICB3aGlsZSAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5lYXQoMCkpIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDMpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZS5lbGVtZW50VHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuZXhwZWN0KDMpO1xuICAgICAgICB0eXBlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNBcnJheVR5cGVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICAgIG5vZGUub2JqZWN0VHlwZSA9IHR5cGU7XG4gICAgICAgIG5vZGUuaW5kZXhUeXBlID0gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICAgICAgdHlwZSA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHRzUGFyc2VUeXBlT3BlcmF0b3IoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3Qgb3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZU9wZXJhdG9yT3JIaWdoZXIoKTtcbiAgICBpZiAob3BlcmF0b3IgPT09IFwicmVhZG9ubHlcIikge1xuICAgICAgdGhpcy50c0NoZWNrVHlwZUFubm90YXRpb25Gb3JSZWFkT25seShub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZU9wZXJhdG9yXCIpO1xuICB9XG4gIHRzQ2hlY2tUeXBlQW5ub3RhdGlvbkZvclJlYWRPbmx5KG5vZGUpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZUFubm90YXRpb24udHlwZSkge1xuICAgICAgY2FzZSBcIlRTVHVwbGVUeXBlXCI6XG4gICAgICBjYXNlIFwiVFNBcnJheVR5cGVcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbmV4cGVjdGVkUmVhZG9ubHksIG5vZGUpO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlSW5mZXJUeXBlKCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMTUpO1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHR5cGVQYXJhbWV0ZXIubmFtZSA9IHRoaXMudHNQYXJzZVR5cGVQYXJhbWV0ZXJOYW1lKCk7XG4gICAgdHlwZVBhcmFtZXRlci5jb25zdHJhaW50ID0gdGhpcy50c1RyeVBhcnNlKCgpID0+IHRoaXMudHNQYXJzZUNvbnN0cmFpbnRGb3JJbmZlclR5cGUoKSk7XG4gICAgbm9kZS50eXBlUGFyYW1ldGVyID0gdGhpcy5maW5pc2hOb2RlKHR5cGVQYXJhbWV0ZXIsIFwiVFNUeXBlUGFyYW1ldGVyXCIpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0luZmVyVHlwZVwiKTtcbiAgfVxuICB0c1BhcnNlQ29uc3RyYWludEZvckluZmVyVHlwZSgpIHtcbiAgICBpZiAodGhpcy5lYXQoODEpKSB7XG4gICAgICBjb25zdCBjb25zdHJhaW50ID0gdGhpcy50c0luRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzUGFyc2VUeXBlKCkpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0IHx8ICF0aGlzLm1hdGNoKDE3KSkge1xuICAgICAgICByZXR1cm4gY29uc3RyYWludDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyKCkge1xuICAgIGNvbnN0IGlzVHlwZU9wZXJhdG9yID0gdG9rZW5Jc1RTVHlwZU9wZXJhdG9yKHRoaXMuc3RhdGUudHlwZSkgJiYgIXRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgcmV0dXJuIGlzVHlwZU9wZXJhdG9yID8gdGhpcy50c1BhcnNlVHlwZU9wZXJhdG9yKCkgOiB0aGlzLmlzQ29udGV4dHVhbCgxMTUpID8gdGhpcy50c1BhcnNlSW5mZXJUeXBlKCkgOiB0aGlzLnRzSW5BbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZUFycmF5VHlwZU9ySGlnaGVyKCkpO1xuICB9XG4gIHRzUGFyc2VVbmlvbk9ySW50ZXJzZWN0aW9uVHlwZShraW5kLCBwYXJzZUNvbnN0aXR1ZW50VHlwZSwgb3BlcmF0b3IpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBoYXNMZWFkaW5nT3BlcmF0b3IgPSB0aGlzLmVhdChvcGVyYXRvcik7XG4gICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICBkbyB7XG4gICAgICB0eXBlcy5wdXNoKHBhcnNlQ29uc3RpdHVlbnRUeXBlKCkpO1xuICAgIH0gd2hpbGUgKHRoaXMuZWF0KG9wZXJhdG9yKSk7XG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSAmJiAhaGFzTGVhZGluZ09wZXJhdG9yKSB7XG4gICAgICByZXR1cm4gdHlwZXNbMF07XG4gICAgfVxuICAgIG5vZGUudHlwZXMgPSB0eXBlcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGtpbmQpO1xuICB9XG4gIHRzUGFyc2VJbnRlcnNlY3Rpb25UeXBlT3JIaWdoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZVVuaW9uT3JJbnRlcnNlY3Rpb25UeXBlKFwiVFNJbnRlcnNlY3Rpb25UeXBlXCIsIHRoaXMudHNQYXJzZVR5cGVPcGVyYXRvck9ySGlnaGVyLmJpbmQodGhpcyksIDQ1KTtcbiAgfVxuICB0c1BhcnNlVW5pb25UeXBlT3JIaWdoZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZVVuaW9uT3JJbnRlcnNlY3Rpb25UeXBlKFwiVFNVbmlvblR5cGVcIiwgdGhpcy50c1BhcnNlSW50ZXJzZWN0aW9uVHlwZU9ySGlnaGVyLmJpbmQodGhpcyksIDQzKTtcbiAgfVxuICB0c0lzU3RhcnRPZkZ1bmN0aW9uVHlwZSgpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxMCkgJiYgdGhpcy50c0xvb2tBaGVhZCh0aGlzLnRzSXNVbmFtYmlndW91c2x5U3RhcnRPZkZ1bmN0aW9uVHlwZS5iaW5kKHRoaXMpKTtcbiAgfVxuICB0c1NraXBQYXJhbWV0ZXJTdGFydCgpIHtcbiAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSB8fCB0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXJyb3JzXG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IHByZXZpb3VzRXJyb3JDb3VudCA9IGVycm9ycy5sZW5ndGg7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnBhcnNlT2JqZWN0TGlrZSg4LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGVycm9ycy5sZW5ndGggPT09IHByZXZpb3VzRXJyb3JDb3VudDtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgwKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGVycm9yc1xuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBwcmV2aW91c0Vycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VwZXIucGFyc2VCaW5kaW5nTGlzdCgzLCA5MywgMSk7XG4gICAgICAgIHJldHVybiBlcnJvcnMubGVuZ3RoID09PSBwcmV2aW91c0Vycm9yQ291bnQ7XG4gICAgICB9IGNhdGNoIChfdW51c2VkMikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0c0lzVW5hbWJpZ3VvdXNseVN0YXJ0T2ZGdW5jdGlvblR5cGUoKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTEpIHx8IHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMudHNTa2lwUGFyYW1ldGVyU3RhcnQoKSkge1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTQpIHx8IHRoaXMubWF0Y2goMTIpIHx8IHRoaXMubWF0Y2goMTcpIHx8IHRoaXMubWF0Y2goMjkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCgxOSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKHJldHVyblRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLmV4cGVjdChyZXR1cm5Ub2tlbik7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IGFzc2VydHMgPSAhIXRoaXMudHNUcnlQYXJzZSh0aGlzLnRzUGFyc2VUeXBlUHJlZGljYXRlQXNzZXJ0cy5iaW5kKHRoaXMpKTtcbiAgICAgIGlmIChhc3NlcnRzICYmIHRoaXMubWF0Y2goNzgpKSB7XG4gICAgICAgIGxldCB0aGlzVHlwZVByZWRpY2F0ZSA9IHRoaXMudHNQYXJzZVRoaXNUeXBlT3JUaGlzVHlwZVByZWRpY2F0ZSgpO1xuICAgICAgICBpZiAodGhpc1R5cGVQcmVkaWNhdGUudHlwZSA9PT0gXCJUU1RoaXNUeXBlXCIpIHtcbiAgICAgICAgICBub2RlLnBhcmFtZXRlck5hbWUgPSB0aGlzVHlwZVByZWRpY2F0ZTtcbiAgICAgICAgICBub2RlLmFzc2VydHMgPSB0cnVlO1xuICAgICAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSBudWxsO1xuICAgICAgICAgIHRoaXNUeXBlUHJlZGljYXRlID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUodGhpc1R5cGVQcmVkaWNhdGUsIG5vZGUpO1xuICAgICAgICAgIHRoaXNUeXBlUHJlZGljYXRlLmFzc2VydHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHQudHlwZUFubm90YXRpb24gPSB0aGlzVHlwZVByZWRpY2F0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0LCBcIlRTVHlwZUFubm90YXRpb25cIik7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlUHJlZGljYXRlVmFyaWFibGUgPSB0aGlzLnRzSXNJZGVudGlmaWVyKCkgJiYgdGhpcy50c1RyeVBhcnNlKHRoaXMudHNQYXJzZVR5cGVQcmVkaWNhdGVQcmVmaXguYmluZCh0aGlzKSk7XG4gICAgICBpZiAoIXR5cGVQcmVkaWNhdGVWYXJpYWJsZSkge1xuICAgICAgICBpZiAoIWFzc2VydHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oZmFsc2UsIHQpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUucGFyYW1ldGVyTmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgICAgIG5vZGUuYXNzZXJ0cyA9IGFzc2VydHM7XG4gICAgICAgIG5vZGUudHlwZUFubm90YXRpb24gPSBudWxsO1xuICAgICAgICB0LnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbihmYWxzZSk7XG4gICAgICBub2RlLnBhcmFtZXRlck5hbWUgPSB0eXBlUHJlZGljYXRlVmFyaWFibGU7XG4gICAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdHlwZTtcbiAgICAgIG5vZGUuYXNzZXJ0cyA9IGFzc2VydHM7XG4gICAgICB0LnR5cGVBbm5vdGF0aW9uID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNUeXBlUHJlZGljYXRlXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZSh0LCBcIlRTVHlwZUFubm90YXRpb25cIik7XG4gICAgfSk7XG4gIH1cbiAgdHNUcnlQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKDE0KTtcbiAgICB9XG4gIH1cbiAgdHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDE0KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgfVxuICB9XG4gIHRzVHJ5UGFyc2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLnRzRWF0VGhlblBhcnNlVHlwZSgxNCk7XG4gIH1cbiAgdHNQYXJzZVR5cGVQcmVkaWNhdGVQcmVmaXgoKSB7XG4gICAgY29uc3QgaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMTYpICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiBpZDtcbiAgICB9XG4gIH1cbiAgdHNQYXJzZVR5cGVQcmVkaWNhdGVBc3NlcnRzKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgIT09IDEwOSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBjb250YWluc0VzYyA9IHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKCF0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpICYmICF0aGlzLm1hdGNoKDc4KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoY29udGFpbnNFc2MpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRFc2NhcGVkUmVzZXJ2ZWRXb3JkLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYywge1xuICAgICAgICByZXNlcnZlZFdvcmQ6IFwiYXNzZXJ0c1wiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdHNQYXJzZVR5cGVBbm5vdGF0aW9uKGVhdENvbG9uID0gdHJ1ZSwgdCA9IHRoaXMuc3RhcnROb2RlKCkpIHtcbiAgICB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIGlmIChlYXRDb2xvbikgdGhpcy5leHBlY3QoMTQpO1xuICAgICAgdC50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNQYXJzZVR5cGUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHQsIFwiVFNUeXBlQW5ub3RhdGlvblwiKTtcbiAgfVxuICB0c1BhcnNlVHlwZSgpIHtcbiAgICBhc3NlcnQodGhpcy5zdGF0ZS5pblR5cGUpO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLnRzUGFyc2VOb25Db25kaXRpb25hbFR5cGUoKTtcbiAgICBpZiAodGhpcy5zdGF0ZS5pbkRpc2FsbG93Q29uZGl0aW9uYWxUeXBlc0NvbnRleHQgfHwgdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSB8fCAhdGhpcy5lYXQoODEpKSB7XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXROb2RlKHR5cGUpO1xuICAgIG5vZGUuY2hlY2tUeXBlID0gdHlwZTtcbiAgICBub2RlLmV4dGVuZHNUeXBlID0gdGhpcy50c0luRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzUGFyc2VOb25Db25kaXRpb25hbFR5cGUoKSk7XG4gICAgdGhpcy5leHBlY3QoMTcpO1xuICAgIG5vZGUudHJ1ZVR5cGUgPSB0aGlzLnRzSW5BbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0KCgpID0+IHRoaXMudHNQYXJzZVR5cGUoKSk7XG4gICAgdGhpcy5leHBlY3QoMTQpO1xuICAgIG5vZGUuZmFsc2VUeXBlID0gdGhpcy50c0luQWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCgoKSA9PiB0aGlzLnRzUGFyc2VUeXBlKCkpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0NvbmRpdGlvbmFsVHlwZVwiKTtcbiAgfVxuICBpc0Fic3RyYWN0Q29uc3RydWN0b3JTaWduYXR1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDEyNCkgJiYgdGhpcy5pc0xvb2thaGVhZENvbnRleHR1YWwoXCJuZXdcIik7XG4gIH1cbiAgdHNQYXJzZU5vbkNvbmRpdGlvbmFsVHlwZSgpIHtcbiAgICBpZiAodGhpcy50c0lzU3RhcnRPZkZ1bmN0aW9uVHlwZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlRnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZShcIlRTRnVuY3Rpb25UeXBlXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCg3NykpIHtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VGdW5jdGlvbk9yQ29uc3RydWN0b3JUeXBlKFwiVFNDb25zdHJ1Y3RvclR5cGVcIik7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQWJzdHJhY3RDb25zdHJ1Y3RvclNpZ25hdHVyZSgpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlRnVuY3Rpb25PckNvbnN0cnVjdG9yVHlwZShcIlRTQ29uc3RydWN0b3JUeXBlXCIsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50c1BhcnNlVW5pb25UeXBlT3JIaWdoZXIoKTtcbiAgfVxuICB0c1BhcnNlVHlwZUFzc2VydGlvbigpIHtcbiAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJ0eXBlc2NyaXB0XCIsIFwiZGlzYWxsb3dBbWJpZ3VvdXNKU1hMaWtlXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlJlc2VydmVkVHlwZUFzc2VydGlvbiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudHlwZUFubm90YXRpb24gPSB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRoaXMubWF0Y2goNzUpID8gdGhpcy50c1BhcnNlVHlwZVJlZmVyZW5jZSgpIDogdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuZXhwZWN0KDQ4KTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlTWF5YmVVbmFyeSgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVBc3NlcnRpb25cIik7XG4gIH1cbiAgdHNQYXJzZUhlcml0YWdlQ2xhdXNlKHRva2VuKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgZGVsaW1pdGVkTGlzdCA9IHRoaXMudHNQYXJzZURlbGltaXRlZExpc3QoXCJIZXJpdGFnZUNsYXVzZUVsZW1lbnRcIiwgKCkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnRzUGFyc2VFbnRpdHlOYW1lKDEgfCAyKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTRXhwcmVzc2lvbldpdGhUeXBlQXJndW1lbnRzXCIpO1xuICAgIH0pO1xuICAgIGlmICghZGVsaW1pdGVkTGlzdC5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuRW1wdHlIZXJpdGFnZUNsYXVzZVR5cGUsIG9yaWdpbmFsU3RhcnRMb2MsIHtcbiAgICAgICAgdG9rZW5cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVsaW1pdGVkTGlzdDtcbiAgfVxuICB0c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSwgcHJvcGVydGllcyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHJldHVybiBudWxsO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCgxMjkpO1xuICAgIGlmIChwcm9wZXJ0aWVzLmRlY2xhcmUpIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgMTMwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5pZCA9IG51bGw7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLk1pc3NpbmdJbnRlcmZhY2VOYW1lLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUluT3V0Q29uc3RNb2RpZmllcnMpO1xuICAgIGlmICh0aGlzLmVhdCg4MSkpIHtcbiAgICAgIG5vZGUuZXh0ZW5kcyA9IHRoaXMudHNQYXJzZUhlcml0YWdlQ2xhdXNlKFwiZXh0ZW5kc1wiKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgYm9keS5ib2R5ID0gdGhpcy50c0luVHlwZSh0aGlzLnRzUGFyc2VPYmplY3RUeXBlTWVtYmVycy5iaW5kKHRoaXMpKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoYm9keSwgXCJUU0ludGVyZmFjZUJvZHlcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNQYXJzZVR5cGVBbGlhc0RlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBub2RlLmlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCAyKTtcbiAgICBub2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c0luVHlwZSgoKSA9PiB7XG4gICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlSW5PdXRNb2RpZmllcnMpO1xuICAgICAgdGhpcy5leHBlY3QoMjkpO1xuICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDExNCkgJiYgdGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpICE9PSA0Nikge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0ludHJpbnNpY0tleXdvcmRcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNJblRvcExldmVsQ29udGV4dChjYikge1xuICAgIGlmICh0aGlzLmN1ckNvbnRleHQoKSAhPT0gdHlwZXMuYnJhY2UpIHtcbiAgICAgIGNvbnN0IG9sZENvbnRleHQgPSB0aGlzLnN0YXRlLmNvbnRleHQ7XG4gICAgICB0aGlzLnN0YXRlLmNvbnRleHQgPSBbb2xkQ29udGV4dFswXV07XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuc3RhdGUuY29udGV4dCA9IG9sZENvbnRleHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH1cbiAgfVxuICB0c0luVHlwZShjYikge1xuICAgIGNvbnN0IG9sZEluVHlwZSA9IHRoaXMuc3RhdGUuaW5UeXBlO1xuICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5UeXBlID0gb2xkSW5UeXBlO1xuICAgIH1cbiAgfVxuICB0c0luRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dChjYikge1xuICAgIGNvbnN0IG9sZEluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0O1xuICAgIHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gb2xkSW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0O1xuICAgIH1cbiAgfVxuICB0c0luQWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dChjYikge1xuICAgIGNvbnN0IG9sZEluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0O1xuICAgIHRoaXMuc3RhdGUuaW5EaXNhbGxvd0NvbmRpdGlvbmFsVHlwZXNDb250ZXh0ID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnN0YXRlLmluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dCA9IG9sZEluRGlzYWxsb3dDb25kaXRpb25hbFR5cGVzQ29udGV4dDtcbiAgICB9XG4gIH1cbiAgdHNFYXRUaGVuUGFyc2VUeXBlKHRva2VuKSB7XG4gICAgaWYgKHRoaXMubWF0Y2godG9rZW4pKSB7XG4gICAgICByZXR1cm4gdGhpcy50c05leHRUaGVuUGFyc2VUeXBlKCk7XG4gICAgfVxuICB9XG4gIHRzRXhwZWN0VGhlblBhcnNlVHlwZSh0b2tlbikge1xuICAgIHJldHVybiB0aGlzLnRzSW5UeXBlKCgpID0+IHtcbiAgICAgIHRoaXMuZXhwZWN0KHRva2VuKTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSk7XG4gIH1cbiAgdHNOZXh0VGhlblBhcnNlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50c0luVHlwZSgoKSA9PiB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgfSk7XG4gIH1cbiAgdHNQYXJzZUVudW1NZW1iZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5pZCA9IHRoaXMubWF0Y2goMTM0KSA/IHN1cGVyLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKSA6IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgIGlmICh0aGlzLmVhdCgyOSkpIHtcbiAgICAgIG5vZGUuaW5pdGlhbGl6ZXIgPSBzdXBlci5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNFbnVtTWVtYmVyXCIpO1xuICB9XG4gIHRzUGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSwgcHJvcGVydGllcyA9IHt9KSB7XG4gICAgaWYgKHByb3BlcnRpZXMuY29uc3QpIG5vZGUuY29uc3QgPSB0cnVlO1xuICAgIGlmIChwcm9wZXJ0aWVzLmRlY2xhcmUpIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKDEyNik7XG4gICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgbm9kZS5jb25zdCA/IDg5NzEgOiA4NDU5KTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICBub2RlLm1lbWJlcnMgPSB0aGlzLnRzUGFyc2VEZWxpbWl0ZWRMaXN0KFwiRW51bU1lbWJlcnNcIiwgdGhpcy50c1BhcnNlRW51bU1lbWJlci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLmV4cGVjdCg4KTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNFbnVtRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNQYXJzZUVudW1Cb2R5KCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIG5vZGUubWVtYmVycyA9IHRoaXMudHNQYXJzZURlbGltaXRlZExpc3QoXCJFbnVtTWVtYmVyc1wiLCB0aGlzLnRzUGFyc2VFbnVtTWVtYmVyLmJpbmQodGhpcykpO1xuICAgIHRoaXMuZXhwZWN0KDgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0VudW1Cb2R5XCIpO1xuICB9XG4gIHRzUGFyc2VNb2R1bGVCbG9jaygpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDApO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIHN1cGVyLnBhcnNlQmxvY2tPck1vZHVsZUJsb2NrQm9keShub2RlLmJvZHkgPSBbXSwgdW5kZWZpbmVkLCB0cnVlLCA4KTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNNb2R1bGVCbG9ja1wiKTtcbiAgfVxuICB0c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbihub2RlLCBuZXN0ZWQgPSBmYWxzZSkge1xuICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgIGlmICghbmVzdGVkKSB7XG4gICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlLmlkLCAxMDI0KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZWF0KDE2KSkge1xuICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy50c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbihpbm5lciwgdHJ1ZSk7XG4gICAgICBub2RlLmJvZHkgPSBpbm5lcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY29wZS5lbnRlcigxMDI0KTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKDApO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy50c1BhcnNlTW9kdWxlQmxvY2soKTtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVFNNb2R1bGVEZWNsYXJhdGlvblwiKTtcbiAgfVxuICB0c1BhcnNlQW1iaWVudEV4dGVybmFsTW9kdWxlRGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMTIpKSB7XG4gICAgICBub2RlLmtpbmQgPSBcImdsb2JhbFwiO1xuICAgICAgbm9kZS5nbG9iYWwgPSB0cnVlO1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIG5vZGUua2luZCA9IFwibW9kdWxlXCI7XG4gICAgICBub2RlLmlkID0gc3VwZXIucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNSkpIHtcbiAgICAgIHRoaXMuc2NvcGUuZW50ZXIoMTAyNCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcigwKTtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMudHNQYXJzZU1vZHVsZUJsb2NrKCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNQYXJzZUltcG9ydEVxdWFsc0RlY2xhcmF0aW9uKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIsIGlzRXhwb3J0KSB7XG4gICAgbm9kZS5pc0V4cG9ydCA9IGlzRXhwb3J0IHx8IGZhbHNlO1xuICAgIG5vZGUuaWQgPSBtYXliZURlZmF1bHRJZGVudGlmaWVyIHx8IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgdGhpcy5jaGVja0lkZW50aWZpZXIobm9kZS5pZCwgNDA5Nik7XG4gICAgdGhpcy5leHBlY3QoMjkpO1xuICAgIGNvbnN0IG1vZHVsZVJlZmVyZW5jZSA9IHRoaXMudHNQYXJzZU1vZHVsZVJlZmVyZW5jZSgpO1xuICAgIGlmIChub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZVwiICYmIG1vZHVsZVJlZmVyZW5jZS50eXBlICE9PSBcIlRTRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2VcIikge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbXBvcnRBbGlhc0hhc0ltcG9ydFR5cGUsIG1vZHVsZVJlZmVyZW5jZSk7XG4gICAgfVxuICAgIG5vZGUubW9kdWxlUmVmZXJlbmNlID0gbW9kdWxlUmVmZXJlbmNlO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIik7XG4gIH1cbiAgdHNJc0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlKCkge1xuICAgIHJldHVybiB0aGlzLmlzQ29udGV4dHVhbCgxMTkpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNDA7XG4gIH1cbiAgdHNQYXJzZU1vZHVsZVJlZmVyZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy50c0lzRXh0ZXJuYWxNb2R1bGVSZWZlcmVuY2UoKSA/IHRoaXMudHNQYXJzZUV4dGVybmFsTW9kdWxlUmVmZXJlbmNlKCkgOiB0aGlzLnRzUGFyc2VFbnRpdHlOYW1lKDApO1xuICB9XG4gIHRzUGFyc2VFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTE5KTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICBub2RlLmV4cHJlc3Npb24gPSBzdXBlci5wYXJzZUV4cHJBdG9tKCk7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU0V4dGVybmFsTW9kdWxlUmVmZXJlbmNlXCIpO1xuICB9XG4gIHRzTG9va0FoZWFkKGYpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuY2xvbmUoKTtcbiAgICBjb25zdCByZXMgPSBmKCk7XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgdHNUcnlQYXJzZUFuZENhdGNoKGYpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IGYoKSB8fCBhYm9ydCgpKTtcbiAgICBpZiAocmVzdWx0LmFib3J0ZWQgfHwgIXJlc3VsdC5ub2RlKSByZXR1cm47XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgdGhpcy5zdGF0ZSA9IHJlc3VsdC5mYWlsU3RhdGU7XG4gICAgcmV0dXJuIHJlc3VsdC5ub2RlO1xuICB9XG4gIHRzVHJ5UGFyc2UoZikge1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZS5jbG9uZSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGYoKTtcbiAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgcmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICB9XG4gIHRzVHJ5UGFyc2VEZWNsYXJlKG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRUeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIHJldHVybiB0aGlzLnRzSW5BbWJpZW50Q29udGV4dCgoKSA9PiB7XG4gICAgICBzd2l0Y2ggKHN0YXJ0VHlwZSkge1xuICAgICAgICBjYXNlIDY4OlxuICAgICAgICAgIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgY2FzZSA4MDpcbiAgICAgICAgICBub2RlLmRlY2xhcmUgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3Mobm9kZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICBjYXNlIDEyNjpcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUsIHtcbiAgICAgICAgICAgIGRlY2xhcmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgY2FzZSAxMTI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUFtYmllbnRFeHRlcm5hbE1vZHVsZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICBjYXNlIDEwMDpcbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb250YWluc0VzYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSA3NTpcbiAgICAgICAgY2FzZSA3NDpcbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goNzUpIHx8ICF0aGlzLmlzTG9va2FoZWFkQ29udGV4dHVhbChcImVudW1cIikpIHtcbiAgICAgICAgICAgIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCB0aGlzLnN0YXRlLnZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5leHBlY3QoNzUpO1xuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24obm9kZSwge1xuICAgICAgICAgICAgY29uc3Q6IHRydWUsXG4gICAgICAgICAgICBkZWNsYXJlOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgIGlmICh0aGlzLmlzVXNpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPblVzaW5nRGVjbGFyYXRpb24sIHRoaXMuc3RhdGUuc3RhcnRMb2MsIFwiZGVjbGFyZVwiKTtcbiAgICAgICAgICAgIG5vZGUuZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBcInVzaW5nXCIsIHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5NjpcbiAgICAgICAgICBpZiAodGhpcy5pc0F3YWl0VXNpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbnZhbGlkTW9kaWZpZXJPbkF3YWl0VXNpbmdEZWNsYXJhdGlvbiwgdGhpcy5zdGF0ZS5zdGFydExvYywgXCJkZWNsYXJlXCIpO1xuICAgICAgICAgICAgbm9kZS5kZWNsYXJlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwgXCJhd2FpdCB1c2luZ1wiLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI5OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHNQYXJzZUludGVyZmFjZURlY2xhcmF0aW9uKG5vZGUsIHtcbiAgICAgICAgICAgICAgZGVjbGFyZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIoc3RhcnRUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKG5vZGUsIHRoaXMuc3RhdGUudHlwZSwgdHJ1ZSwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRzVHJ5UGFyc2VFeHBvcnREZWNsYXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50c1BhcnNlRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSwgdGhpcy5zdGF0ZS50eXBlLCB0cnVlLCBudWxsKTtcbiAgfVxuICB0c1BhcnNlRGVjbGFyYXRpb24obm9kZSwgdHlwZSwgbmV4dCwgZGVjb3JhdG9ycykge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAxMjQ6XG4gICAgICAgIGlmICh0aGlzLnRzQ2hlY2tMaW5lVGVybWluYXRvcihuZXh0KSAmJiAodGhpcy5tYXRjaCg4MCkgfHwgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlQWJzdHJhY3REZWNsYXJhdGlvbihub2RlLCBkZWNvcmF0b3JzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI3OlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3IobmV4dCkpIHtcbiAgICAgICAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlQW1iaWVudEV4dGVybmFsTW9kdWxlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgICBub2RlLmtpbmQgPSBcIm1vZHVsZVwiO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZU1vZHVsZU9yTmFtZXNwYWNlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjg6XG4gICAgICAgIGlmICh0aGlzLnRzQ2hlY2tMaW5lVGVybWluYXRvcihuZXh0KSAmJiB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgICAgbm9kZS5raW5kID0gXCJuYW1lc3BhY2VcIjtcbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlTW9kdWxlT3JOYW1lc3BhY2VEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTMwOlxuICAgICAgICBpZiAodGhpcy50c0NoZWNrTGluZVRlcm1pbmF0b3IobmV4dCkgJiYgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlQWxpYXNEZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdHNDaGVja0xpbmVUZXJtaW5hdG9yKG5leHQpIHtcbiAgICBpZiAobmV4dCkge1xuICAgICAgaWYgKHRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHJldHVybiBmYWxzZTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCk7XG4gIH1cbiAgdHNUcnlQYXJzZUdlbmVyaWNBc3luY0Fycm93RnVuY3Rpb24oc3RhcnRMb2MpIHtcbiAgICBpZiAoIXRoaXMubWF0Y2goNDcpKSByZXR1cm47XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0cnVlO1xuICAgIGNvbnN0IHJlcyA9IHRoaXMudHNUcnlQYXJzZUFuZENhdGNoKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VDb25zdE1vZGlmaWVyKTtcbiAgICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSk7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlT3JUeXBlUHJlZGljYXRlQW5ub3RhdGlvbigpO1xuICAgICAgdGhpcy5leHBlY3QoMTkpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBpZiAoIXJlcykgcmV0dXJuO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUFycm93RXhwcmVzc2lvbihyZXMsIG51bGwsIHRydWUpO1xuICB9XG4gIHRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCkge1xuICAgIGlmICh0aGlzLnJlU2Nhbl9sdCgpICE9PSA0NykgcmV0dXJuO1xuICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzKCk7XG4gIH1cbiAgdHNQYXJzZVR5cGVBcmd1bWVudHMoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnRzSW5UeXBlKCgpID0+IHRoaXMudHNJblRvcExldmVsQ29udGV4dCgoKSA9PiB7XG4gICAgICB0aGlzLmV4cGVjdCg0Nyk7XG4gICAgICByZXR1cm4gdGhpcy50c1BhcnNlRGVsaW1pdGVkTGlzdChcIlR5cGVQYXJhbWV0ZXJzT3JBcmd1bWVudHNcIiwgdGhpcy50c1BhcnNlVHlwZS5iaW5kKHRoaXMpKTtcbiAgICB9KSk7XG4gICAgaWYgKG5vZGUucGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5FbXB0eVR5cGVBcmd1bWVudHMsIG5vZGUpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuc3RhdGUuaW5UeXBlICYmIHRoaXMuY3VyQ29udGV4dCgpID09PSB0eXBlcy5icmFjZSkge1xuICAgICAgdGhpcy5yZVNjYW5fbHRfZ3QoKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoNDgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUU1R5cGVQYXJhbWV0ZXJJbnN0YW50aWF0aW9uXCIpO1xuICB9XG4gIHRzSXNEZWNsYXJhdGlvblN0YXJ0KCkge1xuICAgIHJldHVybiB0b2tlbklzVFNEZWNsYXJhdGlvblN0YXJ0KHRoaXMuc3RhdGUudHlwZSk7XG4gIH1cbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgIGlmICh0aGlzLnRzSXNEZWNsYXJhdGlvblN0YXJ0KCkpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gc3VwZXIuaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCk7XG4gIH1cbiAgcGFyc2VCaW5kaW5nRWxlbWVudChmbGFncywgZGVjb3JhdG9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gZGVjb3JhdG9ycy5sZW5ndGggPyBkZWNvcmF0b3JzWzBdLmxvYy5zdGFydCA6IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgbW9kaWZpZWQgPSB7fTtcbiAgICB0aGlzLnRzUGFyc2VNb2RpZmllcnMoe1xuICAgICAgYWxsb3dlZE1vZGlmaWVyczogW1wicHVibGljXCIsIFwicHJpdmF0ZVwiLCBcInByb3RlY3RlZFwiLCBcIm92ZXJyaWRlXCIsIFwicmVhZG9ubHlcIl1cbiAgICB9LCBtb2RpZmllZCk7XG4gICAgY29uc3QgYWNjZXNzaWJpbGl0eSA9IG1vZGlmaWVkLmFjY2Vzc2liaWxpdHk7XG4gICAgY29uc3Qgb3ZlcnJpZGUgPSBtb2RpZmllZC5vdmVycmlkZTtcbiAgICBjb25zdCByZWFkb25seSA9IG1vZGlmaWVkLnJlYWRvbmx5O1xuICAgIGlmICghKGZsYWdzICYgNCkgJiYgKGFjY2Vzc2liaWxpdHkgfHwgcmVhZG9ubHkgfHwgb3ZlcnJpZGUpKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlVuZXhwZWN0ZWRQYXJhbWV0ZXJNb2RpZmllciwgc3RhcnRMb2MpO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCgpO1xuICAgIGlmIChmbGFncyAmIDIpIHtcbiAgICAgIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtVHlwZShsZWZ0KTtcbiAgICB9XG4gICAgY29uc3QgZWx0ID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChsZWZ0LmxvYy5zdGFydCwgbGVmdCk7XG4gICAgaWYgKGFjY2Vzc2liaWxpdHkgfHwgcmVhZG9ubHkgfHwgb3ZlcnJpZGUpIHtcbiAgICAgIGNvbnN0IHBwID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgcHAuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICB9XG4gICAgICBpZiAoYWNjZXNzaWJpbGl0eSkgcHAuYWNjZXNzaWJpbGl0eSA9IGFjY2Vzc2liaWxpdHk7XG4gICAgICBpZiAocmVhZG9ubHkpIHBwLnJlYWRvbmx5ID0gcmVhZG9ubHk7XG4gICAgICBpZiAob3ZlcnJpZGUpIHBwLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgICBpZiAoZWx0LnR5cGUgIT09IFwiSWRlbnRpZmllclwiICYmIGVsdC50eXBlICE9PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5VbnN1cHBvcnRlZFBhcmFtZXRlclByb3BlcnR5S2luZCwgcHApO1xuICAgICAgfVxuICAgICAgcHAucGFyYW1ldGVyID0gZWx0O1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwcCwgXCJUU1BhcmFtZXRlclByb3BlcnR5XCIpO1xuICAgIH1cbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIGxlZnQuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgfVxuICAgIHJldHVybiBlbHQ7XG4gIH1cbiAgaXNTaW1wbGVQYXJhbWV0ZXIobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiICYmIHN1cGVyLmlzU2ltcGxlUGFyYW1ldGVyKG5vZGUucGFyYW1ldGVyKSB8fCBzdXBlci5pc1NpbXBsZVBhcmFtZXRlcihub2RlKTtcbiAgfVxuICB0c0Rpc2FsbG93T3B0aW9uYWxQYXR0ZXJuKG5vZGUpIHtcbiAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIG5vZGUucGFyYW1zKSB7XG4gICAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgcGFyYW0ub3B0aW9uYWwgJiYgIXRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlBhdHRlcm5Jc09wdGlvbmFsLCBwYXJhbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYykge1xuICAgIHN1cGVyLnNldEFycm93RnVuY3Rpb25QYXJhbWV0ZXJzKG5vZGUsIHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYyk7XG4gICAgdGhpcy50c0Rpc2FsbG93T3B0aW9uYWxQYXR0ZXJuKG5vZGUpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKDE0KTtcbiAgICB9XG4gICAgY29uc3QgYm9kaWxlc3NUeXBlID0gdHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgPyBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIgOiB0eXBlID09PSBcIkNsYXNzTWV0aG9kXCIgfHwgdHlwZSA9PT0gXCJDbGFzc1ByaXZhdGVNZXRob2RcIiA/IFwiVFNEZWNsYXJlTWV0aG9kXCIgOiB1bmRlZmluZWQ7XG4gICAgaWYgKGJvZGlsZXNzVHlwZSAmJiAhdGhpcy5tYXRjaCg1KSAmJiB0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBib2RpbGVzc1R5cGUpO1xuICAgIH1cbiAgICBpZiAoYm9kaWxlc3NUeXBlID09PSBcIlRTRGVjbGFyZUZ1bmN0aW9uXCIgJiYgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0KSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkRlY2xhcmVGdW5jdGlvbkhhc0ltcGxlbWVudGF0aW9uLCBub2RlKTtcbiAgICAgIGlmIChub2RlLmRlY2xhcmUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIGJvZGlsZXNzVHlwZSwgaXNNZXRob2QpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRzRGlzYWxsb3dPcHRpb25hbFBhdHRlcm4obm9kZSk7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kKTtcbiAgfVxuICByZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSkge1xuICAgIGlmICghbm9kZS5ib2R5ICYmIG5vZGUuaWQpIHtcbiAgICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGUuaWQsIDEwMjQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5yZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSk7XG4gICAgfVxuICB9XG4gIHRzQ2hlY2tGb3JJbnZhbGlkVHlwZUNhc3RzKGl0ZW1zKSB7XG4gICAgaXRlbXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGlmICgobm9kZSA9PSBudWxsID8gdm9pZCAwIDogbm9kZS50eXBlKSA9PT0gXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVW5leHBlY3RlZFR5cGVBbm5vdGF0aW9uLCBub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0b1JlZmVyZW5jZWRMaXN0KGV4cHJMaXN0LCBpc0luUGFyZW5zKSB7XG4gICAgdGhpcy50c0NoZWNrRm9ySW52YWxpZFR5cGVDYXN0cyhleHByTGlzdCk7XG4gICAgcmV0dXJuIGV4cHJMaXN0O1xuICB9XG4gIHBhcnNlQXJyYXlMaWtlKGNsb3NlLCBpc1R1cGxlLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlQXJyYXlMaWtlKGNsb3NlLCBpc1R1cGxlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkFycmF5RXhwcmVzc2lvblwiKSB7XG4gICAgICB0aGlzLnRzQ2hlY2tGb3JJbnZhbGlkVHlwZUNhc3RzKG5vZGUuZWxlbWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydExvYywgbm9DYWxscywgc3RhdGUpIHtcbiAgICBpZiAoIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgdGhpcy5tYXRjaCgzNSkpIHtcbiAgICAgIHRoaXMuc3RhdGUuY2FuU3RhcnRKU1hFbGVtZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNvbnN0IG5vbk51bGxFeHByZXNzaW9uID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICBub25OdWxsRXhwcmVzc2lvbi5leHByZXNzaW9uID0gYmFzZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9uTnVsbEV4cHJlc3Npb24sIFwiVFNOb25OdWxsRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgbGV0IGlzT3B0aW9uYWxDYWxsID0gZmFsc2U7XG4gICAgaWYgKHRoaXMubWF0Y2goMTgpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNjApIHtcbiAgICAgIGlmIChub0NhbGxzKSB7XG4gICAgICAgIHN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIgPSBpc09wdGlvbmFsQ2FsbCA9IHRydWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goNDcpIHx8IHRoaXMubWF0Y2goNTEpKSB7XG4gICAgICBsZXQgbWlzc2luZ1BhcmVuRXJyb3JMb2M7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzVHJ5UGFyc2VBbmRDYXRjaCgoKSA9PiB7XG4gICAgICAgIGlmICghbm9DYWxscyAmJiB0aGlzLmF0UG9zc2libGVBc3luY0Fycm93KGJhc2UpKSB7XG4gICAgICAgICAgY29uc3QgYXN5bmNBcnJvd0ZuID0gdGhpcy50c1RyeVBhcnNlR2VuZXJpY0FzeW5jQXJyb3dGdW5jdGlvbihzdGFydExvYyk7XG4gICAgICAgICAgaWYgKGFzeW5jQXJyb3dGbikge1xuICAgICAgICAgICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYXN5bmNBcnJvd0ZuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlQXJndW1lbnRzID0gdGhpcy50c1BhcnNlVHlwZUFyZ3VtZW50c0luRXhwcmVzc2lvbigpO1xuICAgICAgICBpZiAoIXR5cGVBcmd1bWVudHMpIHJldHVybjtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWxDYWxsICYmICF0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICAgIG1pc3NpbmdQYXJlbkVycm9yTG9jID0gdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5Jc1RlbXBsYXRlKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5wYXJzZVRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihiYXNlLCBzdGFydExvYywgc3RhdGUpO1xuICAgICAgICAgIHJlc3VsdC50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5vQ2FsbHMgJiYgdGhpcy5lYXQoMTApKSB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICAgIG5vZGUuY2FsbGVlID0gYmFzZTtcbiAgICAgICAgICBub2RlLmFyZ3VtZW50cyA9IHRoaXMucGFyc2VDYWxsRXhwcmVzc2lvbkFyZ3VtZW50cygpO1xuICAgICAgICAgIHRoaXMudHNDaGVja0ZvckludmFsaWRUeXBlQ2FzdHMobm9kZS5hcmd1bWVudHMpO1xuICAgICAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuICAgICAgICAgIGlmIChzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICAgICAgICBub2RlLm9wdGlvbmFsID0gaXNPcHRpb25hbENhbGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaENhbGxFeHByZXNzaW9uKG5vZGUsIHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRva2VuVHlwZSA9IHRoaXMuc3RhdGUudHlwZTtcbiAgICAgICAgaWYgKHRva2VuVHlwZSA9PT0gNDggfHwgdG9rZW5UeXBlID09PSA1MiB8fCB0b2tlblR5cGUgIT09IDEwICYmIHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHRva2VuVHlwZSkgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgICBub2RlLmV4cHJlc3Npb24gPSBiYXNlO1xuICAgICAgICBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdHlwZUFyZ3VtZW50cztcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIik7XG4gICAgICB9KTtcbiAgICAgIGlmIChtaXNzaW5nUGFyZW5FcnJvckxvYykge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQobWlzc2luZ1BhcmVuRXJyb3JMb2MsIDEwKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIikge1xuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDE2KSB8fCB0aGlzLm1hdGNoKDE4KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgIT09IDQwKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkludmFsaWRQcm9wZXJ0eUFjY2Vzc0FmdGVySW5zdGFudGlhdGlvbkV4cHJlc3Npb24sIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goMTYpICYmICF0aGlzLm1hdGNoKDE4KSkge1xuICAgICAgICAgICAgcmVzdWx0LmV4cHJlc3Npb24gPSBzdXBlci5zdG9wUGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgfVxuICBwYXJzZU5ld0NhbGxlZShub2RlKSB7XG4gICAgdmFyIF9jYWxsZWUkZXh0cmE7XG4gICAgc3VwZXIucGFyc2VOZXdDYWxsZWUobm9kZSk7XG4gICAgY29uc3Qge1xuICAgICAgY2FsbGVlXG4gICAgfSA9IG5vZGU7XG4gICAgaWYgKGNhbGxlZS50eXBlID09PSBcIlRTSW5zdGFudGlhdGlvbkV4cHJlc3Npb25cIiAmJiAhKChfY2FsbGVlJGV4dHJhID0gY2FsbGVlLmV4dHJhKSAhPSBudWxsICYmIF9jYWxsZWUkZXh0cmEucGFyZW50aGVzaXplZCkpIHtcbiAgICAgIG5vZGUudHlwZVBhcmFtZXRlcnMgPSBjYWxsZWUudHlwZVBhcmFtZXRlcnM7XG4gICAgICBub2RlLmNhbGxlZSA9IGNhbGxlZS5leHByZXNzaW9uO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJPcChsZWZ0LCBsZWZ0U3RhcnRMb2MsIG1pblByZWMpIHtcbiAgICBsZXQgaXNTYXRpc2ZpZXM7XG4gICAgaWYgKHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKDU4KSA+IG1pblByZWMgJiYgIXRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkgJiYgKHRoaXMuaXNDb250ZXh0dWFsKDkzKSB8fCAoaXNTYXRpc2ZpZXMgPSB0aGlzLmlzQ29udGV4dHVhbCgxMjApKSkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KGxlZnRTdGFydExvYyk7XG4gICAgICBub2RlLmV4cHJlc3Npb24gPSBsZWZ0O1xuICAgICAgbm9kZS50eXBlQW5ub3RhdGlvbiA9IHRoaXMudHNJblR5cGUoKCkgPT4ge1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goNzUpKSB7XG4gICAgICAgICAgaWYgKGlzU2F0aXNmaWVzKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkS2V5d29yZCwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICAgICAgICBrZXl3b3JkOiBcImNvbnN0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZVJlZmVyZW5jZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VUeXBlKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1NhdGlzZmllcyA/IFwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCIgOiBcIlRTQXNFeHByZXNzaW9uXCIpO1xuICAgICAgdGhpcy5yZVNjYW5fbHRfZ3QoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydExvYywgbWluUHJlYyk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cHJPcChsZWZ0LCBsZWZ0U3RhcnRMb2MsIG1pblByZWMpO1xuICB9XG4gIGNoZWNrUmVzZXJ2ZWRXb3JkKHdvcmQsIHN0YXJ0TG9jLCBjaGVja0tleXdvcmRzLCBpc0JpbmRpbmcpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCkge1xuICAgICAgc3VwZXIuY2hlY2tSZXNlcnZlZFdvcmQod29yZCwgc3RhcnRMb2MsIGNoZWNrS2V5d29yZHMsIGlzQmluZGluZyk7XG4gICAgfVxuICB9XG4gIGNoZWNrSW1wb3J0UmVmbGVjdGlvbihub2RlKSB7XG4gICAgc3VwZXIuY2hlY2tJbXBvcnRSZWZsZWN0aW9uKG5vZGUpO1xuICAgIGlmIChub2RlLm1vZHVsZSAmJiBub2RlLmltcG9ydEtpbmQgIT09IFwidmFsdWVcIikge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbXBvcnRSZWZsZWN0aW9uSGFzSW1wb3J0VHlwZSwgbm9kZS5zcGVjaWZpZXJzWzBdLmxvYy5zdGFydCk7XG4gICAgfVxuICB9XG4gIGNoZWNrRHVwbGljYXRlRXhwb3J0cygpIHt9XG4gIGlzUG90ZW50aWFsSW1wb3J0UGhhc2UoaXNFeHBvcnQpIHtcbiAgICBpZiAoc3VwZXIuaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShpc0V4cG9ydCkpIHJldHVybiB0cnVlO1xuICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApKSB7XG4gICAgICBjb25zdCBjaCA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgIHJldHVybiBpc0V4cG9ydCA/IGNoID09PSAxMjMgfHwgY2ggPT09IDQyIDogY2ggIT09IDYxO1xuICAgIH1cbiAgICByZXR1cm4gIWlzRXhwb3J0ICYmIHRoaXMuaXNDb250ZXh0dWFsKDg3KTtcbiAgfVxuICBhcHBseUltcG9ydFBoYXNlKG5vZGUsIGlzRXhwb3J0LCBwaGFzZSwgbG9jKSB7XG4gICAgc3VwZXIuYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgcGhhc2UsIGxvYyk7XG4gICAgaWYgKGlzRXhwb3J0KSB7XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBwaGFzZSA9PT0gXCJ0eXBlXCIgPyBcInR5cGVcIiA6IFwidmFsdWVcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5pbXBvcnRLaW5kID0gcGhhc2UgPT09IFwidHlwZVwiIHx8IHBoYXNlID09PSBcInR5cGVvZlwiID8gcGhhc2UgOiBcInZhbHVlXCI7XG4gICAgfVxuICB9XG4gIHBhcnNlSW1wb3J0KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICBub2RlLmltcG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VJbXBvcnQobm9kZSk7XG4gICAgfVxuICAgIGxldCBpbXBvcnROb2RlO1xuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNjEpIHtcbiAgICAgIG5vZGUuaW1wb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VJbXBvcnRFcXVhbHNEZWNsYXJhdGlvbihub2RlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEzMCkpIHtcbiAgICAgIGNvbnN0IG1heWJlRGVmYXVsdElkZW50aWZpZXIgPSB0aGlzLnBhcnNlTWF5YmVJbXBvcnRQaGFzZShub2RlLCBmYWxzZSk7XG4gICAgICBpZiAodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA2MSkge1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbXBvcnROb2RlID0gc3VwZXIucGFyc2VJbXBvcnRTcGVjaWZpZXJzQW5kQWZ0ZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGltcG9ydE5vZGUgPSBzdXBlci5wYXJzZUltcG9ydChub2RlKTtcbiAgICB9XG4gICAgaWYgKGltcG9ydE5vZGUuaW1wb3J0S2luZCA9PT0gXCJ0eXBlXCIgJiYgaW1wb3J0Tm9kZS5zcGVjaWZpZXJzLmxlbmd0aCA+IDEgJiYgaW1wb3J0Tm9kZS5zcGVjaWZpZXJzWzBdLnR5cGUgPT09IFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLlR5cGVJbXBvcnRDYW5ub3RTcGVjaWZ5RGVmYXVsdEFuZE5hbWVkLCBpbXBvcnROb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydE5vZGU7XG4gIH1cbiAgcGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycykge1xuICAgIGlmICh0aGlzLm1hdGNoKDgzKSkge1xuICAgICAgY29uc3Qgbm9kZUltcG9ydEVxdWFscyA9IG5vZGU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGxldCBtYXliZURlZmF1bHRJZGVudGlmaWVyID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMzApICYmIHRoaXMuaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShmYWxzZSkpIHtcbiAgICAgICAgbWF5YmVEZWZhdWx0SWRlbnRpZmllciA9IHRoaXMucGFyc2VNYXliZUltcG9ydFBoYXNlKG5vZGVJbXBvcnRFcXVhbHMsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVJbXBvcnRFcXVhbHMuaW1wb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdGhpcy50c1BhcnNlSW1wb3J0RXF1YWxzRGVjbGFyYXRpb24obm9kZUltcG9ydEVxdWFscywgbWF5YmVEZWZhdWx0SWRlbnRpZmllciwgdHJ1ZSk7XG4gICAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gICAgfSBlbHNlIGlmICh0aGlzLmVhdCgyOSkpIHtcbiAgICAgIGNvbnN0IGFzc2lnbiA9IG5vZGU7XG4gICAgICBhc3NpZ24uZXhwcmVzc2lvbiA9IHN1cGVyLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShhc3NpZ24sIFwiVFNFeHBvcnRBc3NpZ25tZW50XCIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgY29uc3QgZGVjbCA9IG5vZGU7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoMTI4KTtcbiAgICAgIGRlY2wuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZGVjbCwgXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycyk7XG4gICAgfVxuICB9XG4gIGlzQWJzdHJhY3RDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTI0KSAmJiB0aGlzLmlzTG9va2FoZWFkQ29udGV4dHVhbChcImNsYXNzXCIpO1xuICB9XG4gIHBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKSB7XG4gICAgaWYgKHRoaXMuaXNBYnN0cmFjdENsYXNzKCkpIHtcbiAgICAgIGNvbnN0IGNscyA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGNscy5hYnN0cmFjdCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKGNscywgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDEyOSkpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudHNQYXJzZUludGVyZmFjZURlY2xhcmF0aW9uKHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgaWYgKHJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKTtcbiAgfVxuICBwYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplciA9IGZhbHNlKSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNBbWJpZW50Q29udGV4dFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gc3VwZXIucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwga2luZCwgYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIgfHwgaXNBbWJpZW50Q29udGV4dCk7XG4gICAgaWYgKCFpc0FtYmllbnRDb250ZXh0KSByZXR1cm4gZGVjbGFyYXRpb247XG4gICAgaWYgKCFub2RlLmRlY2xhcmUgJiYgKGtpbmQgPT09IFwidXNpbmdcIiB8fCBraW5kID09PSBcImF3YWl0IHVzaW5nXCIpKSB7XG4gICAgICB0aGlzLnJhaXNlT3ZlcndyaXRlKFRTRXJyb3JzLlVzaW5nRGVjbGFyYXRpb25JbkFtYmllbnRDb250ZXh0LCBub2RlLCBraW5kKTtcbiAgICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgICB9XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBpZCxcbiAgICAgIGluaXRcbiAgICB9IG9mIGRlY2xhcmF0aW9uLmRlY2xhcmF0aW9ucykge1xuICAgICAgaWYgKCFpbml0KSBjb250aW51ZTtcbiAgICAgIGlmIChraW5kID09PSBcInZhclwiIHx8IGtpbmQgPT09IFwibGV0XCIgfHwgISFpZC50eXBlQW5ub3RhdGlvbikge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkluaXRpYWxpemVyTm90QWxsb3dlZEluQW1iaWVudENvbnRleHQsIGluaXQpO1xuICAgICAgfSBlbHNlIGlmICghaXNWYWxpZEFtYmllbnRDb25zdEluaXRpYWxpemVyKGluaXQsIHRoaXMuaGFzUGx1Z2luKFwiZXN0cmVlXCIpKSkge1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkNvbnN0SW5pdGlhbGl6ZXJNdXN0QmVTdHJpbmdPck51bWVyaWNMaXRlcmFsT3JMaXRlcmFsRW51bVJlZmVyZW5jZSwgaW5pdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgfVxuICBwYXJzZVN0YXRlbWVudENvbnRlbnQoZmxhZ3MsIGRlY29yYXRvcnMpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuY29udGFpbnNFc2MpIHtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgNzU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb29rYWhlYWRDb250ZXh0dWFsKFwiZW51bVwiKSkge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5leHBlY3QoNzUpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlRW51bURlY2xhcmF0aW9uKG5vZGUsIHtcbiAgICAgICAgICAgICAgICBjb25zdDogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAxMjQ6XG4gICAgICAgIGNhc2UgMTI1OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRUb2tlbklzSWRlbnRpZmllckFuZE5vdFRTUmVsYXRpb25hbE9wZXJhdG9yT25TYW1lTGluZSgpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gdG9rZW4gPT09IDEyNSA/IHRoaXMudHNUcnlQYXJzZURlY2xhcmUobm9kZSkgOiB0aGlzLnRzUGFyc2VBYnN0cmFjdERlY2xhcmF0aW9uKG5vZGUsIGRlY29yYXRvcnMpO1xuICAgICAgICAgICAgICBpZiAoZGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IDEyNSkge1xuICAgICAgICAgICAgICAgICAgZGVjbGFyYXRpb24uZGVjbGFyZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWNsYXJhdGlvbjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdChub2RlLmxvYy5zdGFydCksIHRva2VuID09PSAxMjUgPyBcImRlY2xhcmVcIiA6IFwiYWJzdHJhY3RcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW1pY29sb24oZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMTI2OlxuICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VFbnVtRGVjbGFyYXRpb24odGhpcy5zdGFydE5vZGUoKSk7XG4gICAgICAgIGNhc2UgMTEyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Q2ggPT09IDEyMykge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZUFtYmllbnRFeHRlcm5hbE1vZHVsZURlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDEyOTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRzUGFyc2VJbnRlcmZhY2VEZWNsYXJhdGlvbih0aGlzLnN0YXJ0Tm9kZSgpKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgMTI3OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHRUb2tlbklzSWRlbnRpZmllck9yU3RyaW5nTGl0ZXJhbE9uU2FtZUxpbmUoKSkge1xuICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnRzUGFyc2VEZWNsYXJhdGlvbihub2RlLCAxMjcsIGZhbHNlLCBkZWNvcmF0b3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAxMjg6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dFRva2VuSXNJZGVudGlmaWVyT25TYW1lTGluZSgpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZURlY2xhcmF0aW9uKG5vZGUsIDEyOCwgZmFsc2UsIGRlY29yYXRvcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDEzMDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0VG9rZW5Jc0lkZW50aWZpZXJPblNhbWVMaW5lKCkpIHtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlVHlwZUFsaWFzRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZVN0YXRlbWVudENvbnRlbnQoZmxhZ3MsIGRlY29yYXRvcnMpO1xuICB9XG4gIHBhcnNlQWNjZXNzTW9kaWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudHNQYXJzZU1vZGlmaWVyKFtcInB1YmxpY1wiLCBcInByb3RlY3RlZFwiLCBcInByaXZhdGVcIl0pO1xuICB9XG4gIHRzSGFzU29tZU1vZGlmaWVycyhtZW1iZXIsIG1vZGlmaWVycykge1xuICAgIHJldHVybiBtb2RpZmllcnMuc29tZShtb2RpZmllciA9PiB7XG4gICAgICBpZiAodHNJc0FjY2Vzc01vZGlmaWVyKG1vZGlmaWVyKSkge1xuICAgICAgICByZXR1cm4gbWVtYmVyLmFjY2Vzc2liaWxpdHkgPT09IG1vZGlmaWVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEhbWVtYmVyW21vZGlmaWVyXTtcbiAgICB9KTtcbiAgfVxuICB0c0lzU3RhcnRPZlN0YXRpY0Jsb2NrcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0NvbnRleHR1YWwoMTA2KSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDEyMztcbiAgfVxuICBwYXJzZUNsYXNzTWVtYmVyKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSkge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IFtcImRlY2xhcmVcIiwgXCJwcml2YXRlXCIsIFwicHVibGljXCIsIFwicHJvdGVjdGVkXCIsIFwib3ZlcnJpZGVcIiwgXCJhYnN0cmFjdFwiLCBcInJlYWRvbmx5XCIsIFwic3RhdGljXCJdO1xuICAgIHRoaXMudHNQYXJzZU1vZGlmaWVycyh7XG4gICAgICBhbGxvd2VkTW9kaWZpZXJzOiBtb2RpZmllcnMsXG4gICAgICBkaXNhbGxvd2VkTW9kaWZpZXJzOiBbXCJpblwiLCBcIm91dFwiXSxcbiAgICAgIHN0b3BPblN0YXJ0T2ZDbGFzc1N0YXRpY0Jsb2NrOiB0cnVlLFxuICAgICAgZXJyb3JUZW1wbGF0ZTogVFNFcnJvcnMuSW52YWxpZE1vZGlmaWVyT25UeXBlUGFyYW1ldGVyUG9zaXRpb25zXG4gICAgfSwgbWVtYmVyKTtcbiAgICBjb25zdCBjYWxsUGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLnRzSXNTdGFydE9mU3RhdGljQmxvY2tzKCkpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy50c0hhc1NvbWVNb2RpZmllcnMobWVtYmVyLCBtb2RpZmllcnMpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5TdGF0aWNCbG9ja0Nhbm5vdEhhdmVNb2RpZmllciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5wYXJzZUNsYXNzU3RhdGljQmxvY2soY2xhc3NCb2R5LCBtZW1iZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgISFtZW1iZXIuc3RhdGljKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChtZW1iZXIuZGVjbGFyZSkge1xuICAgICAgdGhpcy50c0luQW1iaWVudENvbnRleHQoY2FsbFBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsUGFyc2VDbGFzc01lbWJlcldpdGhJc1N0YXRpYygpO1xuICAgIH1cbiAgfVxuICBwYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgaXNTdGF0aWMpIHtcbiAgICBjb25zdCBpZHggPSB0aGlzLnRzVHJ5UGFyc2VJbmRleFNpZ25hdHVyZShtZW1iZXIpO1xuICAgIGlmIChpZHgpIHtcbiAgICAgIGNsYXNzQm9keS5ib2R5LnB1c2goaWR4KTtcbiAgICAgIGlmIChtZW1iZXIuYWJzdHJhY3QpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbmRleFNpZ25hdHVyZUhhc0Fic3RyYWN0LCBtZW1iZXIpO1xuICAgICAgfVxuICAgICAgaWYgKG1lbWJlci5hY2Nlc3NpYmlsaXR5KSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNBY2Nlc3NpYmlsaXR5LCBtZW1iZXIsIHtcbiAgICAgICAgICBtb2RpZmllcjogbWVtYmVyLmFjY2Vzc2liaWxpdHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAobWVtYmVyLmRlY2xhcmUpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5JbmRleFNpZ25hdHVyZUhhc0RlY2xhcmUsIG1lbWJlcik7XG4gICAgICB9XG4gICAgICBpZiAobWVtYmVyLm92ZXJyaWRlKSB7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuSW5kZXhTaWduYXR1cmVIYXNPdmVycmlkZSwgbWVtYmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnN0YXRlLmluQWJzdHJhY3RDbGFzcyAmJiBtZW1iZXIuYWJzdHJhY3QpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuTm9uQWJzdHJhY3RDbGFzc0hhc0Fic3RyYWN0TWV0aG9kLCBtZW1iZXIpO1xuICAgIH1cbiAgICBpZiAobWVtYmVyLm92ZXJyaWRlKSB7XG4gICAgICBpZiAoIXN0YXRlLmhhZFN1cGVyQ2xhc3MpIHtcbiAgICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5PdmVycmlkZU5vdEluU3ViQ2xhc3MsIG1lbWJlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBpc1N0YXRpYyk7XG4gIH1cbiAgcGFyc2VQb3N0TWVtYmVyTmFtZU1vZGlmaWVycyhtZXRob2RPclByb3ApIHtcbiAgICBjb25zdCBvcHRpb25hbCA9IHRoaXMuZWF0KDE3KTtcbiAgICBpZiAob3B0aW9uYWwpIG1ldGhvZE9yUHJvcC5vcHRpb25hbCA9IHRydWU7XG4gICAgaWYgKG1ldGhvZE9yUHJvcC5yZWFkb25seSAmJiB0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5DbGFzc01ldGhvZEhhc1JlYWRvbmx5LCBtZXRob2RPclByb3ApO1xuICAgIH1cbiAgICBpZiAobWV0aG9kT3JQcm9wLmRlY2xhcmUgJiYgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQ2xhc3NNZXRob2RIYXNEZWNsYXJlLCBtZXRob2RPclByb3ApO1xuICAgIH1cbiAgfVxuICBzaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkge1xuICAgIGlmICh0aGlzLnRzSXNEZWNsYXJhdGlvblN0YXJ0KCkpIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBzdXBlci5zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCk7XG4gIH1cbiAgcGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICghdGhpcy5tYXRjaCgxNykpIHJldHVybiBleHByO1xuICAgIGlmICh0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnMpIHtcbiAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgIGlmIChuZXh0Q2ggPT09IDQ0IHx8IG5leHRDaCA9PT0gNjEgfHwgbmV4dENoID09PSA1OCB8fCBuZXh0Q2ggPT09IDQxKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9uYWxQYXJhbWV0ZXJzRXJyb3IocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgcGFyc2VQYXJlbkl0ZW0obm9kZSwgc3RhcnRMb2MpIHtcbiAgICBjb25zdCBuZXdOb2RlID0gc3VwZXIucGFyc2VQYXJlbkl0ZW0obm9kZSwgc3RhcnRMb2MpO1xuICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIG5ld05vZGUub3B0aW9uYWwgPSB0cnVlO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKG5vZGUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgxNCkpIHtcbiAgICAgIGNvbnN0IHR5cGVDYXN0Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgdHlwZUNhc3ROb2RlLmV4cHJlc3Npb24gPSBub2RlO1xuICAgICAgdHlwZUNhc3ROb2RlLnR5cGVBbm5vdGF0aW9uID0gdGhpcy50c1BhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUodHlwZUNhc3ROb2RlLCBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCAmJiB0aGlzLmlzQ29udGV4dHVhbCgxMjUpKSB7XG4gICAgICByZXR1cm4gdGhpcy50c0luQW1iaWVudENvbnRleHQoKCkgPT4gdGhpcy5wYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IGlzRGVjbGFyZSA9IHRoaXMuZWF0Q29udGV4dHVhbCgxMjUpO1xuICAgIGlmIChpc0RlY2xhcmUgJiYgKHRoaXMuaXNDb250ZXh0dWFsKDEyNSkgfHwgIXRoaXMuc2hvdWxkUGFyc2VFeHBvcnREZWNsYXJhdGlvbigpKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShUU0Vycm9ycy5FeHBlY3RlZEFtYmllbnRBZnRlckV4cG9ydERlY2xhcmUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICBjb25zdCBpc0lkZW50aWZpZXIgPSB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpO1xuICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gaXNJZGVudGlmaWVyICYmIHRoaXMudHNUcnlQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkgfHwgc3VwZXIucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICBpZiAoIWRlY2xhcmF0aW9uKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoZGVjbGFyYXRpb24udHlwZSA9PT0gXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCIgfHwgZGVjbGFyYXRpb24udHlwZSA9PT0gXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCIgfHwgaXNEZWNsYXJlKSB7XG4gICAgICBub2RlLmV4cG9ydEtpbmQgPSBcInR5cGVcIjtcbiAgICB9XG4gICAgaWYgKGlzRGVjbGFyZSAmJiBkZWNsYXJhdGlvbi50eXBlICE9PSBcIlRTSW1wb3J0RXF1YWxzRGVjbGFyYXRpb25cIikge1xuICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb24oZGVjbGFyYXRpb24sIHN0YXJ0TG9jKTtcbiAgICAgIGRlY2xhcmF0aW9uLmRlY2xhcmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZGVjbGFyYXRpb247XG4gIH1cbiAgcGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkLCBiaW5kaW5nVHlwZSkge1xuICAgIGlmICgoIWlzU3RhdGVtZW50IHx8IG9wdGlvbmFsSWQpICYmIHRoaXMuaXNDb250ZXh0dWFsKDExMykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIucGFyc2VDbGFzc0lkKG5vZGUsIGlzU3RhdGVtZW50LCBvcHRpb25hbElkLCBub2RlLmRlY2xhcmUgPyAxMDI0IDogODMzMSk7XG4gICAgY29uc3QgdHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzVHJ5UGFyc2VUeXBlUGFyYW1ldGVycyh0aGlzLnRzUGFyc2VJbk91dENvbnN0TW9kaWZpZXJzKTtcbiAgICBpZiAodHlwZVBhcmFtZXRlcnMpIG5vZGUudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgfVxuICBwYXJzZUNsYXNzUHJvcGVydHlBbm5vdGF0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUub3B0aW9uYWwpIHtcbiAgICAgIGlmICh0aGlzLmVhdCgzNSkpIHtcbiAgICAgICAgbm9kZS5kZWZpbml0ZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgICBub2RlLm9wdGlvbmFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IHRoaXMudHNUcnlQYXJzZVR5cGVBbm5vdGF0aW9uKCk7XG4gICAgaWYgKHR5cGUpIG5vZGUudHlwZUFubm90YXRpb24gPSB0eXBlO1xuICB9XG4gIHBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUNsYXNzUHJvcGVydHlBbm5vdGF0aW9uKG5vZGUpO1xuICAgIGlmICh0aGlzLnN0YXRlLmlzQW1iaWVudENvbnRleHQgJiYgIShub2RlLnJlYWRvbmx5ICYmICFub2RlLnR5cGVBbm5vdGF0aW9uKSAmJiB0aGlzLm1hdGNoKDI5KSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EZWNsYXJlQ2xhc3NGaWVsZEhhc0luaXRpYWxpemVyLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuYWJzdHJhY3QgJiYgdGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5XG4gICAgICB9ID0gbm9kZTtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQWJzdHJhY3RQcm9wZXJ0eUhhc0luaXRpYWxpemVyLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgIHByb3BlcnR5TmFtZToga2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICFub2RlLmNvbXB1dGVkID8ga2V5Lm5hbWUgOiBgWyR7dGhpcy5pbnB1dC5zbGljZSh0aGlzLm9mZnNldFRvU291cmNlUG9zKGtleS5zdGFydCksIHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Moa2V5LmVuZCkpfV1gXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlQ2xhc3NQcm9wZXJ0eShub2RlKTtcbiAgfVxuICBwYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KG5vZGUpIHtcbiAgICBpZiAobm9kZS5hYnN0cmFjdCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5Qcml2YXRlRWxlbWVudEhhc0Fic3RyYWN0LCBub2RlKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuYWNjZXNzaWJpbGl0eSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5Qcml2YXRlRWxlbWVudEhhc0FjY2Vzc2liaWxpdHksIG5vZGUsIHtcbiAgICAgICAgbW9kaWZpZXI6IG5vZGUuYWNjZXNzaWJpbGl0eVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5QW5ub3RhdGlvbihub2RlKTtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzc1ByaXZhdGVQcm9wZXJ0eShub2RlKTtcbiAgfVxuICBwYXJzZUNsYXNzQWNjZXNzb3JQcm9wZXJ0eShub2RlKSB7XG4gICAgdGhpcy5wYXJzZUNsYXNzUHJvcGVydHlBbm5vdGF0aW9uKG5vZGUpO1xuICAgIGlmIChub2RlLm9wdGlvbmFsKSB7XG4gICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFjY2Vzc29yQ2Fubm90QmVPcHRpb25hbCwgbm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUNsYXNzQWNjZXNzb3JQcm9wZXJ0eShub2RlKTtcbiAgfVxuICBwdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzICYmIGlzQ29uc3RydWN0b3IpIHtcbiAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuQ29uc3RydWN0b3JIYXNUeXBlUGFyYW1ldGVycywgdHlwZVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBkZWNsYXJlID0gZmFsc2UsXG4gICAgICBraW5kXG4gICAgfSA9IG1ldGhvZDtcbiAgICBpZiAoZGVjbGFyZSAmJiAoa2luZCA9PT0gXCJnZXRcIiB8fCBraW5kID09PSBcInNldFwiKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5EZWNsYXJlQWNjZXNzb3IsIG1ldGhvZCwge1xuICAgICAgICBraW5kXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSBtZXRob2QudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICBzdXBlci5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcik7XG4gIH1cbiAgcHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUNvbnN0TW9kaWZpZXIpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykgbWV0aG9kLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgc3VwZXIucHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpO1xuICB9XG4gIGRlY2xhcmVDbGFzc1ByaXZhdGVNZXRob2RJblNjb3BlKG5vZGUsIGtpbmQpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIlRTRGVjbGFyZU1ldGhvZFwiKSByZXR1cm47XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJNZXRob2REZWZpbml0aW9uXCIgJiYgbm9kZS52YWx1ZS5ib2R5ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuZGVjbGFyZUNsYXNzUHJpdmF0ZU1ldGhvZEluU2NvcGUobm9kZSwga2luZCk7XG4gIH1cbiAgcGFyc2VDbGFzc1N1cGVyKG5vZGUpIHtcbiAgICBzdXBlci5wYXJzZUNsYXNzU3VwZXIobm9kZSk7XG4gICAgaWYgKG5vZGUuc3VwZXJDbGFzcyAmJiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCg1MSkpKSB7XG4gICAgICBub2RlLnN1cGVyVHlwZVBhcmFtZXRlcnMgPSB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoMTEzKSkge1xuICAgICAgbm9kZS5pbXBsZW1lbnRzID0gdGhpcy50c1BhcnNlSGVyaXRhZ2VDbGF1c2UoXCJpbXBsZW1lbnRzXCIpO1xuICAgIH1cbiAgfVxuICBwYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1RyeVBhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgaWYgKHR5cGVQYXJhbWV0ZXJzKSBwcm9wLnR5cGVQYXJhbWV0ZXJzID0gdHlwZVBhcmFtZXRlcnM7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlT2JqUHJvcFZhbHVlKHByb3AsIHN0YXJ0TG9jLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGlzQ29uc3RydWN0b3IpIHtcbiAgICBjb25zdCB0eXBlUGFyYW1ldGVycyA9IHRoaXMudHNUcnlQYXJzZVR5cGVQYXJhbWV0ZXJzKHRoaXMudHNQYXJzZUNvbnN0TW9kaWZpZXIpO1xuICAgIGlmICh0eXBlUGFyYW1ldGVycykgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVQYXJhbWV0ZXJzO1xuICAgIHN1cGVyLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgaXNDb25zdHJ1Y3Rvcik7XG4gIH1cbiAgcGFyc2VWYXJJZChkZWNsLCBraW5kKSB7XG4gICAgc3VwZXIucGFyc2VWYXJJZChkZWNsLCBraW5kKTtcbiAgICBpZiAoZGVjbC5pZC50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSAmJiB0aGlzLmVhdCgzNSkpIHtcbiAgICAgIGRlY2wuZGVmaW5pdGUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgZGVjbC5pZC50eXBlQW5ub3RhdGlvbiA9IHR5cGU7XG4gICAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oZGVjbC5pZCk7XG4gICAgfVxuICB9XG4gIHBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBub2RlLnJldHVyblR5cGUgPSB0aGlzLnRzUGFyc2VUeXBlQW5ub3RhdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VBc3luY0Fycm93RnJvbUNhbGxFeHByZXNzaW9uKG5vZGUsIGNhbGwpO1xuICB9XG4gIHBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICB2YXIgX2pzeCwgX2pzeDIsIF90eXBlQ2FzdCwgX2pzeDMsIF90eXBlQ2FzdDI7XG4gICAgbGV0IHN0YXRlO1xuICAgIGxldCBqc3g7XG4gICAgbGV0IHR5cGVDYXN0O1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImpzeFwiKSAmJiAodGhpcy5tYXRjaCgxNDMpIHx8IHRoaXMubWF0Y2goNDcpKSkge1xuICAgICAgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgICBqc3ggPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpLCBzdGF0ZSk7XG4gICAgICBpZiAoIWpzeC5lcnJvcikgcmV0dXJuIGpzeC5ub2RlO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250ZXh0XG4gICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIGNvbnN0IGN1cnJlbnRDb250ZXh0ID0gY29udGV4dFtjb250ZXh0Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGN1cnJlbnRDb250ZXh0ID09PSB0eXBlcy5qX29UYWcgfHwgY3VycmVudENvbnRleHQgPT09IHR5cGVzLmpfZXhwcikge1xuICAgICAgICBjb250ZXh0LnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoISgoX2pzeCA9IGpzeCkgIT0gbnVsbCAmJiBfanN4LmVycm9yKSAmJiAhdGhpcy5tYXRjaCg0NykpIHtcbiAgICAgIHJldHVybiBzdXBlci5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKTtcbiAgICB9XG4gICAgaWYgKCFzdGF0ZSB8fCBzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkgc3RhdGUgPSB0aGlzLnN0YXRlLmNsb25lKCk7XG4gICAgbGV0IHR5cGVQYXJhbWV0ZXJzO1xuICAgIGNvbnN0IGFycm93ID0gdGhpcy50cnlQYXJzZShhYm9ydCA9PiB7XG4gICAgICB2YXIgX2V4cHIkZXh0cmEsIF90eXBlUGFyYW1ldGVycztcbiAgICAgIHR5cGVQYXJhbWV0ZXJzID0gdGhpcy50c1BhcnNlVHlwZVBhcmFtZXRlcnModGhpcy50c1BhcnNlQ29uc3RNb2RpZmllcik7XG4gICAgICBjb25zdCBleHByID0gc3VwZXIucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSk7XG4gICAgICBpZiAoZXhwci50eXBlICE9PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgfHwgKF9leHByJGV4dHJhID0gZXhwci5leHRyYSkgIT0gbnVsbCAmJiBfZXhwciRleHRyYS5wYXJlbnRoZXNpemVkKSB7XG4gICAgICAgIGFib3J0KCk7XG4gICAgICB9XG4gICAgICBpZiAoKChfdHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycykgPT0gbnVsbCA/IHZvaWQgMCA6IF90eXBlUGFyYW1ldGVycy5wYXJhbXMubGVuZ3RoKSAhPT0gMCkge1xuICAgICAgICB0aGlzLnJlc2V0U3RhcnRMb2NhdGlvbkZyb21Ob2RlKGV4cHIsIHR5cGVQYXJhbWV0ZXJzKTtcbiAgICAgIH1cbiAgICAgIGV4cHIudHlwZVBhcmFtZXRlcnMgPSB0eXBlUGFyYW1ldGVycztcbiAgICAgIHJldHVybiBleHByO1xuICAgIH0sIHN0YXRlKTtcbiAgICBpZiAoIWFycm93LmVycm9yICYmICFhcnJvdy5hYm9ydGVkKSB7XG4gICAgICBpZiAodHlwZVBhcmFtZXRlcnMpIHRoaXMucmVwb3J0UmVzZXJ2ZWRBcnJvd1R5cGVQYXJhbSh0eXBlUGFyYW1ldGVycyk7XG4gICAgICByZXR1cm4gYXJyb3cubm9kZTtcbiAgICB9XG4gICAgaWYgKCFqc3gpIHtcbiAgICAgIGFzc2VydCghdGhpcy5oYXNQbHVnaW4oXCJqc3hcIikpO1xuICAgICAgdHlwZUNhc3QgPSB0aGlzLnRyeVBhcnNlKCgpID0+IHN1cGVyLnBhcnNlTWF5YmVBc3NpZ24ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpLCBzdGF0ZSk7XG4gICAgICBpZiAoIXR5cGVDYXN0LmVycm9yKSByZXR1cm4gdHlwZUNhc3Qubm9kZTtcbiAgICB9XG4gICAgaWYgKChfanN4MiA9IGpzeCkgIT0gbnVsbCAmJiBfanN4Mi5ub2RlKSB7XG4gICAgICB0aGlzLnN0YXRlID0ganN4LmZhaWxTdGF0ZTtcbiAgICAgIHJldHVybiBqc3gubm9kZTtcbiAgICB9XG4gICAgaWYgKGFycm93Lm5vZGUpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBhcnJvdy5mYWlsU3RhdGU7XG4gICAgICBpZiAodHlwZVBhcmFtZXRlcnMpIHRoaXMucmVwb3J0UmVzZXJ2ZWRBcnJvd1R5cGVQYXJhbSh0eXBlUGFyYW1ldGVycyk7XG4gICAgICByZXR1cm4gYXJyb3cubm9kZTtcbiAgICB9XG4gICAgaWYgKChfdHlwZUNhc3QgPSB0eXBlQ2FzdCkgIT0gbnVsbCAmJiBfdHlwZUNhc3Qubm9kZSkge1xuICAgICAgdGhpcy5zdGF0ZSA9IHR5cGVDYXN0LmZhaWxTdGF0ZTtcbiAgICAgIHJldHVybiB0eXBlQ2FzdC5ub2RlO1xuICAgIH1cbiAgICB0aHJvdyAoKF9qc3gzID0ganN4KSA9PSBudWxsID8gdm9pZCAwIDogX2pzeDMuZXJyb3IpIHx8IGFycm93LmVycm9yIHx8ICgoX3R5cGVDYXN0MiA9IHR5cGVDYXN0KSA9PSBudWxsID8gdm9pZCAwIDogX3R5cGVDYXN0Mi5lcnJvcik7XG4gIH1cbiAgcmVwb3J0UmVzZXJ2ZWRBcnJvd1R5cGVQYXJhbShub2RlKSB7XG4gICAgdmFyIF9ub2RlJGV4dHJhMjtcbiAgICBpZiAobm9kZS5wYXJhbXMubGVuZ3RoID09PSAxICYmICFub2RlLnBhcmFtc1swXS5jb25zdHJhaW50ICYmICEoKF9ub2RlJGV4dHJhMiA9IG5vZGUuZXh0cmEpICE9IG51bGwgJiYgX25vZGUkZXh0cmEyLnRyYWlsaW5nQ29tbWEpICYmIHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwidHlwZXNjcmlwdFwiLCBcImRpc2FsbG93QW1iaWd1b3VzSlNYTGlrZVwiKSkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5SZXNlcnZlZEFycm93VHlwZVBhcmFtLCBub2RlKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VNYXliZVVuYXJ5KHJlZkV4cHJlc3Npb25FcnJvcnMsIHNhd1VuYXJ5KSB7XG4gICAgaWYgKCF0aGlzLmhhc1BsdWdpbihcImpzeFwiKSAmJiB0aGlzLm1hdGNoKDQ3KSkge1xuICAgICAgcmV0dXJuIHRoaXMudHNQYXJzZVR5cGVBc3NlcnRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlTWF5YmVVbmFyeShyZWZFeHByZXNzaW9uRXJyb3JzLCBzYXdVbmFyeSk7XG4gIH1cbiAgcGFyc2VBcnJvdyhub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnRyeVBhcnNlKGFib3J0ID0+IHtcbiAgICAgICAgY29uc3QgcmV0dXJuVHlwZSA9IHRoaXMudHNQYXJzZVR5cGVPclR5cGVQcmVkaWNhdGVBbm5vdGF0aW9uKDE0KTtcbiAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMubWF0Y2goMTkpKSBhYm9ydCgpO1xuICAgICAgICByZXR1cm4gcmV0dXJuVHlwZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlc3VsdC5hYm9ydGVkKSByZXR1cm47XG4gICAgICBpZiAoIXJlc3VsdC50aHJvd24pIHtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikgdGhpcy5zdGF0ZSA9IHJlc3VsdC5mYWlsU3RhdGU7XG4gICAgICAgIG5vZGUucmV0dXJuVHlwZSA9IHJlc3VsdC5ub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGFyc2VBcnJvdyhub2RlKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uUGFyYW1UeXBlKHBhcmFtKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE3KSkge1xuICAgICAgcGFyYW0ub3B0aW9uYWwgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkgcGFyYW0udHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbihwYXJhbSk7XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIGlzQXNzaWduYWJsZShub2RlLCBpc0JpbmRpbmcpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXNzaWduYWJsZShub2RlLmV4cHJlc3Npb24sIGlzQmluZGluZyk7XG4gICAgICBjYXNlIFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBzdXBlci5pc0Fzc2lnbmFibGUobm9kZSwgaXNCaW5kaW5nKTtcbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTID0gZmFsc2UpIHtcbiAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgY2FzZSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlUGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZSwgaXNMSFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICAgICAgaWYgKGlzTEhTKSB7XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkQXJyb3dQYXJhbWV0ZXJCaW5kaW5nRXJyb3IoVFNFcnJvcnMuVW5leHBlY3RlZFR5cGVDYXN0SW5QYXJhbWV0ZXIsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuVW5leHBlY3RlZFR5cGVDYXN0SW5QYXJhbWV0ZXIsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKG5vZGUuZXhwcmVzc2lvbiwgaXNMSFMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOlxuICAgICAgICBpZiAoIWlzTEhTICYmIG5vZGUubGVmdC50eXBlID09PSBcIlRTVHlwZUNhc3RFeHByZXNzaW9uXCIpIHtcbiAgICAgICAgICBub2RlLmxlZnQgPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZS5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKTtcbiAgICB9XG4gIH1cbiAgdG9Bc3NpZ25hYmxlUGFyZW50aGVzaXplZEV4cHJlc3Npb24obm9kZSwgaXNMSFMpIHtcbiAgICBzd2l0Y2ggKG5vZGUuZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICBjYXNlIFwiVFNUeXBlQXNzZXJ0aW9uXCI6XG4gICAgICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0xIUyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc3VwZXIudG9Bc3NpZ25hYmxlKG5vZGUsIGlzTEhTKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tUb1Jlc3RDb252ZXJzaW9uKG5vZGUsIGFsbG93UGF0dGVybikge1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiVFNBc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJUU1R5cGVBc3NlcnRpb25cIjpcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICAgIHRoaXMuY2hlY2tUb1Jlc3RDb252ZXJzaW9uKG5vZGUuZXhwcmVzc2lvbiwgZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHN1cGVyLmNoZWNrVG9SZXN0Q29udmVyc2lvbihub2RlLCBhbGxvd1BhdHRlcm4pO1xuICAgIH1cbiAgfVxuICBpc1ZhbGlkTFZhbCh0eXBlLCBkaXNhbGxvd0NhbGxFeHByZXNzaW9uLCBpc1VucGFyZW50aGVzaXplZEluQXNzaWduLCBiaW5kaW5nKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiVFNUeXBlQ2FzdEV4cHJlc3Npb25cIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlIFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiOlxuICAgICAgICByZXR1cm4gXCJwYXJhbWV0ZXJcIjtcbiAgICAgIGNhc2UgXCJUU05vbk51bGxFeHByZXNzaW9uXCI6XG4gICAgICAgIHJldHVybiBcImV4cHJlc3Npb25cIjtcbiAgICAgIGNhc2UgXCJUU0FzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOlxuICAgICAgY2FzZSBcIlRTVHlwZUFzc2VydGlvblwiOlxuICAgICAgICByZXR1cm4gKGJpbmRpbmcgIT09IDY0IHx8ICFpc1VucGFyZW50aGVzaXplZEluQXNzaWduKSAmJiBbXCJleHByZXNzaW9uXCIsIHRydWVdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmlzVmFsaWRMVmFsKHR5cGUsIGRpc2FsbG93Q2FsbEV4cHJlc3Npb24sIGlzVW5wYXJlbnRoZXNpemVkSW5Bc3NpZ24sIGJpbmRpbmcpO1xuICAgIH1cbiAgfVxuICBwYXJzZUJpbmRpbmdBdG9tKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnR5cGUgPT09IDc4KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gIH1cbiAgcGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByLCBzdGFydExvYykge1xuICAgIGlmICh0aGlzLm1hdGNoKDQ3KSB8fCB0aGlzLm1hdGNoKDUxKSkge1xuICAgICAgY29uc3QgdHlwZUFyZ3VtZW50cyA9IHRoaXMudHNQYXJzZVR5cGVBcmd1bWVudHNJbkV4cHJlc3Npb24oKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICBjb25zdCBjYWxsID0gc3VwZXIucGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByLCBzdGFydExvYyk7XG4gICAgICAgIGNhbGwudHlwZVBhcmFtZXRlcnMgPSB0eXBlQXJndW1lbnRzO1xuICAgICAgICByZXR1cm4gY2FsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCAxMCk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5wYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIsIHN0YXJ0TG9jKTtcbiAgfVxuICBjaGVja0NvbW1hQWZ0ZXJSZXN0KGNsb3NlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCAmJiB0aGlzLm1hdGNoKDEyKSAmJiB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IGNsb3NlKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmNoZWNrQ29tbWFBZnRlclJlc3QoY2xvc2UpO1xuICB9XG4gIGlzQ2xhc3NNZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goNDcpIHx8IHN1cGVyLmlzQ2xhc3NNZXRob2QoKTtcbiAgfVxuICBpc0NsYXNzUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMzUpIHx8IHRoaXMubWF0Y2goMTQpIHx8IHN1cGVyLmlzQ2xhc3NQcm9wZXJ0eSgpO1xuICB9XG4gIHBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0TG9jLCBsZWZ0KSB7XG4gICAgY29uc3Qgbm9kZSA9IHN1cGVyLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0TG9jLCBsZWZ0KTtcbiAgICBpZiAobm9kZS50eXBlID09PSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCIgJiYgbm9kZS50eXBlQW5ub3RhdGlvbiAmJiBub2RlLnJpZ2h0LnN0YXJ0IDwgbm9kZS50eXBlQW5ub3RhdGlvbi5zdGFydCkge1xuICAgICAgdGhpcy5yYWlzZShUU0Vycm9ycy5UeXBlQW5ub3RhdGlvbkFmdGVyQXNzaWduLCBub2RlLnR5cGVBbm5vdGF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUuaW5UeXBlKSB7XG4gICAgICBpZiAoY29kZSA9PT0gNjIpIHtcbiAgICAgICAgdGhpcy5maW5pc2hPcCg0OCwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlID09PSA2MCkge1xuICAgICAgICB0aGlzLmZpbmlzaE9wKDQ3LCAxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBzdXBlci5nZXRUb2tlbkZyb21Db2RlKGNvZGUpO1xuICB9XG4gIHJlU2Nhbl9sdF9ndCgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHR5cGUgPT09IDQ3KSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyAtPSAxO1xuICAgICAgdGhpcy5yZWFkVG9rZW5fbHQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDQ4KSB7XG4gICAgICB0aGlzLnN0YXRlLnBvcyAtPSAxO1xuICAgICAgdGhpcy5yZWFkVG9rZW5fZ3QoKTtcbiAgICB9XG4gIH1cbiAgcmVTY2FuX2x0KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBpZiAodHlwZSA9PT0gNTEpIHtcbiAgICAgIHRoaXMuc3RhdGUucG9zIC09IDI7XG4gICAgICB0aGlzLmZpbmlzaE9wKDQ3LCAxKTtcbiAgICAgIHJldHVybiA0NztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgdG9Bc3NpZ25hYmxlTGlzdEl0ZW0oZXhwckxpc3QsIGluZGV4LCBpc0xIUykge1xuICAgIGNvbnN0IG5vZGUgPSBleHByTGlzdFtpbmRleF07XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gXCJUU1R5cGVDYXN0RXhwcmVzc2lvblwiKSB7XG4gICAgICBleHByTGlzdFtpbmRleF0gPSB0aGlzLnR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZSk7XG4gICAgfVxuICAgIHN1cGVyLnRvQXNzaWduYWJsZUxpc3RJdGVtKGV4cHJMaXN0LCBpbmRleCwgaXNMSFMpO1xuICB9XG4gIHR5cGVDYXN0VG9QYXJhbWV0ZXIobm9kZSkge1xuICAgIG5vZGUuZXhwcmVzc2lvbi50eXBlQW5ub3RhdGlvbiA9IG5vZGUudHlwZUFubm90YXRpb247XG4gICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKG5vZGUuZXhwcmVzc2lvbiwgbm9kZS50eXBlQW5ub3RhdGlvbi5sb2MuZW5kKTtcbiAgICByZXR1cm4gbm9kZS5leHByZXNzaW9uO1xuICB9XG4gIHNob3VsZFBhcnNlQXJyb3cocGFyYW1zKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICByZXR1cm4gcGFyYW1zLmV2ZXJ5KGV4cHIgPT4gdGhpcy5pc0Fzc2lnbmFibGUoZXhwciwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpO1xuICB9XG4gIHNob3VsZFBhcnNlQXN5bmNBcnJvdygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxNCkgfHwgc3VwZXIuc2hvdWxkUGFyc2VBc3luY0Fycm93KCk7XG4gIH1cbiAgY2FuSGF2ZUxlYWRpbmdEZWNvcmF0b3IoKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNhbkhhdmVMZWFkaW5nRGVjb3JhdG9yKCkgfHwgdGhpcy5pc0Fic3RyYWN0Q2xhc3MoKTtcbiAgfVxuICBqc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg0NykgfHwgdGhpcy5tYXRjaCg1MSkpIHtcbiAgICAgIGNvbnN0IHR5cGVBcmd1bWVudHMgPSB0aGlzLnRzVHJ5UGFyc2VBbmRDYXRjaCgoKSA9PiB0aGlzLnRzUGFyc2VUeXBlQXJndW1lbnRzSW5FeHByZXNzaW9uKCkpO1xuICAgICAgaWYgKHR5cGVBcmd1bWVudHMpIHtcbiAgICAgICAgbm9kZS50eXBlUGFyYW1ldGVycyA9IHR5cGVBcmd1bWVudHM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5qc3hQYXJzZU9wZW5pbmdFbGVtZW50QWZ0ZXJOYW1lKG5vZGUpO1xuICB9XG4gIGdldEdldHRlclNldHRlckV4cGVjdGVkUGFyYW1Db3VudChtZXRob2QpIHtcbiAgICBjb25zdCBiYXNlQ291bnQgPSBzdXBlci5nZXRHZXR0ZXJTZXR0ZXJFeHBlY3RlZFBhcmFtQ291bnQobWV0aG9kKTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLmdldE9iamVjdE9yQ2xhc3NNZXRob2RQYXJhbXMobWV0aG9kKTtcbiAgICBjb25zdCBmaXJzdFBhcmFtID0gcGFyYW1zWzBdO1xuICAgIGNvbnN0IGhhc0NvbnRleHRQYXJhbSA9IGZpcnN0UGFyYW0gJiYgdGhpcy5pc1RoaXNQYXJhbShmaXJzdFBhcmFtKTtcbiAgICByZXR1cm4gaGFzQ29udGV4dFBhcmFtID8gYmFzZUNvdW50ICsgMSA6IGJhc2VDb3VudDtcbiAgfVxuICBwYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKSB7XG4gICAgY29uc3QgcGFyYW0gPSBzdXBlci5wYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKTtcbiAgICBjb25zdCB0eXBlID0gdGhpcy50c1RyeVBhcnNlVHlwZUFubm90YXRpb24oKTtcbiAgICBpZiAodHlwZSkge1xuICAgICAgcGFyYW0udHlwZUFubm90YXRpb24gPSB0eXBlO1xuICAgICAgdGhpcy5yZXNldEVuZExvY2F0aW9uKHBhcmFtKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIHRzSW5BbWJpZW50Q29udGV4dChjYikge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzQW1iaWVudENvbnRleHQ6IG9sZElzQW1iaWVudENvbnRleHQsXG4gICAgICBzdHJpY3Q6IG9sZFN0cmljdFxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCA9IHRydWU7XG4gICAgdGhpcy5zdGF0ZS5zdHJpY3QgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNiKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaXNBbWJpZW50Q29udGV4dCA9IG9sZElzQW1iaWVudENvbnRleHQ7XG4gICAgICB0aGlzLnN0YXRlLnN0cmljdCA9IG9sZFN0cmljdDtcbiAgICB9XG4gIH1cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIGNvbnN0IG9sZEluQWJzdHJhY3RDbGFzcyA9IHRoaXMuc3RhdGUuaW5BYnN0cmFjdENsYXNzO1xuICAgIHRoaXMuc3RhdGUuaW5BYnN0cmFjdENsYXNzID0gISFub2RlLmFic3RyYWN0O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gc3VwZXIucGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUuaW5BYnN0cmFjdENsYXNzID0gb2xkSW5BYnN0cmFjdENsYXNzO1xuICAgIH1cbiAgfVxuICB0c1BhcnNlQWJzdHJhY3REZWNsYXJhdGlvbihub2RlLCBkZWNvcmF0b3JzKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goODApKSB7XG4gICAgICBub2RlLmFic3RyYWN0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLm1heWJlVGFrZURlY29yYXRvcnMoZGVjb3JhdG9ycywgdGhpcy5wYXJzZUNsYXNzKG5vZGUsIHRydWUsIGZhbHNlKSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ29udGV4dHVhbCgxMjkpKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzRm9sbG93aW5nTGluZUJyZWFrKCkpIHtcbiAgICAgICAgbm9kZS5hYnN0cmFjdCA9IHRydWU7XG4gICAgICAgIHRoaXMucmFpc2UoVFNFcnJvcnMuTm9uQ2xhc3NNZXRob2RQcm9wZXJ0eUhhc0Fic3RyYWN0TW9kaWZpZXIsIG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcy50c1BhcnNlSW50ZXJmYWNlRGVjbGFyYXRpb24obm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKG51bGwsIDgwKTtcbiAgfVxuICBwYXJzZU1ldGhvZChub2RlLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNDb25zdHJ1Y3RvciwgYWxsb3dEaXJlY3RTdXBlciwgdHlwZSwgaW5DbGFzc1Njb3BlKSB7XG4gICAgY29uc3QgbWV0aG9kID0gc3VwZXIucGFyc2VNZXRob2Qobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSk7XG4gICAgaWYgKG1ldGhvZC5hYnN0cmFjdCB8fCBtZXRob2QudHlwZSA9PT0gXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiKSB7XG4gICAgICBjb25zdCBoYXNFc3RyZWVQbHVnaW4gPSB0aGlzLmhhc1BsdWdpbihcImVzdHJlZVwiKTtcbiAgICAgIGNvbnN0IG1ldGhvZEZuID0gaGFzRXN0cmVlUGx1Z2luID8gbWV0aG9kLnZhbHVlIDogbWV0aG9kO1xuICAgICAgaWYgKG1ldGhvZEZuLmJvZHkpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGtleVxuICAgICAgICB9ID0gbWV0aG9kO1xuICAgICAgICB0aGlzLnJhaXNlKFRTRXJyb3JzLkFic3RyYWN0TWV0aG9kSGFzSW1wbGVtZW50YXRpb24sIG1ldGhvZCwge1xuICAgICAgICAgIG1ldGhvZE5hbWU6IGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiAhbWV0aG9kLmNvbXB1dGVkID8ga2V5Lm5hbWUgOiBgWyR7dGhpcy5pbnB1dC5zbGljZSh0aGlzLm9mZnNldFRvU291cmNlUG9zKGtleS5zdGFydCksIHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Moa2V5LmVuZCkpfV1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xuICB9XG4gIHRzUGFyc2VUeXBlUGFyYW1ldGVyTmFtZSgpIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgcmV0dXJuIHR5cGVOYW1lLm5hbWU7XG4gIH1cbiAgc2hvdWxkUGFyc2VBc0FtYmllbnRDb250ZXh0KCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwidHlwZXNjcmlwdFwiLCBcImR0c1wiKTtcbiAgfVxuICBwYXJzZSgpIHtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZUFzQW1iaWVudENvbnRleHQoKSkge1xuICAgICAgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlKCk7XG4gIH1cbiAgZ2V0RXhwcmVzc2lvbigpIHtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZUFzQW1iaWVudENvbnRleHQoKSkge1xuICAgICAgdGhpcy5zdGF0ZS5pc0FtYmllbnRDb250ZXh0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdldEV4cHJlc3Npb24oKTtcbiAgfVxuICBwYXJzZUV4cG9ydFNwZWNpZmllcihub2RlLCBpc1N0cmluZywgaXNJblR5cGVFeHBvcnQsIGlzTWF5YmVUeXBlT25seSkge1xuICAgIGlmICghaXNTdHJpbmcgJiYgaXNNYXliZVR5cGVPbmx5KSB7XG4gICAgICB0aGlzLnBhcnNlVHlwZU9ubHlJbXBvcnRFeHBvcnRTcGVjaWZpZXIobm9kZSwgZmFsc2UsIGlzSW5UeXBlRXhwb3J0KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRTcGVjaWZpZXJcIik7XG4gICAgfVxuICAgIG5vZGUuZXhwb3J0S2luZCA9IFwidmFsdWVcIjtcbiAgICByZXR1cm4gc3VwZXIucGFyc2VFeHBvcnRTcGVjaWZpZXIobm9kZSwgaXNTdHJpbmcsIGlzSW5UeXBlRXhwb3J0LCBpc01heWJlVHlwZU9ubHkpO1xuICB9XG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHksIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKCFpbXBvcnRlZElzU3RyaW5nICYmIGlzTWF5YmVUeXBlT25seSkge1xuICAgICAgdGhpcy5wYXJzZVR5cGVPbmx5SW1wb3J0RXhwb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgdHJ1ZSwgaXNJblR5cGVPbmx5SW1wb3J0KTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkltcG9ydFNwZWNpZmllclwiKTtcbiAgICB9XG4gICAgc3BlY2lmaWVyLmltcG9ydEtpbmQgPSBcInZhbHVlXCI7XG4gICAgcmV0dXJuIHN1cGVyLnBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHksIGlzSW5UeXBlT25seUltcG9ydCA/IDQwOTggOiA0MDk2KTtcbiAgfVxuICBwYXJzZVR5cGVPbmx5SW1wb3J0RXhwb3J0U3BlY2lmaWVyKG5vZGUsIGlzSW1wb3J0LCBpc0luVHlwZU9ubHlJbXBvcnRFeHBvcnQpIHtcbiAgICBjb25zdCBsZWZ0T2ZBc0tleSA9IGlzSW1wb3J0ID8gXCJpbXBvcnRlZFwiIDogXCJsb2NhbFwiO1xuICAgIGNvbnN0IHJpZ2h0T2ZBc0tleSA9IGlzSW1wb3J0ID8gXCJsb2NhbFwiIDogXCJleHBvcnRlZFwiO1xuICAgIGxldCBsZWZ0T2ZBcyA9IG5vZGVbbGVmdE9mQXNLZXldO1xuICAgIGxldCByaWdodE9mQXM7XG4gICAgbGV0IGhhc1R5cGVTcGVjaWZpZXIgPSBmYWxzZTtcbiAgICBsZXQgY2FuUGFyc2VBc0tleXdvcmQgPSB0cnVlO1xuICAgIGNvbnN0IGxvYyA9IGxlZnRPZkFzLmxvYy5zdGFydDtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTMpKSB7XG4gICAgICBjb25zdCBmaXJzdEFzID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgIGlmICh0aGlzLmlzQ29udGV4dHVhbCg5MykpIHtcbiAgICAgICAgY29uc3Qgc2Vjb25kQXMgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgICBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgICAgIGhhc1R5cGVTcGVjaWZpZXIgPSB0cnVlO1xuICAgICAgICAgIGxlZnRPZkFzID0gZmlyc3RBcztcbiAgICAgICAgICByaWdodE9mQXMgPSBpc0ltcG9ydCA/IHRoaXMucGFyc2VJZGVudGlmaWVyKCkgOiB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgICAgIGNhblBhcnNlQXNLZXl3b3JkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmlnaHRPZkFzID0gc2Vjb25kQXM7XG4gICAgICAgICAgY2FuUGFyc2VBc0tleXdvcmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIGNhblBhcnNlQXNLZXl3b3JkID0gZmFsc2U7XG4gICAgICAgIHJpZ2h0T2ZBcyA9IGlzSW1wb3J0ID8gdGhpcy5wYXJzZUlkZW50aWZpZXIoKSA6IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoYXNUeXBlU3BlY2lmaWVyID0gdHJ1ZTtcbiAgICAgICAgbGVmdE9mQXMgPSBmaXJzdEFzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKSkge1xuICAgICAgaGFzVHlwZVNwZWNpZmllciA9IHRydWU7XG4gICAgICBpZiAoaXNJbXBvcnQpIHtcbiAgICAgICAgbGVmdE9mQXMgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCg5MykpIHtcbiAgICAgICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKGxlZnRPZkFzLm5hbWUsIGxlZnRPZkFzLmxvYy5zdGFydCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnRPZkFzID0gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc1R5cGVTcGVjaWZpZXIgJiYgaXNJblR5cGVPbmx5SW1wb3J0RXhwb3J0KSB7XG4gICAgICB0aGlzLnJhaXNlKGlzSW1wb3J0ID8gVFNFcnJvcnMuVHlwZU1vZGlmaWVySXNVc2VkSW5UeXBlSW1wb3J0cyA6IFRTRXJyb3JzLlR5cGVNb2RpZmllcklzVXNlZEluVHlwZUV4cG9ydHMsIGxvYyk7XG4gICAgfVxuICAgIG5vZGVbbGVmdE9mQXNLZXldID0gbGVmdE9mQXM7XG4gICAgbm9kZVtyaWdodE9mQXNLZXldID0gcmlnaHRPZkFzO1xuICAgIGNvbnN0IGtpbmRLZXkgPSBpc0ltcG9ydCA/IFwiaW1wb3J0S2luZFwiIDogXCJleHBvcnRLaW5kXCI7XG4gICAgbm9kZVtraW5kS2V5XSA9IGhhc1R5cGVTcGVjaWZpZXIgPyBcInR5cGVcIiA6IFwidmFsdWVcIjtcbiAgICBpZiAoY2FuUGFyc2VBc0tleXdvcmQgJiYgdGhpcy5lYXRDb250ZXh0dWFsKDkzKSkge1xuICAgICAgbm9kZVtyaWdodE9mQXNLZXldID0gaXNJbXBvcnQgPyB0aGlzLnBhcnNlSWRlbnRpZmllcigpIDogdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICB9XG4gICAgaWYgKCFub2RlW3JpZ2h0T2ZBc0tleV0pIHtcbiAgICAgIG5vZGVbcmlnaHRPZkFzS2V5XSA9IHRoaXMuY2xvbmVJZGVudGlmaWVyKG5vZGVbbGVmdE9mQXNLZXldKTtcbiAgICB9XG4gICAgaWYgKGlzSW1wb3J0KSB7XG4gICAgICB0aGlzLmNoZWNrSWRlbnRpZmllcihub2RlW3JpZ2h0T2ZBc0tleV0sIGhhc1R5cGVTcGVjaWZpZXIgPyA0MDk4IDogNDA5Nik7XG4gICAgfVxuICB9XG4gIGZpbGxPcHRpb25hbFByb3BlcnRpZXNGb3JUU0VTTGludChub2RlKSB7XG4gICAgdmFyIF9ub2RlJGRpcmVjdGl2ZSwgX25vZGUkZGVjb3JhdG9ycywgX25vZGUkb3B0aW9uYWwsIF9ub2RlJHR5cGVBbm5vdGF0aW9uLCBfbm9kZSRhY2Nlc3NpYmlsaXR5LCBfbm9kZSRkZWNvcmF0b3JzMiwgX25vZGUkb3ZlcnJpZGUsIF9ub2RlJHJlYWRvbmx5LCBfbm9kZSRzdGF0aWMsIF9ub2RlJGRlY2xhcmUsIF9ub2RlJHJldHVyblR5cGUsIF9ub2RlJHR5cGVQYXJhbWV0ZXJzLCBfbm9kZSRvcHRpb25hbDIsIF9ub2RlJG9wdGlvbmFsMywgX25vZGUkYWNjZXNzaWJpbGl0eTIsIF9ub2RlJHJlYWRvbmx5MiwgX25vZGUkc3RhdGljMiwgX25vZGUkZGVjbGFyZTIsIF9ub2RlJGRlZmluaXRlLCBfbm9kZSRyZWFkb25seTMsIF9ub2RlJHR5cGVBbm5vdGF0aW9uMiwgX25vZGUkYWNjZXNzaWJpbGl0eTMsIF9ub2RlJGRlY29yYXRvcnMzLCBfbm9kZSRvdmVycmlkZTIsIF9ub2RlJG9wdGlvbmFsNCwgX25vZGUkaWQsIF9ub2RlJGFic3RyYWN0LCBfbm9kZSRkZWNsYXJlMywgX25vZGUkZGVjb3JhdG9yczQsIF9ub2RlJGltcGxlbWVudHMsIF9ub2RlJHN1cGVyVHlwZUFyZ3VtZSwgX25vZGUkdHlwZVBhcmFtZXRlcnMyLCBfbm9kZSRkZWNsYXJlNCwgX25vZGUkZGVmaW5pdGUyLCBfbm9kZSRjb25zdCwgX25vZGUkZGVjbGFyZTUsIF9ub2RlJGNvbXB1dGVkLCBfbm9kZSRxdWFsaWZpZXIsIF9ub2RlJG9wdGlvbnMsIF9ub2RlJGRlY2xhcmU2LCBfbm9kZSRleHRlbmRzLCBfbm9kZSRvcHRpb25hbDUsIF9ub2RlJHJlYWRvbmx5NCwgX25vZGUkZGVjbGFyZTcsIF9ub2RlJGdsb2JhbCwgX25vZGUkY29uc3QyLCBfbm9kZSRpbiwgX25vZGUkb3V0O1xuICAgIHN3aXRjaCAobm9kZS50eXBlKSB7XG4gICAgICBjYXNlIFwiRXhwcmVzc2lvblN0YXRlbWVudFwiOlxuICAgICAgICAoX25vZGUkZGlyZWN0aXZlID0gbm9kZS5kaXJlY3RpdmUpICE9IG51bGwgPyBfbm9kZSRkaXJlY3RpdmUgOiBub2RlLmRpcmVjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgICAgIG5vZGUudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgY2FzZSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI6XG4gICAgICBjYXNlIFwiT2JqZWN0UGF0dGVyblwiOlxuICAgICAgICAoX25vZGUkZGVjb3JhdG9ycyA9IG5vZGUuZGVjb3JhdG9ycykgIT0gbnVsbCA/IF9ub2RlJGRlY29yYXRvcnMgOiBub2RlLmRlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgKF9ub2RlJG9wdGlvbmFsID0gbm9kZS5vcHRpb25hbCkgIT0gbnVsbCA/IF9ub2RlJG9wdGlvbmFsIDogbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkdHlwZUFubm90YXRpb24gPSBub2RlLnR5cGVBbm5vdGF0aW9uKSAhPSBudWxsID8gX25vZGUkdHlwZUFubm90YXRpb24gOiBub2RlLnR5cGVBbm5vdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVFNQYXJhbWV0ZXJQcm9wZXJ0eVwiOlxuICAgICAgICAoX25vZGUkYWNjZXNzaWJpbGl0eSA9IG5vZGUuYWNjZXNzaWJpbGl0eSkgIT0gbnVsbCA/IF9ub2RlJGFjY2Vzc2liaWxpdHkgOiBub2RlLmFjY2Vzc2liaWxpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIChfbm9kZSRkZWNvcmF0b3JzMiA9IG5vZGUuZGVjb3JhdG9ycykgIT0gbnVsbCA/IF9ub2RlJGRlY29yYXRvcnMyIDogbm9kZS5kZWNvcmF0b3JzID0gW107XG4gICAgICAgIChfbm9kZSRvdmVycmlkZSA9IG5vZGUub3ZlcnJpZGUpICE9IG51bGwgPyBfbm9kZSRvdmVycmlkZSA6IG5vZGUub3ZlcnJpZGUgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJHJlYWRvbmx5ID0gbm9kZS5yZWFkb25seSkgIT0gbnVsbCA/IF9ub2RlJHJlYWRvbmx5IDogbm9kZS5yZWFkb25seSA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkc3RhdGljID0gbm9kZS5zdGF0aWMpICE9IG51bGwgPyBfbm9kZSRzdGF0aWMgOiBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVFNFbXB0eUJvZHlGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgICAgbm9kZS5ib2R5ID0gbnVsbDtcbiAgICAgIGNhc2UgXCJUU0RlY2xhcmVGdW5jdGlvblwiOlxuICAgICAgY2FzZSBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJGdW5jdGlvbkV4cHJlc3Npb25cIjpcbiAgICAgIGNhc2UgXCJDbGFzc01ldGhvZFwiOlxuICAgICAgY2FzZSBcIkNsYXNzUHJpdmF0ZU1ldGhvZFwiOlxuICAgICAgICAoX25vZGUkZGVjbGFyZSA9IG5vZGUuZGVjbGFyZSkgIT0gbnVsbCA/IF9ub2RlJGRlY2xhcmUgOiBub2RlLmRlY2xhcmUgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJHJldHVyblR5cGUgPSBub2RlLnJldHVyblR5cGUpICE9IG51bGwgPyBfbm9kZSRyZXR1cm5UeXBlIDogbm9kZS5yZXR1cm5UeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICAoX25vZGUkdHlwZVBhcmFtZXRlcnMgPSBub2RlLnR5cGVQYXJhbWV0ZXJzKSAhPSBudWxsID8gX25vZGUkdHlwZVBhcmFtZXRlcnMgOiBub2RlLnR5cGVQYXJhbWV0ZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiUHJvcGVydHlcIjpcbiAgICAgICAgKF9ub2RlJG9wdGlvbmFsMiA9IG5vZGUub3B0aW9uYWwpICE9IG51bGwgPyBfbm9kZSRvcHRpb25hbDIgOiBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU01ldGhvZFNpZ25hdHVyZVwiOlxuICAgICAgY2FzZSBcIlRTUHJvcGVydHlTaWduYXR1cmVcIjpcbiAgICAgICAgKF9ub2RlJG9wdGlvbmFsMyA9IG5vZGUub3B0aW9uYWwpICE9IG51bGwgPyBfbm9kZSRvcHRpb25hbDMgOiBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgICBjYXNlIFwiVFNJbmRleFNpZ25hdHVyZVwiOlxuICAgICAgICAoX25vZGUkYWNjZXNzaWJpbGl0eTIgPSBub2RlLmFjY2Vzc2liaWxpdHkpICE9IG51bGwgPyBfbm9kZSRhY2Nlc3NpYmlsaXR5MiA6IG5vZGUuYWNjZXNzaWJpbGl0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgKF9ub2RlJHJlYWRvbmx5MiA9IG5vZGUucmVhZG9ubHkpICE9IG51bGwgPyBfbm9kZSRyZWFkb25seTIgOiBub2RlLnJlYWRvbmx5ID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRzdGF0aWMyID0gbm9kZS5zdGF0aWMpICE9IG51bGwgPyBfbm9kZSRzdGF0aWMyIDogbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlRTQWJzdHJhY3RQcm9wZXJ0eURlZmluaXRpb25cIjpcbiAgICAgIGNhc2UgXCJQcm9wZXJ0eURlZmluaXRpb25cIjpcbiAgICAgIGNhc2UgXCJUU0Fic3RyYWN0QWNjZXNzb3JQcm9wZXJ0eVwiOlxuICAgICAgY2FzZSBcIkFjY2Vzc29yUHJvcGVydHlcIjpcbiAgICAgICAgKF9ub2RlJGRlY2xhcmUyID0gbm9kZS5kZWNsYXJlKSAhPSBudWxsID8gX25vZGUkZGVjbGFyZTIgOiBub2RlLmRlY2xhcmUgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJGRlZmluaXRlID0gbm9kZS5kZWZpbml0ZSkgIT0gbnVsbCA/IF9ub2RlJGRlZmluaXRlIDogbm9kZS5kZWZpbml0ZSA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkcmVhZG9ubHkzID0gbm9kZS5yZWFkb25seSkgIT0gbnVsbCA/IF9ub2RlJHJlYWRvbmx5MyA6IG5vZGUucmVhZG9ubHkgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJHR5cGVBbm5vdGF0aW9uMiA9IG5vZGUudHlwZUFubm90YXRpb24pICE9IG51bGwgPyBfbm9kZSR0eXBlQW5ub3RhdGlvbjIgOiBub2RlLnR5cGVBbm5vdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgY2FzZSBcIlRTQWJzdHJhY3RNZXRob2REZWZpbml0aW9uXCI6XG4gICAgICBjYXNlIFwiTWV0aG9kRGVmaW5pdGlvblwiOlxuICAgICAgICAoX25vZGUkYWNjZXNzaWJpbGl0eTMgPSBub2RlLmFjY2Vzc2liaWxpdHkpICE9IG51bGwgPyBfbm9kZSRhY2Nlc3NpYmlsaXR5MyA6IG5vZGUuYWNjZXNzaWJpbGl0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgKF9ub2RlJGRlY29yYXRvcnMzID0gbm9kZS5kZWNvcmF0b3JzKSAhPSBudWxsID8gX25vZGUkZGVjb3JhdG9yczMgOiBub2RlLmRlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgKF9ub2RlJG92ZXJyaWRlMiA9IG5vZGUub3ZlcnJpZGUpICE9IG51bGwgPyBfbm9kZSRvdmVycmlkZTIgOiBub2RlLm92ZXJyaWRlID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRvcHRpb25hbDQgPSBub2RlLm9wdGlvbmFsKSAhPSBudWxsID8gX25vZGUkb3B0aW9uYWw0IDogbm9kZS5vcHRpb25hbCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiQ2xhc3NFeHByZXNzaW9uXCI6XG4gICAgICAgIChfbm9kZSRpZCA9IG5vZGUuaWQpICE9IG51bGwgPyBfbm9kZSRpZCA6IG5vZGUuaWQgPSBudWxsO1xuICAgICAgY2FzZSBcIkNsYXNzRGVjbGFyYXRpb25cIjpcbiAgICAgICAgKF9ub2RlJGFic3RyYWN0ID0gbm9kZS5hYnN0cmFjdCkgIT0gbnVsbCA/IF9ub2RlJGFic3RyYWN0IDogbm9kZS5hYnN0cmFjdCA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkZGVjbGFyZTMgPSBub2RlLmRlY2xhcmUpICE9IG51bGwgPyBfbm9kZSRkZWNsYXJlMyA6IG5vZGUuZGVjbGFyZSA9IGZhbHNlO1xuICAgICAgICAoX25vZGUkZGVjb3JhdG9yczQgPSBub2RlLmRlY29yYXRvcnMpICE9IG51bGwgPyBfbm9kZSRkZWNvcmF0b3JzNCA6IG5vZGUuZGVjb3JhdG9ycyA9IFtdO1xuICAgICAgICAoX25vZGUkaW1wbGVtZW50cyA9IG5vZGUuaW1wbGVtZW50cykgIT0gbnVsbCA/IF9ub2RlJGltcGxlbWVudHMgOiBub2RlLmltcGxlbWVudHMgPSBbXTtcbiAgICAgICAgKF9ub2RlJHN1cGVyVHlwZUFyZ3VtZSA9IG5vZGUuc3VwZXJUeXBlQXJndW1lbnRzKSAhPSBudWxsID8gX25vZGUkc3VwZXJUeXBlQXJndW1lIDogbm9kZS5zdXBlclR5cGVBcmd1bWVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIChfbm9kZSR0eXBlUGFyYW1ldGVyczIgPSBub2RlLnR5cGVQYXJhbWV0ZXJzKSAhPSBudWxsID8gX25vZGUkdHlwZVBhcmFtZXRlcnMyIDogbm9kZS50eXBlUGFyYW1ldGVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIjpcbiAgICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0aW9uXCI6XG4gICAgICAgIChfbm9kZSRkZWNsYXJlNCA9IG5vZGUuZGVjbGFyZSkgIT0gbnVsbCA/IF9ub2RlJGRlY2xhcmU0IDogbm9kZS5kZWNsYXJlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJWYXJpYWJsZURlY2xhcmF0b3JcIjpcbiAgICAgICAgKF9ub2RlJGRlZmluaXRlMiA9IG5vZGUuZGVmaW5pdGUpICE9IG51bGwgPyBfbm9kZSRkZWZpbml0ZTIgOiBub2RlLmRlZmluaXRlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU0VudW1EZWNsYXJhdGlvblwiOlxuICAgICAgICAoX25vZGUkY29uc3QgPSBub2RlLmNvbnN0KSAhPSBudWxsID8gX25vZGUkY29uc3QgOiBub2RlLmNvbnN0ID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRkZWNsYXJlNSA9IG5vZGUuZGVjbGFyZSkgIT0gbnVsbCA/IF9ub2RlJGRlY2xhcmU1IDogbm9kZS5kZWNsYXJlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU0VudW1NZW1iZXJcIjpcbiAgICAgICAgKF9ub2RlJGNvbXB1dGVkID0gbm9kZS5jb21wdXRlZCkgIT0gbnVsbCA/IF9ub2RlJGNvbXB1dGVkIDogbm9kZS5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiVFNJbXBvcnRUeXBlXCI6XG4gICAgICAgIChfbm9kZSRxdWFsaWZpZXIgPSBub2RlLnF1YWxpZmllcikgIT0gbnVsbCA/IF9ub2RlJHF1YWxpZmllciA6IG5vZGUucXVhbGlmaWVyID0gbnVsbDtcbiAgICAgICAgKF9ub2RlJG9wdGlvbnMgPSBub2RlLm9wdGlvbnMpICE9IG51bGwgPyBfbm9kZSRvcHRpb25zIDogbm9kZS5vcHRpb25zID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIjpcbiAgICAgICAgKF9ub2RlJGRlY2xhcmU2ID0gbm9kZS5kZWNsYXJlKSAhPSBudWxsID8gX25vZGUkZGVjbGFyZTYgOiBub2RlLmRlY2xhcmUgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJGV4dGVuZHMgPSBub2RlLmV4dGVuZHMpICE9IG51bGwgPyBfbm9kZSRleHRlbmRzIDogbm9kZS5leHRlbmRzID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU01hcHBlZFR5cGVcIjpcbiAgICAgICAgKF9ub2RlJG9wdGlvbmFsNSA9IG5vZGUub3B0aW9uYWwpICE9IG51bGwgPyBfbm9kZSRvcHRpb25hbDUgOiBub2RlLm9wdGlvbmFsID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRyZWFkb25seTQgPSBub2RlLnJlYWRvbmx5KSAhPSBudWxsID8gX25vZGUkcmVhZG9ubHk0IDogbm9kZS5yZWFkb25seSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcIlRTTW9kdWxlRGVjbGFyYXRpb25cIjpcbiAgICAgICAgKF9ub2RlJGRlY2xhcmU3ID0gbm9kZS5kZWNsYXJlKSAhPSBudWxsID8gX25vZGUkZGVjbGFyZTcgOiBub2RlLmRlY2xhcmUgPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJGdsb2JhbCA9IG5vZGUuZ2xvYmFsKSAhPSBudWxsID8gX25vZGUkZ2xvYmFsIDogbm9kZS5nbG9iYWwgPSBub2RlLmtpbmQgPT09IFwiZ2xvYmFsXCI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgXCJUU1R5cGVQYXJhbWV0ZXJcIjpcbiAgICAgICAgKF9ub2RlJGNvbnN0MiA9IG5vZGUuY29uc3QpICE9IG51bGwgPyBfbm9kZSRjb25zdDIgOiBub2RlLmNvbnN0ID0gZmFsc2U7XG4gICAgICAgIChfbm9kZSRpbiA9IG5vZGUuaW4pICE9IG51bGwgPyBfbm9kZSRpbiA6IG5vZGUuaW4gPSBmYWxzZTtcbiAgICAgICAgKF9ub2RlJG91dCA9IG5vZGUub3V0KSAhPSBudWxsID8gX25vZGUkb3V0IDogbm9kZS5vdXQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBjaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyQW5kTm90UmVsYXRpb25hbE9wZXJhdG9yKGNoLCBwb3MpIHtcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICBrZXl3b3JkQW5kVFNSZWxhdGlvbmFsT3BlcmF0b3IubGFzdEluZGV4ID0gcG9zO1xuICAgICAgaWYgKGtleXdvcmRBbmRUU1JlbGF0aW9uYWxPcGVyYXRvci50ZXN0KHRoaXMuaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IGVuZENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhrZXl3b3JkQW5kVFNSZWxhdGlvbmFsT3BlcmF0b3IubGFzdEluZGV4KTtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJDaGFyKGVuZENoKSAmJiBlbmRDaCAhPT0gOTIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBuZXh0VG9rZW5Jc0lkZW50aWZpZXJBbmROb3RUU1JlbGF0aW9uYWxPcGVyYXRvck9uU2FtZUxpbmUoKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKTtcbiAgICBjb25zdCBuZXh0Q2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHQpO1xuICAgIHJldHVybiB0aGlzLmNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXJBbmROb3RSZWxhdGlvbmFsT3BlcmF0b3IobmV4dENoLCBuZXh0KTtcbiAgfVxuICBuZXh0VG9rZW5Jc0lkZW50aWZpZXJPclN0cmluZ0xpdGVyYWxPblNhbWVMaW5lKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlbkluTGluZVN0YXJ0KCk7XG4gICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICByZXR1cm4gdGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCkgfHwgbmV4dENoID09PSAzNCB8fCBuZXh0Q2ggPT09IDM5O1xuICB9XG59O1xuZnVuY3Rpb24gaXNQb3NzaWJseUxpdGVyYWxFbnVtKGV4cHJlc3Npb24pIHtcbiAgaWYgKGV4cHJlc3Npb24udHlwZSAhPT0gXCJNZW1iZXJFeHByZXNzaW9uXCIpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qge1xuICAgIGNvbXB1dGVkLFxuICAgIHByb3BlcnR5XG4gIH0gPSBleHByZXNzaW9uO1xuICBpZiAoY29tcHV0ZWQgJiYgcHJvcGVydHkudHlwZSAhPT0gXCJTdHJpbmdMaXRlcmFsXCIgJiYgKHByb3BlcnR5LnR5cGUgIT09IFwiVGVtcGxhdGVMaXRlcmFsXCIgfHwgcHJvcGVydHkuZXhwcmVzc2lvbnMubGVuZ3RoID4gMCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzVW5jb21wdXRlZE1lbWJlckV4cHJlc3Npb25DaGFpbihleHByZXNzaW9uLm9iamVjdCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkQW1iaWVudENvbnN0SW5pdGlhbGl6ZXIoZXhwcmVzc2lvbiwgZXN0cmVlKSB7XG4gIHZhciBfZXhwcmVzc2lvbiRleHRyYTtcbiAgY29uc3Qge1xuICAgIHR5cGVcbiAgfSA9IGV4cHJlc3Npb247XG4gIGlmICgoX2V4cHJlc3Npb24kZXh0cmEgPSBleHByZXNzaW9uLmV4dHJhKSAhPSBudWxsICYmIF9leHByZXNzaW9uJGV4dHJhLnBhcmVudGhlc2l6ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGVzdHJlZSkge1xuICAgIGlmICh0eXBlID09PSBcIkxpdGVyYWxcIikge1xuICAgICAgY29uc3Qge1xuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IGV4cHJlc3Npb247XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlID09PSBcIlN0cmluZ0xpdGVyYWxcIiB8fCB0eXBlID09PSBcIkJvb2xlYW5MaXRlcmFsXCIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNOdW1iZXIoZXhwcmVzc2lvbiwgZXN0cmVlKSB8fCBpc05lZ2F0aXZlTnVtYmVyKGV4cHJlc3Npb24sIGVzdHJlZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJUZW1wbGF0ZUxpdGVyYWxcIiAmJiBleHByZXNzaW9uLmV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc1Bvc3NpYmx5TGl0ZXJhbEVudW0oZXhwcmVzc2lvbikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc051bWJlcihleHByZXNzaW9uLCBlc3RyZWUpIHtcbiAgaWYgKGVzdHJlZSkge1xuICAgIHJldHVybiBleHByZXNzaW9uLnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmICh0eXBlb2YgZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBcImJpZ2ludFwiIGluIGV4cHJlc3Npb24pO1xuICB9XG4gIHJldHVybiBleHByZXNzaW9uLnR5cGUgPT09IFwiTnVtZXJpY0xpdGVyYWxcIiB8fCBleHByZXNzaW9uLnR5cGUgPT09IFwiQmlnSW50TGl0ZXJhbFwiO1xufVxuZnVuY3Rpb24gaXNOZWdhdGl2ZU51bWJlcihleHByZXNzaW9uLCBlc3RyZWUpIHtcbiAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gXCJVbmFyeUV4cHJlc3Npb25cIikge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdG9yLFxuICAgICAgYXJndW1lbnRcbiAgICB9ID0gZXhwcmVzc2lvbjtcbiAgICBpZiAob3BlcmF0b3IgPT09IFwiLVwiICYmIGlzTnVtYmVyKGFyZ3VtZW50LCBlc3RyZWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNVbmNvbXB1dGVkTWVtYmVyRXhwcmVzc2lvbkNoYWluKGV4cHJlc3Npb24pIHtcbiAgaWYgKGV4cHJlc3Npb24udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHJldHVybiB0cnVlO1xuICBpZiAoZXhwcmVzc2lvbi50eXBlICE9PSBcIk1lbWJlckV4cHJlc3Npb25cIiB8fCBleHByZXNzaW9uLmNvbXB1dGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc1VuY29tcHV0ZWRNZW1iZXJFeHByZXNzaW9uQ2hhaW4oZXhwcmVzc2lvbi5vYmplY3QpO1xufVxuY29uc3QgUGxhY2Vob2xkZXJFcnJvcnMgPSBQYXJzZUVycm9yRW51bWBwbGFjZWhvbGRlcnNgKHtcbiAgQ2xhc3NOYW1lSXNSZXF1aXJlZDogXCJBIGNsYXNzIG5hbWUgaXMgcmVxdWlyZWQuXCIsXG4gIFVuZXhwZWN0ZWRTcGFjZTogXCJVbmV4cGVjdGVkIHNwYWNlIGluIHBsYWNlaG9sZGVyLlwiXG59KTtcbnZhciBwbGFjZWhvbGRlcnMgPSBzdXBlckNsYXNzID0+IGNsYXNzIFBsYWNlaG9sZGVyc1BhcnNlck1peGluIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gIHBhcnNlUGxhY2Vob2xkZXIoZXhwZWN0ZWROb2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goMTMzKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHRoaXMuYXNzZXJ0Tm9TcGFjZSgpO1xuICAgICAgbm9kZS5uYW1lID0gc3VwZXIucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgdGhpcy5hc3NlcnROb1NwYWNlKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxMzMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoUGxhY2Vob2xkZXIobm9kZSwgZXhwZWN0ZWROb2RlKTtcbiAgICB9XG4gIH1cbiAgZmluaXNoUGxhY2Vob2xkZXIobm9kZSwgZXhwZWN0ZWROb2RlKSB7XG4gICAgbGV0IHBsYWNlaG9sZGVyID0gbm9kZTtcbiAgICBpZiAoIXBsYWNlaG9sZGVyLmV4cGVjdGVkTm9kZSB8fCAhcGxhY2Vob2xkZXIudHlwZSkge1xuICAgICAgcGxhY2Vob2xkZXIgPSB0aGlzLmZpbmlzaE5vZGUocGxhY2Vob2xkZXIsIFwiUGxhY2Vob2xkZXJcIik7XG4gICAgfVxuICAgIHBsYWNlaG9sZGVyLmV4cGVjdGVkTm9kZSA9IGV4cGVjdGVkTm9kZTtcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gIH1cbiAgZ2V0VG9rZW5Gcm9tQ29kZShjb2RlKSB7XG4gICAgaWYgKGNvZGUgPT09IDM3ICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnN0YXRlLnBvcyArIDEpID09PSAzNykge1xuICAgICAgdGhpcy5maW5pc2hPcCgxMzMsIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5nZXRUb2tlbkZyb21Db2RlKGNvZGUpO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiRXhwcmVzc2lvblwiKSB8fCBzdXBlci5wYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICB9XG4gIHBhcnNlSWRlbnRpZmllcihsaWJlcmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIikgfHwgc3VwZXIucGFyc2VJZGVudGlmaWVyKGxpYmVyYWwpO1xuICB9XG4gIGNoZWNrUmVzZXJ2ZWRXb3JkKHdvcmQsIHN0YXJ0TG9jLCBjaGVja0tleXdvcmRzLCBpc0JpbmRpbmcpIHtcbiAgICBpZiAod29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdXBlci5jaGVja1Jlc2VydmVkV29yZCh3b3JkLCBzdGFydExvYywgY2hlY2tLZXl3b3JkcywgaXNCaW5kaW5nKTtcbiAgICB9XG4gIH1cbiAgY2xvbmVJZGVudGlmaWVyKG5vZGUpIHtcbiAgICBjb25zdCBjbG9uZWQgPSBzdXBlci5jbG9uZUlkZW50aWZpZXIobm9kZSk7XG4gICAgaWYgKGNsb25lZC50eXBlID09PSBcIlBsYWNlaG9sZGVyXCIpIHtcbiAgICAgIGNsb25lZC5leHBlY3RlZE5vZGUgPSBub2RlLmV4cGVjdGVkTm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbiAgfVxuICBjbG9uZVN0cmluZ0xpdGVyYWwobm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIikge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvbmVJZGVudGlmaWVyKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuY2xvbmVTdHJpbmdMaXRlcmFsKG5vZGUpO1xuICB9XG4gIHBhcnNlQmluZGluZ0F0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIlBhdHRlcm5cIikgfHwgc3VwZXIucGFyc2VCaW5kaW5nQXRvbSgpO1xuICB9XG4gIGlzVmFsaWRMVmFsKHR5cGUsIGRpc2FsbG93Q2FsbEV4cHJlc3Npb24sIGlzUGFyZW50aGVzaXplZCwgYmluZGluZykge1xuICAgIHJldHVybiB0eXBlID09PSBcIlBsYWNlaG9sZGVyXCIgfHwgc3VwZXIuaXNWYWxpZExWYWwodHlwZSwgZGlzYWxsb3dDYWxsRXhwcmVzc2lvbiwgaXNQYXJlbnRoZXNpemVkLCBiaW5kaW5nKTtcbiAgfVxuICB0b0Fzc2lnbmFibGUobm9kZSwgaXNMSFMpIHtcbiAgICBpZiAobm9kZSAmJiBub2RlLnR5cGUgPT09IFwiUGxhY2Vob2xkZXJcIiAmJiBub2RlLmV4cGVjdGVkTm9kZSA9PT0gXCJFeHByZXNzaW9uXCIpIHtcbiAgICAgIG5vZGUuZXhwZWN0ZWROb2RlID0gXCJQYXR0ZXJuXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnRvQXNzaWduYWJsZShub2RlLCBpc0xIUyk7XG4gICAgfVxuICB9XG4gIGNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIoY2gsIHBvcykge1xuICAgIGlmIChzdXBlci5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKGNoLCBwb3MpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICBpZiAodGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpID09PSAzNyAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCArIDEpID09PSAzNykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2ZXJpZnlCcmVha0NvbnRpbnVlKG5vZGUsIGlzQnJlYWspIHtcbiAgICB2YXIgX25vZGUkbGFiZWw7XG4gICAgaWYgKCgoX25vZGUkbGFiZWwgPSBub2RlLmxhYmVsKSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkbGFiZWwudHlwZSkgPT09IFwiUGxhY2Vob2xkZXJcIikgcmV0dXJuO1xuICAgIHN1cGVyLnZlcmlmeUJyZWFrQ29udGludWUobm9kZSwgaXNCcmVhayk7XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIHtcbiAgICB2YXIgX2V4cHIkZXh0cmE7XG4gICAgaWYgKGV4cHIudHlwZSAhPT0gXCJQbGFjZWhvbGRlclwiIHx8IChfZXhwciRleHRyYSA9IGV4cHIuZXh0cmEpICE9IG51bGwgJiYgX2V4cHIkZXh0cmEucGFyZW50aGVzaXplZCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByKTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goMTQpKSB7XG4gICAgICBjb25zdCBzdG10ID0gbm9kZTtcbiAgICAgIHN0bXQubGFiZWwgPSB0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKGV4cHIsIFwiSWRlbnRpZmllclwiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgc3RtdC5ib2R5ID0gc3VwZXIucGFyc2VTdGF0ZW1lbnRPclNsb3BweUFubmV4QkZ1bmN0aW9uRGVjbGFyYXRpb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoc3RtdCwgXCJMYWJlbGVkU3RhdGVtZW50XCIpO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIGNvbnN0IHN0bXRQbGFjZWhvbGRlciA9IG5vZGU7XG4gICAgc3RtdFBsYWNlaG9sZGVyLm5hbWUgPSBleHByLm5hbWU7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoUGxhY2Vob2xkZXIoc3RtdFBsYWNlaG9sZGVyLCBcIlN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUJsb2NrKGFsbG93RGlyZWN0aXZlcywgY3JlYXRlTmV3TGV4aWNhbFNjb3BlLCBhZnRlckJsb2NrUGFyc2UpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWNlaG9sZGVyKFwiQmxvY2tTdGF0ZW1lbnRcIikgfHwgc3VwZXIucGFyc2VCbG9jayhhbGxvd0RpcmVjdGl2ZXMsIGNyZWF0ZU5ld0xleGljYWxTY29wZSwgYWZ0ZXJCbG9ja1BhcnNlKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uSWQocmVxdWlyZUlkKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIikgfHwgc3VwZXIucGFyc2VGdW5jdGlvbklkKHJlcXVpcmVJZCk7XG4gIH1cbiAgcGFyc2VDbGFzcyhub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCkge1xuICAgIGNvbnN0IHR5cGUgPSBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIjtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICBjb25zdCBwbGFjZWhvbGRlciA9IHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIklkZW50aWZpZXJcIik7XG4gICAgaWYgKHBsYWNlaG9sZGVyKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaCg4MSkgfHwgdGhpcy5tYXRjaCgxMzMpIHx8IHRoaXMubWF0Y2goNSkpIHtcbiAgICAgICAgbm9kZS5pZCA9IHBsYWNlaG9sZGVyO1xuICAgICAgfSBlbHNlIGlmIChvcHRpb25hbElkIHx8ICFpc1N0YXRlbWVudCkge1xuICAgICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgICAgbm9kZS5ib2R5ID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgXCJDbGFzc0JvZHlcIik7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKFBsYWNlaG9sZGVyRXJyb3JzLkNsYXNzTmFtZUlzUmVxdWlyZWQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCk7XG4gICAgfVxuICAgIHN1cGVyLnBhcnNlQ2xhc3NTdXBlcihub2RlKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJDbGFzc0JvZHlcIikgfHwgc3VwZXIucGFyc2VDbGFzc0JvZHkoISFub2RlLnN1cGVyQ2xhc3MsIG9sZFN0cmljdCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuICBwYXJzZUV4cG9ydChub2RlLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghcGxhY2Vob2xkZXIpIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydChub2RlLCBkZWNvcmF0b3JzKTtcbiAgICBjb25zdCBub2RlMiA9IG5vZGU7XG4gICAgaWYgKCF0aGlzLmlzQ29udGV4dHVhbCg5OCkgJiYgIXRoaXMubWF0Y2goMTIpKSB7XG4gICAgICBub2RlMi5zcGVjaWZpZXJzID0gW107XG4gICAgICBub2RlMi5zb3VyY2UgPSBudWxsO1xuICAgICAgbm9kZTIuZGVjbGFyYXRpb24gPSB0aGlzLmZpbmlzaFBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyLCBcIkRlY2xhcmF0aW9uXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgICB0aGlzLmV4cGVjdFBsdWdpbihcImV4cG9ydERlZmF1bHRGcm9tXCIpO1xuICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgc3BlY2lmaWVyLmV4cG9ydGVkID0gcGxhY2Vob2xkZXI7XG4gICAgbm9kZTIuc3BlY2lmaWVycyA9IFt0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCBcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIildO1xuICAgIHJldHVybiBzdXBlci5wYXJzZUV4cG9ydChub2RlMiwgZGVjb3JhdG9ycyk7XG4gIH1cbiAgaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkge1xuICAgIGlmICh0aGlzLm1hdGNoKDY1KSkge1xuICAgICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuU3RhcnQoKTtcbiAgICAgIGlmICh0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKG5leHQsIFwiZnJvbVwiKSkge1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5zdGFydHNXaXRoKHRva2VuTGFiZWxOYW1lKDEzMyksIHRoaXMubmV4dFRva2VuU3RhcnRTaW5jZShuZXh0ICsgNCkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzRXhwb3J0RGVmYXVsdFNwZWNpZmllcigpO1xuICB9XG4gIG1heWJlUGFyc2VFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpIHtcbiAgICB2YXIgX3NwZWNpZmllcnM7XG4gICAgaWYgKChfc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVycykgIT0gbnVsbCAmJiBfc3BlY2lmaWVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIubWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gIH1cbiAgY2hlY2tFeHBvcnQobm9kZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNwZWNpZmllcnNcbiAgICB9ID0gbm9kZTtcbiAgICBpZiAoc3BlY2lmaWVycyAhPSBudWxsICYmIHNwZWNpZmllcnMubGVuZ3RoKSB7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBzcGVjaWZpZXJzLmZpbHRlcihub2RlID0+IG5vZGUuZXhwb3J0ZWQudHlwZSA9PT0gXCJQbGFjZWhvbGRlclwiKTtcbiAgICB9XG4gICAgc3VwZXIuY2hlY2tFeHBvcnQobm9kZSk7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gc3BlY2lmaWVycztcbiAgfVxuICBwYXJzZUltcG9ydChub2RlKSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLnBhcnNlUGxhY2Vob2xkZXIoXCJJZGVudGlmaWVyXCIpO1xuICAgIGlmICghcGxhY2Vob2xkZXIpIHJldHVybiBzdXBlci5wYXJzZUltcG9ydChub2RlKTtcbiAgICBub2RlLnNwZWNpZmllcnMgPSBbXTtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDk4KSAmJiAhdGhpcy5tYXRjaCgxMikpIHtcbiAgICAgIG5vZGUuc291cmNlID0gdGhpcy5maW5pc2hQbGFjZWhvbGRlcihwbGFjZWhvbGRlciwgXCJTdHJpbmdMaXRlcmFsXCIpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGVBdE5vZGUocGxhY2Vob2xkZXIpO1xuICAgIHNwZWNpZmllci5sb2NhbCA9IHBsYWNlaG9sZGVyO1xuICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKHRoaXMuZmluaXNoTm9kZShzcGVjaWZpZXIsIFwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiKSk7XG4gICAgaWYgKHRoaXMuZWF0KDEyKSkge1xuICAgICAgY29uc3QgaGFzU3RhckltcG9ydCA9IHRoaXMubWF5YmVQYXJzZVN0YXJJbXBvcnRTcGVjaWZpZXIobm9kZSk7XG4gICAgICBpZiAoIWhhc1N0YXJJbXBvcnQpIHRoaXMucGFyc2VOYW1lZEltcG9ydFNwZWNpZmllcnMobm9kZSk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbCg5OCk7XG4gICAgbm9kZS5zb3VyY2UgPSB0aGlzLnBhcnNlSW1wb3J0U291cmNlKCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIik7XG4gIH1cbiAgcGFyc2VJbXBvcnRTb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VQbGFjZWhvbGRlcihcIlN0cmluZ0xpdGVyYWxcIikgfHwgc3VwZXIucGFyc2VJbXBvcnRTb3VyY2UoKTtcbiAgfVxuICBhc3NlcnROb1NwYWNlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlLnN0YXJ0ID4gdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyh0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MuaW5kZXgpKSB7XG4gICAgICB0aGlzLnJhaXNlKFBsYWNlaG9sZGVyRXJyb3JzLlVuZXhwZWN0ZWRTcGFjZSwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jKTtcbiAgICB9XG4gIH1cbn07XG52YXIgdjhpbnRyaW5zaWMgPSBzdXBlckNsYXNzID0+IGNsYXNzIFY4SW50cmluc2ljTWl4aW4gZXh0ZW5kcyBzdXBlckNsYXNzIHtcbiAgcGFyc2VWOEludHJpbnNpYygpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg1NCkpIHtcbiAgICAgIGNvbnN0IHY4SW50cmluc2ljU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLnBhcnNlSWRlbnRpZmllck5hbWUoKTtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcihub2RlLCBuYW1lKTtcbiAgICAgICAgdGhpcy5jYXN0Tm9kZVRvKGlkZW50aWZpZXIsIFwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCIpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy51bmV4cGVjdGVkKHY4SW50cmluc2ljU3RhcnRMb2MpO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVY4SW50cmluc2ljKCkgfHwgc3VwZXIucGFyc2VFeHByQXRvbShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxufTtcbmNvbnN0IFBJUEVMSU5FX1BST1BPU0FMUyA9IFtcIm1pbmltYWxcIiwgXCJmc2hhcnBcIiwgXCJoYWNrXCIsIFwic21hcnRcIl07XG5jb25zdCBUT1BJQ19UT0tFTlMgPSBbXCJeXlwiLCBcIkBAXCIsIFwiXlwiLCBcIiVcIiwgXCIjXCJdO1xuZnVuY3Rpb24gdmFsaWRhdGVQbHVnaW5zKHBsdWdpbnNNYXApIHtcbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgIGlmIChwbHVnaW5zTWFwLmhhcyhcImRlY29yYXRvcnMtbGVnYWN5XCIpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIHRoZSBkZWNvcmF0b3JzIGFuZCBkZWNvcmF0b3JzLWxlZ2FjeSBwbHVnaW4gdG9nZXRoZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlY29yYXRvcnNCZWZvcmVFeHBvcnQgPSBwbHVnaW5zTWFwLmdldChcImRlY29yYXRvcnNcIikuZGVjb3JhdG9yc0JlZm9yZUV4cG9ydDtcbiAgICBpZiAoZGVjb3JhdG9yc0JlZm9yZUV4cG9ydCAhPSBudWxsICYmIHR5cGVvZiBkZWNvcmF0b3JzQmVmb3JlRXhwb3J0ICE9PSBcImJvb2xlYW5cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2RlY29yYXRvcnNCZWZvcmVFeHBvcnQnIG11c3QgYmUgYSBib29sZWFuLCBpZiBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBhbGxvd0NhbGxQYXJlbnRoZXNpemVkID0gcGx1Z2luc01hcC5nZXQoXCJkZWNvcmF0b3JzXCIpLmFsbG93Q2FsbFBhcmVudGhlc2l6ZWQ7XG4gICAgaWYgKGFsbG93Q2FsbFBhcmVudGhlc2l6ZWQgIT0gbnVsbCAmJiB0eXBlb2YgYWxsb3dDYWxsUGFyZW50aGVzaXplZCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIidhbGxvd0NhbGxQYXJlbnRoZXNpemVkJyBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XG4gICAgfVxuICB9XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcImZsb3dcIikgJiYgcGx1Z2luc01hcC5oYXMoXCJ0eXBlc2NyaXB0XCIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgZmxvdyBhbmQgdHlwZXNjcmlwdCBwbHVnaW5zLlwiKTtcbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJwbGFjZWhvbGRlcnNcIikgJiYgcGx1Z2luc01hcC5oYXMoXCJ2OGludHJpbnNpY1wiKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIHBsYWNlaG9sZGVycyBhbmQgdjhpbnRyaW5zaWMgcGx1Z2lucy5cIik7XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwicGlwZWxpbmVPcGVyYXRvclwiKSkge1xuICAgIHZhciBfcGx1Z2luc01hcCRnZXQyO1xuICAgIGNvbnN0IHByb3Bvc2FsID0gcGx1Z2luc01hcC5nZXQoXCJwaXBlbGluZU9wZXJhdG9yXCIpLnByb3Bvc2FsO1xuICAgIGlmICghUElQRUxJTkVfUFJPUE9TQUxTLmluY2x1ZGVzKHByb3Bvc2FsKSkge1xuICAgICAgY29uc3QgcHJvcG9zYWxMaXN0ID0gUElQRUxJTkVfUFJPUE9TQUxTLm1hcChwID0+IGBcIiR7cH1cImApLmpvaW4oXCIsIFwiKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgXCJwaXBlbGluZU9wZXJhdG9yXCIgcmVxdWlyZXMgXCJwcm9wb3NhbFwiIG9wdGlvbiB3aG9zZSB2YWx1ZSBtdXN0IGJlIG9uZSBvZjogJHtwcm9wb3NhbExpc3R9LmApO1xuICAgIH1cbiAgICBpZiAocHJvcG9zYWwgPT09IFwiaGFja1wiKSB7XG4gICAgICB2YXIgX3BsdWdpbnNNYXAkZ2V0O1xuICAgICAgaWYgKHBsdWdpbnNNYXAuaGFzKFwicGxhY2Vob2xkZXJzXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lIHBsYWNlaG9sZGVycyBwbHVnaW4gYW5kIEhhY2stc3R5bGUgcGlwZXMuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHBsdWdpbnNNYXAuaGFzKFwidjhpbnRyaW5zaWNcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgdjhpbnRyaW5zaWMgcGx1Z2luIGFuZCBIYWNrLXN0eWxlIHBpcGVzLlwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvcGljVG9rZW4gPSBwbHVnaW5zTWFwLmdldChcInBpcGVsaW5lT3BlcmF0b3JcIikudG9waWNUb2tlbjtcbiAgICAgIGlmICghVE9QSUNfVE9LRU5TLmluY2x1ZGVzKHRvcGljVG9rZW4pKSB7XG4gICAgICAgIGNvbnN0IHRva2VuTGlzdCA9IFRPUElDX1RPS0VOUy5tYXAodCA9PiBgXCIke3R9XCJgKS5qb2luKFwiLCBcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJwaXBlbGluZU9wZXJhdG9yXCIgaW4gXCJwcm9wb3NhbFwiOiBcImhhY2tcIiBtb2RlIGFsc28gcmVxdWlyZXMgYSBcInRvcGljVG9rZW5cIiBvcHRpb24gd2hvc2UgdmFsdWUgbXVzdCBiZSBvbmUgb2Y6ICR7dG9rZW5MaXN0fS5gKTtcbiAgICAgIH1cbiAgICAgIGlmICh0b3BpY1Rva2VuID09PSBcIiNcIiAmJiAoKF9wbHVnaW5zTWFwJGdldCA9IHBsdWdpbnNNYXAuZ2V0KFwicmVjb3JkQW5kVHVwbGVcIikpID09IG51bGwgPyB2b2lkIDAgOiBfcGx1Z2luc01hcCRnZXQuc3ludGF4VHlwZSkgPT09IFwiaGFzaFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgUGx1Z2luIGNvbmZsaWN0IGJldHdlZW4gXFxgW1wicGlwZWxpbmVPcGVyYXRvclwiLCB7IHByb3Bvc2FsOiBcImhhY2tcIiwgdG9waWNUb2tlbjogXCIjXCIgfV1cXGAgYW5kIFxcYCR7SlNPTi5zdHJpbmdpZnkoW1wicmVjb3JkQW5kVHVwbGVcIiwgcGx1Z2luc01hcC5nZXQoXCJyZWNvcmRBbmRUdXBsZVwiKV0pfVxcYC5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3Bvc2FsID09PSBcInNtYXJ0XCIgJiYgKChfcGx1Z2luc01hcCRnZXQyID0gcGx1Z2luc01hcC5nZXQoXCJyZWNvcmRBbmRUdXBsZVwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wbHVnaW5zTWFwJGdldDIuc3ludGF4VHlwZSkgPT09IFwiaGFzaFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBsdWdpbiBjb25mbGljdCBiZXR3ZWVuIFxcYFtcInBpcGVsaW5lT3BlcmF0b3JcIiwgeyBwcm9wb3NhbDogXCJzbWFydFwiIH1dXFxgIGFuZCBcXGAke0pTT04uc3RyaW5naWZ5KFtcInJlY29yZEFuZFR1cGxlXCIsIHBsdWdpbnNNYXAuZ2V0KFwicmVjb3JkQW5kVHVwbGVcIildKX1cXGAuYCk7XG4gICAgfVxuICB9XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcIm1vZHVsZUF0dHJpYnV0ZXNcIikpIHtcbiAgICBpZiAocGx1Z2luc01hcC5oYXMoXCJkZXByZWNhdGVkSW1wb3J0QXNzZXJ0XCIpIHx8IHBsdWdpbnNNYXAuaGFzKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgaW1wb3J0QXNzZXJ0aW9ucywgZGVwcmVjYXRlZEltcG9ydEFzc2VydCBhbmQgbW9kdWxlQXR0cmlidXRlcyBwbHVnaW5zLlwiKTtcbiAgICB9XG4gICAgY29uc3QgbW9kdWxlQXR0cmlidXRlc1ZlcnNpb25QbHVnaW5PcHRpb24gPSBwbHVnaW5zTWFwLmdldChcIm1vZHVsZUF0dHJpYnV0ZXNcIikudmVyc2lvbjtcbiAgICBpZiAobW9kdWxlQXR0cmlidXRlc1ZlcnNpb25QbHVnaW5PcHRpb24gIT09IFwibWF5LTIwMjBcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdtb2R1bGVBdHRyaWJ1dGVzJyBwbHVnaW4gcmVxdWlyZXMgYSAndmVyc2lvbicgb3B0aW9uLFwiICsgXCIgcmVwcmVzZW50aW5nIHRoZSBsYXN0IHByb3Bvc2FsIHVwZGF0ZS4gQ3VycmVudGx5LCB0aGVcIiArIFwiIG9ubHkgc3VwcG9ydGVkIHZhbHVlIGlzICdtYXktMjAyMCcuXCIpO1xuICAgIH1cbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJpbXBvcnRBc3NlcnRpb25zXCIpKSB7XG4gICAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiZGVwcmVjYXRlZEltcG9ydEFzc2VydFwiKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbWJpbmUgaW1wb3J0QXNzZXJ0aW9ucyBhbmQgZGVwcmVjYXRlZEltcG9ydEFzc2VydCBwbHVnaW5zLlwiKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwiZGVwcmVjYXRlZEltcG9ydEFzc2VydFwiKSkgO2Vsc2UgaWYgKHBsdWdpbnNNYXAuaGFzKFwiaW1wb3J0QXR0cmlidXRlc1wiKSAmJiBwbHVnaW5zTWFwLmdldChcImltcG9ydEF0dHJpYnV0ZXNcIikuZGVwcmVjYXRlZEFzc2VydFN5bnRheCkge1xuICAgIHBsdWdpbnNNYXAuc2V0KFwiZGVwcmVjYXRlZEltcG9ydEFzc2VydFwiLCB7fSk7XG4gIH1cbiAgaWYgKHBsdWdpbnNNYXAuaGFzKFwicmVjb3JkQW5kVHVwbGVcIikpIHtcbiAgICBjb25zdCBzeW50YXhUeXBlID0gcGx1Z2luc01hcC5nZXQoXCJyZWNvcmRBbmRUdXBsZVwiKS5zeW50YXhUeXBlO1xuICAgIGlmIChzeW50YXhUeXBlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IFJFQ09SRF9BTkRfVFVQTEVfU1lOVEFYX1RZUEVTID0gW1wiaGFzaFwiLCBcImJhclwiXTtcbiAgICAgIGlmICghUkVDT1JEX0FORF9UVVBMRV9TWU5UQVhfVFlQRVMuaW5jbHVkZXMoc3ludGF4VHlwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlICdzeW50YXhUeXBlJyBvcHRpb24gb2YgdGhlICdyZWNvcmRBbmRUdXBsZScgcGx1Z2luIG11c3QgYmUgb25lIG9mOiBcIiArIFJFQ09SRF9BTkRfVFVQTEVfU1lOVEFYX1RZUEVTLm1hcChwID0+IGAnJHtwfSdgKS5qb2luKFwiLCBcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJhc3luY0RvRXhwcmVzc2lvbnNcIikgJiYgIXBsdWdpbnNNYXAuaGFzKFwiZG9FeHByZXNzaW9uc1wiKSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiJ2FzeW5jRG9FeHByZXNzaW9ucycgcmVxdWlyZXMgJ2RvRXhwcmVzc2lvbnMnLCBwbGVhc2UgYWRkICdkb0V4cHJlc3Npb25zJyB0byBwYXJzZXIgcGx1Z2lucy5cIik7XG4gICAgZXJyb3IubWlzc2luZ1BsdWdpbnMgPSBcImRvRXhwcmVzc2lvbnNcIjtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxuICBpZiAocGx1Z2luc01hcC5oYXMoXCJvcHRpb25hbENoYWluaW5nQXNzaWduXCIpICYmIHBsdWdpbnNNYXAuZ2V0KFwib3B0aW9uYWxDaGFpbmluZ0Fzc2lnblwiKS52ZXJzaW9uICE9PSBcIjIwMjMtMDdcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSAnb3B0aW9uYWxDaGFpbmluZ0Fzc2lnbicgcGx1Z2luIHJlcXVpcmVzIGEgJ3ZlcnNpb24nIG9wdGlvbixcIiArIFwiIHJlcHJlc2VudGluZyB0aGUgbGFzdCBwcm9wb3NhbCB1cGRhdGUuIEN1cnJlbnRseSwgdGhlXCIgKyBcIiBvbmx5IHN1cHBvcnRlZCB2YWx1ZSBpcyAnMjAyMy0wNycuXCIpO1xuICB9XG4gIGlmIChwbHVnaW5zTWFwLmhhcyhcImRpc2NhcmRCaW5kaW5nXCIpICYmIHBsdWdpbnNNYXAuZ2V0KFwiZGlzY2FyZEJpbmRpbmdcIikuc3ludGF4VHlwZSAhPT0gXCJ2b2lkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ2Rpc2NhcmRCaW5kaW5nJyBwbHVnaW4gcmVxdWlyZXMgYSAnc3ludGF4VHlwZScgb3B0aW9uLiBDdXJyZW50bHkgdGhlIG9ubHkgc3VwcG9ydGVkIHZhbHVlIGlzICd2b2lkJy5cIik7XG4gIH1cbn1cbmNvbnN0IG1peGluUGx1Z2lucyA9IHtcbiAgZXN0cmVlLFxuICBqc3gsXG4gIGZsb3csXG4gIHR5cGVzY3JpcHQsXG4gIHY4aW50cmluc2ljLFxuICBwbGFjZWhvbGRlcnNcbn07XG5jb25zdCBtaXhpblBsdWdpbk5hbWVzID0gT2JqZWN0LmtleXMobWl4aW5QbHVnaW5zKTtcbmNsYXNzIEV4cHJlc3Npb25QYXJzZXIgZXh0ZW5kcyBMVmFsUGFyc2VyIHtcbiAgY2hlY2tQcm90byhwcm9wLCBpc1JlY29yZCwgc2F3UHJvdG8sIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAocHJvcC50eXBlID09PSBcIlNwcmVhZEVsZW1lbnRcIiB8fCB0aGlzLmlzT2JqZWN0TWV0aG9kKHByb3ApIHx8IHByb3AuY29tcHV0ZWQgfHwgcHJvcC5zaG9ydGhhbmQpIHtcbiAgICAgIHJldHVybiBzYXdQcm90bztcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gcHJvcC5rZXk7XG4gICAgY29uc3QgbmFtZSA9IGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiA/IGtleS5uYW1lIDoga2V5LnZhbHVlO1xuICAgIGlmIChuYW1lID09PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICBpZiAoaXNSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUmVjb3JkTm9Qcm90bywga2V5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoc2F3UHJvdG8pIHtcbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5kb3VibGVQcm90b0xvYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5kb3VibGVQcm90b0xvYyA9IGtleS5sb2Muc3RhcnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkR1cGxpY2F0ZVByb3RvLCBrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNhd1Byb3RvO1xuICB9XG4gIHNob3VsZEV4aXREZXNjZW5kaW5nKGV4cHIsIHBvdGVudGlhbEFycm93QXQpIHtcbiAgICByZXR1cm4gZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5vZmZzZXRUb1NvdXJjZVBvcyhleHByLnN0YXJ0KSA9PT0gcG90ZW50aWFsQXJyb3dBdDtcbiAgfVxuICBnZXRFeHByZXNzaW9uKCkge1xuICAgIHRoaXMuZW50ZXJJbml0aWFsU2NvcGVzKCk7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxNDApKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QYXJzZUV4cHJlc3Npb25FbXB0eUlucHV0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDE0MCkpIHtcbiAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlBhcnNlRXhwcmVzc2lvbkV4cGVjdHNFT0YsIHRoaXMuc3RhdGUuc3RhcnRMb2MsIHtcbiAgICAgICAgdW5leHBlY3RlZDogdGhpcy5pbnB1dC5jb2RlUG9pbnRBdCh0aGlzLnN0YXRlLnN0YXJ0KVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuZmluYWxpemVSZW1haW5pbmdDb21tZW50cygpO1xuICAgIGV4cHIuY29tbWVudHMgPSB0aGlzLmNvbW1lbnRzO1xuICAgIGV4cHIuZXJyb3JzID0gdGhpcy5zdGF0ZS5lcnJvcnM7XG4gICAgaWYgKHRoaXMub3B0aW9uRmxhZ3MgJiAyNTYpIHtcbiAgICAgIGV4cHIudG9rZW5zID0gdGhpcy50b2tlbnM7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG4gIHBhcnNlRXhwcmVzc2lvbihkaXNhbGxvd0luLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKGRpc2FsbG93SW4pIHtcbiAgICAgIHJldHVybiB0aGlzLmRpc2FsbG93SW5BbmQoKCkgPT4gdGhpcy5wYXJzZUV4cHJlc3Npb25CYXNlKHJlZkV4cHJlc3Npb25FcnJvcnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYWxsb3dJbkFuZCgoKSA9PiB0aGlzLnBhcnNlRXhwcmVzc2lvbkJhc2UocmVmRXhwcmVzc2lvbkVycm9ycykpO1xuICB9XG4gIHBhcnNlRXhwcmVzc2lvbkJhc2UocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICh0aGlzLm1hdGNoKDEyKSkge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICAgIHdoaWxlICh0aGlzLmVhdCgxMikpIHtcbiAgICAgICAgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3Qobm9kZS5leHByZXNzaW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuICBwYXJzZU1heWJlQXNzaWduRGlzYWxsb3dJbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIHJldHVybiB0aGlzLmRpc2FsbG93SW5BbmQoKCkgPT4gdGhpcy5wYXJzZU1heWJlQXNzaWduKHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSk7XG4gIH1cbiAgcGFyc2VNYXliZUFzc2lnbkFsbG93SW4ocmVmRXhwcmVzc2lvbkVycm9ycywgYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd0luQW5kKCgpID0+IHRoaXMucGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkpO1xuICB9XG4gIHNldE9wdGlvbmFsUGFyYW1ldGVyc0Vycm9yKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICByZWZFeHByZXNzaW9uRXJyb3JzLm9wdGlvbmFsUGFyYW1ldGVyc0xvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gIH1cbiAgcGFyc2VNYXliZUFzc2lnbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBpc1lpZWxkID0gdGhpcy5pc0NvbnRleHR1YWwoMTA4KTtcbiAgICBpZiAoaXNZaWVsZCkge1xuICAgICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc1lpZWxkKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMucGFyc2VZaWVsZChzdGFydExvYyk7XG4gICAgICAgIGlmIChhZnRlckxlZnRQYXJzZSkge1xuICAgICAgICAgIGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG93bkV4cHJlc3Npb25FcnJvcnM7XG4gICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIG93bkV4cHJlc3Npb25FcnJvcnMgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycyA9IG5ldyBFeHByZXNzaW9uRXJyb3JzKCk7XG4gICAgICBvd25FeHByZXNzaW9uRXJyb3JzID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSAxMCB8fCB0b2tlbklzSWRlbnRpZmllcih0eXBlKSkge1xuICAgICAgdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5zdGFydDtcbiAgICB9XG4gICAgbGV0IGxlZnQgPSB0aGlzLnBhcnNlTWF5YmVDb25kaXRpb25hbChyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHtcbiAgICAgIGxlZnQgPSBhZnRlckxlZnRQYXJzZS5jYWxsKHRoaXMsIGxlZnQsIHN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKHRva2VuSXNBc3NpZ25tZW50KHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIGNvbnN0IG9wZXJhdG9yID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDI5KSkge1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShsZWZ0LCB0cnVlKTtcbiAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IHN0YXJ0TG9jLmluZGV4O1xuICAgICAgICBpZiAocmVmRXhwcmVzc2lvbkVycm9ycy5kb3VibGVQcm90b0xvYyAhPSBudWxsICYmIHJlZkV4cHJlc3Npb25FcnJvcnMuZG91YmxlUHJvdG9Mb2MuaW5kZXggPj0gc3RhcnRJbmRleCkge1xuICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMuZG91YmxlUHJvdG9Mb2MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnNob3J0aGFuZEFzc2lnbkxvYyAhPSBudWxsICYmIHJlZkV4cHJlc3Npb25FcnJvcnMuc2hvcnRoYW5kQXNzaWduTG9jLmluZGV4ID49IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICByZWZFeHByZXNzaW9uRXJyb3JzLnNob3J0aGFuZEFzc2lnbkxvYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMucHJpdmF0ZUtleUxvYyAhPSBudWxsICYmIHJlZkV4cHJlc3Npb25FcnJvcnMucHJpdmF0ZUtleUxvYy5pbmRleCA+PSBzdGFydEluZGV4KSB7XG4gICAgICAgICAgdGhpcy5jaGVja0Rlc3RydWN0dXJpbmdQcml2YXRlKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMucHJpdmF0ZUtleUxvYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMudm9pZFBhdHRlcm5Mb2MgIT0gbnVsbCAmJiByZWZFeHByZXNzaW9uRXJyb3JzLnZvaWRQYXR0ZXJuTG9jLmluZGV4ID49IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICByZWZFeHByZXNzaW9uRXJyb3JzLnZvaWRQYXR0ZXJuTG9jID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5jaGVja0xWYWwobGVmdCwgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIiksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3BlcmF0b3IgPT09IFwifHw9XCIgfHwgb3BlcmF0b3IgPT09IFwiJiY9XCIgfHwgb3BlcmF0b3IgPT09IFwiPz89XCIpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChvd25FeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGlzWWllbGQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBjb25zdCBzdGFydHNFeHByID0gdGhpcy5oYXNQbHVnaW4oXCJ2OGludHJpbnNpY1wiKSA/IHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHR5cGUpIDogdG9rZW5DYW5TdGFydEV4cHJlc3Npb24odHlwZSkgJiYgIXRoaXMubWF0Y2goNTQpO1xuICAgICAgaWYgKHN0YXJ0c0V4cHIgJiYgIXRoaXMuaXNBbWJpZ3VvdXNQcmVmaXhPcklkZW50aWZpZXIoKSkge1xuICAgICAgICB0aGlzLnJhaXNlT3ZlcndyaXRlKEVycm9ycy5ZaWVsZE5vdEluR2VuZXJhdG9yRnVuY3Rpb24sIHN0YXJ0TG9jKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VZaWVsZChzdGFydExvYyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZWZ0O1xuICB9XG4gIHBhcnNlTWF5YmVDb25kaXRpb25hbChyZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGNvbnN0IHBvdGVudGlhbEFycm93QXQgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQ7XG4gICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmICh0aGlzLnNob3VsZEV4aXREZXNjZW5kaW5nKGV4cHIsIHBvdGVudGlhbEFycm93QXQpKSB7XG4gICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgcGFyc2VDb25kaXRpb25hbChleHByLCBzdGFydExvYywgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGlmICh0aGlzLmVhdCgxNykpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUudGVzdCA9IGV4cHI7XG4gICAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICBub2RlLmFsdGVybmF0ZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cbiAgcGFyc2VNYXliZVVuYXJ5T3JQcml2YXRlKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCgxMzkpID8gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCkgOiB0aGlzLnBhcnNlTWF5YmVVbmFyeShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgfVxuICBwYXJzZUV4cHJPcHMocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBwb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeU9yUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAodGhpcy5zaG91bGRFeGl0RGVzY2VuZGluZyhleHByLCBwb3RlbnRpYWxBcnJvd0F0KSkge1xuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0TG9jLCAtMSk7XG4gIH1cbiAgcGFyc2VFeHByT3AobGVmdCwgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjKSB7XG4gICAgaWYgKHRoaXMuaXNQcml2YXRlTmFtZShsZWZ0KSkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFByaXZhdGVOYW1lU1YobGVmdCk7XG4gICAgICBpZiAobWluUHJlYyA+PSB0b2tlbk9wZXJhdG9yUHJlY2VkZW5jZSg1OCkgfHwgIXRoaXMucHJvZFBhcmFtLmhhc0luIHx8ICF0aGlzLm1hdGNoKDU4KSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Qcml2YXRlSW5FeHBlY3RlZEluLCBsZWZ0LCB7XG4gICAgICAgICAgaWRlbnRpZmllck5hbWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGFzc1Njb3BlLnVzZVByaXZhdGVOYW1lKHZhbHVlLCBsZWZ0LmxvYy5zdGFydCk7XG4gICAgfVxuICAgIGNvbnN0IG9wID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIGlmICh0b2tlbklzT3BlcmF0b3Iob3ApICYmICh0aGlzLnByb2RQYXJhbS5oYXNJbiB8fCAhdGhpcy5tYXRjaCg1OCkpKSB7XG4gICAgICBsZXQgcHJlYyA9IHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKG9wKTtcbiAgICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgICBpZiAob3AgPT09IDM5KSB7XG4gICAgICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJwaXBlbGluZU9wZXJhdG9yXCIpO1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5KSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jaGVja1BpcGVsaW5lQXRJbmZpeE9wZXJhdG9yKGxlZnQsIGxlZnRTdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQobGVmdFN0YXJ0TG9jKTtcbiAgICAgICAgbm9kZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgbm9kZS5vcGVyYXRvciA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgIGNvbnN0IGxvZ2ljYWwgPSBvcCA9PT0gNDEgfHwgb3AgPT09IDQyO1xuICAgICAgICBjb25zdCBjb2FsZXNjZSA9IG9wID09PSA0MDtcbiAgICAgICAgaWYgKGNvYWxlc2NlKSB7XG4gICAgICAgICAgcHJlYyA9IHRva2VuT3BlcmF0b3JQcmVjZWRlbmNlKDQyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKG9wID09PSAzOSAmJiB0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgICAgICBwcm9wb3NhbDogXCJtaW5pbWFsXCJcbiAgICAgICAgfV0pKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUudHlwZSA9PT0gOTYgJiYgdGhpcy5wcm9kUGFyYW0uaGFzQXdhaXQpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRBd2FpdEFmdGVyUGlwZWxpbmVCb2R5LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VFeHByT3BSaWdodEV4cHIob3AsIHByZWMpO1xuICAgICAgICBjb25zdCBmaW5pc2hlZE5vZGUgPSB0aGlzLmZpbmlzaE5vZGUobm9kZSwgbG9naWNhbCB8fCBjb2FsZXNjZSA/IFwiTG9naWNhbEV4cHJlc3Npb25cIiA6IFwiQmluYXJ5RXhwcmVzc2lvblwiKTtcbiAgICAgICAgY29uc3QgbmV4dE9wID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgICAgICBpZiAoY29hbGVzY2UgJiYgKG5leHRPcCA9PT0gNDEgfHwgbmV4dE9wID09PSA0MikgfHwgbG9naWNhbCAmJiBuZXh0T3AgPT09IDQwKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTWl4aW5nQ29hbGVzY2VXaXRoTG9naWNhbCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3AoZmluaXNoZWROb2RlLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVmdDtcbiAgfVxuICBwYXJzZUV4cHJPcFJpZ2h0RXhwcihvcCwgcHJlYykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICBzd2l0Y2ggKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpKSB7XG4gICAgICAgICAgY2FzZSBcImhhY2tcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpdGhUb3BpY0JpbmRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VIYWNrUGlwZUJvZHkoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhc2UgXCJmc2hhcnBcIjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpdGhTb2xvQXdhaXRQZXJtaXR0aW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRlNoYXJwUGlwZWxpbmVCb2R5KHByZWMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpID09PSBcInNtYXJ0XCIpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy53aXRoVG9waWNCaW5kaW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9kUGFyYW0uaGFzWWllbGQgJiYgdGhpcy5pc0NvbnRleHR1YWwoMTA4KSkge1xuICAgICAgICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QaXBlQm9keUlzVGlnaHRlciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNtYXJ0UGlwZWxpbmVCb2R5SW5TdHlsZSh0aGlzLnBhcnNlRXhwck9wQmFzZVJpZ2h0RXhwcihvcCwgcHJlYyksIHN0YXJ0TG9jKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByT3BCYXNlUmlnaHRFeHByKG9wLCBwcmVjKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VFeHByT3BCYXNlUmlnaHRFeHByKG9wLCBwcmVjKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5T3JQcml2YXRlKCksIHN0YXJ0TG9jLCB0b2tlbklzUmlnaHRBc3NvY2lhdGl2ZShvcCkgPyBwcmVjIC0gMSA6IHByZWMpO1xuICB9XG4gIHBhcnNlSGFja1BpcGVCb2R5KCkge1xuICAgIHZhciBfYm9keSRleHRyYTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydExvY1xuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICBjb25zdCByZXF1aXJlZFBhcmVudGhlc2VzID0gVW5wYXJlbnRoZXNpemVkUGlwZUJvZHlEZXNjcmlwdGlvbnMuaGFzKGJvZHkudHlwZSk7XG4gICAgaWYgKHJlcXVpcmVkUGFyZW50aGVzZXMgJiYgISgoX2JvZHkkZXh0cmEgPSBib2R5LmV4dHJhKSAhPSBudWxsICYmIF9ib2R5JGV4dHJhLnBhcmVudGhlc2l6ZWQpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5QaXBlVW5wYXJlbnRoZXNpemVkQm9keSwgc3RhcnRMb2MsIHtcbiAgICAgICAgdHlwZTogYm9keS50eXBlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnRvcGljUmVmZXJlbmNlV2FzVXNlZEluQ3VycmVudENvbnRleHQoKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUGlwZVRvcGljVW51c2VkLCBzdGFydExvYyk7XG4gICAgfVxuICAgIHJldHVybiBib2R5O1xuICB9XG4gIGNoZWNrRXhwb25lbnRpYWxBZnRlclVuYXJ5KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg1NykpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRUb2tlblVuYXJ5RXhwb25lbnRpYXRpb24sIG5vZGUuYXJndW1lbnQpO1xuICAgIH1cbiAgfVxuICBwYXJzZU1heWJlVW5hcnkocmVmRXhwcmVzc2lvbkVycm9ycywgc2F3VW5hcnkpIHtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgaXNBd2FpdCA9IHRoaXMuaXNDb250ZXh0dWFsKDk2KTtcbiAgICBpZiAoaXNBd2FpdCAmJiB0aGlzLnJlY29yZEF3YWl0SWZBbGxvd2VkKCkpIHtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgY29uc3QgZXhwciA9IHRoaXMucGFyc2VBd2FpdChzdGFydExvYyk7XG4gICAgICBpZiAoIXNhd1VuYXJ5KSB0aGlzLmNoZWNrRXhwb25lbnRpYWxBZnRlclVuYXJ5KGV4cHIpO1xuICAgICAgcmV0dXJuIGV4cHI7XG4gICAgfVxuICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMubWF0Y2goMzQpO1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGlmICh0b2tlbklzUHJlZml4KHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSB0cnVlO1xuICAgICAgaWYgKHRoaXMubWF0Y2goNzIpKSB7XG4gICAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwidGhyb3dFeHByZXNzaW9uc1wiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzRGVsZXRlID0gdGhpcy5tYXRjaCg4OSk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVVbmFyeShudWxsLCB0cnVlKTtcbiAgICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuICAgICAgaWYgKHRoaXMuc3RhdGUuc3RyaWN0ICYmIGlzRGVsZXRlKSB7XG4gICAgICAgIGNvbnN0IGFyZyA9IG5vZGUuYXJndW1lbnQ7XG4gICAgICAgIGlmIChhcmcudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5TdHJpY3REZWxldGUsIG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzUHJvcGVydHlBc1ByaXZhdGVOYW1lKGFyZykpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWxldGVQcml2YXRlRmllbGQsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZSkge1xuICAgICAgICBpZiAoIXNhd1VuYXJ5KSB7XG4gICAgICAgICAgdGhpcy5jaGVja0V4cG9uZW50aWFsQWZ0ZXJVbmFyeShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBleHByID0gdGhpcy5wYXJzZVVwZGF0ZShub2RlLCB1cGRhdGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGlmIChpc0F3YWl0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3Qgc3RhcnRzRXhwciA9IHRoaXMuaGFzUGx1Z2luKFwidjhpbnRyaW5zaWNcIikgPyB0b2tlbkNhblN0YXJ0RXhwcmVzc2lvbih0eXBlKSA6IHRva2VuQ2FuU3RhcnRFeHByZXNzaW9uKHR5cGUpICYmICF0aGlzLm1hdGNoKDU0KTtcbiAgICAgIGlmIChzdGFydHNFeHByICYmICF0aGlzLmlzQW1iaWd1b3VzUHJlZml4T3JJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgdGhpcy5yYWlzZU92ZXJ3cml0ZShFcnJvcnMuQXdhaXROb3RJbkFzeW5jQ29udGV4dCwgc3RhcnRMb2MpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUF3YWl0KHN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG4gIH1cbiAgcGFyc2VVcGRhdGUobm9kZSwgdXBkYXRlLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKHVwZGF0ZSkge1xuICAgICAgY29uc3QgdXBkYXRlRXhwcmVzc2lvbk5vZGUgPSBub2RlO1xuICAgICAgdGhpcy5jaGVja0xWYWwodXBkYXRlRXhwcmVzc2lvbk5vZGUuYXJndW1lbnQsIHRoaXMuZmluaXNoTm9kZSh1cGRhdGVFeHByZXNzaW9uTm9kZSwgXCJVcGRhdGVFeHByZXNzaW9uXCIpKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgbGV0IGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIGZhbHNlKSkgcmV0dXJuIGV4cHI7XG4gICAgd2hpbGUgKHRva2VuSXNQb3N0Zml4KHRoaXMuc3RhdGUudHlwZSkgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgbm9kZS5wcmVmaXggPSBmYWxzZTtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSBleHByO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmNoZWNrTFZhbChleHByLCBleHByID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVXBkYXRlRXhwcmVzc2lvblwiKSk7XG4gICAgfVxuICAgIHJldHVybiBleHByO1xuICB9XG4gIHBhcnNlRXhwclN1YnNjcmlwdHMocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICBjb25zdCBwb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGF0ZS5wb3RlbnRpYWxBcnJvd0F0O1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgaWYgKHRoaXMuc2hvdWxkRXhpdERlc2NlbmRpbmcoZXhwciwgcG90ZW50aWFsQXJyb3dBdCkpIHtcbiAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHMoZXhwciwgc3RhcnRMb2MpO1xuICB9XG4gIHBhcnNlU3Vic2NyaXB0cyhiYXNlLCBzdGFydExvYywgbm9DYWxscykge1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgb3B0aW9uYWxDaGFpbk1lbWJlcjogZmFsc2UsXG4gICAgICBtYXliZUFzeW5jQXJyb3c6IHRoaXMuYXRQb3NzaWJsZUFzeW5jQXJyb3coYmFzZSksXG4gICAgICBzdG9wOiBmYWxzZVxuICAgIH07XG4gICAgZG8ge1xuICAgICAgYmFzZSA9IHRoaXMucGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgICAgIHN0YXRlLm1heWJlQXN5bmNBcnJvdyA9IGZhbHNlO1xuICAgIH0gd2hpbGUgKCFzdGF0ZS5zdG9wKTtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBwYXJzZVN1YnNjcmlwdChiYXNlLCBzdGFydExvYywgbm9DYWxscywgc3RhdGUpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFub0NhbGxzICYmIHR5cGUgPT09IDE1KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUJpbmQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuSXNUZW1wbGF0ZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oYmFzZSwgc3RhcnRMb2MsIHN0YXRlKTtcbiAgICB9XG4gICAgbGV0IG9wdGlvbmFsID0gZmFsc2U7XG4gICAgaWYgKHR5cGUgPT09IDE4KSB7XG4gICAgICBpZiAobm9DYWxscykge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5PcHRpb25hbENoYWluaW5nTm9OZXcsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICBpZiAodGhpcy5sb29rYWhlYWRDaGFyQ29kZSgpID09PSA0MCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnN0b3BQYXJzZVN1YnNjcmlwdChiYXNlLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIgPSBvcHRpb25hbCA9IHRydWU7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgaWYgKCFub0NhbGxzICYmIHRoaXMubWF0Y2goMTApKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNvdmVyQ2FsbEFuZEFzeW5jQXJyb3dIZWFkKGJhc2UsIHN0YXJ0TG9jLCBzdGF0ZSwgb3B0aW9uYWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb21wdXRlZCA9IHRoaXMuZWF0KDApO1xuICAgICAgaWYgKGNvbXB1dGVkIHx8IG9wdGlvbmFsIHx8IHRoaXMuZWF0KDE2KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1lbWJlcihiYXNlLCBzdGFydExvYywgc3RhdGUsIGNvbXB1dGVkLCBvcHRpb25hbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9wUGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzdG9wUGFyc2VTdWJzY3JpcHQoYmFzZSwgc3RhdGUpIHtcbiAgICBzdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuICBwYXJzZU1lbWJlcihiYXNlLCBzdGFydExvYywgc3RhdGUsIGNvbXB1dGVkLCBvcHRpb25hbCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBub2RlLm9iamVjdCA9IGJhc2U7XG4gICAgbm9kZS5jb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgIGlmIChjb21wdXRlZCkge1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMTM5KSkge1xuICAgICAgaWYgKGJhc2UudHlwZSA9PT0gXCJTdXBlclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN1cGVyUHJpdmF0ZUZpZWxkLCBzdGFydExvYyk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsYXNzU2NvcGUudXNlUHJpdmF0ZU5hbWUodGhpcy5zdGF0ZS52YWx1ZSwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICBub2RlLnByb3BlcnR5ID0gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICB9XG4gICAgaWYgKHN0YXRlLm9wdGlvbmFsQ2hhaW5NZW1iZXIpIHtcbiAgICAgIG5vZGUub3B0aW9uYWwgPSBvcHRpb25hbDtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZW1iZXJFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgfVxuICBwYXJzZUJpbmQoYmFzZSwgc3RhcnRMb2MsIG5vQ2FsbHMsIHN0YXRlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUub2JqZWN0ID0gYmFzZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmNhbGxlZSA9IHRoaXMucGFyc2VOb0NhbGxFeHByKCk7XG4gICAgc3RhdGUuc3RvcCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdWJzY3JpcHRzKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkJpbmRFeHByZXNzaW9uXCIpLCBzdGFydExvYywgbm9DYWxscyk7XG4gIH1cbiAgcGFyc2VDb3ZlckNhbGxBbmRBc3luY0Fycm93SGVhZChiYXNlLCBzdGFydExvYywgc3RhdGUsIG9wdGlvbmFsKSB7XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBsZXQgcmVmRXhwcmVzc2lvbkVycm9ycyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgbm9kZS5jYWxsZWUgPSBiYXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heWJlQXN5bmNBcnJvdyxcbiAgICAgIG9wdGlvbmFsQ2hhaW5NZW1iZXJcbiAgICB9ID0gc3RhdGU7XG4gICAgaWYgKG1heWJlQXN5bmNBcnJvdykge1xuICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3QXN5bmNBcnJvd1Njb3BlKCkpO1xuICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycyA9IG5ldyBFeHByZXNzaW9uRXJyb3JzKCk7XG4gICAgfVxuICAgIGlmIChvcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICBub2RlLm9wdGlvbmFsID0gb3B0aW9uYWw7XG4gICAgfVxuICAgIGlmIChvcHRpb25hbCkge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlQ2FsbEV4cHJlc3Npb25Bcmd1bWVudHMoYmFzZS50eXBlICE9PSBcIlN1cGVyXCIsIG5vZGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIH1cbiAgICBsZXQgZmluaXNoZWROb2RlID0gdGhpcy5maW5pc2hDYWxsRXhwcmVzc2lvbihub2RlLCBvcHRpb25hbENoYWluTWVtYmVyKTtcbiAgICBpZiAobWF5YmVBc3luY0Fycm93ICYmIHRoaXMuc2hvdWxkUGFyc2VBc3luY0Fycm93KCkgJiYgIW9wdGlvbmFsKSB7XG4gICAgICBzdGF0ZS5zdG9wID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnZhbGlkYXRlQXNQYXR0ZXJuKCk7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5leGl0KCk7XG4gICAgICBmaW5pc2hlZE5vZGUgPSB0aGlzLnBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbih0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKSwgZmluaXNoZWROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1heWJlQXN5bmNBcnJvdykge1xuICAgICAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZFeHByZXNzaW9uRXJyb3JzLCB0cnVlKTtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZXhpdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy50b1JlZmVyZW5jZWRBcmd1bWVudHMoZmluaXNoZWROb2RlKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICByZXR1cm4gZmluaXNoZWROb2RlO1xuICB9XG4gIHRvUmVmZXJlbmNlZEFyZ3VtZW50cyhub2RlLCBpc1BhcmVudGhlc2l6ZWRFeHByKSB7XG4gICAgdGhpcy50b1JlZmVyZW5jZWRMaXN0RGVlcChub2RlLmFyZ3VtZW50cywgaXNQYXJlbnRoZXNpemVkRXhwcik7XG4gIH1cbiAgcGFyc2VUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24oYmFzZSwgc3RhcnRMb2MsIHN0YXRlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgIG5vZGUudGFnID0gYmFzZTtcbiAgICBub2RlLnF1YXNpID0gdGhpcy5wYXJzZVRlbXBsYXRlKHRydWUpO1xuICAgIGlmIChzdGF0ZS5vcHRpb25hbENoYWluTWVtYmVyKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5PcHRpb25hbENoYWluaW5nTm9UZW1wbGF0ZSwgc3RhcnRMb2MpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCIpO1xuICB9XG4gIGF0UG9zc2libGVBc3luY0Fycm93KGJhc2UpIHtcbiAgICByZXR1cm4gYmFzZS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBiYXNlLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MuaW5kZXggPT09IGJhc2UuZW5kICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIGJhc2UuZW5kIC0gYmFzZS5zdGFydCA9PT0gNSAmJiB0aGlzLm9mZnNldFRvU291cmNlUG9zKGJhc2Uuc3RhcnQpID09PSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQ7XG4gIH1cbiAgZmluaXNoQ2FsbEV4cHJlc3Npb24obm9kZSwgb3B0aW9uYWwpIHtcbiAgICBpZiAobm9kZS5jYWxsZWUudHlwZSA9PT0gXCJJbXBvcnRcIikge1xuICAgICAgaWYgKG5vZGUuYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBub2RlLmFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxBcml0eSwgbm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGFyZyBvZiBub2RlLmFyZ3VtZW50cykge1xuICAgICAgICAgIGlmIChhcmcudHlwZSA9PT0gXCJTcHJlYWRFbGVtZW50XCIpIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxTcHJlYWRBcmd1bWVudCwgYXJnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBvcHRpb25hbCA/IFwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiIDogXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgfVxuICBwYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKGFsbG93UGxhY2Vob2xkZXIsIG5vZGVGb3JFeHRyYSwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IGVsdHMgPSBbXTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGNvbnN0IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gZmFsc2U7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCgxMSkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgICBpZiAobm9kZUZvckV4dHJhKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFRyYWlsaW5nQ29tbWFFeHRyYVRvTm9kZShub2RlRm9yRXh0cmEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWx0cy5wdXNoKHRoaXMucGFyc2VFeHByTGlzdEl0ZW0oMTEsIGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzLCBhbGxvd1BsYWNlaG9sZGVyKSk7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICByZXR1cm4gZWx0cztcbiAgfVxuICBzaG91bGRQYXJzZUFzeW5jQXJyb3coKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTkpICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpO1xuICB9XG4gIHBhcnNlQXN5bmNBcnJvd0Zyb21DYWxsRXhwcmVzc2lvbihub2RlLCBjYWxsKSB7XG4gICAgdmFyIF9jYWxsJGV4dHJhO1xuICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGNhbGwpO1xuICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKG5vZGUsIGNhbGwuYXJndW1lbnRzLCB0cnVlLCAoX2NhbGwkZXh0cmEgPSBjYWxsLmV4dHJhKSA9PSBudWxsID8gdm9pZCAwIDogX2NhbGwkZXh0cmEudHJhaWxpbmdDb21tYUxvYyk7XG4gICAgaWYgKGNhbGwuaW5uZXJDb21tZW50cykge1xuICAgICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjYWxsLmlubmVyQ29tbWVudHMpO1xuICAgIH1cbiAgICBpZiAoY2FsbC5jYWxsZWUudHJhaWxpbmdDb21tZW50cykge1xuICAgICAgc2V0SW5uZXJDb21tZW50cyhub2RlLCBjYWxsLmNhbGxlZS50cmFpbGluZ0NvbW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VOb0NhbGxFeHByKCkge1xuICAgIGNvbnN0IHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICByZXR1cm4gdGhpcy5wYXJzZVN1YnNjcmlwdHModGhpcy5wYXJzZUV4cHJBdG9tKCksIHN0YXJ0TG9jLCB0cnVlKTtcbiAgfVxuICBwYXJzZUV4cHJBdG9tKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBsZXQgbm9kZTtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSA3OTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdXBlcigpO1xuICAgICAgY2FzZSA4MzpcbiAgICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCgxNikpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydE1ldGFQcm9wZXJ0eU9yUGhhc2VDYWxsKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKDEwKSkge1xuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbkZsYWdzICYgNTEyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydENhbGwobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkSW1wb3J0LCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydFwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA3ODpcbiAgICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGhpc0V4cHJlc3Npb25cIik7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEbyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNTY6XG4gICAgICBjYXNlIDMxOlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5yZWFkUmVnZXhwKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VSZWdFeHBMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDEzNTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VOdW1lcmljTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGNhc2UgMTM2OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJpZ0ludExpdGVyYWwodGhpcy5zdGF0ZS52YWx1ZSk7XG4gICAgICBjYXNlIDEzNDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgY2FzZSA4NDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VOdWxsTGl0ZXJhbCgpO1xuICAgICAgY2FzZSA4NTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCb29sZWFuTGl0ZXJhbCh0cnVlKTtcbiAgICAgIGNhc2UgODY6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQm9vbGVhbkxpdGVyYWwoZmFsc2UpO1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IGNhbkJlQXJyb3cgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQgPT09IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAwOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJheUxpa2UoMywgZmFsc2UsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDU6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdExpa2UoOCwgZmFsc2UsIGZhbHNlLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA2ODpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbk9yRnVuY3Rpb25TZW50KCk7XG4gICAgICBjYXNlIDI2OlxuICAgICAgICBkZWNvcmF0b3JzID0gdGhpcy5wYXJzZURlY29yYXRvcnMoKTtcbiAgICAgIGNhc2UgODA6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5tYXliZVRha2VEZWNvcmF0b3JzKGRlY29yYXRvcnMsIHRoaXMuc3RhcnROb2RlKCkpLCBmYWxzZSk7XG4gICAgICBjYXNlIDc3OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU5ld09yTmV3VGFyZ2V0KCk7XG4gICAgICBjYXNlIDI1OlxuICAgICAgY2FzZSAyNDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUZW1wbGF0ZShmYWxzZSk7XG4gICAgICBjYXNlIDE1OlxuICAgICAgICB7XG4gICAgICAgICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgbm9kZS5vYmplY3QgPSBudWxsO1xuICAgICAgICAgIGNvbnN0IGNhbGxlZSA9IG5vZGUuY2FsbGVlID0gdGhpcy5wYXJzZU5vQ2FsbEV4cHIoKTtcbiAgICAgICAgICBpZiAoY2FsbGVlLnR5cGUgPT09IFwiTWVtYmVyRXhwcmVzc2lvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmluZEV4cHJlc3Npb25cIik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkQmluZCwgY2FsbGVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMTM5OlxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuUHJpdmF0ZUluRXhwZWN0ZWRJbiwgdGhpcy5zdGF0ZS5zdGFydExvYywge1xuICAgICAgICAgICAgaWRlbnRpZmllck5hbWU6IHRoaXMuc3RhdGUudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVByaXZhdGVOYW1lKCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMzM6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRvcGljUmVmZXJlbmNlVGhlbkVxdWFsc1NpZ24oNTQsIFwiJVwiKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAzMjpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVG9waWNSZWZlcmVuY2VUaGVuRXF1YWxzU2lnbig0NCwgXCJeXCIpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDM3OlxuICAgICAgY2FzZSAzODpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVG9waWNSZWZlcmVuY2UoXCJoYWNrXCIpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDQ0OlxuICAgICAgY2FzZSA1NDpcbiAgICAgIGNhc2UgMjc6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBwaXBlUHJvcG9zYWwgPSB0aGlzLmdldFBsdWdpbk9wdGlvbihcInBpcGVsaW5lT3BlcmF0b3JcIiwgXCJwcm9wb3NhbFwiKTtcbiAgICAgICAgICBpZiAocGlwZVByb3Bvc2FsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVRvcGljUmVmZXJlbmNlKHBpcGVQcm9wb3NhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICBjYXNlIDQ3OlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgbG9va2FoZWFkQ2ggPSB0aGlzLmlucHV0LmNvZGVQb2ludEF0KHRoaXMubmV4dFRva2VuU3RhcnQoKSk7XG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KGxvb2thaGVhZENoKSB8fCBsb29rYWhlYWRDaCA9PT0gNjIpIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMuZXhwZWN0T25lUGx1Z2luKFtcImpzeFwiLCBcImZsb3dcIiwgXCJ0eXBlc2NyaXB0XCJdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0eXBlID09PSAxMzcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZURlY2ltYWxMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDIgfHwgdHlwZSA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXlMaWtlKHRoaXMuc3RhdGUudHlwZSA9PT0gMiA/IDQgOiAzLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA2IHx8IHR5cGUgPT09IDcpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdExpa2UodGhpcy5zdGF0ZS50eXBlID09PSA2ID8gOSA6IDgsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5Jc0lkZW50aWZpZXIodHlwZSkpIHtcbiAgICAgICAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoMTI3KSAmJiB0aGlzLmxvb2thaGVhZEluTGluZUNoYXJDb2RlKCkgPT09IDEyMykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNb2R1bGVFeHByZXNzaW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGNhbkJlQXJyb3cgPSB0aGlzLnN0YXRlLnBvdGVudGlhbEFycm93QXQgPT09IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgICAgICAgY29uc3QgY29udGFpbnNFc2MgPSB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUlkZW50aWZpZXIoKTtcbiAgICAgICAgICBpZiAoIWNvbnRhaW5zRXNjICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSkge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSA2OCkge1xuICAgICAgICAgICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhpZCk7XG4gICAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFzeW5jRnVuY3Rpb25FeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXROb2RlKGlkKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuSXNJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDYxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBc3luY0Fycm93VW5hcnlGdW5jdGlvbih0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShpZCkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA5MCkge1xuICAgICAgICAgICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhpZCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRG8odGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbkJlQXJyb3cgJiYgdGhpcy5tYXRjaCgxOSkgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpLCBbaWRdLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZVRvcGljUmVmZXJlbmNlVGhlbkVxdWFsc1NpZ24odG9waWNUb2tlblR5cGUsIHRvcGljVG9rZW5WYWx1ZSkge1xuICAgIGNvbnN0IHBpcGVQcm9wb3NhbCA9IHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwicGlwZWxpbmVPcGVyYXRvclwiLCBcInByb3Bvc2FsXCIpO1xuICAgIGlmIChwaXBlUHJvcG9zYWwpIHtcbiAgICAgIHRoaXMuc3RhdGUudHlwZSA9IHRvcGljVG9rZW5UeXBlO1xuICAgICAgdGhpcy5zdGF0ZS52YWx1ZSA9IHRvcGljVG9rZW5WYWx1ZTtcbiAgICAgIHRoaXMuc3RhdGUucG9zLS07XG4gICAgICB0aGlzLnN0YXRlLmVuZC0tO1xuICAgICAgdGhpcy5zdGF0ZS5lbmRMb2MgPSBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQodGhpcy5zdGF0ZS5lbmRMb2MsIC0xKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlVG9waWNSZWZlcmVuY2UocGlwZVByb3Bvc2FsKTtcbiAgICB9XG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbiAgcGFyc2VUb3BpY1JlZmVyZW5jZShwaXBlUHJvcG9zYWwpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBzdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy5zdGF0ZS50eXBlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRvcGljUmVmZXJlbmNlKG5vZGUsIHN0YXJ0TG9jLCBwaXBlUHJvcG9zYWwsIHRva2VuVHlwZSk7XG4gIH1cbiAgZmluaXNoVG9waWNSZWZlcmVuY2Uobm9kZSwgc3RhcnRMb2MsIHBpcGVQcm9wb3NhbCwgdG9rZW5UeXBlKSB7XG4gICAgaWYgKHRoaXMudGVzdFRvcGljUmVmZXJlbmNlQ29uZmlndXJhdGlvbihwaXBlUHJvcG9zYWwsIHN0YXJ0TG9jLCB0b2tlblR5cGUpKSB7XG4gICAgICBpZiAocGlwZVByb3Bvc2FsID09PSBcImhhY2tcIikge1xuICAgICAgICBpZiAoIXRoaXMudG9waWNSZWZlcmVuY2VJc0FsbG93ZWRJbkN1cnJlbnRDb250ZXh0KCkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5QaXBlVG9waWNVbmJvdW5kLCBzdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3RlclRvcGljUmVmZXJlbmNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUb3BpY1JlZmVyZW5jZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpcy50b3BpY1JlZmVyZW5jZUlzQWxsb3dlZEluQ3VycmVudENvbnRleHQoKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlByaW1hcnlUb3BpY05vdEFsbG93ZWQsIHN0YXJ0TG9jKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZ2lzdGVyVG9waWNSZWZlcmVuY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlBpcGVsaW5lUHJpbWFyeVRvcGljUmVmZXJlbmNlXCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5QaXBlVG9waWNVbmNvbmZpZ3VyZWRUb2tlbiwgc3RhcnRMb2MsIHtcbiAgICAgICAgdG9rZW46IHRva2VuTGFiZWxOYW1lKHRva2VuVHlwZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB0ZXN0VG9waWNSZWZlcmVuY2VDb25maWd1cmF0aW9uKHBpcGVQcm9wb3NhbCwgc3RhcnRMb2MsIHRva2VuVHlwZSkge1xuICAgIHN3aXRjaCAocGlwZVByb3Bvc2FsKSB7XG4gICAgICBjYXNlIFwiaGFja1wiOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzUGx1Z2luKFtcInBpcGVsaW5lT3BlcmF0b3JcIiwge1xuICAgICAgICAgICAgdG9waWNUb2tlbjogdG9rZW5MYWJlbE5hbWUodG9rZW5UeXBlKVxuICAgICAgICAgIH1dKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBcInNtYXJ0XCI6XG4gICAgICAgIHJldHVybiB0b2tlblR5cGUgPT09IDI3O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuUGlwZVRvcGljUmVxdWlyZXNIYWNrUGlwZXMsIHN0YXJ0TG9jKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VBc3luY0Fycm93VW5hcnlGdW5jdGlvbihub2RlKSB7XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZnVuY3Rpb25GbGFncyh0cnVlLCB0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCkpO1xuICAgIGNvbnN0IHBhcmFtcyA9IFt0aGlzLnBhcnNlSWRlbnRpZmllcigpXTtcbiAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgaWYgKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkxpbmVUZXJtaW5hdG9yQmVmb3JlQXJyb3csIHRoaXMuc3RhdGUuY3VyUG9zaXRpb24oKSk7XG4gICAgfVxuICAgIHRoaXMuZXhwZWN0KDE5KTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBwYXJhbXMsIHRydWUpO1xuICB9XG4gIHBhcnNlRG8obm9kZSwgaXNBc3luYykge1xuICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZG9FeHByZXNzaW9uc1wiKTtcbiAgICBpZiAoaXNBc3luYykge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJhc3luY0RvRXhwcmVzc2lvbnNcIik7XG4gICAgfVxuICAgIG5vZGUuYXN5bmMgPSBpc0FzeW5jO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IG9sZExhYmVscyA9IHRoaXMuc3RhdGUubGFiZWxzO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzID0gW107XG4gICAgaWYgKGlzQXN5bmMpIHtcbiAgICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKDIpO1xuICAgICAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZUJsb2NrKCk7XG4gICAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jaygpO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IG9sZExhYmVscztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9FeHByZXNzaW9uXCIpO1xuICB9XG4gIHBhcnNlU3VwZXIoKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTApICYmICF0aGlzLnNjb3BlLmFsbG93RGlyZWN0U3VwZXIpIHtcbiAgICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiAxNikpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3VwZXJOb3RBbGxvd2VkLCBub2RlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLnNjb3BlLmFsbG93U3VwZXIpIHtcbiAgICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiAxNikpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFN1cGVyLCBub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLm1hdGNoKDEwKSAmJiAhdGhpcy5tYXRjaCgwKSAmJiAhdGhpcy5tYXRjaCgxNikpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkU3VwZXIsIG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIik7XG4gIH1cbiAgcGFyc2VQcml2YXRlTmFtZSgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBpZCA9IHRoaXMuc3RhcnROb2RlQXQoY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KHRoaXMuc3RhdGUuc3RhcnRMb2MsIDEpKTtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmlkID0gdGhpcy5jcmVhdGVJZGVudGlmaWVyKGlkLCBuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJpdmF0ZU5hbWVcIik7XG4gIH1cbiAgcGFyc2VGdW5jdGlvbk9yRnVuY3Rpb25TZW50KCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLnByb2RQYXJhbS5oYXNZaWVsZCAmJiB0aGlzLm1hdGNoKDE2KSkge1xuICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY3JlYXRlSWRlbnRpZmllcih0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShub2RlKSwgXCJmdW5jdGlvblwiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgaWYgKHRoaXMubWF0Y2goMTAzKSkge1xuICAgICAgICB0aGlzLmV4cGVjdFBsdWdpbihcImZ1bmN0aW9uU2VudFwiKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaGFzUGx1Z2luKFwiZnVuY3Rpb25TZW50XCIpKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VNZXRhUHJvcGVydHkobm9kZSwgbWV0YSwgXCJzZW50XCIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUpO1xuICB9XG4gIHBhcnNlTWV0YVByb3BlcnR5KG5vZGUsIG1ldGEsIHByb3BlcnR5TmFtZSkge1xuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgY29uc3QgY29udGFpbnNFc2MgPSB0aGlzLnN0YXRlLmNvbnRhaW5zRXNjO1xuICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBwcm9wZXJ0eU5hbWUgfHwgY29udGFpbnNFc2MpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkTWV0YVByb3BlcnR5LCBub2RlLnByb3BlcnR5LCB7XG4gICAgICAgIHRhcmdldDogbWV0YS5uYW1lLFxuICAgICAgICBvbmx5VmFsaWRQcm9wZXJ0eU5hbWU6IHByb3BlcnR5TmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNZXRhUHJvcGVydHlcIik7XG4gIH1cbiAgcGFyc2VJbXBvcnRNZXRhUHJvcGVydHlPclBoYXNlQ2FsbChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEwNSkgfHwgdGhpcy5pc0NvbnRleHR1YWwoOTcpKSB7XG4gICAgICBjb25zdCBpc1NvdXJjZSA9IHRoaXMuaXNDb250ZXh0dWFsKDEwNSk7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihpc1NvdXJjZSA/IFwic291cmNlUGhhc2VJbXBvcnRzXCIgOiBcImRlZmVycmVkSW1wb3J0RXZhbHVhdGlvblwiKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5waGFzZSA9IGlzU291cmNlID8gXCJzb3VyY2VcIiA6IFwiZGVmZXJcIjtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0Q2FsbChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXJBdCh0aGlzLnN0YXJ0Tm9kZUF0Tm9kZShub2RlKSwgXCJpbXBvcnRcIiwgdGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDEwMSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmluTW9kdWxlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0TWV0YU91dHNpZGVNb2R1bGUsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNhd1VuYW1iaWd1b3VzRVNNID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTWV0YVByb3BlcnR5KG5vZGUsIGlkLCBcIm1ldGFcIik7XG4gICAgfVxuICB9XG4gIHBhcnNlTGl0ZXJhbEF0Tm9kZSh2YWx1ZSwgdHlwZSwgbm9kZSkge1xuICAgIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJyYXdWYWx1ZVwiLCB2YWx1ZSk7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInJhd1wiLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Mobm9kZS5zdGFydCksIHRoaXMuc3RhdGUuZW5kKSk7XG4gICAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSk7XG4gIH1cbiAgcGFyc2VMaXRlcmFsKHZhbHVlLCB0eXBlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsQXROb2RlKHZhbHVlLCB0eXBlLCBub2RlKTtcbiAgfVxuICBwYXJzZVN0cmluZ0xpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiU3RyaW5nTGl0ZXJhbFwiKTtcbiAgfVxuICBwYXJzZU51bWVyaWNMaXRlcmFsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VMaXRlcmFsKHZhbHVlLCBcIk51bWVyaWNMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlQmlnSW50TGl0ZXJhbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlTGl0ZXJhbCh2YWx1ZSwgXCJCaWdJbnRMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlRGVjaW1hbExpdGVyYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUsIFwiRGVjaW1hbExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VSZWdFeHBMaXRlcmFsKHZhbHVlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5hZGRFeHRyYShub2RlLCBcInJhd1wiLCB0aGlzLmlucHV0LnNsaWNlKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3Mobm9kZS5zdGFydCksIHRoaXMuc3RhdGUuZW5kKSk7XG4gICAgbm9kZS5wYXR0ZXJuID0gdmFsdWUucGF0dGVybjtcbiAgICBub2RlLmZsYWdzID0gdmFsdWUuZmxhZ3M7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJlZ0V4cExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VCb29sZWFuTGl0ZXJhbCh2YWx1ZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQm9vbGVhbkxpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VOdWxsTGl0ZXJhbCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTnVsbExpdGVyYWxcIik7XG4gIH1cbiAgcGFyc2VQYXJlbkFuZERpc3Rpbmd1aXNoRXhwcmVzc2lvbihjYW5CZUFycm93KSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIGxldCB2YWw7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3QXJyb3dIZWFkU2NvcGUoKSk7XG4gICAgY29uc3Qgb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycyA9IHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5ID0gZmFsc2U7XG4gICAgY29uc3QgaW5uZXJTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgY29uc3QgZXhwckxpc3QgPSBbXTtcbiAgICBjb25zdCByZWZFeHByZXNzaW9uRXJyb3JzID0gbmV3IEV4cHJlc3Npb25FcnJvcnMoKTtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGxldCBzcHJlYWRTdGFydExvYztcbiAgICBsZXQgb3B0aW9uYWxDb21tYVN0YXJ0TG9jO1xuICAgIHdoaWxlICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTIsIHJlZkV4cHJlc3Npb25FcnJvcnMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jID09PSBudWxsID8gbnVsbCA6IHJlZkV4cHJlc3Npb25FcnJvcnMub3B0aW9uYWxQYXJhbWV0ZXJzTG9jKTtcbiAgICAgICAgaWYgKHRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgICAgb3B0aW9uYWxDb21tYVN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWF0Y2goMjEpKSB7XG4gICAgICAgIGNvbnN0IHNwcmVhZE5vZGVTdGFydExvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICAgIHNwcmVhZFN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzLnBhcnNlUGFyZW5JdGVtKHRoaXMucGFyc2VSZXN0QmluZGluZygpLCBzcHJlYWROb2RlU3RhcnRMb2MpKTtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrQ29tbWFBZnRlclJlc3QoNDEpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbk9yVm9pZFBhdHRlcm4oMTEsIHJlZkV4cHJlc3Npb25FcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5uZXJFbmRMb2MgPSB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2M7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHRoaXMuc3RhdGUubWF5YmVJbkFycm93UGFyYW1ldGVycyA9IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIGxldCBhcnJvd05vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBpZiAoY2FuQmVBcnJvdyAmJiB0aGlzLnNob3VsZFBhcnNlQXJyb3coZXhwckxpc3QpICYmIChhcnJvd05vZGUgPSB0aGlzLnBhcnNlQXJyb3coYXJyb3dOb2RlKSkpIHtcbiAgICAgIHRoaXMuY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnZhbGlkYXRlQXNQYXR0ZXJuKCk7XG4gICAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5leGl0KCk7XG4gICAgICB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKGFycm93Tm9kZSwgZXhwckxpc3QsIGZhbHNlKTtcbiAgICAgIHJldHVybiBhcnJvd05vZGU7XG4gICAgfVxuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbmFsQ29tbWFTdGFydExvYykgdGhpcy51bmV4cGVjdGVkKG9wdGlvbmFsQ29tbWFTdGFydExvYyk7XG4gICAgaWYgKHNwcmVhZFN0YXJ0TG9jKSB0aGlzLnVuZXhwZWN0ZWQoc3ByZWFkU3RhcnRMb2MpO1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkV4cHJlc3Npb25FcnJvcnMsIHRydWUpO1xuICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdERlZXAoZXhwckxpc3QsIHRydWUpO1xuICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRMb2MpO1xuICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICB0aGlzLmZpbmlzaE5vZGUodmFsLCBcIlNlcXVlbmNlRXhwcmVzc2lvblwiKTtcbiAgICAgIHRoaXMucmVzZXRFbmRMb2NhdGlvbih2YWwsIGlubmVyRW5kTG9jKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsID0gZXhwckxpc3RbMF07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndyYXBQYXJlbnRoZXNpcyhzdGFydExvYywgdmFsKTtcbiAgfVxuICB3cmFwUGFyZW50aGVzaXMoc3RhcnRMb2MsIGV4cHJlc3Npb24pIHtcbiAgICBpZiAoISh0aGlzLm9wdGlvbkZsYWdzICYgMTAyNCkpIHtcbiAgICAgIHRoaXMuYWRkRXh0cmEoZXhwcmVzc2lvbiwgXCJwYXJlbnRoZXNpemVkXCIsIHRydWUpO1xuICAgICAgdGhpcy5hZGRFeHRyYShleHByZXNzaW9uLCBcInBhcmVuU3RhcnRcIiwgc3RhcnRMb2MuaW5kZXgpO1xuICAgICAgdGhpcy50YWtlU3Vycm91bmRpbmdDb21tZW50cyhleHByZXNzaW9uLCBzdGFydExvYy5pbmRleCwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLmluZGV4KTtcbiAgICAgIHJldHVybiBleHByZXNzaW9uO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbkV4cHJlc3Npb24gPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICBwYXJlbkV4cHJlc3Npb24uZXhwcmVzc2lvbiA9IGV4cHJlc3Npb247XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShwYXJlbkV4cHJlc3Npb24sIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIik7XG4gIH1cbiAgc2hvdWxkUGFyc2VBcnJvdyhwYXJhbXMpIHtcbiAgICByZXR1cm4gIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gIH1cbiAgcGFyc2VBcnJvdyhub2RlKSB7XG4gICAgaWYgKHRoaXMuZWF0KDE5KSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIHBhcnNlUGFyZW5JdGVtKG5vZGUsIHN0YXJ0TG9jKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgcGFyc2VOZXdPck5ld1RhcmdldCgpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5tYXRjaCgxNikpIHtcbiAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmNyZWF0ZUlkZW50aWZpZXIodGhpcy5zdGFydE5vZGVBdE5vZGUobm9kZSksIFwibmV3XCIpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBjb25zdCBtZXRhUHJvcCA9IHRoaXMucGFyc2VNZXRhUHJvcGVydHkobm9kZSwgbWV0YSwgXCJ0YXJnZXRcIik7XG4gICAgICBpZiAoIXRoaXMuc2NvcGUuYWxsb3dOZXdUYXJnZXQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZE5ld1RhcmdldCwgbWV0YVByb3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldGFQcm9wO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZU5ldyhub2RlKTtcbiAgfVxuICBwYXJzZU5ldyhub2RlKSB7XG4gICAgdGhpcy5wYXJzZU5ld0NhbGxlZShub2RlKTtcbiAgICBpZiAodGhpcy5lYXQoMTApKSB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5wYXJzZUV4cHJMaXN0KDExKTtcbiAgICAgIHRoaXMudG9SZWZlcmVuY2VkTGlzdChhcmdzKTtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gYXJncztcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hcmd1bWVudHMgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIik7XG4gIH1cbiAgcGFyc2VOZXdDYWxsZWUobm9kZSkge1xuICAgIGNvbnN0IGlzSW1wb3J0ID0gdGhpcy5tYXRjaCg4Myk7XG4gICAgY29uc3QgY2FsbGVlID0gdGhpcy5wYXJzZU5vQ2FsbEV4cHIoKTtcbiAgICBub2RlLmNhbGxlZSA9IGNhbGxlZTtcbiAgICBpZiAoaXNJbXBvcnQgJiYgKGNhbGxlZS50eXBlID09PSBcIkltcG9ydFwiIHx8IGNhbGxlZS50eXBlID09PSBcIkltcG9ydEV4cHJlc3Npb25cIikpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydENhbGxOb3ROZXdFeHByZXNzaW9uLCBjYWxsZWUpO1xuICAgIH1cbiAgfVxuICBwYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YXJ0LFxuICAgICAgc3RhcnRMb2MsXG4gICAgICBlbmQsXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGNvbnN0IGVsZW1TdGFydCA9IHN0YXJ0ICsgMTtcbiAgICBjb25zdCBlbGVtID0gdGhpcy5zdGFydE5vZGVBdChjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQoc3RhcnRMb2MsIDEpKTtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGlmICghaXNUYWdnZWQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW52YWxpZEVzY2FwZVNlcXVlbmNlVGVtcGxhdGUsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLmZpcnN0SW52YWxpZFRlbXBsYXRlRXNjYXBlUG9zLCAxKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGlzVGFpbCA9IHRoaXMubWF0Y2goMjQpO1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IGlzVGFpbCA/IC0xIDogLTI7XG4gICAgY29uc3QgZWxlbUVuZCA9IGVuZCArIGVuZE9mZnNldDtcbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKGVsZW1TdGFydCwgZWxlbUVuZCkucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKSxcbiAgICAgIGNvb2tlZDogdmFsdWUgPT09IG51bGwgPyBudWxsIDogdmFsdWUuc2xpY2UoMSwgZW5kT2Zmc2V0KVxuICAgIH07XG4gICAgZWxlbS50YWlsID0gaXNUYWlsO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IGZpbmlzaGVkTm9kZSA9IHRoaXMuZmluaXNoTm9kZShlbGVtLCBcIlRlbXBsYXRlRWxlbWVudFwiKTtcbiAgICB0aGlzLnJlc2V0RW5kTG9jYXRpb24oZmluaXNoZWROb2RlLCBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQodGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLCBlbmRPZmZzZXQpKTtcbiAgICByZXR1cm4gZmluaXNoZWROb2RlO1xuICB9XG4gIHBhcnNlVGVtcGxhdGUoaXNUYWdnZWQpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBsZXQgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCk7XG4gICAgY29uc3QgcXVhc2lzID0gW2N1ckVsdF07XG4gICAgY29uc3Qgc3Vic3RpdHV0aW9ucyA9IFtdO1xuICAgIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICAgIHN1YnN0aXR1dGlvbnMucHVzaCh0aGlzLnBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKSk7XG4gICAgICB0aGlzLnJlYWRUZW1wbGF0ZUNvbnRpbnVhdGlvbigpO1xuICAgICAgcXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudChpc1RhZ2dlZCkpO1xuICAgIH1cbiAgICBub2RlLmV4cHJlc3Npb25zID0gc3Vic3RpdHV0aW9ucztcbiAgICBub2RlLnF1YXNpcyA9IHF1YXNpcztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVGVtcGxhdGVMaXRlcmFsXCIpO1xuICB9XG4gIHBhcnNlVGVtcGxhdGVTdWJzdGl0dXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIH1cbiAgcGFyc2VPYmplY3RMaWtlKGNsb3NlLCBpc1BhdHRlcm4sIGlzUmVjb3JkLCByZWZFeHByZXNzaW9uRXJyb3JzKSB7XG4gICAgaWYgKGlzUmVjb3JkKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInJlY29yZEFuZFR1cGxlXCIpO1xuICAgIH1cbiAgICBjb25zdCBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IGZhbHNlO1xuICAgIGxldCBzYXdQcm90byA9IGZhbHNlO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgICAgIHRoaXMuYWRkVHJhaWxpbmdDb21tYUV4dHJhVG9Ob2RlKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgcHJvcDtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHtcbiAgICAgICAgcHJvcCA9IHRoaXMucGFyc2VCaW5kaW5nUHJvcGVydHkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AgPSB0aGlzLnBhcnNlUHJvcGVydHlEZWZpbml0aW9uKHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgICBzYXdQcm90byA9IHRoaXMuY2hlY2tQcm90byhwcm9wLCBpc1JlY29yZCwgc2F3UHJvdG8sIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgICAgfVxuICAgICAgaWYgKGlzUmVjb3JkICYmICF0aGlzLmlzT2JqZWN0UHJvcGVydHkocHJvcCkgJiYgcHJvcC50eXBlICE9PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkUmVjb3JkUHJvcGVydHksIHByb3ApO1xuICAgICAgfVxuICAgICAgaWYgKHByb3Auc2hvcnRoYW5kKSB7XG4gICAgICAgIHRoaXMuYWRkRXh0cmEocHJvcCwgXCJzaG9ydGhhbmRcIiwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBub2RlLnByb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIGxldCB0eXBlID0gXCJPYmplY3RFeHByZXNzaW9uXCI7XG4gICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgdHlwZSA9IFwiT2JqZWN0UGF0dGVyblwiO1xuICAgIH0gZWxzZSBpZiAoaXNSZWNvcmQpIHtcbiAgICAgIHR5cGUgPSBcIlJlY29yZEV4cHJlc3Npb25cIjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuICBhZGRUcmFpbGluZ0NvbW1hRXh0cmFUb05vZGUobm9kZSkge1xuICAgIHRoaXMuYWRkRXh0cmEobm9kZSwgXCJ0cmFpbGluZ0NvbW1hXCIsIHRoaXMuc3RhdGUubGFzdFRva1N0YXJ0TG9jLmluZGV4KTtcbiAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwidHJhaWxpbmdDb21tYUxvY1wiLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYywgZmFsc2UpO1xuICB9XG4gIG1heWJlQXN5bmNPckFjY2Vzc29yUHJvcChwcm9wKSB7XG4gICAgcmV0dXJuICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmICh0aGlzLmlzTGl0ZXJhbFByb3BlcnR5TmFtZSgpIHx8IHRoaXMubWF0Y2goMCkgfHwgdGhpcy5tYXRjaCg1NSkpO1xuICB9XG4gIHBhcnNlUHJvcGVydHlEZWZpbml0aW9uKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBsZXQgZGVjb3JhdG9ycyA9IFtdO1xuICAgIGlmICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbnN1cHBvcnRlZFByb3BlcnR5RGVjb3JhdG9yLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICh0aGlzLm1hdGNoKDI2KSkge1xuICAgICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgbGV0IGlzQXN5bmMgPSBmYWxzZTtcbiAgICBsZXQgaXNBY2Nlc3NvciA9IGZhbHNlO1xuICAgIGxldCBzdGFydExvYztcbiAgICBpZiAodGhpcy5tYXRjaCgyMSkpIHtcbiAgICAgIGlmIChkZWNvcmF0b3JzLmxlbmd0aCkgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVNwcmVhZCgpO1xuICAgIH1cbiAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgIHByb3AuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICBkZWNvcmF0b3JzID0gW107XG4gICAgfVxuICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB9XG4gICAgbGV0IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQoNTUpO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWVQcmVmaXhPcGVyYXRvcihwcm9wKTtcbiAgICBjb25zdCBjb250YWluc0VzYyA9IHRoaXMuc3RhdGUuY29udGFpbnNFc2M7XG4gICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAoIWlzR2VuZXJhdG9yICYmICFjb250YWluc0VzYyAmJiB0aGlzLm1heWJlQXN5bmNPckFjY2Vzc29yUHJvcChwcm9wKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBrZXlcbiAgICAgIH0gPSBwcm9wO1xuICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5uYW1lO1xuICAgICAgaWYgKGtleU5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMoa2V5KTtcbiAgICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCg1NSk7XG4gICAgICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5TmFtZSA9PT0gXCJnZXRcIiB8fCBrZXlOYW1lID09PSBcInNldFwiKSB7XG4gICAgICAgIGlzQWNjZXNzb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgICAgICBwcm9wLmtpbmQgPSBrZXlOYW1lO1xuICAgICAgICBpZiAodGhpcy5tYXRjaCg1NSkpIHtcbiAgICAgICAgICBpc0dlbmVyYXRvciA9IHRydWU7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQWNjZXNzb3JJc0dlbmVyYXRvciwgdGhpcy5zdGF0ZS5jdXJQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICBraW5kOiBrZXlOYW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJzZVByb3BlcnR5TmFtZShwcm9wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VPYmpQcm9wVmFsdWUocHJvcCwgc3RhcnRMb2MsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBmYWxzZSwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gIH1cbiAgZ2V0R2V0dGVyU2V0dGVyRXhwZWN0ZWRQYXJhbUNvdW50KG1ldGhvZCkge1xuICAgIHJldHVybiBtZXRob2Qua2luZCA9PT0gXCJnZXRcIiA/IDAgOiAxO1xuICB9XG4gIGdldE9iamVjdE9yQ2xhc3NNZXRob2RQYXJhbXMobWV0aG9kKSB7XG4gICAgcmV0dXJuIG1ldGhvZC5wYXJhbXM7XG4gIH1cbiAgY2hlY2tHZXR0ZXJTZXR0ZXJQYXJhbXMobWV0aG9kKSB7XG4gICAgdmFyIF9wYXJhbXM7XG4gICAgY29uc3QgcGFyYW1Db3VudCA9IHRoaXMuZ2V0R2V0dGVyU2V0dGVyRXhwZWN0ZWRQYXJhbUNvdW50KG1ldGhvZCk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRPYmplY3RPckNsYXNzTWV0aG9kUGFyYW1zKG1ldGhvZCk7XG4gICAgaWYgKHBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgIHRoaXMucmFpc2UobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIgPyBFcnJvcnMuQmFkR2V0dGVyQXJpdHkgOiBFcnJvcnMuQmFkU2V0dGVyQXJpdHksIG1ldGhvZCk7XG4gICAgfVxuICAgIGlmIChtZXRob2Qua2luZCA9PT0gXCJzZXRcIiAmJiAoKF9wYXJhbXMgPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcmFtcy50eXBlKSA9PT0gXCJSZXN0RWxlbWVudFwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5CYWRTZXR0ZXJSZXN0UGFyYW1ldGVyLCBtZXRob2QpO1xuICAgIH1cbiAgfVxuICBwYXJzZU9iamVjdE1ldGhvZChwcm9wLCBpc0dlbmVyYXRvciwgaXNBc3luYywgaXNQYXR0ZXJuLCBpc0FjY2Vzc29yKSB7XG4gICAgaWYgKGlzQWNjZXNzb3IpIHtcbiAgICAgIGNvbnN0IGZpbmlzaGVkUHJvcCA9IHRoaXMucGFyc2VNZXRob2QocHJvcCwgaXNHZW5lcmF0b3IsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIFwiT2JqZWN0TWV0aG9kXCIpO1xuICAgICAgdGhpcy5jaGVja0dldHRlclNldHRlclBhcmFtcyhmaW5pc2hlZFByb3ApO1xuICAgICAgcmV0dXJuIGZpbmlzaGVkUHJvcDtcbiAgICB9XG4gICAgaWYgKGlzQXN5bmMgfHwgaXNHZW5lcmF0b3IgfHwgdGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgIGlmIChpc1BhdHRlcm4pIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgcHJvcC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlTWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBmYWxzZSwgZmFsc2UsIFwiT2JqZWN0TWV0aG9kXCIpO1xuICAgIH1cbiAgfVxuICBwYXJzZU9iamVjdFByb3BlcnR5KHByb3AsIHN0YXJ0TG9jLCBpc1BhdHRlcm4sIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBwcm9wLnNob3J0aGFuZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLmVhdCgxNCkpIHtcbiAgICAgIHByb3AudmFsdWUgPSBpc1BhdHRlcm4gPyB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHRoaXMuc3RhdGUuc3RhcnRMb2MpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbk9yVm9pZFBhdHRlcm4oOCwgcmVmRXhwcmVzc2lvbkVycm9ycyk7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPYmplY3RQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gICAgaWYgKCFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICB0aGlzLmNoZWNrUmVzZXJ2ZWRXb3JkKHByb3Aua2V5Lm5hbWUsIHByb3Aua2V5LmxvYy5zdGFydCwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgaWYgKGlzUGF0dGVybikge1xuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydExvYywgdGhpcy5jbG9uZUlkZW50aWZpZXIocHJvcC5rZXkpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tYXRjaCgyOSkpIHtcbiAgICAgICAgY29uc3Qgc2hvcnRoYW5kQXNzaWduTG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnNob3J0aGFuZEFzc2lnbkxvYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy5zaG9ydGhhbmRBc3NpZ25Mb2MgPSBzaG9ydGhhbmRBc3NpZ25Mb2M7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkludmFsaWRDb3ZlckluaXRpYWxpemVkTmFtZSwgc2hvcnRoYW5kQXNzaWduTG9jKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydExvYywgdGhpcy5jbG9uZUlkZW50aWZpZXIocHJvcC5rZXkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3AudmFsdWUgPSB0aGlzLmNsb25lSWRlbnRpZmllcihwcm9wLmtleSk7XG4gICAgICB9XG4gICAgICBwcm9wLnNob3J0aGFuZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hPYmplY3RQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gIH1cbiAgZmluaXNoT2JqZWN0UHJvcGVydHkobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJPYmplY3RQcm9wZXJ0eVwiKTtcbiAgfVxuICBwYXJzZU9ialByb3BWYWx1ZShwcm9wLCBzdGFydExvYywgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzUGF0dGVybiwgaXNBY2Nlc3NvciwgcmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlT2JqZWN0TWV0aG9kKHByb3AsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc1BhdHRlcm4sIGlzQWNjZXNzb3IpIHx8IHRoaXMucGFyc2VPYmplY3RQcm9wZXJ0eShwcm9wLCBzdGFydExvYywgaXNQYXR0ZXJuLCByZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICBpZiAoIW5vZGUpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlUHJvcGVydHlOYW1lKHByb3AsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAodGhpcy5lYXQoMCkpIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgICB0aGlzLmV4cGVjdCgzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0eXBlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgICBsZXQga2V5O1xuICAgICAgaWYgKHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICAgIGtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAxMzU6XG4gICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlTnVtZXJpY0xpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMzQ6XG4gICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDEzNjpcbiAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VCaWdJbnRMaXRlcmFsKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTM5OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCBwcml2YXRlS2V5TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgICAgICAgICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZWZFeHByZXNzaW9uRXJyb3JzLnByaXZhdGVLZXlMb2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlZkV4cHJlc3Npb25FcnJvcnMucHJpdmF0ZUtleUxvYyA9IHByaXZhdGVLZXlMb2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRQcml2YXRlRmllbGQsIHByaXZhdGVLZXlMb2MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGtleSA9IHRoaXMucGFyc2VQcml2YXRlTmFtZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IDEzNykge1xuICAgICAgICAgICAgICBrZXkgPSB0aGlzLnBhcnNlRGVjaW1hbExpdGVyYWwodmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9wLmtleSA9IGtleTtcbiAgICAgIGlmICh0eXBlICE9PSAxMzkpIHtcbiAgICAgICAgcHJvcC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYykge1xuICAgIG5vZGUuaWQgPSBudWxsO1xuICAgIG5vZGUuZ2VuZXJhdG9yID0gZmFsc2U7XG4gICAgbm9kZS5hc3luYyA9IGlzQXN5bmM7XG4gIH1cbiAgcGFyc2VNZXRob2Qobm9kZSwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIGlzQ29uc3RydWN0b3IsIGFsbG93RGlyZWN0U3VwZXIsIHR5cGUsIGluQ2xhc3NTY29wZSA9IGZhbHNlKSB7XG4gICAgdGhpcy5pbml0RnVuY3Rpb24obm9kZSwgaXNBc3luYyk7XG4gICAgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDUxNCB8IDE2IHwgKGluQ2xhc3NTY29wZSA/IDU3NiA6IDApIHwgKGFsbG93RGlyZWN0U3VwZXIgPyAzMiA6IDApKTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmdW5jdGlvbkZsYWdzKGlzQXN5bmMsIG5vZGUuZ2VuZXJhdG9yKSk7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uUGFyYW1zKG5vZGUsIGlzQ29uc3RydWN0b3IpO1xuICAgIGNvbnN0IGZpbmlzaGVkTm9kZSA9IHRoaXMucGFyc2VGdW5jdGlvbkJvZHlBbmRGaW5pc2gobm9kZSwgdHlwZSwgdHJ1ZSk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHJldHVybiBmaW5pc2hlZE5vZGU7XG4gIH1cbiAgcGFyc2VBcnJheUxpa2UoY2xvc2UsIGlzVHVwbGUsIHJlZkV4cHJlc3Npb25FcnJvcnMpIHtcbiAgICBpZiAoaXNUdXBsZSkge1xuICAgICAgdGhpcy5leHBlY3RQbHVnaW4oXCJyZWNvcmRBbmRUdXBsZVwiKTtcbiAgICB9XG4gICAgY29uc3Qgb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBmYWxzZTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLmVsZW1lbnRzID0gdGhpcy5wYXJzZUV4cHJMaXN0KGNsb3NlLCAhaXNUdXBsZSwgcmVmRXhwcmVzc2lvbkVycm9ycywgbm9kZSk7XG4gICAgdGhpcy5zdGF0ZS5pbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keSA9IG9sZEluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNUdXBsZSA/IFwiVHVwbGVFeHByZXNzaW9uXCIgOiBcIkFycmF5RXhwcmVzc2lvblwiKTtcbiAgfVxuICBwYXJzZUFycm93RXhwcmVzc2lvbihub2RlLCBwYXJhbXMsIGlzQXN5bmMsIHRyYWlsaW5nQ29tbWFMb2MpIHtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDUxNCB8IDQpO1xuICAgIGxldCBmbGFncyA9IGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgZmFsc2UpO1xuICAgIGlmICghdGhpcy5tYXRjaCg1KSAmJiB0aGlzLnByb2RQYXJhbS5oYXNJbikge1xuICAgICAgZmxhZ3MgfD0gODtcbiAgICB9XG4gICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZmxhZ3MpO1xuICAgIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUsIGlzQXN5bmMpO1xuICAgIGNvbnN0IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2V0QXJyb3dGdW5jdGlvblBhcmFtZXRlcnMobm9kZSwgcGFyYW1zLCB0cmFpbGluZ0NvbW1hTG9jKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlKTtcbiAgICB0aGlzLnByb2RQYXJhbS5leGl0KCk7XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIik7XG4gIH1cbiAgc2V0QXJyb3dGdW5jdGlvblBhcmFtZXRlcnMobm9kZSwgcGFyYW1zLCB0cmFpbGluZ0NvbW1hTG9jKSB7XG4gICAgdGhpcy50b0Fzc2lnbmFibGVMaXN0KHBhcmFtcywgdHJhaWxpbmdDb21tYUxvYywgZmFsc2UpO1xuICAgIG5vZGUucGFyYW1zID0gcGFyYW1zO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIHR5cGUsIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlLCBpc01ldGhvZCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCB0eXBlKTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb24sIGlzTWV0aG9kID0gZmFsc2UpIHtcbiAgICBjb25zdCBpc0V4cHJlc3Npb24gPSBhbGxvd0V4cHJlc3Npb24gJiYgIXRoaXMubWF0Y2goNSk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUuZW50ZXIobmV3RXhwcmVzc2lvblNjb3BlKCkpO1xuICAgIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbigpO1xuICAgICAgdGhpcy5jaGVja1BhcmFtcyhub2RlLCBmYWxzZSwgYWxsb3dFeHByZXNzaW9uLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG9sZFN0cmljdCA9IHRoaXMuc3RhdGUuc3RyaWN0O1xuICAgICAgY29uc3Qgb2xkTGFiZWxzID0gdGhpcy5zdGF0ZS5sYWJlbHM7XG4gICAgICB0aGlzLnN0YXRlLmxhYmVscyA9IFtdO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIodGhpcy5wcm9kUGFyYW0uY3VycmVudEZsYWdzKCkgfCA0KTtcbiAgICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VCbG9jayh0cnVlLCBmYWxzZSwgaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSA9PiB7XG4gICAgICAgIGNvbnN0IG5vblNpbXBsZSA9ICF0aGlzLmlzU2ltcGxlUGFyYW1MaXN0KG5vZGUucGFyYW1zKTtcbiAgICAgICAgaWYgKGhhc1N0cmljdE1vZGVEaXJlY3RpdmUgJiYgbm9uU2ltcGxlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSWxsZWdhbExhbmd1YWdlTW9kZURpcmVjdGl2ZSwgKG5vZGUua2luZCA9PT0gXCJtZXRob2RcIiB8fCBub2RlLmtpbmQgPT09IFwiY29uc3RydWN0b3JcIikgJiYgISFub2RlLmtleSA/IG5vZGUua2V5LmxvYy5lbmQgOiBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpY3RNb2RlQ2hhbmdlZCA9ICFvbGRTdHJpY3QgJiYgdGhpcy5zdGF0ZS5zdHJpY3Q7XG4gICAgICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgIXRoaXMuc3RhdGUuc3RyaWN0ICYmICFhbGxvd0V4cHJlc3Npb24gJiYgIWlzTWV0aG9kICYmICFub25TaW1wbGUsIGFsbG93RXhwcmVzc2lvbiwgc3RyaWN0TW9kZUNoYW5nZWQpO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QgJiYgbm9kZS5pZCkge1xuICAgICAgICAgIHRoaXMuY2hlY2tJZGVudGlmaWVyKG5vZGUuaWQsIDY1LCBzdHJpY3RNb2RlQ2hhbmdlZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgdGhpcy5zdGF0ZS5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gICAgfVxuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgfVxuICBpc1NpbXBsZVBhcmFtZXRlcihub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudHlwZSA9PT0gXCJJZGVudGlmaWVyXCI7XG4gIH1cbiAgaXNTaW1wbGVQYXJhbUxpc3QocGFyYW1zKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHBhcmFtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKCF0aGlzLmlzU2ltcGxlUGFyYW1ldGVyKHBhcmFtc1tpXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2hlY2tQYXJhbXMobm9kZSwgYWxsb3dEdXBsaWNhdGVzLCBpc0Fycm93RnVuY3Rpb24sIHN0cmljdE1vZGVDaGFuZ2VkID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNoZWNrQ2xhc2hlcyA9ICFhbGxvd0R1cGxpY2F0ZXMgJiYgbmV3IFNldCgpO1xuICAgIGNvbnN0IGZvcm1hbFBhcmFtZXRlcnMgPSB7XG4gICAgICB0eXBlOiBcIkZvcm1hbFBhcmFtZXRlcnNcIlxuICAgIH07XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBub2RlLnBhcmFtcykge1xuICAgICAgdGhpcy5jaGVja0xWYWwocGFyYW0sIGZvcm1hbFBhcmFtZXRlcnMsIDUsIGNoZWNrQ2xhc2hlcywgc3RyaWN0TW9kZUNoYW5nZWQpO1xuICAgIH1cbiAgfVxuICBwYXJzZUV4cHJMaXN0KGNsb3NlLCBhbGxvd0VtcHR5LCByZWZFeHByZXNzaW9uRXJyb3JzLCBub2RlRm9yRXh0cmEpIHtcbiAgICBjb25zdCBlbHRzID0gW107XG4gICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKGNsb3NlKSkge1xuICAgICAgICAgIGlmIChub2RlRm9yRXh0cmEpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkVHJhaWxpbmdDb21tYUV4dHJhVG9Ob2RlKG5vZGVGb3JFeHRyYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHRzLnB1c2godGhpcy5wYXJzZUV4cHJMaXN0SXRlbShjbG9zZSwgYWxsb3dFbXB0eSwgcmVmRXhwcmVzc2lvbkVycm9ycykpO1xuICAgIH1cbiAgICByZXR1cm4gZWx0cztcbiAgfVxuICBwYXJzZUV4cHJMaXN0SXRlbShjbG9zZSwgYWxsb3dFbXB0eSwgcmVmRXhwcmVzc2lvbkVycm9ycywgYWxsb3dQbGFjZWhvbGRlcikge1xuICAgIGxldCBlbHQ7XG4gICAgaWYgKHRoaXMubWF0Y2goMTIpKSB7XG4gICAgICBpZiAoIWFsbG93RW1wdHkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFRva2VuLCB0aGlzLnN0YXRlLmN1clBvc2l0aW9uKCksIHtcbiAgICAgICAgICB1bmV4cGVjdGVkOiBcIixcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsdCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh0aGlzLm1hdGNoKDIxKSkge1xuICAgICAgY29uc3Qgc3ByZWFkTm9kZVN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICAgIGVsdCA9IHRoaXMucGFyc2VQYXJlbkl0ZW0odGhpcy5wYXJzZVNwcmVhZChyZWZFeHByZXNzaW9uRXJyb3JzKSwgc3ByZWFkTm9kZVN0YXJ0TG9jKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubWF0Y2goMTcpKSB7XG4gICAgICB0aGlzLmV4cGVjdFBsdWdpbihcInBhcnRpYWxBcHBsaWNhdGlvblwiKTtcbiAgICAgIGlmICghYWxsb3dQbGFjZWhvbGRlcikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkQXJndW1lbnRQbGFjZWhvbGRlciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgZWx0ID0gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXJndW1lbnRQbGFjZWhvbGRlclwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWx0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbk9yVm9pZFBhdHRlcm4oY2xvc2UsIHJlZkV4cHJlc3Npb25FcnJvcnMsIHRoaXMucGFyc2VQYXJlbkl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gZWx0O1xuICB9XG4gIHBhcnNlSWRlbnRpZmllcihsaWJlcmFsKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMucGFyc2VJZGVudGlmaWVyTmFtZShsaWJlcmFsKTtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVJZGVudGlmaWVyKG5vZGUsIG5hbWUpO1xuICB9XG4gIGNyZWF0ZUlkZW50aWZpZXIobm9kZSwgbmFtZSkge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gICAgbm9kZS5sb2MuaWRlbnRpZmllck5hbWUgPSBuYW1lO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZGVudGlmaWVyXCIpO1xuICB9XG4gIGNyZWF0ZUlkZW50aWZpZXJBdChub2RlLCBuYW1lLCBlbmRMb2MpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICAgIG5vZGUubG9jLmlkZW50aWZpZXJOYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlQXQobm9kZSwgXCJJZGVudGlmaWVyXCIsIGVuZExvYyk7XG4gIH1cbiAgcGFyc2VJZGVudGlmaWVyTmFtZShsaWJlcmFsKSB7XG4gICAgbGV0IG5hbWU7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRMb2MsXG4gICAgICB0eXBlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKHRva2VuSXNLZXl3b3JkT3JJZGVudGlmaWVyKHR5cGUpKSB7XG4gICAgICBuYW1lID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIGNvbnN0IHRva2VuSXNLZXl3b3JkID0gdG9rZW5LZXl3b3JkT3JJZGVudGlmaWVySXNLZXl3b3JkKHR5cGUpO1xuICAgIGlmIChsaWJlcmFsKSB7XG4gICAgICBpZiAodG9rZW5Jc0tleXdvcmQpIHtcbiAgICAgICAgdGhpcy5yZXBsYWNlVG9rZW4oMTMyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChuYW1lLCBzdGFydExvYywgdG9rZW5Jc0tleXdvcmQsIGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgY2hlY2tSZXNlcnZlZFdvcmQod29yZCwgc3RhcnRMb2MsIGNoZWNrS2V5d29yZHMsIGlzQmluZGluZykge1xuICAgIGlmICh3b3JkLmxlbmd0aCA+IDEwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2FuQmVSZXNlcnZlZFdvcmQod29yZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGNoZWNrS2V5d29yZHMgJiYgaXNLZXl3b3JkKHdvcmQpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkS2V5d29yZCwgc3RhcnRMb2MsIHtcbiAgICAgICAga2V5d29yZDogd29yZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc2VydmVkVGVzdCA9ICF0aGlzLnN0YXRlLnN0cmljdCA/IGlzUmVzZXJ2ZWRXb3JkIDogaXNCaW5kaW5nID8gaXNTdHJpY3RCaW5kUmVzZXJ2ZWRXb3JkIDogaXNTdHJpY3RSZXNlcnZlZFdvcmQ7XG4gICAgaWYgKHJlc2VydmVkVGVzdCh3b3JkLCB0aGlzLmluTW9kdWxlKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFJlc2VydmVkV29yZCwgc3RhcnRMb2MsIHtcbiAgICAgICAgcmVzZXJ2ZWRXb3JkOiB3b3JkXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHdvcmQgPT09IFwieWllbGRcIikge1xuICAgICAgaWYgKHRoaXMucHJvZFBhcmFtLmhhc1lpZWxkKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLllpZWxkQmluZGluZ0lkZW50aWZpZXIsIHN0YXJ0TG9jKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAod29yZCA9PT0gXCJhd2FpdFwiKSB7XG4gICAgICBpZiAodGhpcy5wcm9kUGFyYW0uaGFzQXdhaXQpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXdhaXRCaW5kaW5nSWRlbnRpZmllciwgc3RhcnRMb2MpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5zY29wZS5pblN0YXRpY0Jsb2NrKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkF3YWl0QmluZGluZ0lkZW50aWZpZXJJblN0YXRpY0Jsb2NrLCBzdGFydExvYyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLnJlY29yZEFzeW5jQXJyb3dQYXJhbWV0ZXJzRXJyb3Ioc3RhcnRMb2MpO1xuICAgIH0gZWxzZSBpZiAod29yZCA9PT0gXCJhcmd1bWVudHNcIikge1xuICAgICAgaWYgKHRoaXMuc2NvcGUuaW5DbGFzc0FuZE5vdEluTm9uQXJyb3dGdW5jdGlvbikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bcmd1bWVudHNJbkNsYXNzLCBzdGFydExvYyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVjb3JkQXdhaXRJZkFsbG93ZWQoKSB7XG4gICAgY29uc3QgaXNBd2FpdEFsbG93ZWQgPSB0aGlzLnByb2RQYXJhbS5oYXNBd2FpdDtcbiAgICBpZiAoaXNBd2FpdEFsbG93ZWQgJiYgIXRoaXMuc2NvcGUuaW5GdW5jdGlvbikge1xuICAgICAgdGhpcy5zdGF0ZS5oYXNUb3BMZXZlbEF3YWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzQXdhaXRBbGxvd2VkO1xuICB9XG4gIHBhcnNlQXdhaXQoc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkUGFyYW1ldGVySW5pdGlhbGl6ZXJFcnJvcihFcnJvcnMuQXdhaXRFeHByZXNzaW9uRm9ybWFsUGFyYW1ldGVyLCBub2RlKTtcbiAgICBpZiAodGhpcy5lYXQoNTUpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5PYnNvbGV0ZUF3YWl0U3Rhciwgbm9kZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zY29wZS5pbkZ1bmN0aW9uICYmICEodGhpcy5vcHRpb25GbGFncyAmIDEpKSB7XG4gICAgICBpZiAodGhpcy5pc0FtYmlndW91c1ByZWZpeE9ySWRlbnRpZmllcigpKSB7XG4gICAgICAgIHRoaXMuYW1iaWd1b3VzU2NyaXB0RGlmZmVyZW50QXN0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuc3RhdGUuc29sb0F3YWl0KSB7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBd2FpdEV4cHJlc3Npb25cIik7XG4gIH1cbiAgaXNBbWJpZ3VvdXNQcmVmaXhPcklkZW50aWZpZXIoKSB7XG4gICAgaWYgKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gdHlwZSA9PT0gNTMgfHwgdHlwZSA9PT0gMTAgfHwgdHlwZSA9PT0gMCB8fCB0b2tlbklzVGVtcGxhdGUodHlwZSkgfHwgdHlwZSA9PT0gMTAyICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjIHx8IHR5cGUgPT09IDEzOCB8fCB0eXBlID09PSA1NiB8fCB0aGlzLmhhc1BsdWdpbihcInY4aW50cmluc2ljXCIpICYmIHR5cGUgPT09IDU0O1xuICB9XG4gIHBhcnNlWWllbGQoc3RhcnRMb2MpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgdGhpcy5leHByZXNzaW9uU2NvcGUucmVjb3JkUGFyYW1ldGVySW5pdGlhbGl6ZXJFcnJvcihFcnJvcnMuWWllbGRJblBhcmFtZXRlciwgbm9kZSk7XG4gICAgbGV0IGRlbGVnYXRpbmcgPSBmYWxzZTtcbiAgICBsZXQgYXJndW1lbnQgPSBudWxsO1xuICAgIGlmICghdGhpcy5oYXNQcmVjZWRpbmdMaW5lQnJlYWsoKSkge1xuICAgICAgZGVsZWdhdGluZyA9IHRoaXMuZWF0KDU1KTtcbiAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZS50eXBlKSB7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTQwOlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICBjYXNlIDE0OlxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGlmICghZGVsZWdhdGluZykgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IGRlbGVnYXRpbmc7XG4gICAgbm9kZS5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJZaWVsZEV4cHJlc3Npb25cIik7XG4gIH1cbiAgcGFyc2VJbXBvcnRDYWxsKG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICBub2RlLm9wdGlvbnMgPSBudWxsO1xuICAgIGlmICh0aGlzLmVhdCgxMikpIHtcbiAgICAgIGlmICghdGhpcy5tYXRjaCgxMSkpIHtcbiAgICAgICAgbm9kZS5vcHRpb25zID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgICAgICBpZiAodGhpcy5lYXQoMTIpKSB7XG4gICAgICAgICAgdGhpcy5hZGRUcmFpbGluZ0NvbW1hRXh0cmFUb05vZGUobm9kZS5vcHRpb25zKTtcbiAgICAgICAgICBpZiAoIXRoaXMubWF0Y2goMTEpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHRoaXMucGFyc2VNYXliZUFzc2lnbkFsbG93SW4oKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSAmJiAhdGhpcy5tYXRjaCgxMSkpO1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0Q2FsbEFyaXR5LCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkVHJhaWxpbmdDb21tYUV4dHJhVG9Ob2RlKG5vZGUuc291cmNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRFeHByZXNzaW9uXCIpO1xuICB9XG4gIGNoZWNrUGlwZWxpbmVBdEluZml4T3BlcmF0b3IobGVmdCwgbGVmdFN0YXJ0TG9jKSB7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFtcInBpcGVsaW5lT3BlcmF0b3JcIiwge1xuICAgICAgcHJvcG9zYWw6IFwic21hcnRcIlxuICAgIH1dKSkge1xuICAgICAgaWYgKGxlZnQudHlwZSA9PT0gXCJTZXF1ZW5jZUV4cHJlc3Npb25cIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5QaXBlbGluZUhlYWRTZXF1ZW5jZUV4cHJlc3Npb24sIGxlZnRTdGFydExvYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhcnNlU21hcnRQaXBlbGluZUJvZHlJblN0eWxlKGNoaWxkRXhwciwgc3RhcnRMb2MpIHtcbiAgICBpZiAodGhpcy5pc1NpbXBsZVJlZmVyZW5jZShjaGlsZEV4cHIpKSB7XG4gICAgICBjb25zdCBib2R5Tm9kZSA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRMb2MpO1xuICAgICAgYm9keU5vZGUuY2FsbGVlID0gY2hpbGRFeHByO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShib2R5Tm9kZSwgXCJQaXBlbGluZUJhcmVGdW5jdGlvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYm9keU5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIHRoaXMuY2hlY2tTbWFydFBpcGVUb3BpY0JvZHlFYXJseUVycm9ycyhzdGFydExvYyk7XG4gICAgICBib2R5Tm9kZS5leHByZXNzaW9uID0gY2hpbGRFeHByO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShib2R5Tm9kZSwgXCJQaXBlbGluZVRvcGljRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cbiAgaXNTaW1wbGVSZWZlcmVuY2UoZXhwcmVzc2lvbikge1xuICAgIHN3aXRjaCAoZXhwcmVzc2lvbi50eXBlKSB7XG4gICAgICBjYXNlIFwiTWVtYmVyRXhwcmVzc2lvblwiOlxuICAgICAgICByZXR1cm4gIWV4cHJlc3Npb24uY29tcHV0ZWQgJiYgdGhpcy5pc1NpbXBsZVJlZmVyZW5jZShleHByZXNzaW9uLm9iamVjdCk7XG4gICAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgY2hlY2tTbWFydFBpcGVUb3BpY0JvZHlFYXJseUVycm9ycyhzdGFydExvYykge1xuICAgIGlmICh0aGlzLm1hdGNoKDE5KSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuUGlwZWxpbmVCb2R5Tm9BcnJvdywgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIGlmICghdGhpcy50b3BpY1JlZmVyZW5jZVdhc1VzZWRJbkN1cnJlbnRDb250ZXh0KCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlBpcGVsaW5lVG9waWNVbnVzZWQsIHN0YXJ0TG9jKTtcbiAgICB9XG4gIH1cbiAgd2l0aFRvcGljQmluZGluZ0NvbnRleHQoY2FsbGJhY2spIHtcbiAgICBjb25zdCBvdXRlckNvbnRleHRUb3BpY1N0YXRlID0gdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQ7XG4gICAgdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQgPSB7XG4gICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDEsXG4gICAgICBtYXhUb3BpY0luZGV4OiBudWxsXG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0ID0gb3V0ZXJDb250ZXh0VG9waWNTdGF0ZTtcbiAgICB9XG4gIH1cbiAgd2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihbXCJwaXBlbGluZU9wZXJhdG9yXCIsIHtcbiAgICAgIHByb3Bvc2FsOiBcInNtYXJ0XCJcbiAgICB9XSkpIHtcbiAgICAgIGNvbnN0IG91dGVyQ29udGV4dFRvcGljU3RhdGUgPSB0aGlzLnN0YXRlLnRvcGljQ29udGV4dDtcbiAgICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0ID0ge1xuICAgICAgICBtYXhOdW1PZlJlc29sdmFibGVUb3BpY3M6IDAsXG4gICAgICAgIG1heFRvcGljSW5kZXg6IG51bGxcbiAgICAgIH07XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0ID0gb3V0ZXJDb250ZXh0VG9waWNTdGF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIHdpdGhTb2xvQXdhaXRQZXJtaXR0aW5nQ29udGV4dChjYWxsYmFjaykge1xuICAgIGNvbnN0IG91dGVyQ29udGV4dFNvbG9Bd2FpdFN0YXRlID0gdGhpcy5zdGF0ZS5zb2xvQXdhaXQ7XG4gICAgdGhpcy5zdGF0ZS5zb2xvQXdhaXQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5zdGF0ZS5zb2xvQXdhaXQgPSBvdXRlckNvbnRleHRTb2xvQXdhaXRTdGF0ZTtcbiAgICB9XG4gIH1cbiAgYWxsb3dJbkFuZChjYWxsYmFjaykge1xuICAgIGNvbnN0IGZsYWdzID0gdGhpcy5wcm9kUGFyYW0uY3VycmVudEZsYWdzKCk7XG4gICAgY29uc3QgcHJvZFBhcmFtVG9TZXQgPSA4ICYgfmZsYWdzO1xuICAgIGlmIChwcm9kUGFyYW1Ub1NldCkge1xuICAgICAgdGhpcy5wcm9kUGFyYW0uZW50ZXIoZmxhZ3MgfCA4KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuICBkaXNhbGxvd0luQW5kKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZmxhZ3MgPSB0aGlzLnByb2RQYXJhbS5jdXJyZW50RmxhZ3MoKTtcbiAgICBjb25zdCBwcm9kUGFyYW1Ub0NsZWFyID0gOCAmIGZsYWdzO1xuICAgIGlmIChwcm9kUGFyYW1Ub0NsZWFyKSB7XG4gICAgICB0aGlzLnByb2RQYXJhbS5lbnRlcihmbGFncyAmIH44KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuICByZWdpc3RlclRvcGljUmVmZXJlbmNlKCkge1xuICAgIHRoaXMuc3RhdGUudG9waWNDb250ZXh0Lm1heFRvcGljSW5kZXggPSAwO1xuICB9XG4gIHRvcGljUmVmZXJlbmNlSXNBbGxvd2VkSW5DdXJyZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4TnVtT2ZSZXNvbHZhYmxlVG9waWNzID49IDE7XG4gIH1cbiAgdG9waWNSZWZlcmVuY2VXYXNVc2VkSW5DdXJyZW50Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS50b3BpY0NvbnRleHQubWF4VG9waWNJbmRleCAhPSBudWxsICYmIHRoaXMuc3RhdGUudG9waWNDb250ZXh0Lm1heFRvcGljSW5kZXggPj0gMDtcbiAgfVxuICBwYXJzZUZTaGFycFBpcGVsaW5lQm9keShwcmVjKSB7XG4gICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgIHRoaXMuc3RhdGUucG90ZW50aWFsQXJyb3dBdCA9IHRoaXMuc3RhdGUuc3RhcnQ7XG4gICAgY29uc3Qgb2xkSW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0aGlzLnN0YXRlLmluRlNoYXJwUGlwZWxpbmVEaXJlY3RCb2R5O1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSB0cnVlO1xuICAgIGNvbnN0IHJldCA9IHRoaXMucGFyc2VFeHByT3AodGhpcy5wYXJzZU1heWJlVW5hcnlPclByaXZhdGUoKSwgc3RhcnRMb2MsIHByZWMpO1xuICAgIHRoaXMuc3RhdGUuaW5GU2hhcnBQaXBlbGluZURpcmVjdEJvZHkgPSBvbGRJbkZTaGFycFBpcGVsaW5lRGlyZWN0Qm9keTtcbiAgICByZXR1cm4gcmV0O1xuICB9XG4gIHBhcnNlTW9kdWxlRXhwcmVzc2lvbigpIHtcbiAgICB0aGlzLmV4cGVjdFBsdWdpbihcIm1vZHVsZUJsb2Nrc1wiKTtcbiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAoIXRoaXMubWF0Y2goNSkpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCA1KTtcbiAgICB9XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuc3RhcnROb2RlQXQodGhpcy5zdGF0ZS5lbmRMb2MpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGNvbnN0IHJldmVydFNjb3BlcyA9IHRoaXMuaW5pdGlhbGl6ZVNjb3Blcyh0cnVlKTtcbiAgICB0aGlzLmVudGVySW5pdGlhbFNjb3BlcygpO1xuICAgIHRyeSB7XG4gICAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlUHJvZ3JhbShwcm9ncmFtLCA4LCBcIm1vZHVsZVwiKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmV2ZXJ0U2NvcGVzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJNb2R1bGVFeHByZXNzaW9uXCIpO1xuICB9XG4gIHBhcnNlVm9pZFBhdHRlcm4ocmVmRXhwcmVzc2lvbkVycm9ycykge1xuICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZGlzY2FyZEJpbmRpbmdcIik7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMgIT0gbnVsbCkge1xuICAgICAgcmVmRXhwcmVzc2lvbkVycm9ycy52b2lkUGF0dGVybkxvYyA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgfVxuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJWb2lkUGF0dGVyblwiKTtcbiAgfVxuICBwYXJzZU1heWJlQXNzaWduQWxsb3dJbk9yVm9pZFBhdHRlcm4oY2xvc2UsIHJlZkV4cHJlc3Npb25FcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gICAgaWYgKHJlZkV4cHJlc3Npb25FcnJvcnMgIT0gbnVsbCAmJiB0aGlzLm1hdGNoKDg4KSkge1xuICAgICAgY29uc3QgbmV4dENvZGUgPSB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCk7XG4gICAgICBpZiAobmV4dENvZGUgPT09IDQ0IHx8IG5leHRDb2RlID09PSAoY2xvc2UgPT09IDMgPyA5MyA6IGNsb3NlID09PSA4ID8gMTI1IDogNDEpIHx8IG5leHRDb2RlID09PSA2MSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU1heWJlRGVmYXVsdCh0aGlzLnN0YXRlLnN0YXJ0TG9jLCB0aGlzLnBhcnNlVm9pZFBhdHRlcm4ocmVmRXhwcmVzc2lvbkVycm9ycykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbihyZWZFeHByZXNzaW9uRXJyb3JzLCBhZnRlckxlZnRQYXJzZSk7XG4gIH1cbiAgcGFyc2VQcm9wZXJ0eU5hbWVQcmVmaXhPcGVyYXRvcihwcm9wKSB7fVxufVxuY29uc3QgbG9vcExhYmVsID0ge1xuICAgIGtpbmQ6IDFcbiAgfSxcbiAgc3dpdGNoTGFiZWwgPSB7XG4gICAga2luZDogMlxuICB9O1xuY29uc3QgbG9uZVN1cnJvZ2F0ZSA9IC9bXFx1RDgwMC1cXHVERkZGXS91O1xuY29uc3Qga2V5d29yZFJlbGF0aW9uYWxPcGVyYXRvciA9IC9pbig/OnN0YW5jZW9mKT8veTtcbmZ1bmN0aW9uIGJhYmVsN0NvbXBhdFRva2Vucyh0b2tlbnMsIGlucHV0LCBzdGFydEluZGV4KSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0b2tlbjtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmICh0eXBlID09PSAxMzkpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxvYyxcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBlbmRcbiAgICAgICAgfSA9IHRva2VuO1xuICAgICAgICBjb25zdCBoYXNoRW5kUG9zID0gc3RhcnQgKyAxO1xuICAgICAgICBjb25zdCBoYXNoRW5kTG9jID0gY3JlYXRlUG9zaXRpb25XaXRoQ29sdW1uT2Zmc2V0KGxvYy5zdGFydCwgMSk7XG4gICAgICAgIHRva2Vucy5zcGxpY2UoaSwgMSwgbmV3IFRva2VuKHtcbiAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDI3KSxcbiAgICAgICAgICB2YWx1ZTogXCIjXCIsXG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgIGVuZDogaGFzaEVuZFBvcyxcbiAgICAgICAgICBzdGFydExvYzogbG9jLnN0YXJ0LFxuICAgICAgICAgIGVuZExvYzogaGFzaEVuZExvY1xuICAgICAgICB9KSwgbmV3IFRva2VuKHtcbiAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDEzMiksXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIHN0YXJ0OiBoYXNoRW5kUG9zLFxuICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgIHN0YXJ0TG9jOiBoYXNoRW5kTG9jLFxuICAgICAgICAgIGVuZExvYzogbG9jLmVuZFxuICAgICAgICB9KSk7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodG9rZW5Jc1RlbXBsYXRlKHR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBsb2MsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZW5kXG4gICAgICAgIH0gPSB0b2tlbjtcbiAgICAgICAgY29uc3QgYmFja3F1b3RlRW5kID0gc3RhcnQgKyAxO1xuICAgICAgICBjb25zdCBiYWNrcXVvdGVFbmRMb2MgPSBjcmVhdGVQb3NpdGlvbldpdGhDb2x1bW5PZmZzZXQobG9jLnN0YXJ0LCAxKTtcbiAgICAgICAgbGV0IHN0YXJ0VG9rZW47XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHN0YXJ0IC0gc3RhcnRJbmRleCkgPT09IDk2KSB7XG4gICAgICAgICAgc3RhcnRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDIyKSxcbiAgICAgICAgICAgIHZhbHVlOiBcImBcIixcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogYmFja3F1b3RlRW5kLFxuICAgICAgICAgICAgc3RhcnRMb2M6IGxvYy5zdGFydCxcbiAgICAgICAgICAgIGVuZExvYzogYmFja3F1b3RlRW5kTG9jXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhcnRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDgpLFxuICAgICAgICAgICAgdmFsdWU6IFwifVwiLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBiYWNrcXVvdGVFbmQsXG4gICAgICAgICAgICBzdGFydExvYzogbG9jLnN0YXJ0LFxuICAgICAgICAgICAgZW5kTG9jOiBiYWNrcXVvdGVFbmRMb2NcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGVtcGxhdGVWYWx1ZSwgdGVtcGxhdGVFbGVtZW50RW5kLCB0ZW1wbGF0ZUVsZW1lbnRFbmRMb2MsIGVuZFRva2VuO1xuICAgICAgICBpZiAodHlwZSA9PT0gMjQpIHtcbiAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnRFbmQgPSBlbmQgLSAxO1xuICAgICAgICAgIHRlbXBsYXRlRWxlbWVudEVuZExvYyA9IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChsb2MuZW5kLCAtMSk7XG4gICAgICAgICAgdGVtcGxhdGVWYWx1ZSA9IHZhbHVlID09PSBudWxsID8gbnVsbCA6IHZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICBlbmRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDIyKSxcbiAgICAgICAgICAgIHZhbHVlOiBcImBcIixcbiAgICAgICAgICAgIHN0YXJ0OiB0ZW1wbGF0ZUVsZW1lbnRFbmQsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIHN0YXJ0TG9jOiB0ZW1wbGF0ZUVsZW1lbnRFbmRMb2MsXG4gICAgICAgICAgICBlbmRMb2M6IGxvYy5lbmRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZW1wbGF0ZUVsZW1lbnRFbmQgPSBlbmQgLSAyO1xuICAgICAgICAgIHRlbXBsYXRlRWxlbWVudEVuZExvYyA9IGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldChsb2MuZW5kLCAtMik7XG4gICAgICAgICAgdGVtcGxhdGVWYWx1ZSA9IHZhbHVlID09PSBudWxsID8gbnVsbCA6IHZhbHVlLnNsaWNlKDEsIC0yKTtcbiAgICAgICAgICBlbmRUb2tlbiA9IG5ldyBUb2tlbih7XG4gICAgICAgICAgICB0eXBlOiBnZXRFeHBvcnRlZFRva2VuKDIzKSxcbiAgICAgICAgICAgIHZhbHVlOiBcIiR7XCIsXG4gICAgICAgICAgICBzdGFydDogdGVtcGxhdGVFbGVtZW50RW5kLFxuICAgICAgICAgICAgZW5kOiBlbmQsXG4gICAgICAgICAgICBzdGFydExvYzogdGVtcGxhdGVFbGVtZW50RW5kTG9jLFxuICAgICAgICAgICAgZW5kTG9jOiBsb2MuZW5kXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW5zLnNwbGljZShpLCAxLCBzdGFydFRva2VuLCBuZXcgVG9rZW4oe1xuICAgICAgICAgIHR5cGU6IGdldEV4cG9ydGVkVG9rZW4oMjApLFxuICAgICAgICAgIHZhbHVlOiB0ZW1wbGF0ZVZhbHVlLFxuICAgICAgICAgIHN0YXJ0OiBiYWNrcXVvdGVFbmQsXG4gICAgICAgICAgZW5kOiB0ZW1wbGF0ZUVsZW1lbnRFbmQsXG4gICAgICAgICAgc3RhcnRMb2M6IGJhY2txdW90ZUVuZExvYyxcbiAgICAgICAgICBlbmRMb2M6IHRlbXBsYXRlRWxlbWVudEVuZExvY1xuICAgICAgICB9KSwgZW5kVG9rZW4pO1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdG9rZW4udHlwZSA9IGdldEV4cG9ydGVkVG9rZW4odHlwZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b2tlbnM7XG59XG5jbGFzcyBTdGF0ZW1lbnRQYXJzZXIgZXh0ZW5kcyBFeHByZXNzaW9uUGFyc2VyIHtcbiAgcGFyc2VUb3BMZXZlbChmaWxlLCBwcm9ncmFtKSB7XG4gICAgZmlsZS5wcm9ncmFtID0gdGhpcy5wYXJzZVByb2dyYW0ocHJvZ3JhbSwgMTQwLCB0aGlzLm9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIiA/IFwibW9kdWxlXCIgOiBcInNjcmlwdFwiKTtcbiAgICBmaWxlLmNvbW1lbnRzID0gdGhpcy5jb21tZW50cztcbiAgICBpZiAodGhpcy5vcHRpb25GbGFncyAmIDI1Nikge1xuICAgICAgZmlsZS50b2tlbnMgPSBiYWJlbDdDb21wYXRUb2tlbnModGhpcy50b2tlbnMsIHRoaXMuaW5wdXQsIHRoaXMuc3RhcnRJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZmlsZSwgXCJGaWxlXCIpO1xuICB9XG4gIHBhcnNlUHJvZ3JhbShwcm9ncmFtLCBlbmQsIHNvdXJjZVR5cGUpIHtcbiAgICBwcm9ncmFtLnNvdXJjZVR5cGUgPSBzb3VyY2VUeXBlO1xuICAgIHByb2dyYW0uaW50ZXJwcmV0ZXIgPSB0aGlzLnBhcnNlSW50ZXJwcmV0ZXJEaXJlY3RpdmUoKTtcbiAgICB0aGlzLnBhcnNlQmxvY2tCb2R5KHByb2dyYW0sIHRydWUsIHRydWUsIGVuZCk7XG4gICAgaWYgKHRoaXMuaW5Nb2R1bGUpIHtcbiAgICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiA2NCkgJiYgdGhpcy5zY29wZS51bmRlZmluZWRFeHBvcnRzLnNpemUgPiAwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2xvY2FsTmFtZSwgYXRdIG9mIEFycmF5LmZyb20odGhpcy5zY29wZS51bmRlZmluZWRFeHBvcnRzKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUV4cG9ydFVuZGVmaW5lZCwgYXQsIHtcbiAgICAgICAgICAgIGxvY2FsTmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmFkZEV4dHJhKHByb2dyYW0sIFwidG9wTGV2ZWxBd2FpdFwiLCB0aGlzLnN0YXRlLmhhc1RvcExldmVsQXdhaXQpO1xuICAgIH1cbiAgICBsZXQgZmluaXNoZWRQcm9ncmFtO1xuICAgIGlmIChlbmQgPT09IDE0MCkge1xuICAgICAgZmluaXNoZWRQcm9ncmFtID0gdGhpcy5maW5pc2hOb2RlKHByb2dyYW0sIFwiUHJvZ3JhbVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoZWRQcm9ncmFtID0gdGhpcy5maW5pc2hOb2RlQXQocHJvZ3JhbSwgXCJQcm9ncmFtXCIsIGNyZWF0ZVBvc2l0aW9uV2l0aENvbHVtbk9mZnNldCh0aGlzLnN0YXRlLnN0YXJ0TG9jLCAtMSkpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoZWRQcm9ncmFtO1xuICB9XG4gIHN0bXRUb0RpcmVjdGl2ZShzdG10KSB7XG4gICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5jYXN0Tm9kZVRvKHN0bXQsIFwiRGlyZWN0aXZlXCIpO1xuICAgIGNvbnN0IGRpcmVjdGl2ZUxpdGVyYWwgPSB0aGlzLmNhc3ROb2RlVG8oc3RtdC5leHByZXNzaW9uLCBcIkRpcmVjdGl2ZUxpdGVyYWxcIik7XG4gICAgY29uc3QgZXhwcmVzc2lvblZhbHVlID0gZGlyZWN0aXZlTGl0ZXJhbC52YWx1ZTtcbiAgICBjb25zdCByYXcgPSB0aGlzLmlucHV0LnNsaWNlKHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3MoZGlyZWN0aXZlTGl0ZXJhbC5zdGFydCksIHRoaXMub2Zmc2V0VG9Tb3VyY2VQb3MoZGlyZWN0aXZlTGl0ZXJhbC5lbmQpKTtcbiAgICBjb25zdCB2YWwgPSBkaXJlY3RpdmVMaXRlcmFsLnZhbHVlID0gcmF3LnNsaWNlKDEsIC0xKTtcbiAgICB0aGlzLmFkZEV4dHJhKGRpcmVjdGl2ZUxpdGVyYWwsIFwicmF3XCIsIHJhdyk7XG4gICAgdGhpcy5hZGRFeHRyYShkaXJlY3RpdmVMaXRlcmFsLCBcInJhd1ZhbHVlXCIsIHZhbCk7XG4gICAgdGhpcy5hZGRFeHRyYShkaXJlY3RpdmVMaXRlcmFsLCBcImV4cHJlc3Npb25WYWx1ZVwiLCBleHByZXNzaW9uVmFsdWUpO1xuICAgIGRpcmVjdGl2ZS52YWx1ZSA9IGRpcmVjdGl2ZUxpdGVyYWw7XG4gICAgZGVsZXRlIHN0bXQuZXhwcmVzc2lvbjtcbiAgICByZXR1cm4gZGlyZWN0aXZlO1xuICB9XG4gIHBhcnNlSW50ZXJwcmV0ZXJEaXJlY3RpdmUoKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDI4KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUudmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbnRlcnByZXRlckRpcmVjdGl2ZVwiKTtcbiAgfVxuICBpc0xldCgpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDEwMCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFzRm9sbG93aW5nQmluZGluZ0F0b20oKTtcbiAgfVxuICBpc1VzaW5nKCkge1xuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoMTA3KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW5Jc0lkZW50aWZpZXJPblNhbWVMaW5lKCk7XG4gIH1cbiAgaXNGb3JVc2luZygpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDEwNykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKTtcbiAgICBjb25zdCBuZXh0Q2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKG5leHQpO1xuICAgIGlmICh0aGlzLmlzVW5wYXJzZWRDb250ZXh0dWFsKG5leHQsIFwib2ZcIikpIHtcbiAgICAgIGNvbnN0IG5leHRDaGFyQWZ0ZXJPZiA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGVTaW5jZShuZXh0ICsgMik7XG4gICAgICBpZiAobmV4dENoYXJBZnRlck9mICE9PSA2MSAmJiBuZXh0Q2hhckFmdGVyT2YgIT09IDU4ICYmIG5leHRDaGFyQWZ0ZXJPZiAhPT0gNTkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCkgfHwgdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcInZvaWRcIikpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbmV4dFRva2VuSXNJZGVudGlmaWVyT25TYW1lTGluZSgpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5JbkxpbmVTdGFydCgpO1xuICAgIGNvbnN0IG5leHRDaCA9IHRoaXMuY29kZVBvaW50QXRQb3MobmV4dCk7XG4gICAgcmV0dXJuIHRoaXMuY2hTdGFydHNCaW5kaW5nSWRlbnRpZmllcihuZXh0Q2gsIG5leHQpO1xuICB9XG4gIGlzQXdhaXRVc2luZygpIHtcbiAgICBpZiAoIXRoaXMuaXNDb250ZXh0dWFsKDk2KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKTtcbiAgICBpZiAodGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcInVzaW5nXCIpKSB7XG4gICAgICBuZXh0ID0gdGhpcy5uZXh0VG9rZW5JbkxpbmVTdGFydFNpbmNlKG5leHQgKyA1KTtcbiAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMuY29kZVBvaW50QXRQb3MobmV4dCk7XG4gICAgICBpZiAodGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKGNoLCBwb3MpIHtcbiAgICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgICBrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLmxhc3RJbmRleCA9IHBvcztcbiAgICAgIGlmIChrZXl3b3JkUmVsYXRpb25hbE9wZXJhdG9yLnRlc3QodGhpcy5pbnB1dCkpIHtcbiAgICAgICAgY29uc3QgZW5kQ2ggPSB0aGlzLmNvZGVQb2ludEF0UG9zKGtleXdvcmRSZWxhdGlvbmFsT3BlcmF0b3IubGFzdEluZGV4KTtcbiAgICAgICAgaWYgKCFpc0lkZW50aWZpZXJDaGFyKGVuZENoKSAmJiBlbmRDaCAhPT0gOTIpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09IDkyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBjaFN0YXJ0c0JpbmRpbmdQYXR0ZXJuKGNoKSB7XG4gICAgcmV0dXJuIGNoID09PSA5MSB8fCBjaCA9PT0gMTIzO1xuICB9XG4gIGhhc0ZvbGxvd2luZ0JpbmRpbmdBdG9tKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICByZXR1cm4gdGhpcy5jaFN0YXJ0c0JpbmRpbmdQYXR0ZXJuKG5leHRDaCkgfHwgdGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCk7XG4gIH1cbiAgaGFzSW5MaW5lRm9sbG93aW5nQmluZGluZ0lkZW50aWZpZXJPckJyYWNlKCkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlbkluTGluZVN0YXJ0KCk7XG4gICAgY29uc3QgbmV4dENoID0gdGhpcy5jb2RlUG9pbnRBdFBvcyhuZXh0KTtcbiAgICByZXR1cm4gbmV4dENoID09PSAxMjMgfHwgdGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCk7XG4gIH1cbiAgYWxsb3dzVXNpbmcoKSB7XG4gICAgcmV0dXJuICh0aGlzLnNjb3BlLmluTW9kdWxlIHx8ICF0aGlzLnNjb3BlLmluVG9wTGV2ZWwpICYmICF0aGlzLnNjb3BlLmluQmFyZUNhc2VTdGF0ZW1lbnQ7XG4gIH1cbiAgcGFyc2VNb2R1bGVJdGVtKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50TGlrZSgxIHwgMiB8IDQgfCA4KTtcbiAgfVxuICBwYXJzZVN0YXRlbWVudExpc3RJdGVtKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50TGlrZSgyIHwgNCB8ICghdGhpcy5vcHRpb25zLmFubmV4QiB8fCB0aGlzLnN0YXRlLnN0cmljdCA/IDAgOiA4KSk7XG4gIH1cbiAgcGFyc2VTdGF0ZW1lbnRPclNsb3BweUFubmV4QkZ1bmN0aW9uRGVjbGFyYXRpb24oYWxsb3dMYWJlbGVkRnVuY3Rpb24gPSBmYWxzZSkge1xuICAgIGxldCBmbGFncyA9IDA7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hbm5leEIgJiYgIXRoaXMuc3RhdGUuc3RyaWN0KSB7XG4gICAgICBmbGFncyB8PSA0O1xuICAgICAgaWYgKGFsbG93TGFiZWxlZEZ1bmN0aW9uKSB7XG4gICAgICAgIGZsYWdzIHw9IDg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50TGlrZShmbGFncyk7XG4gIH1cbiAgcGFyc2VTdGF0ZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRMaWtlKDApO1xuICB9XG4gIHBhcnNlU3RhdGVtZW50TGlrZShmbGFncykge1xuICAgIGxldCBkZWNvcmF0b3JzID0gbnVsbDtcbiAgICBpZiAodGhpcy5tYXRjaCgyNikpIHtcbiAgICAgIGRlY29yYXRvcnMgPSB0aGlzLnBhcnNlRGVjb3JhdG9ycyh0cnVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VTdGF0ZW1lbnRDb250ZW50KGZsYWdzLCBkZWNvcmF0b3JzKTtcbiAgfVxuICBwYXJzZVN0YXRlbWVudENvbnRlbnQoZmxhZ3MsIGRlY29yYXRvcnMpIHtcbiAgICBjb25zdCBzdGFydFR5cGUgPSB0aGlzLnN0YXRlLnR5cGU7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgYWxsb3dEZWNsYXJhdGlvbiA9ICEhKGZsYWdzICYgMik7XG4gICAgY29uc3QgYWxsb3dGdW5jdGlvbkRlY2xhcmF0aW9uID0gISEoZmxhZ3MgJiA0KTtcbiAgICBjb25zdCB0b3BMZXZlbCA9IGZsYWdzICYgMTtcbiAgICBzd2l0Y2ggKHN0YXJ0VHlwZSkge1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHRydWUpO1xuICAgICAgY2FzZSA2MzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIGZhbHNlKTtcbiAgICAgIGNhc2UgNjQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZURvV2hpbGVTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDkxOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvclN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNjg6XG4gICAgICAgIGlmICh0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDQ2KSBicmVhaztcbiAgICAgICAgaWYgKCFhbGxvd0Z1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKHRoaXMuc3RhdGUuc3RyaWN0ID8gRXJyb3JzLlN0cmljdEZ1bmN0aW9uIDogdGhpcy5vcHRpb25zLmFubmV4QiA/IEVycm9ycy5TbG9wcHlGdW5jdGlvbkFubmV4QiA6IEVycm9ycy5TbG9wcHlGdW5jdGlvbiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCBmYWxzZSwgIWFsbG93RGVjbGFyYXRpb24gJiYgYWxsb3dGdW5jdGlvbkRlY2xhcmF0aW9uKTtcbiAgICAgIGNhc2UgODA6XG4gICAgICAgIGlmICghYWxsb3dEZWNsYXJhdGlvbikgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ2xhc3ModGhpcy5tYXliZVRha2VEZWNvcmF0b3JzKGRlY29yYXRvcnMsIG5vZGUpLCB0cnVlKTtcbiAgICAgIGNhc2UgNjk6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlSWZTdGF0ZW1lbnQobm9kZSk7XG4gICAgICBjYXNlIDcwOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVJldHVyblN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNzE6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU3dpdGNoU3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA3MjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUaHJvd1N0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNzM6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVHJ5U3RhdGVtZW50KG5vZGUpO1xuICAgICAgY2FzZSA5NjpcbiAgICAgICAgaWYgKHRoaXMuaXNBd2FpdFVzaW5nKCkpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzVXNpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFVzaW5nRGVjbGFyYXRpb24sIG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWFsbG93RGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVuZXhwZWN0ZWRMZXhpY2FsRGVjbGFyYXRpb24sIG5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucmVjb3JkQXdhaXRJZkFsbG93ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXdhaXRVc2luZ05vdEluQXN5bmNDb250ZXh0LCBub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwgXCJhd2FpdCB1c2luZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA3OlxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5jb250YWluc0VzYyB8fCAhdGhpcy5oYXNJbkxpbmVGb2xsb3dpbmdCaW5kaW5nSWRlbnRpZmllck9yQnJhY2UoKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5hbGxvd3NVc2luZygpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZFVzaW5nRGVjbGFyYXRpb24sIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICB9IGVsc2UgaWYgKCFhbGxvd0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZExleGljYWxEZWNsYXJhdGlvbiwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYXJTdGF0ZW1lbnQobm9kZSwgXCJ1c2luZ1wiKTtcbiAgICAgIGNhc2UgMTAwOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdGUuY29udGFpbnNFc2MpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuZXh0ID0gdGhpcy5uZXh0VG9rZW5TdGFydCgpO1xuICAgICAgICAgIGNvbnN0IG5leHRDaCA9IHRoaXMuY29kZVBvaW50QXRQb3MobmV4dCk7XG4gICAgICAgICAgaWYgKG5leHRDaCAhPT0gOTEpIHtcbiAgICAgICAgICAgIGlmICghYWxsb3dEZWNsYXJhdGlvbiAmJiB0aGlzLmhhc0ZvbGxvd2luZ0xpbmVCcmVhaygpKSBicmVhaztcbiAgICAgICAgICAgIGlmICghdGhpcy5jaFN0YXJ0c0JpbmRpbmdJZGVudGlmaWVyKG5leHRDaCwgbmV4dCkgJiYgbmV4dENoICE9PSAxMjMpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIDc1OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCFhbGxvd0RlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkTGV4aWNhbERlY2xhcmF0aW9uLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNzQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBraW5kID0gdGhpcy5zdGF0ZS52YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA5MjpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNzY6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlV2l0aFN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCbG9jaygpO1xuICAgICAgY2FzZSAxMzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFbXB0eVN0YXRlbWVudChub2RlKTtcbiAgICAgIGNhc2UgODM6XG4gICAgICAgIHtcbiAgICAgICAgICBjb25zdCBuZXh0VG9rZW5DaGFyQ29kZSA9IHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKTtcbiAgICAgICAgICBpZiAobmV4dFRva2VuQ2hhckNvZGUgPT09IDQwIHx8IG5leHRUb2tlbkNoYXJDb2RlID09PSA0Nikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBjYXNlIDgyOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCEodGhpcy5vcHRpb25GbGFncyAmIDgpICYmICF0b3BMZXZlbCkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuVW5leHBlY3RlZEltcG9ydEV4cG9ydCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgaWYgKHN0YXJ0VHlwZSA9PT0gODMpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VJbXBvcnQobm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VFeHBvcnQobm9kZSwgZGVjb3JhdG9ycyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXNzZXJ0TW9kdWxlTm9kZUFsbG93ZWQocmVzdWx0KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpIHtcbiAgICAgICAgICAgIGlmICghYWxsb3dEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Bc3luY0Z1bmN0aW9uSW5TaW5nbGVTdGF0ZW1lbnRDb250ZXh0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvblN0YXRlbWVudChub2RlLCB0cnVlLCAhYWxsb3dEZWNsYXJhdGlvbiAmJiBhbGxvd0Z1bmN0aW9uRGVjbGFyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtYXliZU5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcihzdGFydFR5cGUpICYmIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcy5lYXQoMTQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUxhYmVsZWRTdGF0ZW1lbnQobm9kZSwgbWF5YmVOYW1lLCBleHByLCBmbGFncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvblN0YXRlbWVudChub2RlLCBleHByLCBkZWNvcmF0b3JzKTtcbiAgICB9XG4gIH1cbiAgYXNzZXJ0TW9kdWxlTm9kZUFsbG93ZWQobm9kZSkge1xuICAgIGlmICghKHRoaXMub3B0aW9uRmxhZ3MgJiA4KSAmJiAhdGhpcy5pbk1vZHVsZSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0T3V0c2lkZU1vZHVsZSwgbm9kZSk7XG4gICAgfVxuICB9XG4gIGRlY29yYXRvcnNFbmFibGVkQmVmb3JlRXhwb3J0KCkge1xuICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnMtbGVnYWN5XCIpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5oYXNQbHVnaW4oXCJkZWNvcmF0b3JzXCIpICYmIHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnNCZWZvcmVFeHBvcnRcIikgIT09IGZhbHNlO1xuICB9XG4gIG1heWJlVGFrZURlY29yYXRvcnMobWF5YmVEZWNvcmF0b3JzLCBjbGFzc05vZGUsIGV4cG9ydE5vZGUpIHtcbiAgICBpZiAobWF5YmVEZWNvcmF0b3JzKSB7XG4gICAgICB2YXIgX2NsYXNzTm9kZSRkZWNvcmF0b3JzO1xuICAgICAgaWYgKChfY2xhc3NOb2RlJGRlY29yYXRvcnMgPSBjbGFzc05vZGUuZGVjb3JhdG9ycykgIT0gbnVsbCAmJiBfY2xhc3NOb2RlJGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydFwiKSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JzQmVmb3JlQWZ0ZXJFeHBvcnQsIGNsYXNzTm9kZS5kZWNvcmF0b3JzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc05vZGUuZGVjb3JhdG9ycy51bnNoaWZ0KC4uLm1heWJlRGVjb3JhdG9ycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGFzc05vZGUuZGVjb3JhdG9ycyA9IG1heWJlRGVjb3JhdG9ycztcbiAgICAgIH1cbiAgICAgIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUoY2xhc3NOb2RlLCBtYXliZURlY29yYXRvcnNbMF0pO1xuICAgICAgaWYgKGV4cG9ydE5vZGUpIHRoaXMucmVzZXRTdGFydExvY2F0aW9uRnJvbU5vZGUoZXhwb3J0Tm9kZSwgY2xhc3NOb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTm9kZTtcbiAgfVxuICBjYW5IYXZlTGVhZGluZ0RlY29yYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRjaCg4MCk7XG4gIH1cbiAgcGFyc2VEZWNvcmF0b3JzKGFsbG93RXhwb3J0KSB7XG4gICAgY29uc3QgZGVjb3JhdG9ycyA9IFtdO1xuICAgIGRvIHtcbiAgICAgIGRlY29yYXRvcnMucHVzaCh0aGlzLnBhcnNlRGVjb3JhdG9yKCkpO1xuICAgIH0gd2hpbGUgKHRoaXMubWF0Y2goMjYpKTtcbiAgICBpZiAodGhpcy5tYXRjaCg4MikpIHtcbiAgICAgIGlmICghYWxsb3dFeHBvcnQpIHtcbiAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZGVjb3JhdG9yc0VuYWJsZWRCZWZvcmVFeHBvcnQoKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JFeHBvcnRDbGFzcywgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5jYW5IYXZlTGVhZGluZ0RlY29yYXRvcigpKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkTGVhZGluZ0RlY29yYXRvciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvcmF0b3JzO1xuICB9XG4gIHBhcnNlRGVjb3JhdG9yKCkge1xuICAgIHRoaXMuZXhwZWN0T25lUGx1Z2luKFtcImRlY29yYXRvcnNcIiwgXCJkZWNvcmF0b3JzLWxlZ2FjeVwiXSk7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZGVjb3JhdG9yc1wiKSkge1xuICAgICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgbGV0IGV4cHI7XG4gICAgICBpZiAodGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgZXhwciA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gICAgICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICAgICAgZXhwciA9IHRoaXMud3JhcFBhcmVudGhlc2lzKHN0YXJ0TG9jLCBleHByKTtcbiAgICAgICAgY29uc3QgcGFyYW1zU3RhcnRMb2MgPSB0aGlzLnN0YXRlLnN0YXJ0TG9jO1xuICAgICAgICBub2RlLmV4cHJlc3Npb24gPSB0aGlzLnBhcnNlTWF5YmVEZWNvcmF0b3JBcmd1bWVudHMoZXhwciwgc3RhcnRMb2MpO1xuICAgICAgICBpZiAodGhpcy5nZXRQbHVnaW5PcHRpb24oXCJkZWNvcmF0b3JzXCIsIFwiYWxsb3dDYWxsUGFyZW50aGVzaXplZFwiKSA9PT0gZmFsc2UgJiYgbm9kZS5leHByZXNzaW9uICE9PSBleHByKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yQXJndW1lbnRzT3V0c2lkZVBhcmVudGhlc2VzLCBwYXJhbXNTdGFydExvYyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4cHIgPSB0aGlzLnBhcnNlSWRlbnRpZmllcihmYWxzZSk7XG4gICAgICAgIHdoaWxlICh0aGlzLmVhdCgxNikpIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydExvYyk7XG4gICAgICAgICAgbm9kZS5vYmplY3QgPSBleHByO1xuICAgICAgICAgIGlmICh0aGlzLm1hdGNoKDEzOSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xhc3NTY29wZS51c2VQcml2YXRlTmFtZSh0aGlzLnN0YXRlLnZhbHVlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICAgIG5vZGUucHJvcGVydHkgPSB0aGlzLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICAgICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1lbWJlckV4cHJlc3Npb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZU1heWJlRGVjb3JhdG9yQXJndW1lbnRzKGV4cHIsIHN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5leHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJTdWJzY3JpcHRzKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJEZWNvcmF0b3JcIik7XG4gIH1cbiAgcGFyc2VNYXliZURlY29yYXRvckFyZ3VtZW50cyhleHByLCBzdGFydExvYykge1xuICAgIGlmICh0aGlzLmVhdCgxMCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUuY2FsbGVlID0gZXhwcjtcbiAgICAgIG5vZGUuYXJndW1lbnRzID0gdGhpcy5wYXJzZUNhbGxFeHByZXNzaW9uQXJndW1lbnRzKCk7XG4gICAgICB0aGlzLnRvUmVmZXJlbmNlZExpc3Qobm9kZS5hcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNhbGxFeHByZXNzaW9uXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbiAgfVxuICBwYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQobm9kZSwgaXNCcmVhaykge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLmlzTGluZVRlcm1pbmF0b3IoKSkge1xuICAgICAgbm9kZS5sYWJlbCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUubGFiZWwgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB9XG4gICAgdGhpcy52ZXJpZnlCcmVha0NvbnRpbnVlKG5vZGUsIGlzQnJlYWspO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNCcmVhayA/IFwiQnJlYWtTdGF0ZW1lbnRcIiA6IFwiQ29udGludWVTdGF0ZW1lbnRcIik7XG4gIH1cbiAgdmVyaWZ5QnJlYWtDb250aW51ZShub2RlLCBpc0JyZWFrKSB7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc3RhdGUubGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBsYWIgPSB0aGlzLnN0YXRlLmxhYmVsc1tpXTtcbiAgICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgICBpZiAobGFiLmtpbmQgIT0gbnVsbCAmJiAoaXNCcmVhayB8fCBsYWIua2luZCA9PT0gMSkpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGkgPT09IHRoaXMuc3RhdGUubGFiZWxzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdHlwZSA9IGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCI7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbGxlZ2FsQnJlYWtDb250aW51ZSwgbm9kZSwge1xuICAgICAgICB0eXBlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VIZWFkZXJFeHByZXNzaW9uKCkge1xuICAgIHRoaXMuZXhwZWN0KDEwKTtcbiAgICBjb25zdCB2YWwgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIHBhcnNlRG9XaGlsZVN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlU3RhdGVtZW50KCkpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHRoaXMuZXhwZWN0KDkyKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZWF0KDEzKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRG9XaGlsZVN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUZvclN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICAgIGxldCBhd2FpdEF0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTYpICYmIHRoaXMucmVjb3JkQXdhaXRJZkFsbG93ZWQoKSkge1xuICAgICAgYXdhaXRBdCA9IHRoaXMuc3RhdGUuc3RhcnRMb2M7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgdGhpcy5zY29wZS5lbnRlcigwKTtcbiAgICB0aGlzLmV4cGVjdCgxMCk7XG4gICAgaWYgKHRoaXMubWF0Y2goMTMpKSB7XG4gICAgICBpZiAoYXdhaXRBdCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZvcihub2RlLCBudWxsKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRzV2l0aExldCA9IHRoaXMuaXNDb250ZXh0dWFsKDEwMCk7XG4gICAge1xuICAgICAgY29uc3Qgc3RhcnRzV2l0aEF3YWl0VXNpbmcgPSB0aGlzLmlzQXdhaXRVc2luZygpO1xuICAgICAgY29uc3Qgc3RhcnNXaXRoVXNpbmdEZWNsYXJhdGlvbiA9IHN0YXJ0c1dpdGhBd2FpdFVzaW5nIHx8IHRoaXMuaXNGb3JVc2luZygpO1xuICAgICAgY29uc3QgaXNMZXRPclVzaW5nID0gc3RhcnRzV2l0aExldCAmJiB0aGlzLmhhc0ZvbGxvd2luZ0JpbmRpbmdBdG9tKCkgfHwgc3RhcnNXaXRoVXNpbmdEZWNsYXJhdGlvbjtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDc0KSB8fCB0aGlzLm1hdGNoKDc1KSB8fCBpc0xldE9yVXNpbmcpIHtcbiAgICAgICAgY29uc3QgaW5pdE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBsZXQga2luZDtcbiAgICAgICAgaWYgKHN0YXJ0c1dpdGhBd2FpdFVzaW5nKSB7XG4gICAgICAgICAga2luZCA9IFwiYXdhaXQgdXNpbmdcIjtcbiAgICAgICAgICBpZiAoIXRoaXMucmVjb3JkQXdhaXRJZkFsbG93ZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQXdhaXRVc2luZ05vdEluQXN5bmNDb250ZXh0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2luZCA9IHRoaXMuc3RhdGUudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgIHRoaXMucGFyc2VWYXIoaW5pdE5vZGUsIHRydWUsIGtpbmQpO1xuICAgICAgICBjb25zdCBpbml0ID0gdGhpcy5maW5pc2hOb2RlKGluaXROb2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgICAgIGNvbnN0IGlzRm9ySW4gPSB0aGlzLm1hdGNoKDU4KTtcbiAgICAgICAgaWYgKGlzRm9ySW4gJiYgc3RhcnNXaXRoVXNpbmdEZWNsYXJhdGlvbikge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkZvckluVXNpbmcsIGluaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaXNGb3JJbiB8fCB0aGlzLmlzQ29udGV4dHVhbCgxMDIpKSAmJiBpbml0LmRlY2xhcmF0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQsIGF3YWl0QXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhd2FpdEF0ICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKGF3YWl0QXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGFydHNXaXRoQXN5bmMgPSB0aGlzLmlzQ29udGV4dHVhbCg5NSk7XG4gICAgY29uc3QgcmVmRXhwcmVzc2lvbkVycm9ycyA9IG5ldyBFeHByZXNzaW9uRXJyb3JzKCk7XG4gICAgY29uc3QgaW5pdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKHRydWUsIHJlZkV4cHJlc3Npb25FcnJvcnMpO1xuICAgIGNvbnN0IGlzRm9yT2YgPSB0aGlzLmlzQ29udGV4dHVhbCgxMDIpO1xuICAgIGlmIChpc0Zvck9mKSB7XG4gICAgICBpZiAoc3RhcnRzV2l0aExldCkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Gb3JPZkxldCwgaW5pdCk7XG4gICAgICB9XG4gICAgICBpZiAoYXdhaXRBdCA9PT0gbnVsbCAmJiBzdGFydHNXaXRoQXN5bmMgJiYgaW5pdC50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Gb3JPZkFzeW5jLCBpbml0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRm9yT2YgfHwgdGhpcy5tYXRjaCg1OCkpIHtcbiAgICAgIHRoaXMuY2hlY2tEZXN0cnVjdHVyaW5nUHJpdmF0ZShyZWZFeHByZXNzaW9uRXJyb3JzKTtcbiAgICAgIHRoaXMudG9Bc3NpZ25hYmxlKGluaXQsIHRydWUpO1xuICAgICAgY29uc3QgdHlwZSA9IGlzRm9yT2YgPyBcIkZvck9mU3RhdGVtZW50XCIgOiBcIkZvckluU3RhdGVtZW50XCI7XG4gICAgICB0aGlzLmNoZWNrTFZhbChpbml0LCB7XG4gICAgICAgIHR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0LCBhd2FpdEF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRXhwcmVzc2lvbkVycm9ycywgdHJ1ZSk7XG4gICAgfVxuICAgIGlmIChhd2FpdEF0ICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoYXdhaXRBdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpO1xuICB9XG4gIHBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQobm9kZSwgaXNBc3luYywgaXNIYW5naW5nRGVjbGFyYXRpb24pIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIDEgfCAoaXNIYW5naW5nRGVjbGFyYXRpb24gPyAyIDogMCkgfCAoaXNBc3luYyA/IDggOiAwKSk7XG4gIH1cbiAgcGFyc2VJZlN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlU3RhdGVtZW50T3JTbG9wcHlBbm5leEJGdW5jdGlvbkRlY2xhcmF0aW9uKCk7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCg2NikgPyB0aGlzLnBhcnNlU3RhdGVtZW50T3JTbG9wcHlBbm5leEJGdW5jdGlvbkRlY2xhcmF0aW9uKCkgOiBudWxsO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJZlN0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZVJldHVyblN0YXRlbWVudChub2RlKSB7XG4gICAgaWYgKCF0aGlzLnByb2RQYXJhbS5oYXNSZXR1cm4pIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLklsbGVnYWxSZXR1cm4sIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAodGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIG5vZGUuYXJndW1lbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJSZXR1cm5TdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZUhlYWRlckV4cHJlc3Npb24oKTtcbiAgICBjb25zdCBjYXNlcyA9IG5vZGUuY2FzZXMgPSBbXTtcbiAgICB0aGlzLmV4cGVjdCg1KTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wdXNoKHN3aXRjaExhYmVsKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKDI1Nik7XG4gICAgbGV0IGN1cjtcbiAgICBmb3IgKGxldCBzYXdEZWZhdWx0OyAhdGhpcy5tYXRjaCg4KTspIHtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDYxKSB8fCB0aGlzLm1hdGNoKDY1KSkge1xuICAgICAgICBjb25zdCBpc0Nhc2UgPSB0aGlzLm1hdGNoKDYxKTtcbiAgICAgICAgaWYgKGN1cikgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpO1xuICAgICAgICBjYXNlcy5wdXNoKGN1ciA9IHRoaXMuc3RhcnROb2RlKCkpO1xuICAgICAgICBjdXIuY29uc2VxdWVudCA9IFtdO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgaWYgKGlzQ2FzZSkge1xuICAgICAgICAgIGN1ci50ZXN0ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc2F3RGVmYXVsdCkge1xuICAgICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTXVsdGlwbGVEZWZhdWx0c0luU3dpdGNoLCB0aGlzLnN0YXRlLmxhc3RUb2tTdGFydExvYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNhd0RlZmF1bHQgPSB0cnVlO1xuICAgICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3VyKSB7XG4gICAgICAgICAgY3VyLmNvbnNlcXVlbnQucHVzaCh0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgaWYgKGN1cikgdGhpcy5maW5pc2hOb2RlKGN1ciwgXCJTd2l0Y2hDYXNlXCIpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJTd2l0Y2hTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VUaHJvd1N0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKHRoaXMuaGFzUHJlY2VkaW5nTGluZUJyZWFrKCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk5ld2xpbmVBZnRlclRocm93LCB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MpO1xuICAgIH1cbiAgICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKTtcbiAgfVxuICBwYXJzZUNhdGNoQ2xhdXNlUGFyYW0oKSB7XG4gICAgY29uc3QgcGFyYW0gPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgICB0aGlzLnNjb3BlLmVudGVyKHRoaXMub3B0aW9ucy5hbm5leEIgJiYgcGFyYW0udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyA4IDogMCk7XG4gICAgdGhpcy5jaGVja0xWYWwocGFyYW0sIHtcbiAgICAgIHR5cGU6IFwiQ2F0Y2hDbGF1c2VcIlxuICAgIH0sIDkpO1xuICAgIHJldHVybiBwYXJhbTtcbiAgfVxuICBwYXJzZVRyeVN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5ibG9jayA9IHRoaXMucGFyc2VCbG9jaygpO1xuICAgIG5vZGUuaGFuZGxlciA9IG51bGw7XG4gICAgaWYgKHRoaXMubWF0Y2goNjIpKSB7XG4gICAgICBjb25zdCBjbGF1c2UgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5tYXRjaCgxMCkpIHtcbiAgICAgICAgdGhpcy5leHBlY3QoMTApO1xuICAgICAgICBjbGF1c2UucGFyYW0gPSB0aGlzLnBhcnNlQ2F0Y2hDbGF1c2VQYXJhbSgpO1xuICAgICAgICB0aGlzLmV4cGVjdCgxMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGF1c2UucGFyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLnNjb3BlLmVudGVyKDApO1xuICAgICAgfVxuICAgICAgY2xhdXNlLmJvZHkgPSB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZUJsb2NrKGZhbHNlLCBmYWxzZSkpO1xuICAgICAgdGhpcy5zY29wZS5leGl0KCk7XG4gICAgICBub2RlLmhhbmRsZXIgPSB0aGlzLmZpbmlzaE5vZGUoY2xhdXNlLCBcIkNhdGNoQ2xhdXNlXCIpO1xuICAgIH1cbiAgICBub2RlLmZpbmFsaXplciA9IHRoaXMuZWF0KDY3KSA/IHRoaXMucGFyc2VCbG9jaygpIDogbnVsbDtcbiAgICBpZiAoIW5vZGUuaGFuZGxlciAmJiAhbm9kZS5maW5hbGl6ZXIpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk5vQ2F0Y2hPckZpbmFsbHksIG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVHJ5U3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlVmFyU3RhdGVtZW50KG5vZGUsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyID0gZmFsc2UpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLnBhcnNlVmFyKG5vZGUsIGZhbHNlLCBraW5kLCBhbGxvd01pc3NpbmdJbml0aWFsaXplcik7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKTtcbiAgfVxuICBwYXJzZVdoaWxlU3RhdGVtZW50KG5vZGUpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlSGVhZGVyRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudCgpKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiV2hpbGVTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VXaXRoU3RhdGVtZW50KG5vZGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5zdHJpY3QpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlN0cmljdFdpdGgsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VIZWFkZXJFeHByZXNzaW9uKCk7XG4gICAgbm9kZS5ib2R5ID0gdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHRoaXMucGFyc2VTdGF0ZW1lbnQoKSk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIldpdGhTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VFbXB0eVN0YXRlbWVudChub2RlKSB7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkVtcHR5U3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIsIGZsYWdzKSB7XG4gICAgZm9yIChjb25zdCBsYWJlbCBvZiB0aGlzLnN0YXRlLmxhYmVscykge1xuICAgICAgaWYgKGxhYmVsLm5hbWUgPT09IG1heWJlTmFtZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5MYWJlbFJlZGVjbGFyYXRpb24sIGV4cHIsIHtcbiAgICAgICAgICBsYWJlbE5hbWU6IG1heWJlTmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qga2luZCA9IHRva2VuSXNMb29wKHRoaXMuc3RhdGUudHlwZSkgPyAxIDogdGhpcy5tYXRjaCg3MSkgPyAyIDogbnVsbDtcbiAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZS5sYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5zdGF0ZS5sYWJlbHNbaV07XG4gICAgICBpZiAobGFiZWwuc3RhdGVtZW50U3RhcnQgPT09IG5vZGUuc3RhcnQpIHtcbiAgICAgICAgbGFiZWwuc3RhdGVtZW50U3RhcnQgPSB0aGlzLnNvdXJjZVRvT2Zmc2V0UG9zKHRoaXMuc3RhdGUuc3RhcnQpO1xuICAgICAgICBsYWJlbC5raW5kID0ga2luZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wdXNoKHtcbiAgICAgIG5hbWU6IG1heWJlTmFtZSxcbiAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICBzdGF0ZW1lbnRTdGFydDogdGhpcy5zb3VyY2VUb09mZnNldFBvcyh0aGlzLnN0YXRlLnN0YXJ0KVxuICAgIH0pO1xuICAgIG5vZGUuYm9keSA9IGZsYWdzICYgOCA/IHRoaXMucGFyc2VTdGF0ZW1lbnRPclNsb3BweUFubmV4QkZ1bmN0aW9uRGVjbGFyYXRpb24odHJ1ZSkgOiB0aGlzLnBhcnNlU3RhdGVtZW50KCk7XG4gICAgdGhpcy5zdGF0ZS5sYWJlbHMucG9wKCk7XG4gICAgbm9kZS5sYWJlbCA9IGV4cHI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxhYmVsZWRTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIsIGRlY29yYXRvcnMpIHtcbiAgICBub2RlLmV4cHJlc3Npb24gPSBleHByO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VCbG9jayhhbGxvd0RpcmVjdGl2ZXMgPSBmYWxzZSwgY3JlYXRlTmV3TGV4aWNhbFNjb3BlID0gdHJ1ZSwgYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKGFsbG93RGlyZWN0aXZlcykge1xuICAgICAgdGhpcy5zdGF0ZS5zdHJpY3RFcnJvcnMuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkge1xuICAgICAgdGhpcy5zY29wZS5lbnRlcigwKTtcbiAgICB9XG4gICAgdGhpcy5wYXJzZUJsb2NrQm9keShub2RlLCBhbGxvd0RpcmVjdGl2ZXMsIGZhbHNlLCA4LCBhZnRlckJsb2NrUGFyc2UpO1xuICAgIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHtcbiAgICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQmxvY2tTdGF0ZW1lbnRcIik7XG4gIH1cbiAgaXNWYWxpZERpcmVjdGl2ZShzdG10KSB7XG4gICAgcmV0dXJuIHN0bXQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiYgc3RtdC5leHByZXNzaW9uLnR5cGUgPT09IFwiU3RyaW5nTGl0ZXJhbFwiICYmICFzdG10LmV4cHJlc3Npb24uZXh0cmEucGFyZW50aGVzaXplZDtcbiAgfVxuICBwYXJzZUJsb2NrQm9keShub2RlLCBhbGxvd0RpcmVjdGl2ZXMsIHRvcExldmVsLCBlbmQsIGFmdGVyQmxvY2tQYXJzZSkge1xuICAgIGNvbnN0IGJvZHkgPSBub2RlLmJvZHkgPSBbXTtcbiAgICBjb25zdCBkaXJlY3RpdmVzID0gbm9kZS5kaXJlY3RpdmVzID0gW107XG4gICAgdGhpcy5wYXJzZUJsb2NrT3JNb2R1bGVCbG9ja0JvZHkoYm9keSwgYWxsb3dEaXJlY3RpdmVzID8gZGlyZWN0aXZlcyA6IHVuZGVmaW5lZCwgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKTtcbiAgfVxuICBwYXJzZUJsb2NrT3JNb2R1bGVCbG9ja0JvZHkoYm9keSwgZGlyZWN0aXZlcywgdG9wTGV2ZWwsIGVuZCwgYWZ0ZXJCbG9ja1BhcnNlKSB7XG4gICAgY29uc3Qgb2xkU3RyaWN0ID0gdGhpcy5zdGF0ZS5zdHJpY3Q7XG4gICAgbGV0IGhhc1N0cmljdE1vZGVEaXJlY3RpdmUgPSBmYWxzZTtcbiAgICBsZXQgcGFyc2VkTm9uRGlyZWN0aXZlID0gZmFsc2U7XG4gICAgd2hpbGUgKCF0aGlzLm1hdGNoKGVuZCkpIHtcbiAgICAgIGNvbnN0IHN0bXQgPSB0b3BMZXZlbCA/IHRoaXMucGFyc2VNb2R1bGVJdGVtKCkgOiB0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgICAgIGlmIChkaXJlY3RpdmVzICYmICFwYXJzZWROb25EaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNWYWxpZERpcmVjdGl2ZShzdG10KSkge1xuICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHRoaXMuc3RtdFRvRGlyZWN0aXZlKHN0bXQpO1xuICAgICAgICAgIGRpcmVjdGl2ZXMucHVzaChkaXJlY3RpdmUpO1xuICAgICAgICAgIGlmICghaGFzU3RyaWN0TW9kZURpcmVjdGl2ZSAmJiBkaXJlY3RpdmUudmFsdWUudmFsdWUgPT09IFwidXNlIHN0cmljdFwiKSB7XG4gICAgICAgICAgICBoYXNTdHJpY3RNb2RlRGlyZWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RyaWN0KHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZWROb25EaXJlY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXRlLnN0cmljdEVycm9ycy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgYm9keS5wdXNoKHN0bXQpO1xuICAgIH1cbiAgICBhZnRlckJsb2NrUGFyc2UgPT0gbnVsbCB8fCBhZnRlckJsb2NrUGFyc2UuY2FsbCh0aGlzLCBoYXNTdHJpY3RNb2RlRGlyZWN0aXZlKTtcbiAgICBpZiAoIW9sZFN0cmljdCkge1xuICAgICAgdGhpcy5zZXRTdHJpY3QoZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLm5leHQoKTtcbiAgfVxuICBwYXJzZUZvcihub2RlLCBpbml0KSB7XG4gICAgbm9kZS5pbml0ID0gaW5pdDtcbiAgICB0aGlzLnNlbWljb2xvbihmYWxzZSk7XG4gICAgbm9kZS50ZXN0ID0gdGhpcy5tYXRjaCgxMykgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgICB0aGlzLnNlbWljb2xvbihmYWxzZSk7XG4gICAgbm9kZS51cGRhdGUgPSB0aGlzLm1hdGNoKDExKSA/IG51bGwgOiB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIHRoaXMuZXhwZWN0KDExKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLndpdGhTbWFydE1peFRvcGljRm9yYmlkZGluZ0NvbnRleHQoKCkgPT4gdGhpcy5wYXJzZVN0YXRlbWVudCgpKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscy5wb3AoKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRm9yU3RhdGVtZW50XCIpO1xuICB9XG4gIHBhcnNlRm9ySW4obm9kZSwgaW5pdCwgYXdhaXRBdCkge1xuICAgIGNvbnN0IGlzRm9ySW4gPSB0aGlzLm1hdGNoKDU4KTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBpZiAoaXNGb3JJbikge1xuICAgICAgaWYgKGF3YWl0QXQgIT09IG51bGwpIHRoaXMudW5leHBlY3RlZChhd2FpdEF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5hd2FpdCA9IGF3YWl0QXQgIT09IG51bGw7XG4gICAgfVxuICAgIGlmIChpbml0LnR5cGUgPT09IFwiVmFyaWFibGVEZWNsYXJhdGlvblwiICYmIGluaXQuZGVjbGFyYXRpb25zWzBdLmluaXQgIT0gbnVsbCAmJiAoIWlzRm9ySW4gfHwgIXRoaXMub3B0aW9ucy5hbm5leEIgfHwgdGhpcy5zdGF0ZS5zdHJpY3QgfHwgaW5pdC5raW5kICE9PSBcInZhclwiIHx8IGluaXQuZGVjbGFyYXRpb25zWzBdLmlkLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRm9ySW5PZkxvb3BJbml0aWFsaXplciwgaW5pdCwge1xuICAgICAgICB0eXBlOiBpc0ZvckluID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluaXQudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5JbnZhbGlkTGhzLCBpbml0LCB7XG4gICAgICAgIGFuY2VzdG9yOiB7XG4gICAgICAgICAgdHlwZTogXCJGb3JTdGF0ZW1lbnRcIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgICBub2RlLnJpZ2h0ID0gaXNGb3JJbiA/IHRoaXMucGFyc2VFeHByZXNzaW9uKCkgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ25BbGxvd0luKCk7XG4gICAgdGhpcy5leHBlY3QoMTEpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB0aGlzLnBhcnNlU3RhdGVtZW50KCkpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICAgIHRoaXMuc3RhdGUubGFiZWxzLnBvcCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNGb3JJbiA/IFwiRm9ySW5TdGF0ZW1lbnRcIiA6IFwiRm9yT2ZTdGF0ZW1lbnRcIik7XG4gIH1cbiAgcGFyc2VWYXIobm9kZSwgaXNGb3IsIGtpbmQsIGFsbG93TWlzc2luZ0luaXRpYWxpemVyID0gZmFsc2UpIHtcbiAgICBjb25zdCBkZWNsYXJhdGlvbnMgPSBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICAgIG5vZGUua2luZCA9IGtpbmQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgY29uc3QgZGVjbCA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG4gICAgICBkZWNsLmluaXQgPSAhdGhpcy5lYXQoMjkpID8gbnVsbCA6IGlzRm9yID8gdGhpcy5wYXJzZU1heWJlQXNzaWduRGlzYWxsb3dJbigpIDogdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgICAgaWYgKGRlY2wuaW5pdCA9PT0gbnVsbCAmJiAhYWxsb3dNaXNzaW5nSW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgaWYgKGRlY2wuaWQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIgJiYgIShpc0ZvciAmJiAodGhpcy5tYXRjaCg1OCkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTAyKSkpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjbGFyYXRpb25NaXNzaW5nSW5pdGlhbGl6ZXIsIHRoaXMuc3RhdGUubGFzdFRva0VuZExvYywge1xuICAgICAgICAgICAga2luZDogXCJkZXN0cnVjdHVyaW5nXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICgoa2luZCA9PT0gXCJjb25zdFwiIHx8IGtpbmQgPT09IFwidXNpbmdcIiB8fCBraW5kID09PSBcImF3YWl0IHVzaW5nXCIpICYmICEodGhpcy5tYXRjaCg1OCkgfHwgdGhpcy5pc0NvbnRleHR1YWwoMTAyKSkpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNsYXJhdGlvbk1pc3NpbmdJbml0aWFsaXplciwgdGhpcy5zdGF0ZS5sYXN0VG9rRW5kTG9jLCB7XG4gICAgICAgICAgICBraW5kXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlY2xhcmF0aW9ucy5wdXNoKHRoaXMuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgICBpZiAoIXRoaXMuZWF0KDEyKSkgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHBhcnNlVmFySWQoZGVjbCwga2luZCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5wYXJzZUJpbmRpbmdBdG9tKCk7XG4gICAgaWYgKGtpbmQgPT09IFwidXNpbmdcIiB8fCBraW5kID09PSBcImF3YWl0IHVzaW5nXCIpIHtcbiAgICAgIGlmIChpZC50eXBlID09PSBcIkFycmF5UGF0dGVyblwiIHx8IGlkLnR5cGUgPT09IFwiT2JqZWN0UGF0dGVyblwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVzaW5nRGVjbGFyYXRpb25IYXNCaW5kaW5nUGF0dGVybiwgaWQubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlkLnR5cGUgPT09IFwiVm9pZFBhdHRlcm5cIikge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5VbmV4cGVjdGVkVm9pZFBhdHRlcm4sIGlkLmxvYy5zdGFydCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2hlY2tMVmFsKGlkLCB7XG4gICAgICB0eXBlOiBcIlZhcmlhYmxlRGVjbGFyYXRvclwiXG4gICAgfSwga2luZCA9PT0gXCJ2YXJcIiA/IDUgOiA4MjAxKTtcbiAgICBkZWNsLmlkID0gaWQ7XG4gIH1cbiAgcGFyc2VBc3luY0Z1bmN0aW9uRXhwcmVzc2lvbihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGdW5jdGlvbihub2RlLCA4KTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uKG5vZGUsIGZsYWdzID0gMCkge1xuICAgIGNvbnN0IGhhbmdpbmdEZWNsYXJhdGlvbiA9IGZsYWdzICYgMjtcbiAgICBjb25zdCBpc0RlY2xhcmF0aW9uID0gISEoZmxhZ3MgJiAxKTtcbiAgICBjb25zdCByZXF1aXJlSWQgPSBpc0RlY2xhcmF0aW9uICYmICEoZmxhZ3MgJiA0KTtcbiAgICBjb25zdCBpc0FzeW5jID0gISEoZmxhZ3MgJiA4KTtcbiAgICB0aGlzLmluaXRGdW5jdGlvbihub2RlLCBpc0FzeW5jKTtcbiAgICBpZiAodGhpcy5tYXRjaCg1NSkpIHtcbiAgICAgIGlmIChoYW5naW5nRGVjbGFyYXRpb24pIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuR2VuZXJhdG9ySW5TaW5nbGVTdGF0ZW1lbnRDb250ZXh0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgbm9kZS5nZW5lcmF0b3IgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNEZWNsYXJhdGlvbikge1xuICAgICAgbm9kZS5pZCA9IHRoaXMucGFyc2VGdW5jdGlvbklkKHJlcXVpcmVJZCk7XG4gICAgfVxuICAgIGNvbnN0IG9sZE1heWJlSW5BcnJvd1BhcmFtZXRlcnMgPSB0aGlzLnN0YXRlLm1heWJlSW5BcnJvd1BhcmFtZXRlcnM7XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5zY29wZS5lbnRlcig1MTQpO1xuICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKGZ1bmN0aW9uRmxhZ3MoaXNBc3luYywgbm9kZS5nZW5lcmF0b3IpKTtcbiAgICBpZiAoIWlzRGVjbGFyYXRpb24pIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlRnVuY3Rpb25JZCgpO1xuICAgIH1cbiAgICB0aGlzLnBhcnNlRnVuY3Rpb25QYXJhbXMobm9kZSwgZmFsc2UpO1xuICAgIHRoaXMud2l0aFNtYXJ0TWl4VG9waWNGb3JiaWRkaW5nQ29udGV4dCgoKSA9PiB7XG4gICAgICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5QW5kRmluaXNoKG5vZGUsIGlzRGVjbGFyYXRpb24gPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpO1xuICAgIH0pO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICBpZiAoaXNEZWNsYXJhdGlvbiAmJiAhaGFuZ2luZ0RlY2xhcmF0aW9uKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyRnVuY3Rpb25TdGF0ZW1lbnRJZChub2RlKTtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5tYXliZUluQXJyb3dQYXJhbWV0ZXJzID0gb2xkTWF5YmVJbkFycm93UGFyYW1ldGVycztcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uSWQocmVxdWlyZUlkKSB7XG4gICAgcmV0dXJuIHJlcXVpcmVJZCB8fCB0b2tlbklzSWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpID8gdGhpcy5wYXJzZUlkZW50aWZpZXIoKSA6IG51bGw7XG4gIH1cbiAgcGFyc2VGdW5jdGlvblBhcmFtcyhub2RlLCBpc0NvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5leHBlY3QoMTApO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmVudGVyKG5ld1BhcmFtZXRlckRlY2xhcmF0aW9uU2NvcGUoKSk7XG4gICAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QoMTEsIDQxLCAyIHwgKGlzQ29uc3RydWN0b3IgPyA0IDogMCkpO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmV4aXQoKTtcbiAgfVxuICByZWdpc3RlckZ1bmN0aW9uU3RhdGVtZW50SWQobm9kZSkge1xuICAgIGlmICghbm9kZS5pZCkgcmV0dXJuO1xuICAgIHRoaXMuc2NvcGUuZGVjbGFyZU5hbWUobm9kZS5pZC5uYW1lLCAhdGhpcy5vcHRpb25zLmFubmV4QiB8fCB0aGlzLnN0YXRlLnN0cmljdCB8fCBub2RlLmdlbmVyYXRvciB8fCBub2RlLmFzeW5jID8gdGhpcy5zY29wZS50cmVhdEZ1bmN0aW9uc0FzVmFyID8gNSA6IDgyMDEgOiAxNywgbm9kZS5pZC5sb2Muc3RhcnQpO1xuICB9XG4gIHBhcnNlQ2xhc3Mobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpIHtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBjb25zdCBvbGRTdHJpY3QgPSB0aGlzLnN0YXRlLnN0cmljdDtcbiAgICB0aGlzLnN0YXRlLnN0cmljdCA9IHRydWU7XG4gICAgdGhpcy5wYXJzZUNsYXNzSWQobm9kZSwgaXNTdGF0ZW1lbnQsIG9wdGlvbmFsSWQpO1xuICAgIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICAgIG5vZGUuYm9keSA9IHRoaXMucGFyc2VDbGFzc0JvZHkoISFub2RlLnN1cGVyQ2xhc3MsIG9sZFN0cmljdCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIik7XG4gIH1cbiAgaXNDbGFzc1Byb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoKDI5KSB8fCB0aGlzLm1hdGNoKDEzKSB8fCB0aGlzLm1hdGNoKDgpO1xuICB9XG4gIGlzQ2xhc3NNZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2goMTApO1xuICB9XG4gIG5hbWVJc0NvbnN0cnVjdG9yKGtleSkge1xuICAgIHJldHVybiBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYga2V5Lm5hbWUgPT09IFwiY29uc3RydWN0b3JcIiB8fCBrZXkudHlwZSA9PT0gXCJTdHJpbmdMaXRlcmFsXCIgJiYga2V5LnZhbHVlID09PSBcImNvbnN0cnVjdG9yXCI7XG4gIH1cbiAgaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihtZXRob2QpIHtcbiAgICByZXR1cm4gIW1ldGhvZC5jb21wdXRlZCAmJiAhbWV0aG9kLnN0YXRpYyAmJiB0aGlzLm5hbWVJc0NvbnN0cnVjdG9yKG1ldGhvZC5rZXkpO1xuICB9XG4gIHBhcnNlQ2xhc3NCb2R5KGhhZFN1cGVyQ2xhc3MsIG9sZFN0cmljdCkge1xuICAgIHRoaXMuY2xhc3NTY29wZS5lbnRlcigpO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgaGFkQ29uc3RydWN0b3I6IGZhbHNlLFxuICAgICAgaGFkU3VwZXJDbGFzc1xuICAgIH07XG4gICAgbGV0IGRlY29yYXRvcnMgPSBbXTtcbiAgICBjb25zdCBjbGFzc0JvZHkgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIGNsYXNzQm9keS5ib2R5ID0gW107XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgdGhpcy53aXRoU21hcnRNaXhUb3BpY0ZvcmJpZGRpbmdDb250ZXh0KCgpID0+IHtcbiAgICAgIHdoaWxlICghdGhpcy5tYXRjaCg4KSkge1xuICAgICAgICBpZiAodGhpcy5lYXQoMTMpKSB7XG4gICAgICAgICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yU2VtaWNvbG9uLCB0aGlzLnN0YXRlLmxhc3RUb2tFbmRMb2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXRjaCgyNikpIHtcbiAgICAgICAgICBkZWNvcmF0b3JzLnB1c2godGhpcy5wYXJzZURlY29yYXRvcigpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZW1iZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBpZiAoZGVjb3JhdG9ycy5sZW5ndGgpIHtcbiAgICAgICAgICBtZW1iZXIuZGVjb3JhdG9ycyA9IGRlY29yYXRvcnM7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXJ0TG9jYXRpb25Gcm9tTm9kZShtZW1iZXIsIGRlY29yYXRvcnNbMF0pO1xuICAgICAgICAgIGRlY29yYXRvcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlQ2xhc3NNZW1iZXIoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlKTtcbiAgICAgICAgaWYgKG1lbWJlci5raW5kID09PSBcImNvbnN0cnVjdG9yXCIgJiYgbWVtYmVyLmRlY29yYXRvcnMgJiYgbWVtYmVyLmRlY29yYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlY29yYXRvckNvbnN0cnVjdG9yLCBtZW1iZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zdGF0ZS5zdHJpY3QgPSBvbGRTdHJpY3Q7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgaWYgKGRlY29yYXRvcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5UcmFpbGluZ0RlY29yYXRvciwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgfVxuICAgIHRoaXMuY2xhc3NTY29wZS5leGl0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShjbGFzc0JvZHksIFwiQ2xhc3NCb2R5XCIpO1xuICB9XG4gIHBhcnNlQ2xhc3NNZW1iZXJGcm9tTW9kaWZpZXIoY2xhc3NCb2R5LCBtZW1iZXIpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlSWRlbnRpZmllcih0cnVlKTtcbiAgICBpZiAodGhpcy5pc0NsYXNzTWV0aG9kKCkpIHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IG1lbWJlcjtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIG1ldGhvZC5jb21wdXRlZCA9IGZhbHNlO1xuICAgICAgbWV0aG9kLmtleSA9IGtleTtcbiAgICAgIG1ldGhvZC5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIHRoaXMucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDbGFzc1Byb3BlcnR5KCkpIHtcbiAgICAgIGNvbnN0IHByb3AgPSBtZW1iZXI7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgICBwcm9wLmtleSA9IGtleTtcbiAgICAgIHByb3Auc3RhdGljID0gZmFsc2U7XG4gICAgICBjbGFzc0JvZHkuYm9keS5wdXNoKHRoaXMucGFyc2VDbGFzc1Byb3BlcnR5KHByb3ApKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwYXJzZUNsYXNzTWVtYmVyKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSkge1xuICAgIGNvbnN0IGlzU3RhdGljID0gdGhpcy5pc0NvbnRleHR1YWwoMTA2KTtcbiAgICBpZiAoaXNTdGF0aWMpIHtcbiAgICAgIGlmICh0aGlzLnBhcnNlQ2xhc3NNZW1iZXJGcm9tTW9kaWZpZXIoY2xhc3NCb2R5LCBtZW1iZXIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVhdCg1KSkge1xuICAgICAgICB0aGlzLnBhcnNlQ2xhc3NTdGF0aWNCbG9jayhjbGFzc0JvZHksIG1lbWJlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wYXJzZUNsYXNzTWVtYmVyV2l0aElzU3RhdGljKGNsYXNzQm9keSwgbWVtYmVyLCBzdGF0ZSwgaXNTdGF0aWMpO1xuICB9XG4gIHBhcnNlQ2xhc3NNZW1iZXJXaXRoSXNTdGF0aWMoY2xhc3NCb2R5LCBtZW1iZXIsIHN0YXRlLCBpc1N0YXRpYykge1xuICAgIGNvbnN0IHB1YmxpY01ldGhvZCA9IG1lbWJlcjtcbiAgICBjb25zdCBwcml2YXRlTWV0aG9kID0gbWVtYmVyO1xuICAgIGNvbnN0IHB1YmxpY1Byb3AgPSBtZW1iZXI7XG4gICAgY29uc3QgcHJpdmF0ZVByb3AgPSBtZW1iZXI7XG4gICAgY29uc3QgYWNjZXNzb3JQcm9wID0gbWVtYmVyO1xuICAgIGNvbnN0IG1ldGhvZCA9IHB1YmxpY01ldGhvZDtcbiAgICBjb25zdCBwdWJsaWNNZW1iZXIgPSBwdWJsaWNNZXRob2Q7XG4gICAgbWVtYmVyLnN0YXRpYyA9IGlzU3RhdGljO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWVQcmVmaXhPcGVyYXRvcihtZW1iZXIpO1xuICAgIGlmICh0aGlzLmVhdCg1NSkpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIGNvbnN0IGlzUHJpdmF0ZU5hbWUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShtZXRob2QpO1xuICAgICAgdGhpcy5wYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKG1ldGhvZCk7XG4gICAgICBpZiAoaXNQcml2YXRlTmFtZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBwcml2YXRlTWV0aG9kLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IocHVibGljTWV0aG9kKSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Db25zdHJ1Y3RvcklzR2VuZXJhdG9yLCBwdWJsaWNNZXRob2Qua2V5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHVzaENsYXNzTWV0aG9kKGNsYXNzQm9keSwgcHVibGljTWV0aG9kLCB0cnVlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNDb250ZXh0dWFsID0gIXRoaXMuc3RhdGUuY29udGFpbnNFc2MgJiYgdG9rZW5Jc0lkZW50aWZpZXIodGhpcy5zdGF0ZS50eXBlKTtcbiAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShtZW1iZXIpO1xuICAgIGNvbnN0IG1heWJlQ29udGV4dHVhbEt3ID0gaXNDb250ZXh0dWFsID8ga2V5Lm5hbWUgOiBudWxsO1xuICAgIGNvbnN0IGlzUHJpdmF0ZSA9IHRoaXMuaXNQcml2YXRlTmFtZShrZXkpO1xuICAgIGNvbnN0IG1heWJlUXVlc3Rpb25Ub2tlblN0YXJ0TG9jID0gdGhpcy5zdGF0ZS5zdGFydExvYztcbiAgICB0aGlzLnBhcnNlUG9zdE1lbWJlck5hbWVNb2RpZmllcnMocHVibGljTWVtYmVyKTtcbiAgICBpZiAodGhpcy5pc0NsYXNzTWV0aG9kKCkpIHtcbiAgICAgIG1ldGhvZC5raW5kID0gXCJtZXRob2RcIjtcbiAgICAgIGlmIChpc1ByaXZhdGUpIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcml2YXRlTWV0aG9kKGNsYXNzQm9keSwgcHJpdmF0ZU1ldGhvZCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNDb25zdHJ1Y3RvciA9IHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpO1xuICAgICAgbGV0IGFsbG93c0RpcmVjdFN1cGVyID0gZmFsc2U7XG4gICAgICBpZiAoaXNDb25zdHJ1Y3Rvcikge1xuICAgICAgICBwdWJsaWNNZXRob2Qua2luZCA9IFwiY29uc3RydWN0b3JcIjtcbiAgICAgICAgaWYgKHN0YXRlLmhhZENvbnN0cnVjdG9yICYmICF0aGlzLmhhc1BsdWdpbihcInR5cGVzY3JpcHRcIikpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EdXBsaWNhdGVDb25zdHJ1Y3Rvciwga2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciAmJiB0aGlzLmhhc1BsdWdpbihcInR5cGVzY3JpcHRcIikgJiYgbWVtYmVyLm92ZXJyaWRlKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuT3ZlcnJpZGVPbkNvbnN0cnVjdG9yLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmhhZENvbnN0cnVjdG9yID0gdHJ1ZTtcbiAgICAgICAgYWxsb3dzRGlyZWN0U3VwZXIgPSBzdGF0ZS5oYWRTdXBlckNsYXNzO1xuICAgICAgfVxuICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIGZhbHNlLCBmYWxzZSwgaXNDb25zdHJ1Y3RvciwgYWxsb3dzRGlyZWN0U3VwZXIpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NsYXNzUHJvcGVydHkoKSkge1xuICAgICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVQcm9wZXJ0eShjbGFzc0JvZHksIHByaXZhdGVQcm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJvcGVydHkoY2xhc3NCb2R5LCBwdWJsaWNQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1heWJlQ29udGV4dHVhbEt3ID09PSBcImFzeW5jXCIgJiYgIXRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICB0aGlzLnJlc2V0UHJldmlvdXNOb2RlVHJhaWxpbmdDb21tZW50cyhrZXkpO1xuICAgICAgY29uc3QgaXNHZW5lcmF0b3IgPSB0aGlzLmVhdCg1NSk7XG4gICAgICBpZiAocHVibGljTWVtYmVyLm9wdGlvbmFsKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZChtYXliZVF1ZXN0aW9uVG9rZW5TdGFydExvYyk7XG4gICAgICB9XG4gICAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShtZXRob2QpO1xuICAgICAgdGhpcy5wYXJzZVBvc3RNZW1iZXJOYW1lTW9kaWZpZXJzKHB1YmxpY01lbWJlcik7XG4gICAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIHByaXZhdGVNZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmlzTm9uc3RhdGljQ29uc3RydWN0b3IocHVibGljTWV0aG9kKSkge1xuICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkNvbnN0cnVjdG9ySXNBc3luYywgcHVibGljTWV0aG9kLmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBwdWJsaWNNZXRob2QsIGlzR2VuZXJhdG9yLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKG1heWJlQ29udGV4dHVhbEt3ID09PSBcImdldFwiIHx8IG1heWJlQ29udGV4dHVhbEt3ID09PSBcInNldFwiKSAmJiAhKHRoaXMubWF0Y2goNTUpICYmIHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSkge1xuICAgICAgdGhpcy5yZXNldFByZXZpb3VzTm9kZVRyYWlsaW5nQ29tbWVudHMoa2V5KTtcbiAgICAgIG1ldGhvZC5raW5kID0gbWF5YmVDb250ZXh0dWFsS3c7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShwdWJsaWNNZXRob2QpO1xuICAgICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgICB0aGlzLnB1c2hDbGFzc1ByaXZhdGVNZXRob2QoY2xhc3NCb2R5LCBwcml2YXRlTWV0aG9kLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOb25zdGF0aWNDb25zdHJ1Y3RvcihwdWJsaWNNZXRob2QpKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JJc0FjY2Vzc29yLCBwdWJsaWNNZXRob2Qua2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hDbGFzc01ldGhvZChjbGFzc0JvZHksIHB1YmxpY01ldGhvZCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja0dldHRlclNldHRlclBhcmFtcyhwdWJsaWNNZXRob2QpO1xuICAgIH0gZWxzZSBpZiAobWF5YmVDb250ZXh0dWFsS3cgPT09IFwiYWNjZXNzb3JcIiAmJiAhdGhpcy5pc0xpbmVUZXJtaW5hdG9yKCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZGVjb3JhdG9yQXV0b0FjY2Vzc29yc1wiKTtcbiAgICAgIHRoaXMucmVzZXRQcmV2aW91c05vZGVUcmFpbGluZ0NvbW1lbnRzKGtleSk7XG4gICAgICBjb25zdCBpc1ByaXZhdGUgPSB0aGlzLm1hdGNoKDEzOSk7XG4gICAgICB0aGlzLnBhcnNlQ2xhc3NFbGVtZW50TmFtZShwdWJsaWNQcm9wKTtcbiAgICAgIHRoaXMucHVzaENsYXNzQWNjZXNzb3JQcm9wZXJ0eShjbGFzc0JvZHksIGFjY2Vzc29yUHJvcCwgaXNQcml2YXRlKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNMaW5lVGVybWluYXRvcigpKSB7XG4gICAgICBpZiAoaXNQcml2YXRlKSB7XG4gICAgICAgIHRoaXMucHVzaENsYXNzUHJpdmF0ZVByb3BlcnR5KGNsYXNzQm9keSwgcHJpdmF0ZVByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wdXNoQ2xhc3NQcm9wZXJ0eShjbGFzc0JvZHksIHB1YmxpY1Byb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB9XG4gIH1cbiAgcGFyc2VDbGFzc0VsZW1lbnROYW1lKG1lbWJlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGUsXG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICgodHlwZSA9PT0gMTMyIHx8IHR5cGUgPT09IDEzNCkgJiYgbWVtYmVyLnN0YXRpYyAmJiB2YWx1ZSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU3RhdGljUHJvdG90eXBlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IDEzOSkge1xuICAgICAgaWYgKHZhbHVlID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JDbGFzc1ByaXZhdGVGaWVsZCwgdGhpcy5zdGF0ZS5zdGFydExvYyk7XG4gICAgICB9XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLnBhcnNlUHJpdmF0ZU5hbWUoKTtcbiAgICAgIG1lbWJlci5rZXkgPSBrZXk7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKG1lbWJlcik7XG4gICAgcmV0dXJuIG1lbWJlci5rZXk7XG4gIH1cbiAgcGFyc2VDbGFzc1N0YXRpY0Jsb2NrKGNsYXNzQm9keSwgbWVtYmVyKSB7XG4gICAgdmFyIF9tZW1iZXIkZGVjb3JhdG9ycztcbiAgICB0aGlzLnNjb3BlLmVudGVyKDU3NiB8IDEyOCB8IDE2KTtcbiAgICBjb25zdCBvbGRMYWJlbHMgPSB0aGlzLnN0YXRlLmxhYmVscztcbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IFtdO1xuICAgIHRoaXMucHJvZFBhcmFtLmVudGVyKDApO1xuICAgIGNvbnN0IGJvZHkgPSBtZW1iZXIuYm9keSA9IFtdO1xuICAgIHRoaXMucGFyc2VCbG9ja09yTW9kdWxlQmxvY2tCb2R5KGJvZHksIHVuZGVmaW5lZCwgZmFsc2UsIDgpO1xuICAgIHRoaXMucHJvZFBhcmFtLmV4aXQoKTtcbiAgICB0aGlzLnNjb3BlLmV4aXQoKTtcbiAgICB0aGlzLnN0YXRlLmxhYmVscyA9IG9sZExhYmVscztcbiAgICBjbGFzc0JvZHkuYm9keS5wdXNoKHRoaXMuZmluaXNoTm9kZShtZW1iZXIsIFwiU3RhdGljQmxvY2tcIikpO1xuICAgIGlmICgoX21lbWJlciRkZWNvcmF0b3JzID0gbWVtYmVyLmRlY29yYXRvcnMpICE9IG51bGwgJiYgX21lbWJlciRkZWNvcmF0b3JzLmxlbmd0aCkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRGVjb3JhdG9yU3RhdGljQmxvY2ssIG1lbWJlcik7XG4gICAgfVxuICB9XG4gIHB1c2hDbGFzc1Byb3BlcnR5KGNsYXNzQm9keSwgcHJvcCkge1xuICAgIGlmICghcHJvcC5jb21wdXRlZCAmJiB0aGlzLm5hbWVJc0NvbnN0cnVjdG9yKHByb3Aua2V5KSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JDbGFzc0ZpZWxkLCBwcm9wLmtleSk7XG4gICAgfVxuICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5wYXJzZUNsYXNzUHJvcGVydHkocHJvcCkpO1xuICB9XG4gIHB1c2hDbGFzc1ByaXZhdGVQcm9wZXJ0eShjbGFzc0JvZHksIHByb3ApIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5wYXJzZUNsYXNzUHJpdmF0ZVByb3BlcnR5KHByb3ApO1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2gobm9kZSk7XG4gICAgdGhpcy5jbGFzc1Njb3BlLmRlY2xhcmVQcml2YXRlTmFtZSh0aGlzLmdldFByaXZhdGVOYW1lU1Yobm9kZS5rZXkpLCAwLCBub2RlLmtleS5sb2Muc3RhcnQpO1xuICB9XG4gIHB1c2hDbGFzc0FjY2Vzc29yUHJvcGVydHkoY2xhc3NCb2R5LCBwcm9wLCBpc1ByaXZhdGUpIHtcbiAgICBpZiAoIWlzUHJpdmF0ZSAmJiAhcHJvcC5jb21wdXRlZCAmJiB0aGlzLm5hbWVJc0NvbnN0cnVjdG9yKHByb3Aua2V5KSkge1xuICAgICAgdGhpcy5yYWlzZShFcnJvcnMuQ29uc3RydWN0b3JDbGFzc0ZpZWxkLCBwcm9wLmtleSk7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlQ2xhc3NBY2Nlc3NvclByb3BlcnR5KHByb3ApO1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2gobm9kZSk7XG4gICAgaWYgKGlzUHJpdmF0ZSkge1xuICAgICAgdGhpcy5jbGFzc1Njb3BlLmRlY2xhcmVQcml2YXRlTmFtZSh0aGlzLmdldFByaXZhdGVOYW1lU1Yobm9kZS5rZXkpLCAwLCBub2RlLmtleS5sb2Muc3RhcnQpO1xuICAgIH1cbiAgfVxuICBwdXNoQ2xhc3NNZXRob2QoY2xhc3NCb2R5LCBtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlcikge1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2godGhpcy5wYXJzZU1ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBpc0NvbnN0cnVjdG9yLCBhbGxvd3NEaXJlY3RTdXBlciwgXCJDbGFzc01ldGhvZFwiLCB0cnVlKSk7XG4gIH1cbiAgcHVzaENsYXNzUHJpdmF0ZU1ldGhvZChjbGFzc0JvZHksIG1ldGhvZCwgaXNHZW5lcmF0b3IsIGlzQXN5bmMpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5wYXJzZU1ldGhvZChtZXRob2QsIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBmYWxzZSwgZmFsc2UsIFwiQ2xhc3NQcml2YXRlTWV0aG9kXCIsIHRydWUpO1xuICAgIGNsYXNzQm9keS5ib2R5LnB1c2gobm9kZSk7XG4gICAgY29uc3Qga2luZCA9IG5vZGUua2luZCA9PT0gXCJnZXRcIiA/IG5vZGUuc3RhdGljID8gNiA6IDIgOiBub2RlLmtpbmQgPT09IFwic2V0XCIgPyBub2RlLnN0YXRpYyA/IDUgOiAxIDogMDtcbiAgICB0aGlzLmRlY2xhcmVDbGFzc1ByaXZhdGVNZXRob2RJblNjb3BlKG5vZGUsIGtpbmQpO1xuICB9XG4gIGRlY2xhcmVDbGFzc1ByaXZhdGVNZXRob2RJblNjb3BlKG5vZGUsIGtpbmQpIHtcbiAgICB0aGlzLmNsYXNzU2NvcGUuZGVjbGFyZVByaXZhdGVOYW1lKHRoaXMuZ2V0UHJpdmF0ZU5hbWVTVihub2RlLmtleSksIGtpbmQsIG5vZGUua2V5LmxvYy5zdGFydCk7XG4gIH1cbiAgcGFyc2VQb3N0TWVtYmVyTmFtZU1vZGlmaWVycyhtZXRob2RPclByb3ApIHt9XG4gIHBhcnNlQ2xhc3NQcml2YXRlUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMucGFyc2VJbml0aWFsaXplcihub2RlKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiKTtcbiAgfVxuICBwYXJzZUNsYXNzUHJvcGVydHkobm9kZSkge1xuICAgIHRoaXMucGFyc2VJbml0aWFsaXplcihub2RlKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJDbGFzc1Byb3BlcnR5XCIpO1xuICB9XG4gIHBhcnNlQ2xhc3NBY2Nlc3NvclByb3BlcnR5KG5vZGUpIHtcbiAgICB0aGlzLnBhcnNlSW5pdGlhbGl6ZXIobm9kZSk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQ2xhc3NBY2Nlc3NvclByb3BlcnR5XCIpO1xuICB9XG4gIHBhcnNlSW5pdGlhbGl6ZXIobm9kZSkge1xuICAgIHRoaXMuc2NvcGUuZW50ZXIoNTc2IHwgMTYpO1xuICAgIHRoaXMuZXhwcmVzc2lvblNjb3BlLmVudGVyKG5ld0V4cHJlc3Npb25TY29wZSgpKTtcbiAgICB0aGlzLnByb2RQYXJhbS5lbnRlcigwKTtcbiAgICBub2RlLnZhbHVlID0gdGhpcy5lYXQoMjkpID8gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpIDogbnVsbDtcbiAgICB0aGlzLmV4cHJlc3Npb25TY29wZS5leGl0KCk7XG4gICAgdGhpcy5wcm9kUGFyYW0uZXhpdCgpO1xuICAgIHRoaXMuc2NvcGUuZXhpdCgpO1xuICB9XG4gIHBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCwgb3B0aW9uYWxJZCwgYmluZGluZ1R5cGUgPSA4MzMxKSB7XG4gICAgaWYgKHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkpIHtcbiAgICAgIG5vZGUuaWQgPSB0aGlzLnBhcnNlSWRlbnRpZmllcigpO1xuICAgICAgaWYgKGlzU3RhdGVtZW50KSB7XG4gICAgICAgIHRoaXMuZGVjbGFyZU5hbWVGcm9tSWRlbnRpZmllcihub2RlLmlkLCBiaW5kaW5nVHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChvcHRpb25hbElkIHx8ICFpc1N0YXRlbWVudCkge1xuICAgICAgICBub2RlLmlkID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLk1pc3NpbmdDbGFzc05hbWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwYXJzZUNsYXNzU3VwZXIobm9kZSkge1xuICAgIG5vZGUuc3VwZXJDbGFzcyA9IHRoaXMuZWF0KDgxKSA/IHRoaXMucGFyc2VFeHByU3Vic2NyaXB0cygpIDogbnVsbDtcbiAgfVxuICBwYXJzZUV4cG9ydChub2RlLCBkZWNvcmF0b3JzKSB7XG4gICAgY29uc3QgbWF5YmVEZWZhdWx0SWRlbnRpZmllciA9IHRoaXMucGFyc2VNYXliZUltcG9ydFBoYXNlKG5vZGUsIHRydWUpO1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSB0aGlzLm1heWJlUGFyc2VFeHBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpO1xuICAgIGNvbnN0IHBhcnNlQWZ0ZXJEZWZhdWx0ID0gIWhhc0RlZmF1bHQgfHwgdGhpcy5lYXQoMTIpO1xuICAgIGNvbnN0IGhhc1N0YXIgPSBwYXJzZUFmdGVyRGVmYXVsdCAmJiB0aGlzLmVhdEV4cG9ydFN0YXIobm9kZSk7XG4gICAgY29uc3QgaGFzTmFtZXNwYWNlID0gaGFzU3RhciAmJiB0aGlzLm1heWJlUGFyc2VFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXIobm9kZSk7XG4gICAgY29uc3QgcGFyc2VBZnRlck5hbWVzcGFjZSA9IHBhcnNlQWZ0ZXJEZWZhdWx0ICYmICghaGFzTmFtZXNwYWNlIHx8IHRoaXMuZWF0KDEyKSk7XG4gICAgY29uc3QgaXNGcm9tUmVxdWlyZWQgPSBoYXNEZWZhdWx0IHx8IGhhc1N0YXI7XG4gICAgaWYgKGhhc1N0YXIgJiYgIWhhc05hbWVzcGFjZSkge1xuICAgICAgaWYgKGhhc0RlZmF1bHQpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgICAgaWYgKGRlY29yYXRvcnMpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWREZWNvcmF0b3JFeHBvcnQsIG5vZGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5wYXJzZUV4cG9ydEZyb20obm9kZSwgdHJ1ZSk7XG4gICAgICB0aGlzLnNhd1VuYW1iaWd1b3VzRVNNID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKTtcbiAgICB9XG4gICAgY29uc3QgaGFzU3BlY2lmaWVycyA9IHRoaXMubWF5YmVQYXJzZUV4cG9ydE5hbWVkU3BlY2lmaWVycyhub2RlKTtcbiAgICBpZiAoaGFzRGVmYXVsdCAmJiBwYXJzZUFmdGVyRGVmYXVsdCAmJiAhaGFzU3RhciAmJiAhaGFzU3BlY2lmaWVycykge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKG51bGwsIDUpO1xuICAgIH1cbiAgICBpZiAoaGFzTmFtZXNwYWNlICYmIHBhcnNlQWZ0ZXJOYW1lc3BhY2UpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZChudWxsLCA5OCk7XG4gICAgfVxuICAgIGxldCBoYXNEZWNsYXJhdGlvbjtcbiAgICBpZiAoaXNGcm9tUmVxdWlyZWQgfHwgaGFzU3BlY2lmaWVycykge1xuICAgICAgaGFzRGVjbGFyYXRpb24gPSBmYWxzZTtcbiAgICAgIGlmIChkZWNvcmF0b3JzKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyc2VFeHBvcnRGcm9tKG5vZGUsIGlzRnJvbVJlcXVpcmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzRGVjbGFyYXRpb24gPSB0aGlzLm1heWJlUGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICB9XG4gICAgaWYgKGlzRnJvbVJlcXVpcmVkIHx8IGhhc1NwZWNpZmllcnMgfHwgaGFzRGVjbGFyYXRpb24pIHtcbiAgICAgIHZhciBfbm9kZTIkZGVjbGFyYXRpb247XG4gICAgICBjb25zdCBub2RlMiA9IG5vZGU7XG4gICAgICB0aGlzLmNoZWNrRXhwb3J0KG5vZGUyLCB0cnVlLCBmYWxzZSwgISFub2RlMi5zb3VyY2UpO1xuICAgICAgaWYgKCgoX25vZGUyJGRlY2xhcmF0aW9uID0gbm9kZTIuZGVjbGFyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZTIkZGVjbGFyYXRpb24udHlwZSkgPT09IFwiQ2xhc3NEZWNsYXJhdGlvblwiKSB7XG4gICAgICAgIHRoaXMubWF5YmVUYWtlRGVjb3JhdG9ycyhkZWNvcmF0b3JzLCBub2RlMi5kZWNsYXJhdGlvbiwgbm9kZTIpO1xuICAgICAgfSBlbHNlIGlmIChkZWNvcmF0b3JzKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2F3VW5hbWJpZ3VvdXNFU00gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlMiwgXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lYXQoNjUpKSB7XG4gICAgICBjb25zdCBub2RlMiA9IG5vZGU7XG4gICAgICBjb25zdCBkZWNsID0gdGhpcy5wYXJzZUV4cG9ydERlZmF1bHRFeHByZXNzaW9uKCk7XG4gICAgICBub2RlMi5kZWNsYXJhdGlvbiA9IGRlY2w7XG4gICAgICBpZiAoZGVjbC50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xuICAgICAgICB0aGlzLm1heWJlVGFrZURlY29yYXRvcnMoZGVjb3JhdG9ycywgZGVjbCwgbm9kZTIpO1xuICAgICAgfSBlbHNlIGlmIChkZWNvcmF0b3JzKSB7XG4gICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLlVuc3VwcG9ydGVkRGVjb3JhdG9yRXhwb3J0LCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQobm9kZTIsIHRydWUsIHRydWUpO1xuICAgICAgdGhpcy5zYXdVbmFtYmlndW91c0VTTSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUyLCBcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiKTtcbiAgICB9XG4gICAgdGhyb3cgdGhpcy51bmV4cGVjdGVkKG51bGwsIDUpO1xuICB9XG4gIGVhdEV4cG9ydFN0YXIobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmVhdCg1NSk7XG4gIH1cbiAgbWF5YmVQYXJzZUV4cG9ydERlZmF1bHRTcGVjaWZpZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcikge1xuICAgIGlmIChtYXliZURlZmF1bHRJZGVudGlmaWVyIHx8IHRoaXMuaXNFeHBvcnREZWZhdWx0U3BlY2lmaWVyKCkpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZXhwb3J0RGVmYXVsdEZyb21cIiwgbWF5YmVEZWZhdWx0SWRlbnRpZmllciA9PSBudWxsID8gdm9pZCAwIDogbWF5YmVEZWZhdWx0SWRlbnRpZmllci5sb2Muc3RhcnQpO1xuICAgICAgY29uc3QgaWQgPSBtYXliZURlZmF1bHRJZGVudGlmaWVyIHx8IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGVBdE5vZGUoaWQpO1xuICAgICAgc3BlY2lmaWVyLmV4cG9ydGVkID0gaWQ7XG4gICAgICBub2RlLnNwZWNpZmllcnMgPSBbdGhpcy5maW5pc2hOb2RlKHNwZWNpZmllciwgXCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCIpXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWF5YmVQYXJzZUV4cG9ydE5hbWVzcGFjZVNwZWNpZmllcihub2RlKSB7XG4gICAgaWYgKHRoaXMuaXNDb250ZXh0dWFsKDkzKSkge1xuICAgICAgdmFyIF9yZWYsIF9yZWYkc3BlY2lmaWVycztcbiAgICAgIChfcmVmJHNwZWNpZmllcnMgPSAoX3JlZiA9IG5vZGUpLnNwZWNpZmllcnMpICE9IG51bGwgPyBfcmVmJHNwZWNpZmllcnMgOiBfcmVmLnNwZWNpZmllcnMgPSBbXTtcbiAgICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlQXQodGhpcy5zdGF0ZS5sYXN0VG9rU3RhcnRMb2MpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBzcGVjaWZpZXIuZXhwb3J0ZWQgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hOb2RlKHNwZWNpZmllciwgXCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIikpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXliZVBhcnNlRXhwb3J0TmFtZWRTcGVjaWZpZXJzKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg1KSkge1xuICAgICAgY29uc3Qgbm9kZTIgPSBub2RlO1xuICAgICAgaWYgKCFub2RlMi5zcGVjaWZpZXJzKSBub2RlMi5zcGVjaWZpZXJzID0gW107XG4gICAgICBjb25zdCBpc1R5cGVFeHBvcnQgPSBub2RlMi5leHBvcnRLaW5kID09PSBcInR5cGVcIjtcbiAgICAgIG5vZGUyLnNwZWNpZmllcnMucHVzaCguLi50aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyhpc1R5cGVFeHBvcnQpKTtcbiAgICAgIG5vZGUyLnNvdXJjZSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJpbXBvcnRBc3NlcnRpb25zXCIpKSB7XG4gICAgICAgIG5vZGUyLmFzc2VydGlvbnMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUyLmF0dHJpYnV0ZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIG5vZGUyLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWF5YmVQYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5zaG91bGRQYXJzZUV4cG9ydERlY2xhcmF0aW9uKCkpIHtcbiAgICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiaW1wb3J0QXNzZXJ0aW9uc1wiKSkge1xuICAgICAgICBub2RlLmFzc2VydGlvbnMgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcyA9IFtdO1xuICAgICAgfVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VFeHBvcnREZWNsYXJhdGlvbihub2RlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNBc3luY0Z1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5pc0NvbnRleHR1YWwoOTUpKSByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dFRva2VuSW5MaW5lU3RhcnQoKTtcbiAgICByZXR1cm4gdGhpcy5pc1VucGFyc2VkQ29udGV4dHVhbChuZXh0LCBcImZ1bmN0aW9uXCIpO1xuICB9XG4gIHBhcnNlRXhwb3J0RGVmYXVsdEV4cHJlc3Npb24oKSB7XG4gICAgY29uc3QgZXhwciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgaWYgKHRoaXMubWF0Y2goNjgpKSB7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24oZXhwciwgMSB8IDQpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSkge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24oZXhwciwgMSB8IDQgfCA4KTtcbiAgICB9XG4gICAgaWYgKHRoaXMubWF0Y2goODApKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUNsYXNzKGV4cHIsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5tYXRjaCgyNikpIHtcbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikgJiYgdGhpcy5nZXRQbHVnaW5PcHRpb24oXCJkZWNvcmF0b3JzXCIsIFwiZGVjb3JhdG9yc0JlZm9yZUV4cG9ydFwiKSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JCZWZvcmVFeHBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLm1heWJlVGFrZURlY29yYXRvcnModGhpcy5wYXJzZURlY29yYXRvcnMoZmFsc2UpLCB0aGlzLnN0YXJ0Tm9kZSgpKSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDc1KSB8fCB0aGlzLm1hdGNoKDc0KSB8fCB0aGlzLmlzTGV0KCkgfHwgdGhpcy5pc1VzaW5nKCkgfHwgdGhpcy5pc0F3YWl0VXNpbmcoKSkge1xuICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuVW5zdXBwb3J0ZWREZWZhdWx0RXhwb3J0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gdGhpcy5wYXJzZU1heWJlQXNzaWduQWxsb3dJbigpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBwYXJzZUV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCg4MCkpIHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhcnNlQ2xhc3ModGhpcy5zdGFydE5vZGUoKSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlU3RhdGVtZW50TGlzdEl0ZW0oKTtcbiAgfVxuICBpc0V4cG9ydERlZmF1bHRTcGVjaWZpZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0b2tlbklzSWRlbnRpZmllcih0eXBlKSkge1xuICAgICAgaWYgKHR5cGUgPT09IDk1ICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjIHx8IHR5cGUgPT09IDEwMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoKHR5cGUgPT09IDEzMCB8fCB0eXBlID09PSAxMjkpICYmICF0aGlzLnN0YXRlLmNvbnRhaW5zRXNjKSB7XG4gICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgICAgIGNvbnN0IG5leHRDaGFyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KG5leHQpO1xuICAgICAgICBpZiAobmV4dENoYXIgPT09IDEyMyB8fCB0aGlzLmNoU3RhcnRzQmluZGluZ0lkZW50aWZpZXIobmV4dENoYXIsIG5leHQpICYmICF0aGlzLmlucHV0LnN0YXJ0c1dpdGgoXCJmcm9tXCIsIG5leHQpKSB7XG4gICAgICAgICAgdGhpcy5leHBlY3RPbmVQbHVnaW4oW1wiZmxvd1wiLCBcInR5cGVzY3JpcHRcIl0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMubWF0Y2goNjUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSB0aGlzLm5leHRUb2tlblN0YXJ0KCk7XG4gICAgY29uc3QgaGFzRnJvbSA9IHRoaXMuaXNVbnBhcnNlZENvbnRleHR1YWwobmV4dCwgXCJmcm9tXCIpO1xuICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQobmV4dCkgPT09IDQ0IHx8IHRva2VuSXNJZGVudGlmaWVyKHRoaXMuc3RhdGUudHlwZSkgJiYgaGFzRnJvbSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLm1hdGNoKDY1KSAmJiBoYXNGcm9tKSB7XG4gICAgICBjb25zdCBuZXh0QWZ0ZXJGcm9tID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMubmV4dFRva2VuU3RhcnRTaW5jZShuZXh0ICsgNCkpO1xuICAgICAgcmV0dXJuIG5leHRBZnRlckZyb20gPT09IDM0IHx8IG5leHRBZnRlckZyb20gPT09IDM5O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcGFyc2VFeHBvcnRGcm9tKG5vZGUsIGV4cGVjdCkge1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoOTgpKSB7XG4gICAgICBub2RlLnNvdXJjZSA9IHRoaXMucGFyc2VJbXBvcnRTb3VyY2UoKTtcbiAgICAgIHRoaXMuY2hlY2tFeHBvcnQobm9kZSk7XG4gICAgICB0aGlzLm1heWJlUGFyc2VJbXBvcnRBdHRyaWJ1dGVzKG5vZGUpO1xuICAgICAgdGhpcy5jaGVja0pTT05Nb2R1bGVJbXBvcnQobm9kZSk7XG4gICAgfSBlbHNlIGlmIChleHBlY3QpIHtcbiAgICAgIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIH1cbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICB9XG4gIHNob3VsZFBhcnNlRXhwb3J0RGVjbGFyYXRpb24oKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZVxuICAgIH0gPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlID09PSAyNikge1xuICAgICAgdGhpcy5leHBlY3RPbmVQbHVnaW4oW1wiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnMtbGVnYWN5XCJdKTtcbiAgICAgIGlmICh0aGlzLmhhc1BsdWdpbihcImRlY29yYXRvcnNcIikpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UGx1Z2luT3B0aW9uKFwiZGVjb3JhdG9yc1wiLCBcImRlY29yYXRvcnNCZWZvcmVFeHBvcnRcIikgPT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5EZWNvcmF0b3JCZWZvcmVFeHBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5pc1VzaW5nKCkpIHtcbiAgICAgIHRoaXMucmFpc2UoRXJyb3JzLlVzaW5nRGVjbGFyYXRpb25FeHBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzQXdhaXRVc2luZygpKSB7XG4gICAgICB0aGlzLnJhaXNlKEVycm9ycy5Vc2luZ0RlY2xhcmF0aW9uRXhwb3J0LCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZSA9PT0gNzQgfHwgdHlwZSA9PT0gNzUgfHwgdHlwZSA9PT0gNjggfHwgdHlwZSA9PT0gODAgfHwgdGhpcy5pc0xldCgpIHx8IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCk7XG4gIH1cbiAgY2hlY2tFeHBvcnQobm9kZSwgY2hlY2tOYW1lcywgaXNEZWZhdWx0LCBpc0Zyb20pIHtcbiAgICBpZiAoY2hlY2tOYW1lcykge1xuICAgICAgdmFyIF9ub2RlJHNwZWNpZmllcnM7XG4gICAgICBpZiAoaXNEZWZhdWx0KSB7XG4gICAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKG5vZGUsIFwiZGVmYXVsdFwiKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzUGx1Z2luKFwiZXhwb3J0RGVmYXVsdEZyb21cIikpIHtcbiAgICAgICAgICB2YXIgX2RlY2xhcmF0aW9uJGV4dHJhO1xuICAgICAgICAgIGNvbnN0IGRlY2xhcmF0aW9uID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICAgICAgICBpZiAoZGVjbGFyYXRpb24udHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgZGVjbGFyYXRpb24ubmFtZSA9PT0gXCJmcm9tXCIgJiYgZGVjbGFyYXRpb24uZW5kIC0gZGVjbGFyYXRpb24uc3RhcnQgPT09IDQgJiYgISgoX2RlY2xhcmF0aW9uJGV4dHJhID0gZGVjbGFyYXRpb24uZXh0cmEpICE9IG51bGwgJiYgX2RlY2xhcmF0aW9uJGV4dHJhLnBhcmVudGhlc2l6ZWQpKSB7XG4gICAgICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5FeHBvcnREZWZhdWx0RnJvbUFzSWRlbnRpZmllciwgZGVjbGFyYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoX25vZGUkc3BlY2lmaWVycyA9IG5vZGUuc3BlY2lmaWVycykgIT0gbnVsbCAmJiBfbm9kZSRzcGVjaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNwZWNpZmllciBvZiBub2RlLnNwZWNpZmllcnMpIHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBleHBvcnRlZFxuICAgICAgICAgIH0gPSBzcGVjaWZpZXI7XG4gICAgICAgICAgY29uc3QgZXhwb3J0TmFtZSA9IGV4cG9ydGVkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gZXhwb3J0ZWQubmFtZSA6IGV4cG9ydGVkLnZhbHVlO1xuICAgICAgICAgIHRoaXMuY2hlY2tEdXBsaWNhdGVFeHBvcnRzKHNwZWNpZmllciwgZXhwb3J0TmFtZSk7XG4gICAgICAgICAgaWYgKCFpc0Zyb20gJiYgc3BlY2lmaWVyLmxvY2FsKSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGxvY2FsXG4gICAgICAgICAgICB9ID0gc3BlY2lmaWVyO1xuICAgICAgICAgICAgaWYgKGxvY2FsLnR5cGUgIT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICAgICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkV4cG9ydEJpbmRpbmdJc1N0cmluZywgc3BlY2lmaWVyLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxOYW1lOiBsb2NhbC52YWx1ZSxcbiAgICAgICAgICAgICAgICBleHBvcnROYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChsb2NhbC5uYW1lLCBsb2NhbC5sb2Muc3RhcnQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgdGhpcy5zY29wZS5jaGVja0xvY2FsRXhwb3J0KGxvY2FsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5kZWNsYXJhdGlvbikge1xuICAgICAgICBjb25zdCBkZWNsID0gbm9kZS5kZWNsYXJhdGlvbjtcbiAgICAgICAgaWYgKGRlY2wudHlwZSA9PT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgfHwgZGVjbC50eXBlID09PSBcIkNsYXNzRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSA9IGRlY2w7XG4gICAgICAgICAgaWYgKCFpZCkgdGhyb3cgbmV3IEVycm9yKFwiQXNzZXJ0aW9uIGZhaWx1cmVcIik7XG4gICAgICAgICAgdGhpcy5jaGVja0R1cGxpY2F0ZUV4cG9ydHMobm9kZSwgaWQubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGVjbC50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIikge1xuICAgICAgICAgIGZvciAoY29uc3QgZGVjbGFyYXRpb24gb2YgZGVjbC5kZWNsYXJhdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihkZWNsYXJhdGlvbi5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNoZWNrRGVjbGFyYXRpb24obm9kZSkge1xuICAgIGlmIChub2RlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiKSB7XG4gICAgICB0aGlzLmNoZWNrRHVwbGljYXRlRXhwb3J0cyhub2RlLCBub2RlLm5hbWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIk9iamVjdFBhdHRlcm5cIikge1xuICAgICAgZm9yIChjb25zdCBwcm9wIG9mIG5vZGUucHJvcGVydGllcykge1xuICAgICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24ocHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiQXJyYXlQYXR0ZXJuXCIpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBub2RlLmVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChlbGVtKSB7XG4gICAgICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IFwiT2JqZWN0UHJvcGVydHlcIikge1xuICAgICAgdGhpcy5jaGVja0RlY2xhcmF0aW9uKG5vZGUudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSBcIlJlc3RFbGVtZW50XCIpIHtcbiAgICAgIHRoaXMuY2hlY2tEZWNsYXJhdGlvbihub2RlLmFyZ3VtZW50KTtcbiAgICB9IGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKSB7XG4gICAgICB0aGlzLmNoZWNrRGVjbGFyYXRpb24obm9kZS5sZWZ0KTtcbiAgICB9XG4gIH1cbiAgY2hlY2tEdXBsaWNhdGVFeHBvcnRzKG5vZGUsIGV4cG9ydE5hbWUpIHtcbiAgICBpZiAodGhpcy5leHBvcnRlZElkZW50aWZpZXJzLmhhcyhleHBvcnROYW1lKSkge1xuICAgICAgaWYgKGV4cG9ydE5hbWUgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkR1cGxpY2F0ZURlZmF1bHRFeHBvcnQsIG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuRHVwbGljYXRlRXhwb3J0LCBub2RlLCB7XG4gICAgICAgICAgZXhwb3J0TmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5leHBvcnRlZElkZW50aWZpZXJzLmFkZChleHBvcnROYW1lKTtcbiAgfVxuICBwYXJzZUV4cG9ydFNwZWNpZmllcnMoaXNJblR5cGVFeHBvcnQpIHtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGxldCBmaXJzdCA9IHRydWU7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgd2hpbGUgKCF0aGlzLmVhdCg4KSkge1xuICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgIGZpcnN0ID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmV4cGVjdCgxMik7XG4gICAgICAgIGlmICh0aGlzLmVhdCg4KSkgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBpc01heWJlVHlwZU9ubHkgPSB0aGlzLmlzQ29udGV4dHVhbCgxMzApO1xuICAgICAgY29uc3QgaXNTdHJpbmcgPSB0aGlzLm1hdGNoKDEzNCk7XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpO1xuICAgICAgbm9kZXMucHVzaCh0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVyKG5vZGUsIGlzU3RyaW5nLCBpc0luVHlwZUV4cG9ydCwgaXNNYXliZVR5cGVPbmx5KSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICBwYXJzZUV4cG9ydFNwZWNpZmllcihub2RlLCBpc1N0cmluZywgaXNJblR5cGVFeHBvcnQsIGlzTWF5YmVUeXBlT25seSkge1xuICAgIGlmICh0aGlzLmVhdENvbnRleHR1YWwoOTMpKSB7XG4gICAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5wYXJzZU1vZHVsZUV4cG9ydE5hbWUoKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKSB7XG4gICAgICBub2RlLmV4cG9ydGVkID0gdGhpcy5jbG9uZVN0cmluZ0xpdGVyYWwobm9kZS5sb2NhbCk7XG4gICAgfSBlbHNlIGlmICghbm9kZS5leHBvcnRlZCkge1xuICAgICAgbm9kZS5leHBvcnRlZCA9IHRoaXMuY2xvbmVJZGVudGlmaWVyKG5vZGUubG9jYWwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0U3BlY2lmaWVyXCIpO1xuICB9XG4gIHBhcnNlTW9kdWxlRXhwb3J0TmFtZSgpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGNvbnN0IHN1cnJvZ2F0ZSA9IGxvbmVTdXJyb2dhdGUuZXhlYyhyZXN1bHQudmFsdWUpO1xuICAgICAgaWYgKHN1cnJvZ2F0ZSkge1xuICAgICAgICB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVFeHBvcnROYW1lSGFzTG9uZVN1cnJvZ2F0ZSwgcmVzdWx0LCB7XG4gICAgICAgICAgc3Vycm9nYXRlQ2hhckNvZGU6IHN1cnJvZ2F0ZVswXS5jaGFyQ29kZUF0KDApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICB9XG4gIGlzSlNPTk1vZHVsZUltcG9ydChub2RlKSB7XG4gICAgaWYgKG5vZGUuYXNzZXJ0aW9ucyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gbm9kZS5hc3NlcnRpb25zLnNvbWUoKHtcbiAgICAgICAga2V5LFxuICAgICAgICB2YWx1ZVxuICAgICAgfSkgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWUgPT09IFwianNvblwiICYmIChrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgPyBrZXkubmFtZSA9PT0gXCJ0eXBlXCIgOiBrZXkudmFsdWUgPT09IFwidHlwZVwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2hlY2tJbXBvcnRSZWZsZWN0aW9uKG5vZGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzcGVjaWZpZXJzXG4gICAgfSA9IG5vZGU7XG4gICAgY29uc3Qgc2luZ2xlQmluZGluZ1R5cGUgPSBzcGVjaWZpZXJzLmxlbmd0aCA9PT0gMSA/IHNwZWNpZmllcnNbMF0udHlwZSA6IG51bGw7XG4gICAgaWYgKG5vZGUucGhhc2UgPT09IFwic291cmNlXCIpIHtcbiAgICAgIGlmIChzaW5nbGVCaW5kaW5nVHlwZSAhPT0gXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuU291cmNlUGhhc2VJbXBvcnRSZXF1aXJlc0RlZmF1bHQsIHNwZWNpZmllcnNbMF0ubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUucGhhc2UgPT09IFwiZGVmZXJcIikge1xuICAgICAgaWYgKHNpbmdsZUJpbmRpbmdUeXBlICE9PSBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkRlZmVySW1wb3J0UmVxdWlyZXNOYW1lc3BhY2UsIHNwZWNpZmllcnNbMF0ubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUubW9kdWxlKSB7XG4gICAgICB2YXIgX25vZGUkYXNzZXJ0aW9ucztcbiAgICAgIGlmIChzaW5nbGVCaW5kaW5nVHlwZSAhPT0gXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0UmVmbGVjdGlvbk5vdEJpbmRpbmcsIHNwZWNpZmllcnNbMF0ubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmICgoKF9ub2RlJGFzc2VydGlvbnMgPSBub2RlLmFzc2VydGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRhc3NlcnRpb25zLmxlbmd0aCkgPiAwKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydFJlZmxlY3Rpb25IYXNBc3NlcnRpb24sIHNwZWNpZmllcnNbMF0ubG9jLnN0YXJ0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY2hlY2tKU09OTW9kdWxlSW1wb3J0KG5vZGUpIHtcbiAgICBpZiAodGhpcy5pc0pTT05Nb2R1bGVJbXBvcnQobm9kZSkgJiYgbm9kZS50eXBlICE9PSBcIkV4cG9ydEFsbERlY2xhcmF0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3BlY2lmaWVyc1xuICAgICAgfSA9IG5vZGU7XG4gICAgICBpZiAoc3BlY2lmaWVycyAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG5vbkRlZmF1bHROYW1lZFNwZWNpZmllciA9IHNwZWNpZmllcnMuZmluZChzcGVjaWZpZXIgPT4ge1xuICAgICAgICAgIGxldCBpbXBvcnRlZDtcbiAgICAgICAgICBpZiAoc3BlY2lmaWVyLnR5cGUgPT09IFwiRXhwb3J0U3BlY2lmaWVyXCIpIHtcbiAgICAgICAgICAgIGltcG9ydGVkID0gc3BlY2lmaWVyLmxvY2FsO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3BlY2lmaWVyLnR5cGUgPT09IFwiSW1wb3J0U3BlY2lmaWVyXCIpIHtcbiAgICAgICAgICAgIGltcG9ydGVkID0gc3BlY2lmaWVyLmltcG9ydGVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW1wb3J0ZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydGVkLnR5cGUgPT09IFwiSWRlbnRpZmllclwiID8gaW1wb3J0ZWQubmFtZSAhPT0gXCJkZWZhdWx0XCIgOiBpbXBvcnRlZC52YWx1ZSAhPT0gXCJkZWZhdWx0XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG5vbkRlZmF1bHROYW1lZFNwZWNpZmllciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuSW1wb3J0SlNPTkJpbmRpbmdOb3REZWZhdWx0LCBub25EZWZhdWx0TmFtZWRTcGVjaWZpZXIubG9jLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpc1BvdGVudGlhbEltcG9ydFBoYXNlKGlzRXhwb3J0KSB7XG4gICAgaWYgKGlzRXhwb3J0KSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMuaXNDb250ZXh0dWFsKDEwNSkgfHwgdGhpcy5pc0NvbnRleHR1YWwoOTcpIHx8IHRoaXMuaXNDb250ZXh0dWFsKDEyNyk7XG4gIH1cbiAgYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgcGhhc2UsIGxvYykge1xuICAgIGlmIChpc0V4cG9ydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocGhhc2UgPT09IFwibW9kdWxlXCIpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiaW1wb3J0UmVmbGVjdGlvblwiLCBsb2MpO1xuICAgICAgbm9kZS5tb2R1bGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oYXNQbHVnaW4oXCJpbXBvcnRSZWZsZWN0aW9uXCIpKSB7XG4gICAgICBub2RlLm1vZHVsZSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGhhc2UgPT09IFwic291cmNlXCIpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwic291cmNlUGhhc2VJbXBvcnRzXCIsIGxvYyk7XG4gICAgICBub2RlLnBoYXNlID0gXCJzb3VyY2VcIjtcbiAgICB9IGVsc2UgaWYgKHBoYXNlID09PSBcImRlZmVyXCIpIHtcbiAgICAgIHRoaXMuZXhwZWN0UGx1Z2luKFwiZGVmZXJyZWRJbXBvcnRFdmFsdWF0aW9uXCIsIGxvYyk7XG4gICAgICBub2RlLnBoYXNlID0gXCJkZWZlclwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oYXNQbHVnaW4oXCJzb3VyY2VQaGFzZUltcG9ydHNcIikpIHtcbiAgICAgIG5vZGUucGhhc2UgPSBudWxsO1xuICAgIH1cbiAgfVxuICBwYXJzZU1heWJlSW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQpIHtcbiAgICBpZiAoIXRoaXMuaXNQb3RlbnRpYWxJbXBvcnRQaGFzZShpc0V4cG9ydCkpIHtcbiAgICAgIHRoaXMuYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgbnVsbCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcGhhc2VJZGVudGlmaWVyID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBjb25zdCBwaGFzZUlkZW50aWZpZXJOYW1lID0gdGhpcy5wYXJzZUlkZW50aWZpZXJOYW1lKHRydWUpO1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBpc0ltcG9ydFBoYXNlID0gdG9rZW5Jc0tleXdvcmRPcklkZW50aWZpZXIodHlwZSkgPyB0eXBlICE9PSA5OCB8fCB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDEwMiA6IHR5cGUgIT09IDEyO1xuICAgIGlmIChpc0ltcG9ydFBoYXNlKSB7XG4gICAgICB0aGlzLmFwcGx5SW1wb3J0UGhhc2Uobm9kZSwgaXNFeHBvcnQsIHBoYXNlSWRlbnRpZmllck5hbWUsIHBoYXNlSWRlbnRpZmllci5sb2Muc3RhcnQpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYXBwbHlJbXBvcnRQaGFzZShub2RlLCBpc0V4cG9ydCwgbnVsbCk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJZGVudGlmaWVyKHBoYXNlSWRlbnRpZmllciwgcGhhc2VJZGVudGlmaWVyTmFtZSk7XG4gICAgfVxuICB9XG4gIGlzUHJlY2VkaW5nSWRJbXBvcnRQaGFzZShwaGFzZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gdG9rZW5Jc0lkZW50aWZpZXIodHlwZSkgPyB0eXBlICE9PSA5OCB8fCB0aGlzLmxvb2thaGVhZENoYXJDb2RlKCkgPT09IDEwMiA6IHR5cGUgIT09IDEyO1xuICB9XG4gIHBhcnNlSW1wb3J0KG5vZGUpIHtcbiAgICBpZiAodGhpcy5tYXRjaCgxMzQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUltcG9ydFNvdXJjZUFuZEF0dHJpYnV0ZXMobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyc0FuZEFmdGVyKG5vZGUsIHRoaXMucGFyc2VNYXliZUltcG9ydFBoYXNlKG5vZGUsIGZhbHNlKSk7XG4gIH1cbiAgcGFyc2VJbXBvcnRTcGVjaWZpZXJzQW5kQWZ0ZXIobm9kZSwgbWF5YmVEZWZhdWx0SWRlbnRpZmllcikge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIGNvbnN0IGhhc0RlZmF1bHQgPSB0aGlzLm1heWJlUGFyc2VEZWZhdWx0SW1wb3J0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpO1xuICAgIGNvbnN0IHBhcnNlTmV4dCA9ICFoYXNEZWZhdWx0IHx8IHRoaXMuZWF0KDEyKTtcbiAgICBjb25zdCBoYXNTdGFyID0gcGFyc2VOZXh0ICYmIHRoaXMubWF5YmVQYXJzZVN0YXJJbXBvcnRTcGVjaWZpZXIobm9kZSk7XG4gICAgaWYgKHBhcnNlTmV4dCAmJiAhaGFzU3RhcikgdGhpcy5wYXJzZU5hbWVkSW1wb3J0U3BlY2lmaWVycyhub2RlKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoOTgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlSW1wb3J0U291cmNlQW5kQXR0cmlidXRlcyhub2RlKTtcbiAgfVxuICBwYXJzZUltcG9ydFNvdXJjZUFuZEF0dHJpYnV0ZXMobm9kZSkge1xuICAgIHZhciBfbm9kZSRzcGVjaWZpZXJzMjtcbiAgICAoX25vZGUkc3BlY2lmaWVyczIgPSBub2RlLnNwZWNpZmllcnMpICE9IG51bGwgPyBfbm9kZSRzcGVjaWZpZXJzMiA6IG5vZGUuc3BlY2lmaWVycyA9IFtdO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUltcG9ydFNvdXJjZSgpO1xuICAgIHRoaXMubWF5YmVQYXJzZUltcG9ydEF0dHJpYnV0ZXMobm9kZSk7XG4gICAgdGhpcy5jaGVja0ltcG9ydFJlZmxlY3Rpb24obm9kZSk7XG4gICAgdGhpcy5jaGVja0pTT05Nb2R1bGVJbXBvcnQobm9kZSk7XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgICB0aGlzLnNhd1VuYW1iaWd1b3VzRVNNID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0RGVjbGFyYXRpb25cIik7XG4gIH1cbiAgcGFyc2VJbXBvcnRTb3VyY2UoKSB7XG4gICAgaWYgKCF0aGlzLm1hdGNoKDEzNCkpIHRoaXMudW5leHBlY3RlZCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRXhwckF0b20oKTtcbiAgfVxuICBwYXJzZUltcG9ydFNwZWNpZmllckxvY2FsKG5vZGUsIHNwZWNpZmllciwgdHlwZSkge1xuICAgIHNwZWNpZmllci5sb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCB0eXBlKSk7XG4gIH1cbiAgZmluaXNoSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgdHlwZSwgYmluZGluZ1R5cGUgPSA4MjAxKSB7XG4gICAgdGhpcy5jaGVja0xWYWwoc3BlY2lmaWVyLmxvY2FsLCB7XG4gICAgICB0eXBlXG4gICAgfSwgYmluZGluZ1R5cGUpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoc3BlY2lmaWVyLCB0eXBlKTtcbiAgfVxuICBwYXJzZUltcG9ydEF0dHJpYnV0ZXMoKSB7XG4gICAgdGhpcy5leHBlY3QoNSk7XG4gICAgY29uc3QgYXR0cnMgPSBbXTtcbiAgICBjb25zdCBhdHRyTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgZG8ge1xuICAgICAgaWYgKHRoaXMubWF0Y2goOCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICAgIGNvbnN0IGtleU5hbWUgPSB0aGlzLnN0YXRlLnZhbHVlO1xuICAgICAgaWYgKGF0dHJOYW1lcy5oYXMoa2V5TmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlc1dpdGhEdXBsaWNhdGVLZXlzLCB0aGlzLnN0YXRlLnN0YXJ0TG9jLCB7XG4gICAgICAgICAga2V5OiBrZXlOYW1lXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYXR0ck5hbWVzLmFkZChrZXlOYW1lKTtcbiAgICAgIGlmICh0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgICAgbm9kZS5rZXkgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbChrZXlOYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUua2V5ID0gdGhpcy5wYXJzZUlkZW50aWZpZXIodHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4cGVjdCgxNCk7XG4gICAgICBpZiAoIXRoaXMubWF0Y2goMTM0KSkge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5Nb2R1bGVBdHRyaWJ1dGVJbnZhbGlkVmFsdWUsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgbm9kZS52YWx1ZSA9IHRoaXMucGFyc2VTdHJpbmdMaXRlcmFsKHRoaXMuc3RhdGUudmFsdWUpO1xuICAgICAgYXR0cnMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnRBdHRyaWJ1dGVcIikpO1xuICAgIH0gd2hpbGUgKHRoaXMuZWF0KDEyKSk7XG4gICAgdGhpcy5leHBlY3QoOCk7XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG4gIHBhcnNlTW9kdWxlQXR0cmlidXRlcygpIHtcbiAgICBjb25zdCBhdHRycyA9IFtdO1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBuZXcgU2V0KCk7XG4gICAgZG8ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBub2RlLmtleSA9IHRoaXMucGFyc2VJZGVudGlmaWVyKHRydWUpO1xuICAgICAgaWYgKG5vZGUua2V5Lm5hbWUgIT09IFwidHlwZVwiKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLk1vZHVsZUF0dHJpYnV0ZURpZmZlcmVudEZyb21UeXBlLCBub2RlLmtleSk7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlcy5oYXMobm9kZS5rZXkubmFtZSkpIHtcbiAgICAgICAgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlc1dpdGhEdXBsaWNhdGVLZXlzLCBub2RlLmtleSwge1xuICAgICAgICAgIGtleTogbm9kZS5rZXkubmFtZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGF0dHJpYnV0ZXMuYWRkKG5vZGUua2V5Lm5hbWUpO1xuICAgICAgdGhpcy5leHBlY3QoMTQpO1xuICAgICAgaWYgKCF0aGlzLm1hdGNoKDEzNCkpIHtcbiAgICAgICAgdGhyb3cgdGhpcy5yYWlzZShFcnJvcnMuTW9kdWxlQXR0cmlidXRlSW52YWxpZFZhbHVlLCB0aGlzLnN0YXRlLnN0YXJ0TG9jKTtcbiAgICAgIH1cbiAgICAgIG5vZGUudmFsdWUgPSB0aGlzLnBhcnNlU3RyaW5nTGl0ZXJhbCh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICAgIGF0dHJzLnB1c2godGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSW1wb3J0QXR0cmlidXRlXCIpKTtcbiAgICB9IHdoaWxlICh0aGlzLmVhdCgxMikpO1xuICAgIHJldHVybiBhdHRycztcbiAgfVxuICBtYXliZVBhcnNlSW1wb3J0QXR0cmlidXRlcyhub2RlKSB7XG4gICAgbGV0IGF0dHJpYnV0ZXM7XG4gICAgdmFyIHVzZVdpdGggPSBmYWxzZTtcbiAgICBpZiAodGhpcy5tYXRjaCg3NikpIHtcbiAgICAgIGlmICh0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpICYmIHRoaXMubG9va2FoZWFkQ2hhckNvZGUoKSA9PT0gNDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAodGhpcy5oYXNQbHVnaW4oXCJtb2R1bGVBdHRyaWJ1dGVzXCIpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlTW9kdWxlQXR0cmlidXRlcygpO1xuICAgICAgICB0aGlzLmFkZEV4dHJhKG5vZGUsIFwiZGVwcmVjYXRlZFdpdGhMZWdhY3lTeW50YXhcIiwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyaWJ1dGVzID0gdGhpcy5wYXJzZUltcG9ydEF0dHJpYnV0ZXMoKTtcbiAgICAgIH1cbiAgICAgIHVzZVdpdGggPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5pc0NvbnRleHR1YWwoOTQpICYmICF0aGlzLmhhc1ByZWNlZGluZ0xpbmVCcmVhaygpKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzUGx1Z2luKFwiZGVwcmVjYXRlZEltcG9ydEFzc2VydFwiKSAmJiAhdGhpcy5oYXNQbHVnaW4oXCJpbXBvcnRBc3NlcnRpb25zXCIpKSB7XG4gICAgICAgIHRoaXMucmFpc2UoRXJyb3JzLkltcG9ydEF0dHJpYnV0ZXNVc2VBc3NlcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmhhc1BsdWdpbihcImltcG9ydEFzc2VydGlvbnNcIikpIHtcbiAgICAgICAgdGhpcy5hZGRFeHRyYShub2RlLCBcImRlcHJlY2F0ZWRBc3NlcnRTeW50YXhcIiwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIGF0dHJpYnV0ZXMgPSB0aGlzLnBhcnNlSW1wb3J0QXR0cmlidXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdHRyaWJ1dGVzID0gW107XG4gICAgfVxuICAgIGlmICghdXNlV2l0aCAmJiB0aGlzLmhhc1BsdWdpbihcImltcG9ydEFzc2VydGlvbnNcIikpIHtcbiAgICAgIG5vZGUuYXNzZXJ0aW9ucyA9IGF0dHJpYnV0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgfVxuICB9XG4gIG1heWJlUGFyc2VEZWZhdWx0SW1wb3J0U3BlY2lmaWVyKG5vZGUsIG1heWJlRGVmYXVsdElkZW50aWZpZXIpIHtcbiAgICBpZiAobWF5YmVEZWZhdWx0SWRlbnRpZmllcikge1xuICAgICAgY29uc3Qgc3BlY2lmaWVyID0gdGhpcy5zdGFydE5vZGVBdE5vZGUobWF5YmVEZWZhdWx0SWRlbnRpZmllcik7XG4gICAgICBzcGVjaWZpZXIubG9jYWwgPSBtYXliZURlZmF1bHRJZGVudGlmaWVyO1xuICAgICAgbm9kZS5zcGVjaWZpZXJzLnB1c2godGhpcy5maW5pc2hJbXBvcnRTcGVjaWZpZXIoc3BlY2lmaWVyLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh0b2tlbklzS2V5d29yZE9ySWRlbnRpZmllcih0aGlzLnN0YXRlLnR5cGUpKSB7XG4gICAgICB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyTG9jYWwobm9kZSwgdGhpcy5zdGFydE5vZGUoKSwgXCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBtYXliZVBhcnNlU3RhckltcG9ydFNwZWNpZmllcihub2RlKSB7XG4gICAgaWYgKHRoaXMubWF0Y2goNTUpKSB7XG4gICAgICBjb25zdCBzcGVjaWZpZXIgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoOTMpO1xuICAgICAgdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllckxvY2FsKG5vZGUsIHNwZWNpZmllciwgXCJJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXJcIik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHBhcnNlTmFtZWRJbXBvcnRTcGVjaWZpZXJzKG5vZGUpIHtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIHRoaXMuZXhwZWN0KDUpO1xuICAgIHdoaWxlICghdGhpcy5lYXQoOCkpIHtcbiAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDE0KSkge1xuICAgICAgICAgIHRocm93IHRoaXMucmFpc2UoRXJyb3JzLkRlc3RydWN0dXJlTmFtZWRJbXBvcnQsIHRoaXMuc3RhdGUuc3RhcnRMb2MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZXhwZWN0KDEyKTtcbiAgICAgICAgaWYgKHRoaXMuZWF0KDgpKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNwZWNpZmllciA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICBjb25zdCBpbXBvcnRlZElzU3RyaW5nID0gdGhpcy5tYXRjaCgxMzQpO1xuICAgICAgY29uc3QgaXNNYXliZVR5cGVPbmx5ID0gdGhpcy5pc0NvbnRleHR1YWwoMTMwKTtcbiAgICAgIHNwZWNpZmllci5pbXBvcnRlZCA9IHRoaXMucGFyc2VNb2R1bGVFeHBvcnROYW1lKCk7XG4gICAgICBjb25zdCBpbXBvcnRTcGVjaWZpZXIgPSB0aGlzLnBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgbm9kZS5pbXBvcnRLaW5kID09PSBcInR5cGVcIiB8fCBub2RlLmltcG9ydEtpbmQgPT09IFwidHlwZW9mXCIsIGlzTWF5YmVUeXBlT25seSwgdW5kZWZpbmVkKTtcbiAgICAgIG5vZGUuc3BlY2lmaWVycy5wdXNoKGltcG9ydFNwZWNpZmllcik7XG4gICAgfVxuICB9XG4gIHBhcnNlSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgaW1wb3J0ZWRJc1N0cmluZywgaXNJblR5cGVPbmx5SW1wb3J0LCBpc01heWJlVHlwZU9ubHksIGJpbmRpbmdUeXBlKSB7XG4gICAgaWYgKHRoaXMuZWF0Q29udGV4dHVhbCg5MykpIHtcbiAgICAgIHNwZWNpZmllci5sb2NhbCA9IHRoaXMucGFyc2VJZGVudGlmaWVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW1wb3J0ZWRcbiAgICAgIH0gPSBzcGVjaWZpZXI7XG4gICAgICBpZiAoaW1wb3J0ZWRJc1N0cmluZykge1xuICAgICAgICB0aHJvdyB0aGlzLnJhaXNlKEVycm9ycy5JbXBvcnRCaW5kaW5nSXNTdHJpbmcsIHNwZWNpZmllciwge1xuICAgICAgICAgIGltcG9ydE5hbWU6IGltcG9ydGVkLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja1Jlc2VydmVkV29yZChpbXBvcnRlZC5uYW1lLCBzcGVjaWZpZXIubG9jLnN0YXJ0LCB0cnVlLCB0cnVlKTtcbiAgICAgIGlmICghc3BlY2lmaWVyLmxvY2FsKSB7XG4gICAgICAgIHNwZWNpZmllci5sb2NhbCA9IHRoaXMuY2xvbmVJZGVudGlmaWVyKGltcG9ydGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoSW1wb3J0U3BlY2lmaWVyKHNwZWNpZmllciwgXCJJbXBvcnRTcGVjaWZpZXJcIiwgYmluZGluZ1R5cGUpO1xuICB9XG4gIGlzVGhpc1BhcmFtKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIHBhcmFtLm5hbWUgPT09IFwidGhpc1wiO1xuICB9XG59XG5jbGFzcyBQYXJzZXIgZXh0ZW5kcyBTdGF0ZW1lbnRQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpbnB1dCwgcGx1Z2luc01hcCkge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRPcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICBzdXBlcihub3JtYWxpemVkT3B0aW9ucywgaW5wdXQpO1xuICAgIHRoaXMub3B0aW9ucyA9IG5vcm1hbGl6ZWRPcHRpb25zO1xuICAgIHRoaXMuaW5pdGlhbGl6ZVNjb3BlcygpO1xuICAgIHRoaXMucGx1Z2lucyA9IHBsdWdpbnNNYXA7XG4gICAgdGhpcy5maWxlbmFtZSA9IG5vcm1hbGl6ZWRPcHRpb25zLnNvdXJjZUZpbGVuYW1lO1xuICAgIHRoaXMuc3RhcnRJbmRleCA9IG5vcm1hbGl6ZWRPcHRpb25zLnN0YXJ0SW5kZXg7XG4gICAgbGV0IG9wdGlvbkZsYWdzID0gMDtcbiAgICBpZiAobm9ybWFsaXplZE9wdGlvbnMuYWxsb3dBd2FpdE91dHNpZGVGdW5jdGlvbikge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gMTtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWRPcHRpb25zLmFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSAyO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZE9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSA4O1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZE9wdGlvbnMuYWxsb3dTdXBlck91dHNpZGVNZXRob2QpIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDE2O1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZE9wdGlvbnMuYWxsb3dVbmRlY2xhcmVkRXhwb3J0cykge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gNjQ7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkT3B0aW9ucy5hbGxvd05ld1RhcmdldE91dHNpZGVGdW5jdGlvbikge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gNDtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWRPcHRpb25zLmFsbG93WWllbGRPdXRzaWRlRnVuY3Rpb24pIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDMyO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZE9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSAxMjg7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkT3B0aW9ucy50b2tlbnMpIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDI1NjtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWRPcHRpb25zLmNyZWF0ZUltcG9ydEV4cHJlc3Npb25zKSB7XG4gICAgICBvcHRpb25GbGFncyB8PSA1MTI7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkT3B0aW9ucy5jcmVhdGVQYXJlbnRoZXNpemVkRXhwcmVzc2lvbnMpIHtcbiAgICAgIG9wdGlvbkZsYWdzIHw9IDEwMjQ7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkT3B0aW9ucy5lcnJvclJlY292ZXJ5KSB7XG4gICAgICBvcHRpb25GbGFncyB8PSAyMDQ4O1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZE9wdGlvbnMuYXR0YWNoQ29tbWVudCkge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gNDA5NjtcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWRPcHRpb25zLmFubmV4Qikge1xuICAgICAgb3B0aW9uRmxhZ3MgfD0gODE5MjtcbiAgICB9XG4gICAgdGhpcy5vcHRpb25GbGFncyA9IG9wdGlvbkZsYWdzO1xuICB9XG4gIGdldFNjb3BlSGFuZGxlcigpIHtcbiAgICByZXR1cm4gU2NvcGVIYW5kbGVyO1xuICB9XG4gIHBhcnNlKCkge1xuICAgIHRoaXMuZW50ZXJJbml0aWFsU2NvcGVzKCk7XG4gICAgY29uc3QgZmlsZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0VG9rZW4oKTtcbiAgICBmaWxlLmVycm9ycyA9IG51bGw7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wYXJzZVRvcExldmVsKGZpbGUsIHByb2dyYW0pO1xuICAgIHJlc3VsdC5lcnJvcnMgPSB0aGlzLnN0YXRlLmVycm9ycztcbiAgICByZXN1bHQuY29tbWVudHMubGVuZ3RoID0gdGhpcy5zdGF0ZS5jb21tZW50c0xlbjtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICB2YXIgX29wdGlvbnM7XG4gIGlmICgoKF9vcHRpb25zID0gb3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRpb25zLnNvdXJjZVR5cGUpID09PSBcInVuYW1iaWd1b3VzXCIpIHtcbiAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMuc291cmNlVHlwZSA9IFwibW9kdWxlXCI7XG4gICAgICBjb25zdCBwYXJzZXIgPSBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpO1xuICAgICAgY29uc3QgYXN0ID0gcGFyc2VyLnBhcnNlKCk7XG4gICAgICBpZiAocGFyc2VyLnNhd1VuYW1iaWd1b3VzRVNNKSB7XG4gICAgICAgIHJldHVybiBhc3Q7XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VyLmFtYmlndW91c1NjcmlwdERpZmZlcmVudEFzdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9wdGlvbnMuc291cmNlVHlwZSA9IFwic2NyaXB0XCI7XG4gICAgICAgICAgcmV0dXJuIGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCkucGFyc2UoKTtcbiAgICAgICAgfSBjYXRjaCAoX3VudXNlZCkge31cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzdC5wcm9ncmFtLnNvdXJjZVR5cGUgPSBcInNjcmlwdFwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFzdDtcbiAgICB9IGNhdGNoIChtb2R1bGVFcnJvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgb3B0aW9ucy5zb3VyY2VUeXBlID0gXCJzY3JpcHRcIjtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNlcihvcHRpb25zLCBpbnB1dCkucGFyc2UoKTtcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQyKSB7fVxuICAgICAgdGhyb3cgbW9kdWxlRXJyb3I7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpLnBhcnNlKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbihpbnB1dCwgb3B0aW9ucykge1xuICBjb25zdCBwYXJzZXIgPSBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpO1xuICBpZiAocGFyc2VyLm9wdGlvbnMuc3RyaWN0TW9kZSkge1xuICAgIHBhcnNlci5zdGF0ZS5zdHJpY3QgPSB0cnVlO1xuICB9XG4gIHJldHVybiBwYXJzZXIuZ2V0RXhwcmVzc2lvbigpO1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVFeHBvcnRlZFRva2VuVHlwZXMoaW50ZXJuYWxUb2tlblR5cGVzKSB7XG4gIGNvbnN0IHRva2VuVHlwZXMgPSB7fTtcbiAgZm9yIChjb25zdCB0eXBlTmFtZSBvZiBPYmplY3Qua2V5cyhpbnRlcm5hbFRva2VuVHlwZXMpKSB7XG4gICAgdG9rZW5UeXBlc1t0eXBlTmFtZV0gPSBnZXRFeHBvcnRlZFRva2VuKGludGVybmFsVG9rZW5UeXBlc1t0eXBlTmFtZV0pO1xuICB9XG4gIHJldHVybiB0b2tlblR5cGVzO1xufVxuY29uc3QgdG9rVHlwZXMgPSBnZW5lcmF0ZUV4cG9ydGVkVG9rZW5UeXBlcyh0dCk7XG5mdW5jdGlvbiBnZXRQYXJzZXIob3B0aW9ucywgaW5wdXQpIHtcbiAgbGV0IGNscyA9IFBhcnNlcjtcbiAgY29uc3QgcGx1Z2luc01hcCA9IG5ldyBNYXAoKTtcbiAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLnBsdWdpbnMpIHtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBvcHRpb25zLnBsdWdpbnMpIHtcbiAgICAgIGxldCBuYW1lLCBvcHRzO1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbmFtZSA9IHBsdWdpbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFtuYW1lLCBvcHRzXSA9IHBsdWdpbjtcbiAgICAgIH1cbiAgICAgIGlmICghcGx1Z2luc01hcC5oYXMobmFtZSkpIHtcbiAgICAgICAgcGx1Z2luc01hcC5zZXQobmFtZSwgb3B0cyB8fCB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhbGlkYXRlUGx1Z2lucyhwbHVnaW5zTWFwKTtcbiAgICBjbHMgPSBnZXRQYXJzZXJDbGFzcyhwbHVnaW5zTWFwKTtcbiAgfVxuICByZXR1cm4gbmV3IGNscyhvcHRpb25zLCBpbnB1dCwgcGx1Z2luc01hcCk7XG59XG5jb25zdCBwYXJzZXJDbGFzc0NhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0UGFyc2VyQ2xhc3MocGx1Z2luc01hcCkge1xuICBjb25zdCBwbHVnaW5MaXN0ID0gW107XG4gIGZvciAoY29uc3QgbmFtZSBvZiBtaXhpblBsdWdpbk5hbWVzKSB7XG4gICAgaWYgKHBsdWdpbnNNYXAuaGFzKG5hbWUpKSB7XG4gICAgICBwbHVnaW5MaXN0LnB1c2gobmFtZSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IGtleSA9IHBsdWdpbkxpc3Quam9pbihcInxcIik7XG4gIGxldCBjbHMgPSBwYXJzZXJDbGFzc0NhY2hlLmdldChrZXkpO1xuICBpZiAoIWNscykge1xuICAgIGNscyA9IFBhcnNlcjtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5MaXN0KSB7XG4gICAgICBjbHMgPSBtaXhpblBsdWdpbnNbcGx1Z2luXShjbHMpO1xuICAgIH1cbiAgICBwYXJzZXJDbGFzc0NhY2hlLnNldChrZXksIGNscyk7XG4gIH1cbiAgcmV0dXJuIGNscztcbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMucGFyc2VFeHByZXNzaW9uID0gcGFyc2VFeHByZXNzaW9uO1xuZXhwb3J0cy50b2tUeXBlcyA9IHRva1R5cGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../node_modules/.pnpm/@babel+parser@7.28.6/node_modules/@babel/parser/lib/index.js\n");

/***/ })

};
;